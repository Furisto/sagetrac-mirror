From 359213d4b0a0fc1e3261c9f62693b4904882ecce Mon Sep 17 00:00:00 2001
From: Simon King <simon.king@uni-jena.de>
Date: Tue, 22 Mar 2016 16:28:59 +0100
Subject: [PATCH 2/3] Propagation of error return values


diff --git a/src/cfinfo.c b/src/cfinfo.c
index 8ce3f2d..7080c68 100644
--- a/src/cfinfo.c
+++ b/src/cfinfo.c
@@ -207,7 +207,7 @@ int Lat_ReadInfo(Lat_Info *li, const char *basename)
 	    }
 	    for (i = 0; i < li->NCf; ++i)
 	    {
-		ReadWord(f,&(li->Cf[i].idword),&(li->Cf[i].idpol),fn);
+		if (!ReadWord(f,&(li->Cf[i].idword),&(li->Cf[i].idpol),fn)) return -1;
 		if (StfMatch(f,i < li->NCf - 1 ? "," : "];") != 0)
 		{
 		    MTX_ERROR2("%s: %E",fn,MTX_ERR_FILEFMT);
@@ -224,7 +224,7 @@ int Lat_ReadInfo(Lat_Info *li, const char *basename)
 	    }
 	    for (i = 0; i < li->NCf; ++i)
 	    {
-		ReadWord(f,&(li->Cf[i].peakword),&(li->Cf[i].peakpol),fn);
+		if (!ReadWord(f,&(li->Cf[i].peakword),&(li->Cf[i].peakpol),fn)) return -1;
 		if (StfMatch(f,i < li->NCf - 1 ? "," : "];") != 0)
 		{
 		    MTX_ERROR2("%s: %E",fn,MTX_ERR_FILEFMT);
diff --git a/src/chbasis.c b/src/chbasis.c
index ec334d2..d94b335 100644
--- a/src/chbasis.c
+++ b/src/chbasis.c
@@ -51,7 +51,8 @@ int MrChangeBasis(MatRep_t *rep, const Matrix_t *trans)
 /** Conjugate a list @em gen of @em ngen square matrices over the same
  *  field and of the same dimensions by a mattrix @em trans
  *  and write the result into @em newgen. If @em gen == @em newgen, then
- *  the previous content of @em newgen will be overridden. **/
+ *  the previous content of @em newgen will be overridden.
+ *  Return -1 on error and 0 on success. **/
 int ChangeBasis(const Matrix_t *trans, int ngen, const Matrix_t *gen[],
 	Matrix_t *newgen[])
 
@@ -73,18 +74,36 @@ int ChangeBasis(const Matrix_t *trans, int ngen, const Matrix_t *gen[],
     }
 
     Matrix_t *tmp = MatAlloc(trans->Field, trans->Nor, trans->Noc);
+    if (!tmp) return -1;
     size_t tmpsize = FfCurrentRowSize*trans->Nor;
     for (i = 0; i < ngen; ++i)
     {
         MTX_VERIFY(gen[i]->Nor==trans->Nor);
         MTX_VERIFY(gen[i]->Noc==trans->Noc);
         memset(tmp->Data, FF_ZERO, tmpsize);
-        MatMulStrassen(tmp, trans, gen[i]);
+        if (!MatMulStrassen(tmp, trans, gen[i]))
+        {
+			MatFree(tmp);
+			return -1;
+		}
         if ((const Matrix_t **)newgen == gen)
             memset(newgen[i]->Data, FF_ZERO, tmpsize);
         else
+        {
             newgen[i] = MatAlloc(trans->Field, trans->Nor, trans->Noc);
-        MatMulStrassen(newgen[i], tmp, bi);
+            if (!newgen[i])
+            {
+                MatFree(tmp);
+                MatFree(bi);
+                return -1;
+            }
+        }
+        if (!MatMulStrassen(newgen[i], tmp, bi))
+        {
+            MatFree(tmp);
+            MatFree(bi);
+            return -1;
+        }
     }
     MatFree(bi);
     MatFree(tmp);
diff --git a/src/ffio.c b/src/ffio.c
index f008661..a50ba52 100644
--- a/src/ffio.c
+++ b/src/ffio.c
@@ -42,8 +42,9 @@ int FfReadRows(FILE *f, PTR buf, int n)
       if (fread(b,FfTrueRowSize(FfNoc),1,f) != 1) { break; }
       b += FfCurrentRowSize;
    }
-   if (ferror(f)) {
-      MTX_ERROR("Read failed: %S");
+   if (ferror(f))
+   {
+      return MTX_ERROR("Read failed: %S"), -1;
    }
    return i;
 }
@@ -77,8 +78,9 @@ int FfWriteRows(FILE *f, PTR buf, int n)
       if (fwrite(b,FfTrueRowSize(FfNoc),1,f) != 1) { break; }
       b += FfCurrentRowSize;
    }
-   if (ferror(f)) {
-      MTX_ERROR("Write failed: %S");
+   if (ferror(f))
+   {
+      return MTX_ERROR("Write failed: %S"), -1;
    }
    return i;
 }
diff --git a/src/kernel-0.c b/src/kernel-0.c
index 98978db..4996a31 100644
--- a/src/kernel-0.c
+++ b/src/kernel-0.c
@@ -224,7 +224,7 @@ static FILE *OpenTableFile(int fl)
    /* Create the table file.
       ---------------------- */
    if (FfMakeTables(fl) != 0) {
-      MTX_ERROR("Unable to build arithmetic tables");
+      return MTX_ERROR("Unable to build arithmetic tables"), NULL;
    }
    fd = SysFopen(fn,FM_READ | FM_LIB);
    return fd;
@@ -276,8 +276,7 @@ static int ReadTableFile(FILE *fd, int field)
       return -1;
    }
    FfOrder = field;
-   FfSetNoc(FfOrder);
-   return 0;
+   return FfSetNoc(FfOrder);
 }
 
 
@@ -372,7 +371,7 @@ size_t FfTrueRowSize(int noc)
 /// Embed a subfield.
 /// @param a Element of the subfield field.
 /// @param subfield Subfield order. Must be a divisor of the current field order.
-/// @return @em a, embedded into the current field.
+/// @return @em a, embedded into the current field, or 255 on error.
 
 FEL FfEmbed(FEL a, int subfield)
 {
@@ -386,8 +385,7 @@ FEL FfEmbed(FEL a, int subfield)
          return mtx_embed[i][a];
       }
    }
-   MTX_ERROR2("Cannot embed GF(%d) into GF(%d)",(int)subfield,(int)FfOrder);
-   return FF_ZERO;
+   return MTX_ERROR2("Cannot embed GF(%d) into GF(%d)",(int)subfield,(int)FfOrder), (FEL)255;
 }
 
 
@@ -401,6 +399,7 @@ FEL FfEmbed(FEL a, int subfield)
 /// <tt>FfSetField(subfield)</tt>.
 /// @param a Element of the current field.
 /// @param subfield Subfield order. Must be a divisor of the current field order.
+/// Return 255 on error.
 
 FEL FfRestrict(FEL a, int subfield)
 {
@@ -414,8 +413,7 @@ FEL FfRestrict(FEL a, int subfield)
          return mtx_restrict[i][a];
       }
    }
-   MTX_ERROR2("Cannot restrict GF(%d) to GF(%d)",(int)FfOrder, (int)subfield);
-   return FF_ZERO;
+   return MTX_ERROR2("Cannot restrict GF(%d) to GF(%d)",(int)FfOrder, (int)subfield), (FEL)255;
 }
 
 
diff --git a/src/maddmul.c b/src/maddmul.c
index 39c0c0c..15d4b45 100644
--- a/src/maddmul.c
+++ b/src/maddmul.c
@@ -49,7 +49,7 @@ Matrix_t *MatAddMul(Matrix_t *dest, const Matrix_t *src, FEL coeff)
          ------------ */
       PTR dp = dest->Data, sp = src->Data;
       int n;
-      FfSetField(src->Field);
+      FfSetField(src->Field);  /* No error checking */
       FfSetNoc(src->Noc);
       for (n = src->Nor; n > 0; --n) {
          FfAddMulRow(dp,sp,coeff);
diff --git a/src/maketab-0.c b/src/maketab-0.c
index 2bff492..93f5077 100644
--- a/src/maketab-0.c
+++ b/src/maketab-0.c
@@ -171,10 +171,10 @@ static void polymod(POLY a, POLY b)
 
 
 /* -----------------------------------------------------------------
-   testprim() - Test for primitivity.
+   testprim() - Test for primitivity --- 1 on error.
    ----------------------------------------------------------------- */
 
-static void testprim()
+static int testprim()
 {
     int i, a[256];
 
@@ -185,16 +185,17 @@ static void testprim()
        	if(a[i] != 1)
 	{
 	    fprintf(stderr,"*** a[%d]=%d.",i,a[i]);
-	    MTX_ERROR("Polynome is not primitive.");
+	    return MTX_ERROR("Polynome is not primitive."), 1;
 	}
+    return 0;
 }
 
 
 /* -----------------------------------------------------------------
-   initarith() - Initialize index and zech logarithm tables.
+   initarith() - Initialize index and zech logarithm tables --- 1 on error.
    ----------------------------------------------------------------- */
 
-static void initarith()
+static int initarith()
 {	int i,elem;
 	POLY a;
 
@@ -213,7 +214,7 @@ static void initarith()
 		polmultx(a);
 		polymod(a,irred);
         }
-	testprim();
+	if (testprim()) return 1;
 
 	/* Calculate zech logarithms
 	   ------------------------- */
@@ -221,6 +222,7 @@ static void initarith()
 	{	elem = (int)((i%P)==P-1 ? i+1-P : i+1); /* add 1 */
 		zech[indx[i]]=indx[elem]; /* Zech-table=result */
         }
+	return 0;
 }
 
 
@@ -310,10 +312,10 @@ static BYTE pack(BYTE a[8])
 
 /* -----------------------------------------------------------------
    writeheader() - Set info[], open table file, select polynomial,
-	and initialize tables.
+	and initialize tables --- 1 on error.
    ----------------------------------------------------------------- */
 
-static void writeheader()
+static int writeheader()
 {
     int i, j;
 
@@ -322,7 +324,7 @@ static void writeheader()
     if (fd == NULL)
     {
 	perror(filename);
-	MTX_ERROR("Cannot open table file");
+	return MTX_ERROR("Cannot open table file"), 1;
     }
     for (CPM=1,maxmem=Q; (long)maxmem * Q <= 256L; ++CPM, maxmem *= Q);
     for (i = 0; irrednrs[i] != (int) Q && irrednrs[i] != 0; ++i);
@@ -332,7 +334,7 @@ static void writeheader()
         for (j = 0; j <= MAXGRAD; j++)
             irred[j] = irreducibles[i][MAXGRAD-j];
 	G = P;		/* Generator is X */
-	initarith();	/* Init index- and Zech-tables */
+	if (initarith()) return 1;	/* Init index- and Zech-tables */
     }
     else
     {	
@@ -356,21 +358,21 @@ static void writeheader()
     }
     MESSAGE(1,("Generator   : %ld\n",info[1]));
     MESSAGE(1,("Packing     : %ld/byte\n",info[3]));
+    return 0;
 }
 
 
 /* -----------------------------------------------------------------
-   checkq() - Set Q and N. Verify that Q is a prime power.
+   checkq() - Set Q and N. Verify that Q is a prime power --- 1 on error
    ----------------------------------------------------------------- */
 
-static void checkq(long l)
+static int checkq(long l)
 {
     long q, d;
 
     if (l < 2 || l > 256)
     {
-	fprintf(stderr,"Field order out of range (2-256)\n");
-	exit(EXIT_ERR);
+      return MTX_ERROR1("Field order out of range (2-256): %E", MTX_ERR_RANGE), 1;
     }
 
     Q = l;
@@ -380,9 +382,9 @@ static void checkq(long l)
        	q /= d;
     if (q != 1)
     {
-	fprintf(stderr,"Illegal Field order\n");
-	exit(EXIT_ERR);
+      return MTX_ERROR("Illegal Field order\n"), 1;
     }
+    return 0;
 }
 
 
@@ -403,10 +405,10 @@ static void inittables()
 }
 
 /* -----------------------------------------------------------------
-   mkembed() - Calculate embeddings of all subfields.
+   mkembed() - Calculate embeddings of all subfields --- 1 on error
    ----------------------------------------------------------------- */
 
-static void mkembed()
+static int mkembed()
 {
     int n;	/* Degree of subfield over Z_p */
     long q; /* subfield order */
@@ -454,7 +456,7 @@ static void mkembed()
 	if ((Q-1) % (q-1) != 0)
 	{
 	    fprintf(stderr,"*** q=%ld, Q=%ld.",q,Q);
-	    MTX_ERROR("Internal error.");
+	    return MTX_ERROR("Internal error."), 1;
 	}
 
 	/* Calculate a generator for the subfield
@@ -501,17 +503,17 @@ static void mkembed()
 	    fflush(stdout);
 	}
     }
+    return 0;
 }
 
-
+// -1 on error
 static int Init(int field)
 {
-    checkq(field);
-    return 0;
+    return -checkq(field);
 }
 
 /* -----------------------------------------------------------------
-   FfMakeTables() - Build meataxe arithmetic tables
+   FfMakeTables() - Build meataxe arithmetic tables --- 1 on error
    ----------------------------------------------------------------- */
 
 int FfMakeTables(int field)
@@ -525,7 +527,7 @@ int FfMakeTables(int field)
        ---------- */
     if (Init(field) != 0)
 	return 1;
-    writeheader();			/* Open file and write header */
+    if (writeheader()) return 1;	/* Open file and write header */
     inittables();
 
     /* Make insert table
@@ -617,7 +619,7 @@ int FfMakeTables(int field)
 	}
     }
 
-    mkembed();
+    if (mkembed()) return 1;
 
     MESSAGE(1,("Writing tables to %s\n",filename));
     if (
@@ -637,7 +639,7 @@ int FfMakeTables(int field)
       )
     {
 	perror(filename);
-	MTX_ERROR("Error writing table file");
+	return MTX_ERROR("Error writing table file"), 1;
     }
     fclose(fd);
     return(0);
diff --git a/src/matadd.c b/src/matadd.c
index 58ffcfd..03e81d8 100644
--- a/src/matadd.c
+++ b/src/matadd.c
@@ -43,6 +43,7 @@ Matrix_t *MatAdd(Matrix_t *dest, const Matrix_t *src)
       ------------------- */
    dp = dest->Data;
    sp = src->Data;
+   // No error check -- existing matrix
    FfSetField(src->Field);
    FfSetNoc(src->Noc);
    for (n = src->Nor; n > 0; --n) {
diff --git a/src/matclean.c b/src/matclean.c
index dcf9adc..91d88e4 100644
--- a/src/matclean.c
+++ b/src/matclean.c
@@ -45,7 +45,7 @@ int MatClean(Matrix_t *mat, const Matrix_t *sub)
 
    /* Clean
       ----- */
-   FfSetNoc(mat->Noc);
+   FfSetNoc(mat->Noc);  // No error check -- existing matrix
    for (i = 0; i < mat->Nor; ++i) {
       PTR m = MatGetPtr(mat,i);
       FfCleanRow(m,sub->Data,sub->Nor,sub->PivotTable);
diff --git a/src/matcmp.c b/src/matcmp.c
index 79693f8..7ba1628 100644
--- a/src/matcmp.c
+++ b/src/matcmp.c
@@ -35,7 +35,7 @@ MTX_DEFINE_FILE_INFO
 /// not necessarily mean that an error has occured.
 /// @param a First matrix.
 /// @param b Second matrix.
-/// @return 0 if the matrices are equal, nonzero otherwise (see description).
+/// @return 0 if the matrices are equal, nonzero otherwise (see description), -2 on error.
 
 int MatCompare(const Matrix_t *a, const Matrix_t *b)
 {
@@ -45,7 +45,7 @@ int MatCompare(const Matrix_t *a, const Matrix_t *b)
       ------------------ */
    if (!MatIsValid(a) || !MatIsValid(b)) {
       MTX_ERROR1("%E",MTX_ERR_BADARG);
-      return -1;
+      return -2;
    }
 
    /* Compare fields and dimensions
@@ -63,6 +63,7 @@ int MatCompare(const Matrix_t *a, const Matrix_t *b)
    /* Compare the entries row by row. We do not use memcmp on the
       whole matrix because we must ignore padding bytes.
       ----------------------------------------------------------- */
+   // No error check -- existing matrix
    FfSetField(a->Field);
    FfSetNoc(a->Noc);
    for (i = 0; i < a->Nor; ++i) {
diff --git a/src/matcopy.c b/src/matcopy.c
index 886e705..d8f6fcc 100644
--- a/src/matcopy.c
+++ b/src/matcopy.c
@@ -92,6 +92,7 @@ int MatCopyRegion(Matrix_t *dest, int destrow, int destcol,
       for (k = col1; k < col1 + ncols; ++k) {
 #ifdef PARANOID
          FEL f;
+	 // No error check -- existing matrix
          FfSetNoc(src->Noc);
          f = FfExtract(s,k);
          FfSetNoc(dest->Noc);
@@ -112,4 +113,4 @@ int MatCopyRegion(Matrix_t *dest, int destrow, int destcol,
 }
 
 
-/// @}
\ No newline at end of file
+/// @}
diff --git a/src/matcore.c b/src/matcore.c
index c2bc2d3..c83bcd6 100644
--- a/src/matcore.c
+++ b/src/matcore.c
@@ -120,7 +120,7 @@ Matrix_t *MatAlloc(int field, int nor, int noc)
       SysFree(m);
       return NULL;
    }
-   FfSetNoc(noc);
+    if (FfSetNoc(noc)) return NULL;
    m->Magic = MAT_MAGIC;
    m->Field = field;
    m->Nor = nor;
diff --git a/src/matcut.c b/src/matcut.c
index 9d36b34..08c4f49 100644
--- a/src/matcut.c
+++ b/src/matcut.c
@@ -75,11 +75,12 @@ Matrix_t *MatCut(const Matrix_t *src, int row1, int col1, int nrows, int ncols)
    /* Initialize pointers to the source and destination matrix
       -------------------------------------------------------- */
    s = MatGetPtr(src,row1);
+   if (!s) return NULL;
    d = result->Data;
 
    /* Copy the requested data
       ----------------------- */
-   FfSetNoc(ncols);
+   if (FfSetNoc(ncols)) return NULL;
    for (n = nrows; n > 0; --n) {
       if (col1 == 0) {
          FfCopyRow(d,s);
@@ -88,9 +89,9 @@ Matrix_t *MatCut(const Matrix_t *src, int row1, int col1, int nrows, int ncols)
          for (k = 0; k < ncols; ++k) {
 #ifdef PARANOID
             FEL f;
-            FfSetNoc(src->Noc);
+            FfSetNoc(src->Noc); // No error check -- existing matrix
             f = FfExtract(s,col1 + k);
-            FfSetNoc(ncols);
+            FfSetNoc(ncols); // Error check was done above
             FfInsert(d,k,f);
 #else
             FfInsert(d,k,FfExtract(s,col1 + k));
diff --git a/src/matech.c b/src/matech.c
index 1631a1c..2332700 100644
--- a/src/matech.c
+++ b/src/matech.c
@@ -113,7 +113,7 @@ int MatEchelonize(Matrix_t *mat)
 
    /* Build the pivot table
       --------------------- */
-   FfSetField(mat->Field);
+    FfSetField(mat->Field);  /* No error checking */
    FfSetNoc(mat->Noc);
    rank = zmkechelon(mat->Data,mat->Nor,mat->Noc,mat->PivotTable,is_pivot);
 
@@ -146,12 +146,17 @@ long MatNullity(const Matrix_t *mat)
 /// This function calculates the dimension of the null-space of a matrix
 /// and deletes the matrix.
 /// @param mat Pointer to the matrix.
-/// @return Nullity of @em mat, or -$ on error.
+/// @return Nullity of @em mat, or -1 on error.
 
 long MatNullity__(Matrix_t *mat)
 {
    long nul;
-   MatEchelonize(mat);
+   if (!mat) return -1;
+   if (MatEchelonize(mat)<0)
+   {
+      MatFree(mat);
+      return -1;
+   }
    nul = mat->Noc - mat->Nor;
    MatFree(mat);
    return nul;
diff --git a/src/matins.c b/src/matins.c
index 0255ad1..627c6d2 100644
--- a/src/matins.c
+++ b/src/matins.c
@@ -50,6 +50,7 @@ Matrix_t *MatInsert_(Matrix_t *mat, const Poly_t *pol)
       return NULL;
    }
 
+   // No error checking needed, as the data come from an existing matrix.
    FfSetField(mat->Field);
    FfSetNoc(nor);
 
@@ -73,6 +74,7 @@ Matrix_t *MatInsert_(Matrix_t *mat, const Poly_t *pol)
    // Evaluate p(A)
    if (pol->Degree > 1) {
       x = MatDup(mat);
+      if (!x) return NULL;
    }
    if ((f = pol->Data[pol->Degree]) != FF_ONE) {
       for (l = nor, v = mat->Data; l > 0; --l, FfStepPtr(&v)) {
@@ -135,6 +137,7 @@ Matrix_t *MatInsert(const Matrix_t *mat, const Poly_t *pol)
    // Special case: deg(p) = 0
    if (pol->Degree == 0) {
       x = MatAlloc(mat->Field,nor,nor);
+      if (!x) return NULL;
       for (l = 0, v = x->Data; l < nor; ++l, FfStepPtr(&v)) {
          FfInsert(v,l,pol->Data[0]);
       }
@@ -143,6 +146,7 @@ Matrix_t *MatInsert(const Matrix_t *mat, const Poly_t *pol)
 
    // Evaluate p(A)
    x = MatDup(mat);
+   if (!x) return NULL;
    if ((f = pol->Data[pol->Degree]) != FF_ONE) {
       for (l = nor, v = x->Data; l > 0; --l, FfStepPtr(&v)) {
          FfMulRow(v,f);
diff --git a/src/matinv.c b/src/matinv.c
index 5be8b6a..74ac97b 100644
--- a/src/matinv.c
+++ b/src/matinv.c
@@ -98,6 +98,7 @@ Matrix_t *MatInverse(const Matrix_t *mat)
 
    // Copy matrix into workspace
    tmp = FfAlloc(mat->Nor);
+   if (!tmp) return NULL;
    memcpy(tmp,mat->Data,FfCurrentRowSize * mat->Nor);
 
    // Inversion
diff --git a/src/matnull.c b/src/matnull.c
index 1212881..90f405e 100644
--- a/src/matnull.c
+++ b/src/matnull.c
@@ -30,6 +30,7 @@ MTX_DEFINE_FILE_INFO
 /// - |piv| contains a pivot table for the null space.
 /// If |flags| is nonzero, the null-space is not reduced to echelon form,
 /// and the contents of |piv| are undefined.
+/// @return The dimension of the null space on success, -1 on error.
 
 static long znullsp(PTR matrix, long nor, int *piv, PTR nsp, int flags)
 {
@@ -40,7 +41,7 @@ static long znullsp(PTR matrix, long nor, int *piv, PTR nsp, int flags)
    FEL f;
 
    // initialize result with identity
-   FfSetNoc(nor);
+   if (FfSetNoc(nor)) return -1;
    x = nsp;
    for (i = 0; i < nor; ++i) {
       piv[i] = -1;
@@ -57,12 +58,11 @@ static long znullsp(PTR matrix, long nor, int *piv, PTR nsp, int flags)
       long k, p;
 
       for (k = 0; k < i; ++k) {
-         FfSetNoc(noc);
+         FfSetNoc(noc);  /* No error checking, since noc used to be the previously assigned number of columns */
          if (((p = piv[k]) >= 0) && ((f = FfExtract(x,p)) != FF_ZERO)) {
             f = FfNeg(FfDiv(f,FfExtract(xx,p)));
-            FfSetNoc(noc);
             FfAddMulRow(x,xx,f);
-            FfSetNoc(nor);
+            FfSetNoc(nor);  /* we have asserted above that it doesn't fail */
             FfAddMulRow(y,yy,f);
          }
          FfSetNoc(noc);
@@ -115,7 +115,7 @@ static long znullsp(PTR matrix, long nor, int *piv, PTR nsp, int flags)
 /// The result is in echelon form.
 /// @param mat Pointer to the matrix.
 /// @param flags If nonzero, the null-space is not reduced to echelon form.
-/// @return Pointer to the null-space of |mat|, or |NULL| on error.
+/// @return Pointer to the null-space of |mat|, or NULL on error.
 
 Matrix_t *MatNullSpace_(Matrix_t *mat, int flags)
 {
@@ -133,10 +133,19 @@ Matrix_t *MatNullSpace_(Matrix_t *mat, int flags)
       return NULL;
    }
    nsp->PivotTable = NREALLOC(nsp->PivotTable,int,mat->Nor);
+   if (!nsp->PivotTable) {
+     MatFree(nsp);
+     return NULL;
+   }
 
    // calculate the null-space
    FfSetNoc(mat->Noc);
    dim = znullsp(mat->Data,mat->Nor,nsp->PivotTable,nsp->Data,flags);
+   if (dim==-1)
+   {
+      MatFree(nsp);
+      return NULL;
+   }
    if (flags) {
       SysFree(nsp->PivotTable);
       nsp->PivotTable = NULL;
diff --git a/src/matorder.c b/src/matorder.c
index ae66b7f..edc8a71 100644
--- a/src/matorder.c
+++ b/src/matorder.c
@@ -25,7 +25,7 @@ MTX_DEFINE_FILE_INFO
 /// the order is greater than 1000000, or if the order on any cyclic
 /// subspace is greater than 1000.
 /// @param mat Pointer to the matrix.
-/// @return The order of @em mat, or 1 on error.
+/// @return The order of @em mat, or -1 on error.
 
 int MatOrder(const Matrix_t *mat)
 {
@@ -52,15 +52,50 @@ int MatOrder(const Matrix_t *mat)
    FfSetNoc(mat->Noc);
    nor = mat->Nor;
    m1 = FfAlloc(nor);
+   if (!m1) return -1;
    memcpy(m1,mat->Data,FfCurrentRowSize * nor);
    bend = basis = FfAlloc(nor + 1);
+   if (!bend) {
+     SysFree(m1);
+     return -1;
+   }
 
    piv = NALLOC(int,nor + 1);
+   if (!piv) {
+     SysFree(m1);
+     return -1;
+   }
    done = NALLOC(char,nor);
+   if (!done) {
+     SysFree(m1);
+     SysFree(piv);
+     return -1;
+   }
    memset(done,0,(size_t)nor);
    v1 = FfAlloc(1);
+   if (!v1) {
+     SysFree(m1);
+     SysFree(piv);
+     SysFree(done);
+     return -1;
+   }
    v2 = FfAlloc(1);
+   if (!v2) {
+     SysFree(m1);
+     SysFree(piv);
+     SysFree(done);
+     SysFree(v1);
+     return -1;
+   }
    v3 = FfAlloc(1);
+   if (!v3) {
+     SysFree(m1);
+     SysFree(piv);
+     SysFree(done);
+     SysFree(v1);
+     SysFree(v2);
+     return -1;
+   }
    tord = ord = 1;
    dim = 0;
    j1 = 1;
diff --git a/src/matpivot.c b/src/matpivot.c
index a85512f..4b6371e 100644
--- a/src/matpivot.c
+++ b/src/matpivot.c
@@ -63,7 +63,6 @@ static int zmkpivot(PTR matrix, int nor, int noc, int *piv, int *ispiv)
 
 int MatPivotize(Matrix_t *mat)
 {
-   int rc;
    int *newtab;
    static int *is_pivot = NULL;
    static int maxnoc = -1;
@@ -93,9 +92,7 @@ int MatPivotize(Matrix_t *mat)
    // build the pivot table
    FfSetField(mat->Field);
    FfSetNoc(mat->Noc);
-   rc = zmkpivot(mat->Data,mat->Nor,mat->Noc,mat->PivotTable,is_pivot);
-
-   return rc;
+   return zmkpivot(mat->Data,mat->Nor,mat->Noc,mat->PivotTable,is_pivot);
 }
 
 
diff --git a/src/matpwr.c b/src/matpwr.c
index 0e50db4..9540a96 100644
--- a/src/matpwr.c
+++ b/src/matpwr.c
@@ -98,8 +98,13 @@ Matrix_t *MatPower(const Matrix_t *mat, long n)
    FfSetField(mat->Field);
    FfSetNoc(mat->Noc);
    tmp = FfAlloc(FfNoc);
+   if (!tmp) return NULL;
    memcpy(tmp,mat->Data,FfCurrentRowSize * FfNoc);
    tmp2 = FfAlloc(FfNoc);
+   if (!tmp2) {
+     SysFree(tmp);
+     return NULL;
+   }
    result = MatAlloc(mat->Field,mat->Nor,mat->Noc);
    if (result != NULL) {
       matpwr_(n,tmp,result->Data,tmp2);
diff --git a/src/matread.c b/src/matread.c
index 673e3d7..21e21d0 100644
--- a/src/matread.c
+++ b/src/matread.c
@@ -41,7 +41,7 @@ Matrix_t *MatRead(FILE *f)
    }
    if (FfReadRows(f,m->Data,m->Nor) != m->Nor) {
       MatFree(m);
-      return NULL;
+      return MTX_ERROR("Number of given rows does not coincide with given row number"), NULL;
    }
    return m;
 }
diff --git a/src/mattrace.c b/src/mattrace.c
index e5135f2..93a5b65 100644
--- a/src/mattrace.c
+++ b/src/mattrace.c
@@ -16,7 +16,7 @@
 /// This function calculates the sum of all diagonal elements of a matrix.
 /// Note that the matrix need not be square.
 /// @param mat Pointer to the matrix.
-/// @return Trace of @a mat, @c FF_ZERO on error.
+/// @return Trace of @a mat, @c 255 on error.
 
 FEL MatTrace(const Matrix_t *mat)
 {
@@ -29,7 +29,7 @@ FEL MatTrace(const Matrix_t *mat)
       ------------------ */
 #ifdef DEBUG
    if (!MatIsValid(mat)) {
-      return FF_ZERO;
+     return (FEL)255;
    }
 #endif
 
diff --git a/src/matwrite.c b/src/matwrite.c
index 9b2a7b7..715b19a 100644
--- a/src/matwrite.c
+++ b/src/matwrite.c
@@ -41,7 +41,7 @@ int MatWrite(const Matrix_t *mat, FILE *f)
    FfSetField(mat->Field);
    FfSetNoc(mat->Noc);
    if (FfWriteRows(f,mat->Data,mat->Nor) != mat->Nor) {
-      return -1;
+     return MTX_ERROR("Cannot write rows"),-1;
    }
    return 0;
 }
@@ -72,7 +72,7 @@ int MatSave(const Matrix_t *mat, const char *fn)
    i = MatWrite(mat,f);
    fclose(f);
    if (i != 0) {
-      MTX_ERROR1("Cannot write matrix to %s",fn);
+     return MTX_ERROR1("Cannot write matrix to %s",fn), -1;
    }
    return i;
 }
diff --git a/src/meataxe.h.in b/src/meataxe.h.in
index cdad674..2923a49 100644
--- a/src/meataxe.h.in
+++ b/src/meataxe.h.in
@@ -128,8 +128,8 @@ PTR FfSubRow(PTR dest, PTR src);
 PTR FfAlloc(int nor);
 int FfCmpRows(PTR p1, PTR p2);
 void FfCleanRow(PTR row, PTR matrix, int nor, const int *piv);
-void FfCleanRow2(PTR row, PTR matrix, int nor, const int *piv, PTR row2);
-void FfCleanRowAndRepeat(PTR row, PTR mat, int nor, const int *piv,
+int FfCleanRow2(PTR row, PTR matrix, int nor, const int *piv, PTR row2);
+int FfCleanRowAndRepeat(PTR row, PTR mat, int nor, const int *piv,
                          PTR row2, PTR mat2);
 void FfCopyRow(PTR dest, PTR src);
 FEL FfEmbed(FEL a, int subfield);
diff --git a/src/mmulscal.c b/src/mmulscal.c
index 353cf38..b38a1b8 100644
--- a/src/mmulscal.c
+++ b/src/mmulscal.c
@@ -18,7 +18,7 @@
 /// Multiply a Matrix by a Constant.
 /// @param dest Pointer to the matrix.
 /// @param coeff Value to multiply with.
-/// @return The function returns @a dest.
+/// @return The function returns @a dest, or NULL on error in debug mode.
 
 Matrix_t *MatMulScalar(Matrix_t *dest, FEL coeff)
 {
diff --git a/src/mtensor.c b/src/mtensor.c
index b3f4cc7..e1ea4e3 100644
--- a/src/mtensor.c
+++ b/src/mtensor.c
@@ -79,6 +79,11 @@ Matrix_t *MatTensor(const Matrix_t *m1, const Matrix_t *m2)
          ---------------------------------------- */
       x1 = m1->Data;
       x3 = MatGetPtr(temat,i2);
+    if (!x3)
+    {
+        MatFree(temat);
+        return NULL;
+    }
       FfSetNoc(temat->Noc);
 
       /* Loop through all rows of <m1>
diff --git a/src/quotient.c b/src/quotient.c
index a5ed4ad..7de2a47 100644
--- a/src/quotient.c
+++ b/src/quotient.c
@@ -39,7 +39,7 @@ MTX_DEFINE_FILE_INFO
 ///
 /// @param subspace The invariant subspace.
 /// @param vectors The vectors to project.
-/// @return Projection of @a vectors on the quotient by @a subspace, or 0 on error.
+/// @return Projection of @a vectors on the quotient by @a subspace, or NULL on error.
 
 Matrix_t *QProjection(const Matrix_t *subspace, const Matrix_t *vectors)
 {
@@ -67,15 +67,21 @@ Matrix_t *QProjection(const Matrix_t *subspace, const Matrix_t *vectors)
    sdim = subspace->Nor;
    qdim = subspace->Noc - sdim;
    result = MatAlloc(subspace->Field,vectors->Nor,qdim);
+   if (!result) return NULL;
 
    /* Calculate the projection
       ------------------------ */
    FfSetNoc(subspace->Noc);
    tmp = FfAlloc(1);
+   if (!tmp) return NULL;
    non_piv = subspace->PivotTable + subspace->Nor;
    for (i = 0; i < vectors->Nor; ++i) {
       int k;
       PTR q = MatGetPtr(result,i);
+      if (!q) {
+	SysFree(tmp);
+	return NULL;
+      }
       FfCopyRow(tmp,MatGetPtr(vectors,i));
       FfCleanRow(tmp,subspace->Data,sdim,subspace->PivotTable);
       for (k = 0; k < qdim; ++k) {
@@ -140,13 +146,18 @@ Matrix_t *QAction(const Matrix_t *subspace, const Matrix_t *gen)
 
    /* Calculate the action on the quotient
       ------------------------------------ */
-   FfSetNoc(dim);
+   FfSetNoc(dim);  /* No error checking, since dim is the ->Noc of an existing matrix */
    tmp = FfAlloc(1);
+   if (!tmp) return NULL;
    piv = subspace->PivotTable;
    non_piv = piv + subspace->Nor;
    for (k = 0; k < qdim; ++k) {
       int l;
       PTR qx = MatGetPtr(action,k);
+      if (!qx) {
+	SysFree(tmp);
+	return NULL;
+      }
       FfCopyRow(tmp,MatGetPtr(gen,non_piv[k]));
       FfCleanRow(tmp,subspace->Data,sdim,piv);
       for (l = 0; l < qdim; ++l) {
diff --git a/src/saction.c b/src/saction.c
index 864a8e7..1328ae1 100644
--- a/src/saction.c
+++ b/src/saction.c
@@ -63,8 +63,14 @@ Matrix_t *SAction(const Matrix_t *subspace, const Matrix_t *gen)
     sdim = subspace->Nor;
     FfSetField(subspace->Field);
     action = MatAlloc(FfOrder,sdim,sdim);
-    FfSetNoc(dim);
+    if (!action) return NULL;
+    FfSetNoc(dim);  /* No error checking, since dim is the ->Noc of an existing matrix */
     tmp = FfAlloc(1);
+    if (!tmp)
+    {
+        MatFree(action);
+        return NULL;
+    }
 
     /* Calaculate the action.
        ---------------------- */
@@ -72,6 +78,12 @@ Matrix_t *SAction(const Matrix_t *subspace, const Matrix_t *gen)
     {
 	PTR xi = MatGetPtr(subspace,i);
 	PTR yi = MatGetPtr(action,i);
+    if (!xi || !yi)
+    {
+        MatFree(action);
+        SysFree(tmp);
+        return NULL;
+    }
 	FEL f;
 
 	/* Calculate the image of the <i>-th row of <subspace>.
@@ -80,10 +92,20 @@ Matrix_t *SAction(const Matrix_t *subspace, const Matrix_t *gen)
 
 	/* Clean the image with the subspace and store coefficients.
 	   --------------------------------------------------------- */
-	FfCleanRow2(tmp,subspace->Data,sdim,subspace->PivotTable,yi);
+	if (FfCleanRow2(tmp,subspace->Data,sdim,subspace->PivotTable,yi))
+    {
+        MatFree(action);
+        SysFree(tmp);
+        return NULL;
+    }
 	if (FfFindPivot(tmp,&f) >= 0)
-	    MTX_ERROR("Split(): Subspace not invariant");
+	{
+        MatFree(action);
+        SysFree(tmp);
+        MTX_ERROR("Split(): Subspace not invariant");
+        return NULL;
     }
+	}
 
     /* Clean up and return the result.
        ------------------------------- */
diff --git a/src/soc.c b/src/soc.c
index ea4aaf9..ab7f377 100644
--- a/src/soc.c
+++ b/src/soc.c
@@ -155,7 +155,7 @@ static void WriteBasis(const Matrix_t *basis)
 }
 
 
-
+// return -1 on error
 static int NextLayer()
 
 {
@@ -273,7 +273,7 @@ static int NextLayer()
        ------------------------------------------------------------- */
     echbas = MatAlloc(bas->Field,bas->Noc,bas->Noc);
     MatCopyRegion(echbas,0,0,bas,0,0,-1,-1);
-    MatEchelonize(bas);
+    if (MatEchelonize(bas)<0) { MatFree(bas); return -1; }
     for (i = bas->Nor; i < bas->Noc; ++i)
 	FfInsert(MatGetPtr(echbas,i),bas->PivotTable[i],FF_ONE);
     MatFree(bas);
diff --git a/src/stabpwr.c b/src/stabpwr.c
index 3d227b8..41babe7 100644
--- a/src/stabpwr.c
+++ b/src/stabpwr.c
@@ -54,14 +54,26 @@ int StablePower_(Matrix_t *mat, int *pwr, Matrix_t **ker)
       --------------------------- */
    p = 1;
    k1 = MatNullSpace(mat);
-   MatMul(mat,mat);
+   if (!k1) return -1;
+   if (!MatMul(mat,mat)) {
+     MatFree(k1);
+     return -1;
+   }
    k2 = MatNullSpace(mat);
+   if (!k2) {
+     MatFree(k1);
+     return -1;
+   }
    while (k2->Nor > k1->Nor) {
       p *= 2;
       MatFree(k1);
       k1 = k2;
-      MatMul(mat,mat);
+      if (!MatMul(mat,mat)) {
+	MatFree(k2);
+	return -1;
+      }
       k2 = MatNullSpace(mat);
+      if (!k2) return -1;
    }
    MatFree(k2);
 
diff --git a/src/sumint.c b/src/sumint.c
index bab0444..b18e9e0 100644
--- a/src/sumint.c
+++ b/src/sumint.c
@@ -73,7 +73,7 @@ int FfSumAndIntersection(PTR wrk1, int *nor1, int *nor2, PTR wrk2, int *piv)
     {
 	FEL f;
 	int p;
-	FfCleanRowAndRepeat(x1,wrk1,k,piv,x2,wrk2);
+	if (FfCleanRowAndRepeat(x1,wrk1,k,piv,x2,wrk2)) return -1;
 	if ((p = FfFindPivot(x1,&f)) < 0)
 	    continue;	/* Null row - ignore */
 	if (k < i)
diff --git a/src/temap.c b/src/temap.c
index d4e7abd..cc9411b 100644
--- a/src/temap.c
+++ b/src/temap.c
@@ -62,14 +62,20 @@ Matrix_t *TensorMap(Matrix_t *vec, const Matrix_t *a, const Matrix_t *b)
       Matrix_t *tmp = MatTransposed(a);
       Matrix_t *v = VectorToMatrix(vec,i,b->Nor);
       if (v == NULL) {
-         MTX_ERROR("Conversion failed");
-         break;
+	return MTX_ERROR("Conversion failed"), NULL;
+      }
+      if (!MatMul(tmp,v)) {
+	MatFree(v);
+	return NULL;
       }
-      MatMul(tmp,v);
       MatFree(v);
-      MatMul(tmp,b);
+      if (!MatMul(tmp,b)) {
+	MatFree(tmp);
+	return NULL;
+      }
       if (MatrixToVector(tmp,result,i)) {
-         MTX_ERROR("Conversion failed");
+	MatFree(tmp);
+	return MTX_ERROR("Conversion failed"), NULL;
       }
       MatFree(tmp);
    }
diff --git a/src/vec2mat.c b/src/vec2mat.c
index acb6941..be6030d 100644
--- a/src/vec2mat.c
+++ b/src/vec2mat.c
@@ -54,7 +54,7 @@ Matrix_t *VectorToMatrix(Matrix_t *vecs, int n, int noc)
    }
    for (i = 0; i < result->Nor; ++i) {
       if (MatCopyRegion(result,i,0, vecs,n,i * noc,1,noc) != 0) {
-         MTX_ERROR("Copy failed");
+	return MTX_ERROR("Copy failed"), NULL;
       }
    }
    return result;
diff --git a/src/window.c b/src/window.c
index ea0e1b9..1abb3ea 100644
--- a/src/window.c
+++ b/src/window.c
@@ -69,7 +69,11 @@ MatrixWindow_t *WindowAlloc(int fl, int nor, size_t rowsize)
         MTX_ERROR1("%E",MTX_ERR_NOMEM);
         return NULL;
     }
-    FfSetField(fl);
+    if (FfSetField(fl))
+    {
+        free(out);
+        return NULL;
+    }
     out->Matrix = MatAlloc(fl, nor, rowsize*sizeof(long)*MPB);
     if (out->Matrix == NULL)
     {
@@ -453,7 +457,8 @@ PTR FfSubRowWindowReverse(PTR dest, PTR src, int first, int len)
 
 /** dest := left+right
    left and right must be distinct, but one of them may coincide with dest -- under the assumption
-   that, in that case, the ambient matrices coincide as well. **/
+   that, in that case, the ambient matrices coincide as well.
+   Return dest, or NULL on error (the only error may occur in a compatibility check). **/
 MatrixWindow_t *WindowSum(MatrixWindow_t *dest, MatrixWindow_t *left, MatrixWindow_t *right)
 {
   PTR x, result, tmp;
@@ -522,6 +527,7 @@ MatrixWindow_t *WindowSum(MatrixWindow_t *dest, MatrixWindow_t *left, MatrixWind
 /** dest := left-right
    left and right must be distinct, but one of them may coincide with dest -- under the assumption
    that, in that case, the ambient matrices coincide as well.
+   Return dest, or NULL on error (the only error may occur in a compatibility check).
 **/
 MatrixWindow_t *WindowDif(MatrixWindow_t *dest, MatrixWindow_t *left, MatrixWindow_t *right)
 {
@@ -595,7 +601,8 @@ MatrixWindow_t *WindowDif(MatrixWindow_t *dest, MatrixWindow_t *left, MatrixWind
    it. Moreover, the chunk of memory pointed at by dest MUST be
    disjoint from the chunks for left and right!
 
-   Dimensions are not tested!
+   Dimensions are not tested, there is no error return value!
+   @return dest
 **/
 MatrixWindow_t *WindowAddMul(MatrixWindow_t *dest, MatrixWindow_t *left, MatrixWindow_t *right)
 {
@@ -805,7 +812,7 @@ int StrassenStep(MatrixWindow_t *dest_win, MatrixWindow_t *A_win, MatrixWindow_t
   S2->RowSize = A_sub_rowsize;
   S2->Matrix = X->Matrix;
   S2->ULCorner = X->ULCorner;
-  WindowDif(S2, A00, A10);
+  WindowDif(S2, A00, A10); /* No error checking, as we know that the windows are compatible */
   /*
   printf("1.  S2 = A00-A10 in X\n");
   WindowShow(X);
@@ -841,7 +848,7 @@ int StrassenStep(MatrixWindow_t *dest_win, MatrixWindow_t *A_win, MatrixWindow_t
   S0->RowSize = A_sub_rowsize;
   S0->Matrix = X->Matrix;
   S0->ULCorner = X->ULCorner;
-  WindowSum(S0, A10, A11);
+  WindowSum(S0, A10, A11); /* no error checking here and below, as we know the dimensions of the windows */
   /*
   printf("4.  S0 = A10+A11 in X\n");
   WindowShow(X);
diff --git a/src/zcleanrow.c b/src/zcleanrow.c
index 50da91b..ecdef0a 100644
--- a/src/zcleanrow.c
+++ b/src/zcleanrow.c
@@ -53,16 +53,15 @@ void FfCleanRow(PTR row, PTR matrix, int nor, const int *piv)
 /// @param nor Number of rows.
 /// @param piv Pivot table for @em matrix.
 /// @param row2 Pointer to row where the operations are recorded.
-/// @return Always 0.
+/// @return 0, or 1 on error.
 
-void FfCleanRow2(PTR row, PTR mat, int nor, const int *piv, PTR row2)
+int FfCleanRow2(PTR row, PTR mat, int nor, const int *piv, PTR row2)
 {
    int i;
    PTR x;
 
    if ((row2 == NULL) || (piv == NULL)) {
-      MTX_ERROR1("%E",MTX_ERR_BADARG);
-      return;
+      return MTX_ERROR1("%E",MTX_ERR_BADARG), 1;
    }
    for (i = 0, x = mat; i < nor; ++i, FfStepPtr(&x)) {
       FEL f = FfExtract(row,piv[i]);
@@ -72,6 +71,7 @@ void FfCleanRow2(PTR row, PTR mat, int nor, const int *piv, PTR row2)
          FfInsert(row2,i,f);
       }
    }
+   return 0;
 }
 
 
@@ -84,9 +84,9 @@ void FfCleanRow2(PTR row, PTR mat, int nor, const int *piv, PTR row2)
 /// @param piv Pivot table for @em mat.
 /// @param row2 Pointer to the second row to be cleaned.
 /// @param mat2 Matrix to the second matrix.
-/// @return Always 0.
+/// @return 0, or 1 on error.
 
-void FfCleanRowAndRepeat(PTR row, PTR mat, int nor, const int *piv, PTR row2, PTR mat2)
+int FfCleanRowAndRepeat(PTR row, PTR mat, int nor, const int *piv, PTR row2, PTR mat2)
 {
    int i;
    PTR x, x2;
@@ -94,7 +94,7 @@ void FfCleanRowAndRepeat(PTR row, PTR mat, int nor, const int *piv, PTR row2, PT
 #ifdef DEBUG
    if ((row2 == NULL) || (piv == NULL) || (row2 == NULL) || (mat2 == NULL)) {
       MTX_ERROR1("%E",MTX_ERR_BADARG);
-      return;
+      return 1;
    }
 #endif
    for (i = 0, x = mat, x2 = mat2; i < nor; ++i, FfStepPtr(&x), FfStepPtr(&x2)) {
@@ -105,7 +105,8 @@ void FfCleanRowAndRepeat(PTR row, PTR mat, int nor, const int *piv, PTR row2, PT
          FfAddMulRow(row2,x2,f);
       }
    }
+    return 0;
 }
 
 
-/// @}
\ No newline at end of file
+/// @}
-- 
2.5.0

