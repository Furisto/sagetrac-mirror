From ca8f0b226d7054a0ee37a05945c59d481441c480 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Fr=C3=A9d=C3=A9ric=20Chapoton?= <chapoton@unistra.fr>
Date: Wed, 6 Jan 2021 19:31:05 +0100
Subject: [PATCH] some typos found by codespell

---
 NEWS                       |  4 ++--
 README                     |  2 +-
 acinclude.m4               |  6 +++---
 ginac/basic.cpp            |  2 +-
 ginac/ex.cpp               |  6 +++---
 ginac/ex.h                 |  2 +-
 ginac/flags.h              |  2 +-
 ginac/function_info.cpp    |  6 +++---
 ginac/inifcns_hyperb.cpp   |  2 +-
 ginac/inifcns_nstdsums.cpp |  4 ++--
 ginac/inifcns_trig.cpp     |  2 +-
 ginac/mul.cpp              |  6 +++---
 ginac/order.cpp            | 18 +++++++++---------
 m4/pkg.m4                  |  2 +-
 14 files changed, 32 insertions(+), 32 deletions(-)

diff --git a/NEWS b/NEWS
index 8c054d9..ccb78b8 100644
--- a/NEWS
+++ b/NEWS
@@ -652,7 +652,7 @@ Backporting bug-fix release from version 1.4.1.
   less brain-dead ones and should now have much better performance.
 * Checks were completely reorganized and split up into three parts:
   a) exams (small regression tests with predefined input)
-  b) checks (lenghty coherence checks with random input)
+  b) checks (lengthy coherence checks with random input)
   c) timings (for coherence and crude benchmarking)
 * Behaviour of .evalf() was changed: it doesn't .evalf() any exponents.
 * Expanded expressions now remember they are expanded to prevent
@@ -671,7 +671,7 @@ Backporting bug-fix release from version 1.4.1.
 * Fixes a small number of bugs.
 
 0.5.0 (7 February 2000)
-* Expressions can be written ("archived") to files and read therefrom.
+* Expressions can be written ("archived") to files and read from there.
 * Addition of GiNaC-cint, which lets you write complete programs in
   an interactive shell-like manner in your favoured programming
   language (i.e. C++).
diff --git a/README b/README
index ca1ea94..ed286a1 100644
--- a/README
+++ b/README
@@ -1,5 +1,5 @@
 Pynac -- "Python is Not a CAS" is a modified version of Ginac that
-replaces the depency of GiNaC on CLN by a dependency instead of Python.
+replaces the dependency of GiNaC on CLN by a dependency instead of Python.
 It is a lite version of GiNaC as well, not implementing all the features
 of the full GiNaC, and it is *only* meant to be used as a Python library.
 
diff --git a/acinclude.m4 b/acinclude.m4
index dd7299c..6da61d7 100644
--- a/acinclude.m4
+++ b/acinclude.m4
@@ -6,9 +6,9 @@ dnl ===========================================================================
 
 dnl Usage: GINAC_RLVERSION
 dnl The maintainers of libreadline are complete morons: they don't care a shit
-dnl about compatiblilty (which is not so bad by itself) and at the same time 
+dnl about compatibility (which is not so bad by itself) and at the same time 
 dnl they don't export the version to the preprocessor so we could kluge around 
-dnl incomatiblities.  The only reliable way to figure out the version is by 
+dnl incompatibilities.  The only reliable way to figure out the version is by 
 dnl checking the extern variable rl_library_version at runtime.  &#@$%*!
 AC_DEFUN([GINAC_LIB_READLINE_VERSION],
 [AC_CACHE_CHECK([for version of libreadline], ginac_cv_rlversion, [
@@ -89,7 +89,7 @@ ginac_warning=yes])
 dnl Usage: GINAC_CHECK_ERRORS
 dnl (must be put at end of configure.in, because it exits on error)
 dnl This macro displays a warning message if GINAC_ERROR or GINAC_WARNING 
-dnl has occured previously.
+dnl has occurred previously.
 AC_DEFUN([GINAC_CHECK_ERRORS],[
 if test "x${ginac_error}" = "xyes"; then
     echo "**** The following problems have been detected by configure."
diff --git a/ginac/basic.cpp b/ginac/basic.cpp
index b8e6e43..7515bd8 100644
--- a/ginac/basic.cpp
+++ b/ginac/basic.cpp
@@ -249,7 +249,7 @@ const ex basic::op(size_t /*unused*/) const
 	throw(std::range_error(std::string("basic::op(): ") + class_name() + std::string(" has no operands")));
 }
 
-/** Return modifyable operand/member at position i. */
+/** Return modifiable operand/member at position i. */
 ex & basic::let_op(size_t /*unused*/)
 {
 	ensure_if_modifiable();
diff --git a/ginac/ex.cpp b/ginac/ex.cpp
index 469d791..a4783ab 100644
--- a/ginac/ex.cpp
+++ b/ginac/ex.cpp
@@ -66,13 +66,13 @@ void ex::print(const print_context & c, unsigned level) const
 	bp->print(c, level);
 }
 
-/** Little wrapper arount print to be called within a debugger. */
+/** Little wrapper around print to be called within a debugger. */
 void ex::dbgprint() const
 {
 	bp->dbgprint();
 }
 
-/** Little wrapper arount printtree to be called within a debugger. */
+/** Little wrapper around printtree to be called within a debugger. */
 void ex::dbgprinttree() const
 {
 	bp->dbgprinttree();
@@ -259,7 +259,7 @@ void ex::traverse_postorder(visitor & v) const
 	accept(v);
 }
 
-/** Return modifyable operand/member at position i. */
+/** Return modifiable operand/member at position i. */
 ex & ex::let_op(size_t i)
 {
 	makewriteable();
diff --git a/ginac/ex.h b/ginac/ex.h
index f904fb6..7d220d2 100644
--- a/ginac/ex.h
+++ b/ginac/ex.h
@@ -62,7 +62,7 @@ class library_init {
 static library_init library_initializer;
 
 /** Rotate bits of unsigned value by one bit to the left.
-  * This can be necesary if the user wants to define its own hashes. */
+  * This can be necessary if the user wants to define its own hashes. */
 inline unsigned rotate_left(unsigned n)
 {
 	return (n & 0x80000000U) ? (n << 1 | 0x00000001U) : (n << 1);
diff --git a/ginac/flags.h b/ginac/flags.h
index 53791a9..fd5652e 100644
--- a/ginac/flags.h
+++ b/ginac/flags.h
@@ -65,7 +65,7 @@ class subs_options {
 		pattern_is_product = 0x0004,     ///< used internally by expairseq::subschildren()
 		pattern_is_not_product = 0x0008, ///< used internally by expairseq::subschildren()
 		no_index_renaming = 0x0010,
-		// To indicate that we want to substitue an index by something that is
+		// To indicate that we want to substitute an index by something that is
 		// is not an index. Without this flag the index value would be
 		// substituted in that case.
 		really_subs_idx = 0x0020,
diff --git a/ginac/function_info.cpp b/ginac/function_info.cpp
index c034e10..e12941f 100644
--- a/ginac/function_info.cpp
+++ b/ginac/function_info.cpp
@@ -380,13 +380,13 @@ bool function::info(unsigned inf) const
                 {binomial_SERIAL::serial, &binomial_info},
                 {factorial_SERIAL::serial, &factorial_info},
         }};
-        static bool initalized = false;
-        if (not initalized) {
+        static bool initialized = false;
+        if (not initialized) {
                 auto ser = function::find_function("min", 0);
                 funcmap.insert(std::pair<unsigned int,ifun_t*>(ser, &min_info));
                 ser = function::find_function("max", 0);
                 funcmap.insert(std::pair<unsigned int,ifun_t*>(ser, &max_info));
-                initalized = true;
+                initialized = true;
         }
 
         auto search = funcmap.find(serial);
diff --git a/ginac/inifcns_hyperb.cpp b/ginac/inifcns_hyperb.cpp
index c5a4448..000692a 100644
--- a/ginac/inifcns_hyperb.cpp
+++ b/ginac/inifcns_hyperb.cpp
@@ -893,7 +893,7 @@ static ex atanh_series(const ex &arg,
 	GINAC_ASSERT(is_a<symbol>(rel.lhs()));
 	// method:
 	// Taylor series where there is no pole or cut falls back to atanh_deriv.
-	// There are two branch cuts, one runnig from 1 up the real axis and one
+	// There are two branch cuts, one running from 1 up the real axis and one
 	// one running from -1 down the real axis.  The points 1 and -1 are poles
 	// On the branch cuts and the poles series expand
 	//     (log(1+x)-log(1-x))/2
diff --git a/ginac/inifcns_nstdsums.cpp b/ginac/inifcns_nstdsums.cpp
index 43deaf8..caee5a7 100644
--- a/ginac/inifcns_nstdsums.cpp
+++ b/ginac/inifcns_nstdsums.cpp
@@ -2188,7 +2188,7 @@ bool convert_parameter_H_to_Li(const lst& l, lst& m, lst& s, ex& pf)
 }
 
 
-// recursivly transforms H to corresponding multiple polylogarithms
+// recursively transforms H to corresponding multiple polylogarithms
 struct map_trafo_H_convert_to_Li : public map_function
 {
 	ex operator()(const ex& e)
@@ -2227,7 +2227,7 @@ struct map_trafo_H_convert_to_Li : public map_function
 };
 
 
-// recursivly transforms H to corresponding zetas
+// recursively transforms H to corresponding zetas
 struct map_trafo_H_convert_to_zeta : public map_function
 {
 	ex operator()(const ex& e)
diff --git a/ginac/inifcns_trig.cpp b/ginac/inifcns_trig.cpp
index 08fffe2..3c9bd8d 100644
--- a/ginac/inifcns_trig.cpp
+++ b/ginac/inifcns_trig.cpp
@@ -1322,7 +1322,7 @@ static ex atan_series(const ex &arg,
 	GINAC_ASSERT(is_a<symbol>(rel.lhs()));
 	// method:
 	// Taylor series where there is no pole or cut falls back to atan_deriv.
-	// There are two branch cuts, one runnig from I up the imaginary axis and
+	// There are two branch cuts, one running from I up the imaginary axis and
 	// one running from -I down the imaginary axis.  The points I and -I are
 	// poles.
 	// On the branch cuts and the poles series expand
diff --git a/ginac/mul.cpp b/ginac/mul.cpp
index a2b0609..1a29c01 100644
--- a/ginac/mul.cpp
+++ b/ginac/mul.cpp
@@ -619,7 +619,7 @@ ex mul::eval(int level) const
 		GINAC_ASSERT(!is_exactly_a<numeric>(recombine_pair_to_ex(elem)));
 		/* for paranoia */
 		//   The following test will fail on sage: exp(x)*exp(x)
-		//   Thats probably not an issue, but should be investigated.
+		//   That's probably not an issue, but should be investigated.
 		// expair p = split_ex_to_pair(recombine_pair_to_ex(*i));
 		// GINAC_ASSERT(p.rest.is_equal(i->rest));
 		// GINAC_ASSERT(p.coeff.is_equal(i->coeff));
@@ -914,7 +914,7 @@ bool tryfactsubs(const ex & origfactor, const ex & patternfactor, int & nummatch
 	return true;
 }
 
-/** Checks wheter e matches to the pattern pat and the (possibly to be updated)
+/** Checks whether e matches to the pattern pat and the (possibly to be updated)
   * list of replacements repls. This matching is in the sense of algebraic
   * substitutions. Matching starts with pat.op(factor) of the pattern because
   * the factors before this one have already been matched. The (possibly
@@ -1365,7 +1365,7 @@ ex mul::expand(unsigned options) const
 				// Multiply explicitly all non-numeric terms of add1 and add2:
                                 for (const auto & elem2 : add2.seq) {
 					// We really have to combine terms here in order to compactify
-					// the result.  Otherwise it would become waayy tooo bigg.
+					// the result.  Otherwise it would become *way too big*.
 					numeric oc(*_num0_p);
 					epvector distrseq2;
 					distrseq2.reserve(add1.seq.size());
diff --git a/ginac/order.cpp b/ginac/order.cpp
index a3f9409..2f70997 100644
--- a/ginac/order.cpp
+++ b/ginac/order.cpp
@@ -220,7 +220,7 @@ int print_order::compare(const basic &lh, const basic &rh) const
 		//print fderivatives after everything else
 		return -1;
 	else if (typeid_rh == fderivative_id())
-		//print fderivatives after everything esle
+		//print fderivatives after everything else
 		return 1;
 	else if (typeid_lh == function_id())
 		//print functions before fderivatives, after anything else
@@ -292,7 +292,7 @@ int print_order::compare(const basic &lh, const basic &rh) const
 		//print pseries after everything else
 		return -1;
 	else if (typeid_rh == pseries_id())
-		//print pseries after everything esle
+		//print pseries after everything else
 		return 1;
         return generic_compare(typeid_lh, typeid_rh);
 }
@@ -374,7 +374,7 @@ int print_order::compare_mul_power(const mul &lh, const power &rh) const
 }
 
 // compare two mul objects
-// same behavior wihtin mul and add objects:
+// same behavior within mul and add objects:
 // first we compare total degrees
 // if equal we compare the basis of the smallest items
 // then their exponents
@@ -424,7 +424,7 @@ int print_order::compare_same_type_mul(const mul &lh, const mul &rh) const
 }
 
 // compare an add and a symbol objects
-// same behavior wihtin mul and add objects:
+// same behavior within mul and add objects:
 // the coefficient of the symbol is 1
 int print_order::compare_add_symbol(const add &lh, const symbol &rh) const
 {
@@ -480,7 +480,7 @@ int print_order::compare_add_mul(const add &lh,
 }
 
 // compare an add and a pow objects
-// same behavior wihtin mul and add objects:
+// same behavior within mul and add objects:
 // the coefficient of the power object is 1
 int print_order::compare_add_power(const add &lh,
 		const power &rh) const
@@ -508,7 +508,7 @@ int print_order::compare_add_power(const add &lh,
 }
 
 // compare two add objects
-// same behavior wihtin mul and add objects:
+// same behavior within mul and add objects:
 // first we compare the basis of the biggest items
 // then their coefficients
 // and so on
@@ -632,7 +632,7 @@ int print_order::compare_same_type_power(const power &lh, const power &rh) const
 }
 
 // compare two symbol objects
-// same behavior wihtin mul and add objects:
+// same behavior within mul and add objects:
 // we compare names
 int print_order::compare_same_type_symbol(const symbol &lh, const symbol &rh) const
 {
@@ -662,7 +662,7 @@ int print_order::compare_same_type_container(const container<C> &lh,
 }
 
 // compare two function objects
-// same behavior wihtin mul and add objects:
+// same behavior within mul and add objects:
 // we compare names
 int print_order::compare_same_type_function(const function &lh,
 					    const function &rh) const
@@ -675,7 +675,7 @@ int print_order::compare_same_type_function(const function &lh,
 }
 
 // compare two fderivative objects
-// same behavior wihtin mul and add objects:
+// same behavior within mul and add objects:
 // we compare names
 int print_order::compare_same_type_fderivative(const fderivative &lh,
 					       const fderivative &rh) const
diff --git a/m4/pkg.m4 b/m4/pkg.m4
index c5b26b5..c0a8d3d 100644
--- a/m4/pkg.m4
+++ b/m4/pkg.m4
@@ -53,7 +53,7 @@ fi[]dnl
 # to PKG_CHECK_MODULES(), but does not set variables or print errors.
 #
 # Please remember that m4 expands AC_REQUIRE([PKG_PROG_PKG_CONFIG])
-# only at the first occurence in configure.ac, so if the first place
+# only at the first occurrence in configure.ac, so if the first place
 # it's called might be skipped (such as if it is within an "if", you
 # have to call PKG_CHECK_EXISTS manually
 # --------------------------------------------------------------
