.. -*- coding: utf-8 -*-
.. escape-backslashes
.. default-role:: math


Tutorial on hyperbolic surfaces
===============================

A *hyperbolic surface with cusps* is a topological surface together with
a hyperbolic structure of finite area. ``polymake`` can deal with
hyperbolic surfaces in view of Penners coordinates of the decorated
Teichm√ºller space (lambda lengths). These allow to pick a hyperbolic
surface by choosing a triangulation of the surface along with one
positive parameter for each edge.

The `secondary fan <https://arxiv.org/abs/1708.08714v1>`__ of a
hyperbolic surface stratifies the space of weight vectors (horocyclic
decorations) according to which Delaunay triangulations are induced by
the Epstein-Penner convex hull construction. For each point on the
surface, there is a `secondary
polyhedron <https://arxiv.org/abs/1708.08714v1>`__ whose normal fan is
the secondary fan.

This tutorial shows how to deal with secondary fans and secondary
polyhedra of hyperbolic surfaces.

Construction of hyperbolic surfaces
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

To define a hyperbolic surface we need to specify (a) a triangulation
and (b) Penner coordinates.

(a) The triangulation is obtained by specifying the ``DCEL_DATA`` as an
    ``Array<Array<Int>>``. This constructs a doubly connected edge list
    as follows: Each row of ``DCEL_DATA`` reads { (*2i*).head ,
    (*2i+1*).head , (*2i*).next , (*2i+1*).next }. In general, for each
    edge *i* of the triangulation there are two half edges *2i* and
    *2i+1*, one for each orientation.

(b) The ``PENNER_COORDINATES`` assign a positive rational number to each
    edge of the triangulation, ordered in the same sense as prescribed
    by the ``DCEL_DATA``.

Example 1: hyperbolic sphere with three cusps
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


.. link

.. CODE-BLOCK:: perl

    polymake> application 'fan';
    polymake> application 'topaz';

.. link

.. CODE-BLOCK:: perl

    polymake> $S3 = new Array<Array<Int>>([[1,0,2,5],[2,1,4,1],[0,2,0,3]]);
    polymake> $s = new HyperbolicSurface(DCEL_DATA=>$S3,PENNER_COORDINATES=>[1,1,1]);

In this example the doubly connected edge list looks like this:
|Paper.Skizzen.2%281%29.png|

The secondary fan
~~~~~~~~~~~~~~~~~

The secondary fan of the hyperbolic sphere from above can now be
computed as follows.

.. |Paper.Skizzen.2%281%29.png| image:: attachment:Paper.Skizzen.2%281%29.png


.. link

.. CODE-BLOCK:: perl

    polymake> $f = $s->SECONDARY_FAN;
    polymake> $f->properties;
    type: PolyhedralFan<Rational>
    
    RAYS
    0 1 1
    1 0 1
    1 1 0
    0 0 1
    1 0 0
    0 1 0
    
    
    MAXIMAL_CONES
    {0 1 2}
    {0 1 3}
    {1 2 4}
    {0 2 5}
    





.. raw:: html

    <details><summary><pre style="display:inline"><small>Click here for additional output</small></pre></summary>
    <pre>
    polymake: used package ppl
      The Parma Polyhedra Library (PPL): A C++ library for convex polyhedra
      and other numerical abstractions.
      http://www.cs.unipr.it/ppl/
    
    </pre>
    </details>




.. link

.. CODE-BLOCK:: perl

    polymake> $f->VISUAL;


.. raw:: html

    <!--
    polymake for loewe
    Fri Feb  9 13:50:03 2018
    fan:
    -->
    
    
    <html>
       <head>
          <title>fan:</title>
          <style>
    /*
    // COMMON_CODE_BLOCK_BEGIN
    */
             html{overflow: scroll;}
             body { font-family: Arial, Helvetica, sans-serif}
             strong{font-size: 18px;}
             canvas { z-index: 8; }
             input[type='range'] {}
             input[type='radio'] {margin-left:0;}
             input[type='checkbox'] {margin-right:7px; margin-left: 0px; padding-left:0px;}
             .group{padding-bottom: 40px;}
             .settings * {z-index: 11; }
             .settings{z-index: 10; margin-left: 30px; display: none; width: 14em; height: 90%; border: solid 1px silver; padding: 2px; overflow-y: scroll; background-color: white }
             .indented{margin-left: 20px; margin-top: 15px; padding-bottom: 0px;} 
             .shownObjectsList{overflow: auto; max-width: 150px; max-height: 150px;}
             .showSettingsButton{display: block; z-index: 12; position: absolute }
             .hideSettingsButton{display: none; z-index: 12; position: absolute; opacity: 0.5}
             .resetButton{margin-top: 20px;}
             button{margin-left: 0;}
             img{cursor: pointer;}
             .suboption{padding-top: 30px;}
             .transparency{display: none;}
             .labelsCheckbox{margin-top: 10px;}
    
    
             input[type=range] {
               -webkit-appearance: none;
               padding:0; 
               width:90%; 
               margin-left: auto;
               margin-right: auto;
               margin-top: 20px;
               display: block;	
             }
             input[type=range]:focus {
               outline: none;
             }
             input[type=range]::-webkit-slider-runnable-track {
               height: 4px;
               cursor: pointer;
               animate: 0.2s;
               box-shadow: 0px 0px 0px #000000;
               background: #E3E3E3;
               border-radius: 0px;
               border: 0px solid #000000;
             }
             input[type=range]::-webkit-slider-thumb {
               box-shadow: 1px 1px 2px #B8B8B8;
               border: 1px solid #ABABAB;
               height: 13px;
               width: 25px;
               border-radius: 20px;
               background: #E0E0E0;
               cursor: pointer;
               -webkit-appearance: none;
               margin-top: -5px;
             }
             input[type=range]:focus::-webkit-slider-runnable-track {
               background: #E3E3E3;
             }
             input[type=range]::-moz-range-track {
               height: 4px;
               cursor: pointer;
               animate: 0.2s;
               box-shadow: 0px 0px 0px #000000;
               background: #E3E3E3;
               border-radius: 0px;
               border: 0px solid #000000;
             }
             input[type=range]::-moz-range-thumb {
               box-shadow: 1px 1px 2px #B8B8B8;
               border: 1px solid #ABABAB;
               height: 13px;
               width: 25px;
               border-radius: 20px;
               background: #E0E0E0;
               cursor: pointer;
             }
             input[type=range]::-ms-track {
               height: 4px;
               cursor: pointer;
               animate: 0.2s;
               background: transparent;
               border-color: transparent;
               color: transparent;
             }
             input[type=range]::-ms-fill-lower {
               background: #E3E3E3;
               border: 0px solid #000000;
               border-radius: 0px;
               box-shadow: 0px 0px 0px #000000;
             }
             input[type=range]::-ms-fill-upper {
               background: #E3E3E3;
               border: 0px solid #000000;
               border-radius: 0px;
               box-shadow: 0px 0px 0px #000000;
             }
             input[type=range]::-ms-thumb {
               box-shadow: 1px 1px 2px #B8B8B8;
               border: 1px solid #ABABAB;
               height: 13px;
               width: 25px;
               border-radius: 20px;
               background: #E0E0E0;
               cursor: pointer;
             }
             input[type=range]:focus::-ms-fill-lower {
               background: #E3E3E3;
             }
             input[type=range]:focus::-ms-fill-upper {
               background: #E3E3E3;
             }
    /*
    // COMMON_CODE_BLOCK_END
    */
    		</style>
       </head>
    
    <body>
    
    		<div id='settings_0' class='settings'>
    			<div class=group id='explode_0'>
    				<strong>Explode</strong>
    				<input id='explodeRange_0' type='range' min=0 max=6 step=0.01 value=0>
    				<div class=indented><input id='explodeCheckbox_0' type='checkbox'>Automatic explosion</div>
    				<div class=suboption>Exploding speed</div>
    				<input id='explodingSpeedRange_0' type='range' min=0 max=0.5 step=0.001 value=0.05>
    			</div>
    
    			
    			<div class=group id='transparency_0' class='transparency'>
    				<strong>Transparency</strong>
    				<input id='transparencyRange_0' type='range' min=0 max=1 step=0.01 value=0>
    			</div>
    			
    			<div class=group id='rotation_0'>
    				<strong>Rotation</strong>
    				<div class=indented>
    					<div><input type='checkbox' id='changeRotationX_0'> x-axis</div>
    					<div><input type='checkbox' id='changeRotationY_0'> y-axis</div>
    					<div><input type='checkbox' id='changeRotationZ_0'> z-axis</div>
    					<button id='resetButton_0' class='resetButton' >Reset</button>
    				</div>
    
    				<div class=suboption>Rotation speed</div>
    				<input id='rotationSpeedRange_0' type='range' min=0 max=5 step=0.01 value=2>
    
    			</div>
    
    
    			<div class=group id='display_0'>
    				<strong>Display</strong>
    				<div class=indented>
    					<div id='shownObjectsList_0' class='shownObjectsList'></div>
    					<div class='labelsCheckbox'><input type='checkbox' id='labelsCheckboxInput_0' checked>Labels</div>
    				</div>
    			</div>
    
    
    			<div class=group id='svg_0'>
    				<strong>SVG</strong>
    				<div class=indented>
    					<form>
    						<input type="radio" name='screenshotMode' value='download' id='download_0' checked> Download<br>
    						<input type="radio" name='screenshotMode' value='tab' id='tab_0' > New tab<br>
    					</form>
    					<button id='takeScreenshot_0'>Screenshot</button>
    				</div>
    			</div>
    
    		</div>	<!-- end of settings -->
    		<img id='hideSettingsButton_0' style="display: none" class='hideSettingsButton' src='/kernelspecs/polymake/close.svg' width=20px">
    		<img id='showSettingsButton_0' class='showSettingsButton' src='/kernelspecs/polymake/menu.svg' width=20px">
    <div id="model67242984015"></div>
    
    <script>
    requirejs.config({
      paths: {
        three: '/kernelspecs/polymake/three',
        Detector: '/kernelspecs/polymake/Detector',
        SVGRenderer: '/kernelspecs/polymake/SVGRenderer',
        CanvasRenderer: '/kernelspecs/polymake/CanvasRenderer',
        Projector: '/kernelspecs/polymake/Projector',
        TrackballControls: '/kernelspecs/polymake/TrackballControls'
      },
      shim: {
        'three':
        {
          exports: 'THREE'
        },
        'Detector':
        {
          deps: [ 'three' ],
          exports: 'Detector'
        },
        'SVGRenderer':
        {
          deps: [ 'three' ],
          exports: 'THREE.SVGRenderer'
        },
        'CanvasRenderer':
        {
          deps: [ 'three' ],
          exports: 'THREE.CanvasRenderer'
        },
        'Projector':
        {
          deps: [ 'three' ],
          exports: 'THREE.Projector'
        },
        'TrackballControls':
        {
          deps: [ 'three' ],
          exports: 'THREE.TrackballControls'
        }
      }
    });
    require(['three'],function(THREE){
        window.THREE = THREE;
      require(['Detector','SVGRenderer','CanvasRenderer','Projector','TrackballControls'],function(Detector,SVGRenderer,CanvasRenderer,Projector,TrackballControls){
          THREE.SVGRenderer = SVGRenderer;
          THREE.CanvasRenderer = CanvasRenderer;
          THREE.Projector = Projector;
          THREE.TrackballControls = TrackballControls;
    
    // COMMON_CODE_BLOCK_BEGIN
    	var foldable = false;
       var container = document.getElementById( 'model67242984015' );
       var renderer = Detector.webgl? new THREE.WebGLRenderer({antialias: true}): new THREE.CanvasRenderer({antialias: true});
    	var svgRenderer = new THREE.SVGRenderer({antialias: true});
                var box = document.getElementsByClassName( 'output_subarea' )[0];
             var notebook = document.getElementById( 'notebook_panel' );
    
       var width = box.clientWidth - 25;
       var height = notebook.clientHeight * 0.8;
       renderer.setSize(width, height);
       svgRenderer.setSize(width, height);
       renderer.setClearColor(0xFFFFFF, 1);
       svgRenderer.setClearColor(0xFFFFFF, 1);
    
       container.appendChild(renderer.domElement);
    
       var scene = new THREE.Scene();
       var camera = new THREE.PerspectiveCamera(75, width/height, 0.1, 1000);
    
       var renderid;
    
       camera.position.set(0, 0, 5);
       camera.lookAt(0, 0, 0);
       camera.up.set(0, 1, 0);
    
       // class to allow move points together with labels and spheres
       var PMPoint = function (x,y,z) {
          this.vector = new THREE.Vector3(x,y,z);
          this.sprite = null;
          this.sphere = null;
       }
       PMPoint.prototype.makelabel = function(label) {
          this.sprite = textSprite( label );
          this.sprite.position.copy(this.vector);
       }
       PMPoint.prototype.makesphere = function(radius,material) {
          this.sphere = new THREE.Mesh(new THREE.SphereGeometry(radius), material);
          this.sphere.position.copy(this.vector);
       }
    
       PMPoint.prototype.setX = function(x) {
          this.vector.setX(x);
          if (this.sprite) {
             this.sprite.position.setX(x);
          }
          if (this.sphere) {
             this.sphere.position.setX(x);
          }
       };
       PMPoint.prototype.setY = function(y) {
          this.vector.setY(y);
          if (this.sprite) {
             this.sprite.position.setY(y);
          }
          if (this.sphere) {
             this.sphere.position.setY(y);
          }
       };
       PMPoint.prototype.setZ = function(z) {
          this.vector.setZ(z);
          if (this.sprite) {
             this.sprite.position.setZ(z);
          }
          if (this.sphere) {
             this.sphere.position.setZ(z);
          }
       };
       PMPoint.prototype.set = function(x,y,z) {
          this.vector.set(x,y,z);
          if (this.sprite) {
             this.sprite.position.set(x,y,z);
          }
          if (this.sphere) {
             this.sphere.position.set(x,y,z);
          }
       };
       PMPoint.prototype.add = function(o) {
          if (this.sprite) {
             o.add(this.sprite);
          }
          if (this.sphere) {
             o.add(this.sphere);
          }
       };
    
    
       var controls = new THREE.TrackballControls(camera, container);
    	controls.zoomSpeed = 0.2;
    	controls.rotateSpeed = 4;
    
       var all_objects = [];
       var centroids = [];
       // select the target node
       var target = document.querySelector('#model67242984015');
    
       // create an observer instance
       var observer = new MutationObserver(function(mutations) {
          mutations.forEach(function(mutation) {
             if (mutation.removedNodes && mutation.removedNodes.length > 0) {
                cancelAnimationFrame(renderId);
                observer.disconnect();
                console.log("cancelled frame "+renderId);
             }
          });
       });
    
       // configuration of the observer:
       var config = { childList: true, characterData: true }
    
       // pass in the target node, as well as the observer options
       while (target) {
          if (target.className=="output") {
             observer.observe(target, config);
             break;
          }
          target = target.parentNode;
       }
    
    // COMMON_CODE_BLOCK_END
    
       var objectnames = ["Rays","unnamed__1","unnamed__2","unnamed__3","unnamed__4"];
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0, 0, 0));
       allpoints.push(new PMPoint(0, 0.707107, 0.707107));
       allpoints.push(new PMPoint(0.707107, 0, 0.707107));
       allpoints.push(new PMPoint(0.707107, 0.707107, 0));
       allpoints.push(new PMPoint(0, 0, 1));
       allpoints.push(new PMPoint(1, 0, 0));
       allpoints.push(new PMPoint(0, 1, 0));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
       allpoints[3].makesphere(0.02,points_material);
       allpoints[4].makesphere(0.02,points_material);
       allpoints[5].makesphere(0.02,points_material);
       allpoints[6].makesphere(0.02,points_material);
       allpoints[0].makelabel(" ");
       allpoints[1].makelabel("0");
       allpoints[2].makelabel("1");
       allpoints[3].makelabel("2");
       allpoints[4].makelabel("3");
       allpoints[5].makelabel("4");
       allpoints[6].makelabel("5");
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES -->
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[4].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[5].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[6].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0, 0.707107, 0.707107));
       allpoints.push(new PMPoint(0.707107, 0, 0.707107));
       allpoints.push(new PMPoint(0.707107, 0.707107, 0));
       allpoints.push(new PMPoint(0, 0, 0));
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
       faces.vertices.push(allpoints[3].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var materials = [
          new THREE.MeshBasicMaterial({ transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, color: 0x77EC9E, }),
          new THREE.MeshBasicMaterial({ transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, color: 0x77EC9E, }),
          new THREE.MeshBasicMaterial({ transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, color: 0x77EC9E, }),
          new THREE.MeshBasicMaterial({ transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, color: 0xFF0000, }),
       ];
       for (index = 0; index < materials.length; ++index) {
          materials[index].side = THREE.DoubleSide;
       }
       var faces_material = new THREE.MeshFaceMaterial ( materials );
    
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(2, 3, 0, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(1, 3, 2, undefined, undefined, 1));
    
       faces.faces.push(new THREE.Face3(0, 3, 1, undefined, undefined, 2));
    
       faces.faces.push(new THREE.Face3(2, 0, 1, undefined, undefined, 3));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0, 0.707107, 0.707107));
       allpoints.push(new PMPoint(0.707107, 0, 0.707107));
       allpoints.push(new PMPoint(0, 0, 1));
       allpoints.push(new PMPoint(0, 0, 0));
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
       faces.vertices.push(allpoints[3].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var materials = [
          new THREE.MeshBasicMaterial({ transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, color: 0x77EC9E, }),
          new THREE.MeshBasicMaterial({ transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, color: 0x77EC9E, }),
          new THREE.MeshBasicMaterial({ transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, color: 0x77EC9E, }),
          new THREE.MeshBasicMaterial({ transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, color: 0xFF0000, }),
       ];
       for (index = 0; index < materials.length; ++index) {
          materials[index].side = THREE.DoubleSide;
       }
       var faces_material = new THREE.MeshFaceMaterial ( materials );
    
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(3, 0, 1, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(2, 0, 3, undefined, undefined, 1));
    
       faces.faces.push(new THREE.Face3(3, 1, 2, undefined, undefined, 2));
    
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 3));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[3].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[2].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[3].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0.707107, 0, 0.707107));
       allpoints.push(new PMPoint(0.707107, 0.707107, 0));
       allpoints.push(new PMPoint(1, 0, 0));
       allpoints.push(new PMPoint(0, 0, 0));
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
       faces.vertices.push(allpoints[3].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var materials = [
          new THREE.MeshBasicMaterial({ transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, color: 0x77EC9E, }),
          new THREE.MeshBasicMaterial({ transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, color: 0x77EC9E, }),
          new THREE.MeshBasicMaterial({ transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, color: 0x77EC9E, }),
          new THREE.MeshBasicMaterial({ transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, color: 0xFF0000, }),
       ];
       for (index = 0; index < materials.length; ++index) {
          materials[index].side = THREE.DoubleSide;
       }
       var faces_material = new THREE.MeshFaceMaterial ( materials );
    
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(3, 0, 1, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(2, 0, 3, undefined, undefined, 1));
    
       faces.faces.push(new THREE.Face3(3, 1, 2, undefined, undefined, 2));
    
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 3));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[3].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[2].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[3].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0, 0.707107, 0.707107));
       allpoints.push(new PMPoint(0.707107, 0.707107, 0));
       allpoints.push(new PMPoint(0, 1, 0));
       allpoints.push(new PMPoint(0, 0, 0));
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
       faces.vertices.push(allpoints[3].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var materials = [
          new THREE.MeshBasicMaterial({ transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, color: 0x77EC9E, }),
          new THREE.MeshBasicMaterial({ transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, color: 0x77EC9E, }),
          new THREE.MeshBasicMaterial({ transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, color: 0x77EC9E, }),
          new THREE.MeshBasicMaterial({ transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, color: 0xFF0000, }),
       ];
       for (index = 0; index < materials.length; ++index) {
          materials[index].side = THREE.DoubleSide;
       }
       var faces_material = new THREE.MeshFaceMaterial ( materials );
    
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 3, 1, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(2, 3, 0, undefined, undefined, 1));
    
       faces.faces.push(new THREE.Face3(1, 3, 2, undefined, undefined, 2));
    
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 3));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
    // COMMON_CODE_BLOCK_BEGIN
    var xRotationEnabled = false;
    var yRotationEnabled = false;
    var zRotationEnabled = false;
    var rotationSpeedFactor = 1;
    var settingsShown = false;
    var labelsShown = true;
    var intervals = [];
    var timeouts = [];
    var explodingSpeed = 0.05;
    var explodeScale = 0;
    var XMLS = new XMLSerializer();
    var svgElement;
    var renderId;
    
    	var render = function () {
    
    		renderId = requestAnimationFrame(render);
    
    //		comment in for automatic explosion
    //		explode(updateFactor());
    
    		var phi = 0.02 * rotationSpeedFactor;
    
    		if (xRotationEnabled){
    			scene.rotation.x += phi;
    		}
    		if(yRotationEnabled){
    			scene.rotation.y += phi;
    		}
    		if(zRotationEnabled){
    			scene.rotation.z += phi;
    		}
    
    		controls.update();
    		renderer.render(scene, camera);
    	};
    
    	render();
    
    	function computeCentroid(geom) {
    		centroid = new THREE.Vector3();
    		geom.vertices.forEach(function(v) {
    			centroid.add(v);			
    		});
    		centroid.divideScalar(geom.vertices.length);
    		return centroid;
    	}
    
    	function changeTransparency(event){
    		var opacity = 1-Number(event.currentTarget.value);
    		for (var i=0; i<all_objects.length; i++){
    			for (var j=0; j<all_objects[i].children.length; j++){
    				if (all_objects[i].children[j].material.type == "MultiMaterial") {
    					for (var k=0; k<all_objects[i].children[j].material.materials.length; k++){
    						all_objects[i].children[j].material.materials[k].opacity = opacity;
    						all_objects[i].children[j].material.materials[k].depthWrite = opacity < 0.5 ? false : true;
    						all_objects[i].children[j].material.materials[k].depthTest = opacity < 0.5 ? false : true;
    					}
    				} else if (all_objects[i].children[j].material.transparent && 
    							  all_objects[i].children[j].material.type == "MeshBasicMaterial" &&
    							  all_objects[i].children[j].geometry.type == "Geometry"){
    					all_objects[i].children[j].material.opacity = opacity;
    					all_objects[i].children[j].material.depthWrite = opacity < 0.5 ? false : true;
    					all_objects[i].children[j].material.depthTest = opacity < 0.5 ? false : true;
    				}
    			}
    		}
    	}
    
    	function changeRotationX(event){
    		xRotationEnabled = event.currentTarget.checked;
    	}	
    
    	function changeRotationY(event){
    		yRotationEnabled = event.currentTarget.checked;
    	}	
    
    	function changeRotationZ(event){
    		zRotationEnabled = event.currentTarget.checked;
    	}	
    
    
    	function changeRotationSpeedFactor(event){
    		rotationSpeedFactor = Number(event.currentTarget.value);
    	}
    
    	function resetScene(){
    		scene.rotation.set(0,0,0);
    		camera.position.set(0,0,5);
    		camera.up.set(0,1,0);
    	}
    
    	function showSettings(event){
    		event.currentTarget.style.display = 'none';
    		document.getElementById('settings_0').style.position = 'absolute';
    		document.getElementById('settings_0').style.display = 'block';
    		document.getElementById('showSettingsButton_0').style.display = 'none';
    		document.getElementById('hideSettingsButton_0').style.display = 'block';
    		settingsShown = true;
    	}
    
    	function hideSettings(event){
    		event.currentTarget.style.display = 'none';
    		document.getElementById('settings_0').style.display = 'none';
    		document.getElementById('hideSettingsButton_0').style.display = 'none';
    		document.getElementById('showSettingsButton_0').style.display = 'block';
    		settingsShown = false;
    	}
    
    
    
    	var pos = 150* Math.PI;
    
    	function updateFactor() {
    		pos++;
    		return Math.sin(.01*pos)+1;
    	}
    
    	function makelabel(message, x, y, z, params) {
    		var spritey = textSprite( message, params );
    		spritey.position.set(x, y, z);
    		obj.add(spritey);
    	}
    
    	function textSprite(message, parameters)
    	{
    		if ( parameters === undefined ) parameters = {};
    
    		var fontface = "Helvetica";
    
    		var fontsize = parameters.hasOwnProperty("fontsize") ? 
    			parameters["fontsize"] : 18;
    		fontsize = fontsize*10;
    
    		var canvas = document.createElement('canvas');
    		var size = 1024;
    		canvas.width = size;
    		canvas.height = size;
    		var context = canvas.getContext('2d');
    		context.font = fontsize + "px " + fontface;
    
    		// text color
    		context.fillStyle = "rgba(0, 0, 0, 1.0)";
    
    		context.fillText(message, size/2, size/2);
    
    		// canvas contents will be used for a texture
    		var texture = new THREE.Texture(canvas);
    		texture.needsUpdate = true;
    
    		var spriteMaterial = new THREE.SpriteMaterial(
    			{map: texture, useScreenCoordinates: false});
    		var sprite = new THREE.Sprite(spriteMaterial);
    		return sprite;
    	}
    
    	function takeSvgScreenshot(){
    		if (labelsShown){
    			hideLabels();
    		}
    		svgRenderer.render(scene,camera);
    		svgElement = XMLS.serializeToString(svgRenderer.domElement);
    		
    		if (labelsShown){
    			displayLabels();
    		}
    
    		if (document.getElementById('tab_0').checked){
    			//show in new tab
    			var myWindow = window.open("","");
    			myWindow.document.body.innerHTML = svgElement;
    		} else{
    			// download svg file 
    			download("screenshot.svg", svgElement);
    		}
    	}
    		
    
    	function showOrHideObject(event){
    		var nr = Number(event.currentTarget.name);
    		all_objects[nr].visible = event.currentTarget.checked;
    	}
    
    
    	function displayOrHideOptions(){
    		for (var i=0; i<all_objects.length; i++){
    			for (var j=0; j<all_objects[i].children.length; j++){
    				if (all_objects[i].children[j].material.type == "MultiMaterial") {
    					for (var k=0; k<all_objects[i].children[j].material.materials.length; k++){
    						if (all_objects[i].children[j].material.materials[k].transparent) {
    							document.getElementById('transparency_0').style.display = 'block';
    							document.getElementById('transparencyRange_0').value = 1 - 
    							    all_objects[i].children[j].material.materials[k].opacity;
    							return;
    						}
    					}
    				} else if (all_objects[i].children[j].material.transparent && 
    							  all_objects[i].children[j].material.type == "MeshBasicMaterial" &&
    							  all_objects[i].children[j].geometry.type == "Geometry"){
    					document.getElementById('transparency_0').style.display = 'block';
    					return;
    				}
    			}
    		}
    	}
    
    	displayOrHideOptions()
    
    
    
    
    // ---------------------- EXPLOSION ------------------------------------------------
    // ---------------------------------------------------------------------------------
    
    	function explode(factor) {
    		var obj, c;
    		var c0 = centroids[0];
    		for (var i = 0; i<centroids.length; ++i) {
    			c = centroids[i];
    			obj = all_objects[all_objects.length - centroids.length + i];
    			obj.position.set(c.x*factor, c.y*factor, c.z*factor);
    		}	
    	}
    
    	function triggerExplode(event){
    		explodeScale = Number(event.currentTarget.value);
    		explode(explodeScale);
    	}
    
    	function setExplodingSpeed(event){
    		explodingSpeed = Number(event.currentTarget.value);
    	}
    
    	function triggerAutomaticExplode(event){
    		if (event.currentTarget.checked){
    			startExploding();
    		} else {
    			clearIntervals();
    		}	
    	}
    
    	function startExploding(){
    		intervals.push(setInterval(explodingInterval, 25));
    	}
    
    
    	function explodingInterval(){
    		explodeScale += explodingSpeed;
    		if (explodeScale <= 6){ 
    			explode(explodeScale);
    		}
    		else{
    			explode(6);
    			explodeScale = 6;
    			clearIntervals();
    			timeouts.push(setTimeout(startUnexploding, 3000));
    		}
    		document.getElementById('explodeRange_0').value = explodeScale;
    	}
    
    
    	function startUnexploding(){
    		intervals.push(setInterval(unexplodingInterval, 25));
    	}
    
    	function unexplodingInterval(){
    		explodeScale -= explodingSpeed;
    		if (explodeScale >= 0){	
    			explode(explodeScale);
    		}
    		else {
    			explode(0);
    			explodeScale = 0;
    			clearIntervals();
    			timeouts.push(setTimeout(startExploding, 3000));
    		}
    		document.getElementById('explodeRange_0').value = explodeScale;
    	}
    
    	function clearIntervals(){
    		intervals.forEach(function(interval){
    			clearInterval(interval);
    		});
    		intervals = [];
    		timeouts.forEach(function(timeout){
    			clearTimeout(timeout);
    		});
    		timeouts = [];
    	}
    
    			
    
    	// append checkboxes for displaying or hiding objects
    	var shownObjectsList = document.getElementById('shownObjectsList_0');
    	for (var i=0; i<all_objects.length; i++){
    		var objNode = document.createElement('span');
    		objNode.innerHTML = objectnames[i] + '<br>';
    		var checkbox = document.createElement('input');
    		checkbox.type = 'checkbox';
    		checkbox.checked = true;
    		checkbox.name = String(i);
    		checkbox.onchange = showOrHideObject;
    		shownObjectsList.appendChild(checkbox);
    		shownObjectsList.appendChild(objNode);
    	}
    
    	function displayLabels(){
    		for (var i=0; i<all_objects.length; i++){
    			for (var j=0; j<all_objects[i].children.length; j++){
    				var child = all_objects[i].children[j];
    				if (child.type == 'Sprite'){
    					child.visible = true;
    				}
    			}
    		}
    	}
    
    	function hideLabels(){
    		for (var i=0; i<all_objects.length; i++){
    			for (var j=0; j<all_objects[i].children.length; j++){
    				var child = all_objects[i].children[j];
    				if (child.type == 'Sprite'){
    					child.visible = false;
    				}
    			}
    		}
    	}
    
    	function displayOrHideLabels(event){
    		if (event.currentTarget.checked){
    			displayLabels();
    			labelsShown = true;
    		} else {
    			hideLabels();
    			labelsShown = false;
    		}
    	}
    
    	function download(filename, text) {
    	  var element = document.createElement('a');
    	  element.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(text));
    	  element.setAttribute('download', filename);
    
    	  element.style.display = 'none';
    	  document.body.appendChild(element);
    
    	  element.click();
    
    	  document.body.removeChild(element);
    	}
    
    var tempobj;
    tempobj = document.getElementById('explodeRange_0');
    if (tempobj) {
       tempobj.oninput = triggerExplode;
       document.getElementById('explodeCheckbox_0').onchange = triggerAutomaticExplode;
       document.getElementById('explodingSpeedRange_0').oninput = setExplodingSpeed;
    }
    tempobj = document.getElementById('foldRange_0');
    if (tempobj) {
       tempobj.oninput = fold;
    }
    document.getElementById('transparencyRange_0').oninput = changeTransparency;
    document.getElementById('changeRotationX_0').onchange = changeRotationX;
    document.getElementById('changeRotationY_0').onchange = changeRotationY;
    document.getElementById('changeRotationZ_0').onchange = changeRotationZ;
    document.getElementById('resetButton_0').onclick = resetScene;
    document.getElementById('rotationSpeedRange_0').oninput = changeRotationSpeedFactor;
    document.getElementById('labelsCheckboxInput_0').onchange = displayOrHideLabels;
    document.getElementById('takeScreenshot_0').onclick = takeSvgScreenshot;
    document.getElementById('showSettingsButton_0').onclick = showSettings;
    document.getElementById('hideSettingsButton_0').onclick = hideSettings;
    
    	
    
    // ------------------ SHORTCUTS --------------------------------------------
    // -------------------------------------------------------------------------
    
    /**
     * http://www.openjs.com/scripts/events/keyboard_shortcuts/
     * Version : 2.01.B
     * By Binny V A
     * License : BSD
     */
    shortcut = {
    	'all_shortcuts':{},//All the shortcuts are stored in this array
    	'add': function(shortcut_combination,callback,opt) {
    		//Provide a set of default options
    		var default_options = {
    			'type':'keydown',
    			'propagate':false,
    			'disable_in_input':false,
    			'target':document,
    			'keycode':false
    		}
    		if(!opt) opt = default_options;
    		else {
    			for(var dfo in default_options) {
    				if(typeof opt[dfo] == 'undefined') opt[dfo] = default_options[dfo];
    			}
    		}
    
    		var ele = opt.target;
    		if(typeof opt.target == 'string') ele = document.getElementById(opt.target);
    		var ths = this;
    		shortcut_combination = shortcut_combination.toLowerCase();
    
    		//The function to be called at keypress
    		var func = function(e) {
    			e = e || window.event;
    			
    			if(opt['disable_in_input']) { //Don't enable shortcut keys in Input, Textarea fields
    				var element;
    				if(e.target) element=e.target;
    				else if(e.srcElement) element=e.srcElement;
    				if(element.nodeType==3) element=element.parentNode;
    
    				if(element.tagName == 'INPUT' || element.tagName == 'TEXTAREA') return;
    			}
    	
    			//Find Which key is pressed
    			if (e.keyCode) code = e.keyCode;
    			else if (e.which) code = e.which;
    			var character = String.fromCharCode(code).toLowerCase();
    			
    			if(code == 188) character=","; //If the user presses , when the type is onkeydown
    			if(code == 190) character="."; //If the user presses , when the type is onkeydown
    
    			var keys = shortcut_combination.split("+");
    			//Key Pressed - counts the number of valid keypresses - if it is same as the number of keys, the shortcut function is invoked
    			var kp = 0;
    			
    			//Work around for stupid Shift key bug created by using lowercase - as a result the shift+num combination was broken
    			var shift_nums = {
    				"`":"~",
    				"1":"!",
    				"2":"@",
    				"3":"#",
    				"4":"$",
    				"5":"%",
    				"6":"^",
    				"7":"&",
    				"8":"*",
    				"9":"(",
    				"0":")",
    				"-":"_",
    				"=":"+",
    				";":":",
    				"'":"\"",
    				",":"<",
    				".":">",
    				"/":"?",
    				"\\":"|"
    			}
    			//Special Keys - and their codes
    			var special_keys = {
    				'esc':27,
    				'escape':27,
    				'tab':9,
    				'space':32,
    				'return':13,
    				'enter':13,
    				'backspace':8,
    	
    				'scrolllock':145,
    				'scroll_lock':145,
    				'scroll':145,
    				'capslock':20,
    				'caps_lock':20,
    				'caps':20,
    				'numlock':144,
    				'num_lock':144,
    				'num':144,
    				
    				'pause':19,
    				'break':19,
    				
    				'insert':45,
    				'home':36,
    				'delete':46,
    				'end':35,
    				
    				'pageup':33,
    				'page_up':33,
    				'pu':33,
    	
    				'pagedown':34,
    				'page_down':34,
    				'pd':34,
    	
    				'left':37,
    				'up':38,
    				'right':39,
    				'down':40,
    	
    				'f1':112,
    				'f2':113,
    				'f3':114,
    				'f4':115,
    				'f5':116,
    				'f6':117,
    				'f7':118,
    				'f8':119,
    				'f9':120,
    				'f10':121,
    				'f11':122,
    				'f12':123
    			}
    	
    			var modifiers = { 
    				shift: { wanted:false, pressed:false},
    				ctrl : { wanted:false, pressed:false},
    				alt  : { wanted:false, pressed:false},
    				meta : { wanted:false, pressed:false}	//Meta is Mac specific
    			};
                            
    			if(e.ctrlKey)	modifiers.ctrl.pressed = true;
    			if(e.shiftKey)	modifiers.shift.pressed = true;
    			if(e.altKey)	modifiers.alt.pressed = true;
    			if(e.metaKey)   modifiers.meta.pressed = true;
                            
    			for(var i=0; k=keys[i],i<keys.length; i++) {
    				//Modifiers
    				if(k == 'ctrl' || k == 'control') {
    					kp++;
    					modifiers.ctrl.wanted = true;
    
    				} else if(k == 'shift') {
    					kp++;
    					modifiers.shift.wanted = true;
    
    				} else if(k == 'alt') {
    					kp++;
    					modifiers.alt.wanted = true;
    				} else if(k == 'meta') {
    					kp++;
    					modifiers.meta.wanted = true;
    				} else if(k.length > 1) { //If it is a special key
    					if(special_keys[k] == code) kp++;
    					
    				} else if(opt['keycode']) {
    					if(opt['keycode'] == code) kp++;
    
    				} else { //The special keys did not match
    					if(character == k) kp++;
    					else {
    						if(shift_nums[character] && e.shiftKey) { //Stupid Shift key bug created by using lowercase
    							character = shift_nums[character]; 
    							if(character == k) kp++;
    						}
    					}
    				}
    			}
    			
    			if(kp == keys.length && 
    						modifiers.ctrl.pressed == modifiers.ctrl.wanted &&
    						modifiers.shift.pressed == modifiers.shift.wanted &&
    						modifiers.alt.pressed == modifiers.alt.wanted &&
    						modifiers.meta.pressed == modifiers.meta.wanted) {
    				callback(e);
    	
    				if(!opt['propagate']) { //Stop the event
    					//e.cancelBubble is supported by IE - this will kill the bubbling process.
    					e.cancelBubble = true;
    					e.returnValue = false;
    	
    					//e.stopPropagation works in Firefox.
    					if (e.stopPropagation) {
    						e.stopPropagation();
    						e.preventDefault();
    					}
    					return false;
    				}
    			}
    		}
    		this.all_shortcuts[shortcut_combination] = {
    			'callback':func, 
    			'target':ele, 
    			'event': opt['type']
    		};
    		//Attach the function with the event
    		if(ele.addEventListener) ele.addEventListener(opt['type'], func, false);
    		else if(ele.attachEvent) ele.attachEvent('on'+opt['type'], func);
    		else ele['on'+opt['type']] = func;
    	},
    
    	//Remove the shortcut - just specify the shortcut and I will remove the binding
    	'remove':function(shortcut_combination) {
    		shortcut_combination = shortcut_combination.toLowerCase();
    		var binding = this.all_shortcuts[shortcut_combination];
    		delete(this.all_shortcuts[shortcut_combination])
    		if(!binding) return;
    		var type = binding['event'];
    		var ele = binding['target'];
    		var callback = binding['callback'];
    
    		if(ele.detachEvent) ele.detachEvent('on'+type, callback);
    		else if(ele.removeEventListener) ele.removeEventListener(type, callback, false);
    		else ele['on'+type] = false;
    	}
    }
    
    shortcut.add("Alt+Left",function() {
    	var event = new Event('click');
    	if (settingsShown){
    		document.getElementById('hideSettingsButton_0').dispatchEvent(event);
    	} else{
    		document.getElementById('showSettingsButton_0').dispatchEvent(event);
    	}
    });
    
    if (foldable) moveToBaryCenter();
    
    
    });});
    // COMMON_CODE_BLOCK_END
    </script>
    
    </body>
    </html>



.. raw:: html

    <details><summary><pre style="display:inline"><small>Click here for additional output</small></pre></summary>
    <pre>
    polymake: used package cdd
      cddlib
      Implementation of the double description method of Motzkin et al.
      Copyright by Komei Fukuda.
      http://www-oldurls.inf.ethz.ch/personal/fukudak/cdd_home/
    
    polymake: used package threejs
       Three.js is a lightweight cross-browser JavaScript library/API used to create and display animated 3D computer graphics on a Web browser.
       See http://github.com/mrdoob for the source code.
    
    </pre>
    </details>




.. link

.. CODE-BLOCK:: perl

    polymake> $s->properties;
    name: s
    type: HyperbolicSurface
    
    DCEL_DATA
    1 0 2 5
    2 1 4 1
    0 2 0 3
    
    
    PENNER_COORDINATES
    1 1 1
    
    SECONDARY_FAN
    type: PolyhedralFan<Rational>
    
    FLIP_WORDS
    {}
    {0}
    {1}
    {2}
    





The ``FLIP_WORDS`` indicate how to obtain the Delaunay triangulations.
The k-th flip word is a list of integers (the indices of the edges) that
describe which edge flips produce the k-th Delaunay triangulation. Note
that the k-th Delaunay triangulation also corresponds to the k-th
maximal cone of the ``SECONDARY_FAN``.


GKZ vectors & secondary polyhedra
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

In order to compute ``GKZ_VECTORS`` or a ``secondary_polyhedron`` of a
hyperbolic surface one needs to additionally specify a ``SPECIAL_POINT``
on the surface. This is done by choosing two rational numbers.

Continuing with the above example, lets look at the following.


.. link

.. CODE-BLOCK:: perl

    polymake> $s = new HyperbolicSurface(DCEL_DATA=>$S3,PENNER_COORDINATES=>[1,1,1],SPECIAL_POINT=>[1,0]);

Now we may compute an approximation of the ``GKZ_VECTORS`` of the
surface. The approximation depends on a parameter *depth* that restricts
the depth of the (covering) triangles that are summed over in the
definition of the GKZ vectors.


.. link

.. CODE-BLOCK:: perl

    polymake> print $s->GKZ_VECTORS(3);
    1 33346854621/25672050625 33346854621/25672050625 19782163/27238250
    1 2361/3250 3955357/5447650 33346854621/25672050625
    1 10549213550005124385885122/6365327663846199230365625 11433978/13287625 30327974429709/105771923977850
    1 11433978/13287625 10549213550005124385885122/6365327663846199230365625 30327974429709/105771923977850





The secondary polyhedron can be computed similarly using the function
``secondary_polyhedron``.


.. link

.. CODE-BLOCK:: perl

    polymake> $p = secondary_polyhedron($s,10);
    polymake> $p->properties;
    name: p
    type: Polytope<Float>
    
    VERTICES
    1 1.315301353 1.315301353 0.7316378744
    1 0.7316489581 0.7316267908 1.315301353
    1 1.752046187 0.8750928112 0.2910011302
    1 0.8750928112 1.752046187 0.2910011302
    0 -1 0 0
    0 0 -1 0
    0 0 0 -1
    
    
    VERTICES_IN_FACETS
    {0 1 3 4}
    {0 1 2 5}
    {0 2 3 6}
    {1 4 5}
    {2 5 6}
    {3 4 6}
    
    
    CONE_AMBIENT_DIM
    4





.. link

.. CODE-BLOCK:: perl

    polymake> $p->VISUAL(FacetColor=>'255 180 80');


.. raw:: html

    <!--
    polymake for loewe
    Fri Feb  9 13:50:05 2018
    p_bounded
    -->
    
    
    <html>
       <head>
          <title>p_bounded</title>
          <style>
    /*
    // COMMON_CODE_BLOCK_BEGIN
    */
             html{overflow: scroll;}
             body { font-family: Arial, Helvetica, sans-serif}
             strong{font-size: 18px;}
             canvas { z-index: 8; }
             input[type='range'] {}
             input[type='radio'] {margin-left:0;}
             input[type='checkbox'] {margin-right:7px; margin-left: 0px; padding-left:0px;}
             .group{padding-bottom: 40px;}
             .settings * {z-index: 11; }
             .settings{z-index: 10; margin-left: 30px; display: none; width: 14em; height: 90%; border: solid 1px silver; padding: 2px; overflow-y: scroll; background-color: white }
             .indented{margin-left: 20px; margin-top: 15px; padding-bottom: 0px;} 
             .shownObjectsList{overflow: auto; max-width: 150px; max-height: 150px;}
             .showSettingsButton{display: block; z-index: 12; position: absolute }
             .hideSettingsButton{display: none; z-index: 12; position: absolute; opacity: 0.5}
             .resetButton{margin-top: 20px;}
             button{margin-left: 0;}
             img{cursor: pointer;}
             .suboption{padding-top: 30px;}
             .transparency{display: none;}
             .labelsCheckbox{margin-top: 10px;}
    
    
             input[type=range] {
               -webkit-appearance: none;
               padding:0; 
               width:90%; 
               margin-left: auto;
               margin-right: auto;
               margin-top: 20px;
               display: block;	
             }
             input[type=range]:focus {
               outline: none;
             }
             input[type=range]::-webkit-slider-runnable-track {
               height: 4px;
               cursor: pointer;
               animate: 0.2s;
               box-shadow: 0px 0px 0px #000000;
               background: #E3E3E3;
               border-radius: 0px;
               border: 0px solid #000000;
             }
             input[type=range]::-webkit-slider-thumb {
               box-shadow: 1px 1px 2px #B8B8B8;
               border: 1px solid #ABABAB;
               height: 13px;
               width: 25px;
               border-radius: 20px;
               background: #E0E0E0;
               cursor: pointer;
               -webkit-appearance: none;
               margin-top: -5px;
             }
             input[type=range]:focus::-webkit-slider-runnable-track {
               background: #E3E3E3;
             }
             input[type=range]::-moz-range-track {
               height: 4px;
               cursor: pointer;
               animate: 0.2s;
               box-shadow: 0px 0px 0px #000000;
               background: #E3E3E3;
               border-radius: 0px;
               border: 0px solid #000000;
             }
             input[type=range]::-moz-range-thumb {
               box-shadow: 1px 1px 2px #B8B8B8;
               border: 1px solid #ABABAB;
               height: 13px;
               width: 25px;
               border-radius: 20px;
               background: #E0E0E0;
               cursor: pointer;
             }
             input[type=range]::-ms-track {
               height: 4px;
               cursor: pointer;
               animate: 0.2s;
               background: transparent;
               border-color: transparent;
               color: transparent;
             }
             input[type=range]::-ms-fill-lower {
               background: #E3E3E3;
               border: 0px solid #000000;
               border-radius: 0px;
               box-shadow: 0px 0px 0px #000000;
             }
             input[type=range]::-ms-fill-upper {
               background: #E3E3E3;
               border: 0px solid #000000;
               border-radius: 0px;
               box-shadow: 0px 0px 0px #000000;
             }
             input[type=range]::-ms-thumb {
               box-shadow: 1px 1px 2px #B8B8B8;
               border: 1px solid #ABABAB;
               height: 13px;
               width: 25px;
               border-radius: 20px;
               background: #E0E0E0;
               cursor: pointer;
             }
             input[type=range]:focus::-ms-fill-lower {
               background: #E3E3E3;
             }
             input[type=range]:focus::-ms-fill-upper {
               background: #E3E3E3;
             }
    /*
    // COMMON_CODE_BLOCK_END
    */
    		</style>
       </head>
    
    <body>
    
    		<div id='settings_1' class='settings'>
    			<div class=group id='transparency_1' class='transparency'>
    				<strong>Transparency</strong>
    				<input id='transparencyRange_1' type='range' min=0 max=1 step=0.01 value=0>
    			</div>
    			
    			<div class=group id='rotation_1'>
    				<strong>Rotation</strong>
    				<div class=indented>
    					<div><input type='checkbox' id='changeRotationX_1'> x-axis</div>
    					<div><input type='checkbox' id='changeRotationY_1'> y-axis</div>
    					<div><input type='checkbox' id='changeRotationZ_1'> z-axis</div>
    					<button id='resetButton_1' class='resetButton' >Reset</button>
    				</div>
    
    				<div class=suboption>Rotation speed</div>
    				<input id='rotationSpeedRange_1' type='range' min=0 max=5 step=0.01 value=2>
    
    			</div>
    
    
    			<div class=group id='display_1'>
    				<strong>Display</strong>
    				<div class=indented>
    					<div id='shownObjectsList_1' class='shownObjectsList'></div>
    					<div class='labelsCheckbox'><input type='checkbox' id='labelsCheckboxInput_1' checked>Labels</div>
    				</div>
    			</div>
    
    
    			<div class=group id='svg_1'>
    				<strong>SVG</strong>
    				<div class=indented>
    					<form>
    						<input type="radio" name='screenshotMode' value='download' id='download_1' checked> Download<br>
    						<input type="radio" name='screenshotMode' value='tab' id='tab_1' > New tab<br>
    					</form>
    					<button id='takeScreenshot_1'>Screenshot</button>
    				</div>
    			</div>
    
    		</div>	<!-- end of settings -->
    		<img id='hideSettingsButton_1' style="display: none" class='hideSettingsButton' src='/kernelspecs/polymake/close.svg' width=20px">
    		<img id='showSettingsButton_1' class='showSettingsButton' src='/kernelspecs/polymake/menu.svg' width=20px">
    <div id="model40961939501"></div>
    
    <script>
    requirejs.config({
      paths: {
        three: '/kernelspecs/polymake/three',
        Detector: '/kernelspecs/polymake/Detector',
        SVGRenderer: '/kernelspecs/polymake/SVGRenderer',
        CanvasRenderer: '/kernelspecs/polymake/CanvasRenderer',
        Projector: '/kernelspecs/polymake/Projector',
        TrackballControls: '/kernelspecs/polymake/TrackballControls'
      },
      shim: {
        'three':
        {
          exports: 'THREE'
        },
        'Detector':
        {
          deps: [ 'three' ],
          exports: 'Detector'
        },
        'SVGRenderer':
        {
          deps: [ 'three' ],
          exports: 'THREE.SVGRenderer'
        },
        'CanvasRenderer':
        {
          deps: [ 'three' ],
          exports: 'THREE.CanvasRenderer'
        },
        'Projector':
        {
          deps: [ 'three' ],
          exports: 'THREE.Projector'
        },
        'TrackballControls':
        {
          deps: [ 'three' ],
          exports: 'THREE.TrackballControls'
        }
      }
    });
    require(['three'],function(THREE){
        window.THREE = THREE;
      require(['Detector','SVGRenderer','CanvasRenderer','Projector','TrackballControls'],function(Detector,SVGRenderer,CanvasRenderer,Projector,TrackballControls){
          THREE.SVGRenderer = SVGRenderer;
          THREE.CanvasRenderer = CanvasRenderer;
          THREE.Projector = Projector;
          THREE.TrackballControls = TrackballControls;
    
    // COMMON_CODE_BLOCK_BEGIN
    	var foldable = false;
       var container = document.getElementById( 'model40961939501' );
       var renderer = Detector.webgl? new THREE.WebGLRenderer({antialias: true}): new THREE.CanvasRenderer({antialias: true});
    	var svgRenderer = new THREE.SVGRenderer({antialias: true});
                var box = document.getElementsByClassName( 'output_subarea' )[0];
             var notebook = document.getElementById( 'notebook_panel' );
    
       var width = box.clientWidth - 25;
       var height = notebook.clientHeight * 0.8;
       renderer.setSize(width, height);
       svgRenderer.setSize(width, height);
       renderer.setClearColor(0xFFFFFF, 1);
       svgRenderer.setClearColor(0xFFFFFF, 1);
    
       container.appendChild(renderer.domElement);
    
       var scene = new THREE.Scene();
       var camera = new THREE.PerspectiveCamera(75, width/height, 0.1, 1000);
    
       var renderid;
    
       camera.position.set(0, 0, 5);
       camera.lookAt(0, 0, 0);
       camera.up.set(0, 1, 0);
    
       // class to allow move points together with labels and spheres
       var PMPoint = function (x,y,z) {
          this.vector = new THREE.Vector3(x,y,z);
          this.sprite = null;
          this.sphere = null;
       }
       PMPoint.prototype.makelabel = function(label) {
          this.sprite = textSprite( label );
          this.sprite.position.copy(this.vector);
       }
       PMPoint.prototype.makesphere = function(radius,material) {
          this.sphere = new THREE.Mesh(new THREE.SphereGeometry(radius), material);
          this.sphere.position.copy(this.vector);
       }
    
       PMPoint.prototype.setX = function(x) {
          this.vector.setX(x);
          if (this.sprite) {
             this.sprite.position.setX(x);
          }
          if (this.sphere) {
             this.sphere.position.setX(x);
          }
       };
       PMPoint.prototype.setY = function(y) {
          this.vector.setY(y);
          if (this.sprite) {
             this.sprite.position.setY(y);
          }
          if (this.sphere) {
             this.sphere.position.setY(y);
          }
       };
       PMPoint.prototype.setZ = function(z) {
          this.vector.setZ(z);
          if (this.sprite) {
             this.sprite.position.setZ(z);
          }
          if (this.sphere) {
             this.sphere.position.setZ(z);
          }
       };
       PMPoint.prototype.set = function(x,y,z) {
          this.vector.set(x,y,z);
          if (this.sprite) {
             this.sprite.position.set(x,y,z);
          }
          if (this.sphere) {
             this.sphere.position.set(x,y,z);
          }
       };
       PMPoint.prototype.add = function(o) {
          if (this.sprite) {
             o.add(this.sprite);
          }
          if (this.sphere) {
             o.add(this.sphere);
          }
       };
    
    
       var controls = new THREE.TrackballControls(camera, container);
    	controls.zoomSpeed = 0.2;
    	controls.rotateSpeed = 4;
    
       var all_objects = [];
       var centroids = [];
       // select the target node
       var target = document.querySelector('#model40961939501');
    
       // create an observer instance
       var observer = new MutationObserver(function(mutations) {
          mutations.forEach(function(mutation) {
             if (mutation.removedNodes && mutation.removedNodes.length > 0) {
                cancelAnimationFrame(renderId);
                observer.disconnect();
                console.log("cancelled frame "+renderId);
             }
          });
       });
    
       // configuration of the observer:
       var config = { childList: true, characterData: true }
    
       // pass in the target node, as well as the observer options
       while (target) {
          if (target.className=="output") {
             observer.observe(target, config);
             break;
          }
          target = target.parentNode;
       }
    
    // COMMON_CODE_BLOCK_END
    
       var objectnames = ["p_bounded"];
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(1.75205, 0.876119, 0.291727));
       allpoints.push(new PMPoint(1.75205, -0.492876, 0.290856));
       allpoints.push(new PMPoint(0.731446, -0.492876, 1.3153));
       allpoints.push(new PMPoint(-0.492828, 1.75205, -0.938159));
       allpoints.push(new PMPoint(-0.492828, -0.492876, 1.3153));
       allpoints.push(new PMPoint(-0.492828, -0.492876, -0.938159));
       allpoints.push(new PMPoint(1.75205, -0.492876, -0.938159));
       allpoints.push(new PMPoint(1.75205, 0.875004, -0.938159));
       allpoints.push(new PMPoint(0.875004, 1.75205, -0.938159));
       allpoints.push(new PMPoint(-0.492828, 0.731423, 1.3153));
       allpoints.push(new PMPoint(-0.492828, 1.75205, 0.290856));
       allpoints.push(new PMPoint(0.876119, 1.75205, 0.291731));
       allpoints.push(new PMPoint(0.732223, 0.732203, 1.3153));
       allpoints.push(new PMPoint(1.31428, 1.31428, 0.731417));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makelabel(" ");
       allpoints[1].makelabel(" ");
       allpoints[2].makelabel(" ");
       allpoints[3].makelabel(" ");
       allpoints[4].makelabel(" ");
       allpoints[5].makelabel(" ");
       allpoints[6].makelabel(" ");
       allpoints[7].makelabel(" ");
       allpoints[8].makelabel(" ");
       allpoints[9].makelabel(" ");
       allpoints[10].makelabel(" ");
       allpoints[11].makelabel(" ");
       allpoints[12].makelabel(" ");
       allpoints[13].makelabel(" ");
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
       faces.vertices.push(allpoints[3].vector);
       faces.vertices.push(allpoints[4].vector);
       faces.vertices.push(allpoints[5].vector);
       faces.vertices.push(allpoints[6].vector);
       faces.vertices.push(allpoints[7].vector);
       faces.vertices.push(allpoints[8].vector);
       faces.vertices.push(allpoints[9].vector);
       faces.vertices.push(allpoints[10].vector);
       faces.vertices.push(allpoints[11].vector);
       faces.vertices.push(allpoints[12].vector);
       faces.vertices.push(allpoints[13].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var materials = [
          new THREE.MeshBasicMaterial({ transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, color: 0xFFB450, }),
          new THREE.MeshBasicMaterial({ transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, color: 0xFFB450, }),
          new THREE.MeshBasicMaterial({ transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, color: 0xFFB450, }),
          new THREE.MeshBasicMaterial({ transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, color: 0xFFB450, }),
          new THREE.MeshBasicMaterial({ transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, color: 0xFFB450, }),
          new THREE.MeshBasicMaterial({ transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, color: 0xFFB450, }),
          new THREE.MeshBasicMaterial({ transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, color: 0xFF0000, }),
          new THREE.MeshBasicMaterial({ transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, color: 0xFF0000, }),
          new THREE.MeshBasicMaterial({ transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, color: 0xFF0000, }),
       ];
       for (index = 0; index < materials.length; ++index) {
          materials[index].side = THREE.DoubleSide;
       }
       var faces_material = new THREE.MeshFaceMaterial ( materials );
    
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(12, 13, 11, undefined, undefined, 0));
       faces.faces.push(new THREE.Face3(12, 11, 10, undefined, undefined, 0));
       faces.faces.push(new THREE.Face3(12, 10, 9, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(0, 13, 12, undefined, undefined, 1));
       faces.faces.push(new THREE.Face3(0, 12, 2, undefined, undefined, 1));
       faces.faces.push(new THREE.Face3(0, 2, 1, undefined, undefined, 1));
    
       faces.faces.push(new THREE.Face3(11, 13, 0, undefined, undefined, 2));
       faces.faces.push(new THREE.Face3(11, 0, 7, undefined, undefined, 2));
       faces.faces.push(new THREE.Face3(11, 7, 8, undefined, undefined, 2));
    
       faces.faces.push(new THREE.Face3(12, 9, 4, undefined, undefined, 3));
       faces.faces.push(new THREE.Face3(12, 4, 2, undefined, undefined, 3));
    
       faces.faces.push(new THREE.Face3(7, 0, 1, undefined, undefined, 4));
       faces.faces.push(new THREE.Face3(7, 1, 6, undefined, undefined, 4));
    
       faces.faces.push(new THREE.Face3(10, 11, 8, undefined, undefined, 5));
       faces.faces.push(new THREE.Face3(10, 8, 3, undefined, undefined, 5));
    
       faces.faces.push(new THREE.Face3(9, 10, 3, undefined, undefined, 6));
       faces.faces.push(new THREE.Face3(9, 3, 5, undefined, undefined, 6));
       faces.faces.push(new THREE.Face3(9, 5, 4, undefined, undefined, 6));
    
       faces.faces.push(new THREE.Face3(4, 5, 6, undefined, undefined, 7));
       faces.faces.push(new THREE.Face3(4, 6, 1, undefined, undefined, 7));
       faces.faces.push(new THREE.Face3(4, 1, 2, undefined, undefined, 7));
    
       faces.faces.push(new THREE.Face3(8, 7, 6, undefined, undefined, 8));
       faces.faces.push(new THREE.Face3(8, 6, 5, undefined, undefined, 8));
       faces.faces.push(new THREE.Face3(8, 5, 3, undefined, undefined, 8));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[12].vector);
       line.vertices.push(allpoints[13].vector);
       line.vertices.push(allpoints[11].vector);
       line.vertices.push(allpoints[10].vector);
       line.vertices.push(allpoints[9].vector);
       line.vertices.push(allpoints[12].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[13].vector);
       line.vertices.push(allpoints[12].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[11].vector);
       line.vertices.push(allpoints[13].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[7].vector);
       line.vertices.push(allpoints[8].vector);
       line.vertices.push(allpoints[11].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[12].vector);
       line.vertices.push(allpoints[9].vector);
       line.vertices.push(allpoints[4].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[12].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[7].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[6].vector);
       line.vertices.push(allpoints[7].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[10].vector);
       line.vertices.push(allpoints[11].vector);
       line.vertices.push(allpoints[8].vector);
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[10].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[9].vector);
       line.vertices.push(allpoints[10].vector);
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[5].vector);
       line.vertices.push(allpoints[4].vector);
       line.vertices.push(allpoints[9].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[4].vector);
       line.vertices.push(allpoints[5].vector);
       line.vertices.push(allpoints[6].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[4].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[8].vector);
       line.vertices.push(allpoints[7].vector);
       line.vertices.push(allpoints[6].vector);
       line.vertices.push(allpoints[5].vector);
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[8].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
    // COMMON_CODE_BLOCK_BEGIN
    var xRotationEnabled = false;
    var yRotationEnabled = false;
    var zRotationEnabled = false;
    var rotationSpeedFactor = 1;
    var settingsShown = false;
    var labelsShown = true;
    var intervals = [];
    var timeouts = [];
    var explodingSpeed = 0.05;
    var explodeScale = 0;
    var XMLS = new XMLSerializer();
    var svgElement;
    var renderId;
    
    	var render = function () {
    
    		renderId = requestAnimationFrame(render);
    
    //		comment in for automatic explosion
    //		explode(updateFactor());
    
    		var phi = 0.02 * rotationSpeedFactor;
    
    		if (xRotationEnabled){
    			scene.rotation.x += phi;
    		}
    		if(yRotationEnabled){
    			scene.rotation.y += phi;
    		}
    		if(zRotationEnabled){
    			scene.rotation.z += phi;
    		}
    
    		controls.update();
    		renderer.render(scene, camera);
    	};
    
    	render();
    
    	function computeCentroid(geom) {
    		centroid = new THREE.Vector3();
    		geom.vertices.forEach(function(v) {
    			centroid.add(v);			
    		});
    		centroid.divideScalar(geom.vertices.length);
    		return centroid;
    	}
    
    	function changeTransparency(event){
    		var opacity = 1-Number(event.currentTarget.value);
    		for (var i=0; i<all_objects.length; i++){
    			for (var j=0; j<all_objects[i].children.length; j++){
    				if (all_objects[i].children[j].material.type == "MultiMaterial") {
    					for (var k=0; k<all_objects[i].children[j].material.materials.length; k++){
    						all_objects[i].children[j].material.materials[k].opacity = opacity;
    						all_objects[i].children[j].material.materials[k].depthWrite = opacity < 0.5 ? false : true;
    						all_objects[i].children[j].material.materials[k].depthTest = opacity < 0.5 ? false : true;
    					}
    				} else if (all_objects[i].children[j].material.transparent && 
    							  all_objects[i].children[j].material.type == "MeshBasicMaterial" &&
    							  all_objects[i].children[j].geometry.type == "Geometry"){
    					all_objects[i].children[j].material.opacity = opacity;
    					all_objects[i].children[j].material.depthWrite = opacity < 0.5 ? false : true;
    					all_objects[i].children[j].material.depthTest = opacity < 0.5 ? false : true;
    				}
    			}
    		}
    	}
    
    	function changeRotationX(event){
    		xRotationEnabled = event.currentTarget.checked;
    	}	
    
    	function changeRotationY(event){
    		yRotationEnabled = event.currentTarget.checked;
    	}	
    
    	function changeRotationZ(event){
    		zRotationEnabled = event.currentTarget.checked;
    	}	
    
    
    	function changeRotationSpeedFactor(event){
    		rotationSpeedFactor = Number(event.currentTarget.value);
    	}
    
    	function resetScene(){
    		scene.rotation.set(0,0,0);
    		camera.position.set(0,0,5);
    		camera.up.set(0,1,0);
    	}
    
    	function showSettings(event){
    		event.currentTarget.style.display = 'none';
    		document.getElementById('settings_1').style.position = 'absolute';
    		document.getElementById('settings_1').style.display = 'block';
    		document.getElementById('showSettingsButton_1').style.display = 'none';
    		document.getElementById('hideSettingsButton_1').style.display = 'block';
    		settingsShown = true;
    	}
    
    	function hideSettings(event){
    		event.currentTarget.style.display = 'none';
    		document.getElementById('settings_1').style.display = 'none';
    		document.getElementById('hideSettingsButton_1').style.display = 'none';
    		document.getElementById('showSettingsButton_1').style.display = 'block';
    		settingsShown = false;
    	}
    
    
    
    	var pos = 150* Math.PI;
    
    	function updateFactor() {
    		pos++;
    		return Math.sin(.01*pos)+1;
    	}
    
    	function makelabel(message, x, y, z, params) {
    		var spritey = textSprite( message, params );
    		spritey.position.set(x, y, z);
    		obj.add(spritey);
    	}
    
    	function textSprite(message, parameters)
    	{
    		if ( parameters === undefined ) parameters = {};
    
    		var fontface = "Helvetica";
    
    		var fontsize = parameters.hasOwnProperty("fontsize") ? 
    			parameters["fontsize"] : 18;
    		fontsize = fontsize*10;
    
    		var canvas = document.createElement('canvas');
    		var size = 1024;
    		canvas.width = size;
    		canvas.height = size;
    		var context = canvas.getContext('2d');
    		context.font = fontsize + "px " + fontface;
    
    		// text color
    		context.fillStyle = "rgba(0, 0, 0, 1.0)";
    
    		context.fillText(message, size/2, size/2);
    
    		// canvas contents will be used for a texture
    		var texture = new THREE.Texture(canvas);
    		texture.needsUpdate = true;
    
    		var spriteMaterial = new THREE.SpriteMaterial(
    			{map: texture, useScreenCoordinates: false});
    		var sprite = new THREE.Sprite(spriteMaterial);
    		return sprite;
    	}
    
    	function takeSvgScreenshot(){
    		if (labelsShown){
    			hideLabels();
    		}
    		svgRenderer.render(scene,camera);
    		svgElement = XMLS.serializeToString(svgRenderer.domElement);
    		
    		if (labelsShown){
    			displayLabels();
    		}
    
    		if (document.getElementById('tab_1').checked){
    			//show in new tab
    			var myWindow = window.open("","");
    			myWindow.document.body.innerHTML = svgElement;
    		} else{
    			// download svg file 
    			download("screenshot.svg", svgElement);
    		}
    	}
    		
    
    	function showOrHideObject(event){
    		var nr = Number(event.currentTarget.name);
    		all_objects[nr].visible = event.currentTarget.checked;
    	}
    
    
    	function displayOrHideOptions(){
    		for (var i=0; i<all_objects.length; i++){
    			for (var j=0; j<all_objects[i].children.length; j++){
    				if (all_objects[i].children[j].material.type == "MultiMaterial") {
    					for (var k=0; k<all_objects[i].children[j].material.materials.length; k++){
    						if (all_objects[i].children[j].material.materials[k].transparent) {
    							document.getElementById('transparency_1').style.display = 'block';
    							document.getElementById('transparencyRange_1').value = 1 - 
    							    all_objects[i].children[j].material.materials[k].opacity;
    							return;
    						}
    					}
    				} else if (all_objects[i].children[j].material.transparent && 
    							  all_objects[i].children[j].material.type == "MeshBasicMaterial" &&
    							  all_objects[i].children[j].geometry.type == "Geometry"){
    					document.getElementById('transparency_1').style.display = 'block';
    					return;
    				}
    			}
    		}
    	}
    
    	displayOrHideOptions()
    
    
    
    
    // ---------------------- EXPLOSION ------------------------------------------------
    // ---------------------------------------------------------------------------------
    
    	function explode(factor) {
    		var obj, c;
    		var c0 = centroids[0];
    		for (var i = 0; i<centroids.length; ++i) {
    			c = centroids[i];
    			obj = all_objects[all_objects.length - centroids.length + i];
    			obj.position.set(c.x*factor, c.y*factor, c.z*factor);
    		}	
    	}
    
    	function triggerExplode(event){
    		explodeScale = Number(event.currentTarget.value);
    		explode(explodeScale);
    	}
    
    	function setExplodingSpeed(event){
    		explodingSpeed = Number(event.currentTarget.value);
    	}
    
    	function triggerAutomaticExplode(event){
    		if (event.currentTarget.checked){
    			startExploding();
    		} else {
    			clearIntervals();
    		}	
    	}
    
    	function startExploding(){
    		intervals.push(setInterval(explodingInterval, 25));
    	}
    
    
    	function explodingInterval(){
    		explodeScale += explodingSpeed;
    		if (explodeScale <= 6){ 
    			explode(explodeScale);
    		}
    		else{
    			explode(6);
    			explodeScale = 6;
    			clearIntervals();
    			timeouts.push(setTimeout(startUnexploding, 3000));
    		}
    		document.getElementById('explodeRange_1').value = explodeScale;
    	}
    
    
    	function startUnexploding(){
    		intervals.push(setInterval(unexplodingInterval, 25));
    	}
    
    	function unexplodingInterval(){
    		explodeScale -= explodingSpeed;
    		if (explodeScale >= 0){	
    			explode(explodeScale);
    		}
    		else {
    			explode(0);
    			explodeScale = 0;
    			clearIntervals();
    			timeouts.push(setTimeout(startExploding, 3000));
    		}
    		document.getElementById('explodeRange_1').value = explodeScale;
    	}
    
    	function clearIntervals(){
    		intervals.forEach(function(interval){
    			clearInterval(interval);
    		});
    		intervals = [];
    		timeouts.forEach(function(timeout){
    			clearTimeout(timeout);
    		});
    		timeouts = [];
    	}
    
    			
    
    	// append checkboxes for displaying or hiding objects
    	var shownObjectsList = document.getElementById('shownObjectsList_1');
    	for (var i=0; i<all_objects.length; i++){
    		var objNode = document.createElement('span');
    		objNode.innerHTML = objectnames[i] + '<br>';
    		var checkbox = document.createElement('input');
    		checkbox.type = 'checkbox';
    		checkbox.checked = true;
    		checkbox.name = String(i);
    		checkbox.onchange = showOrHideObject;
    		shownObjectsList.appendChild(checkbox);
    		shownObjectsList.appendChild(objNode);
    	}
    
    	function displayLabels(){
    		for (var i=0; i<all_objects.length; i++){
    			for (var j=0; j<all_objects[i].children.length; j++){
    				var child = all_objects[i].children[j];
    				if (child.type == 'Sprite'){
    					child.visible = true;
    				}
    			}
    		}
    	}
    
    	function hideLabels(){
    		for (var i=0; i<all_objects.length; i++){
    			for (var j=0; j<all_objects[i].children.length; j++){
    				var child = all_objects[i].children[j];
    				if (child.type == 'Sprite'){
    					child.visible = false;
    				}
    			}
    		}
    	}
    
    	function displayOrHideLabels(event){
    		if (event.currentTarget.checked){
    			displayLabels();
    			labelsShown = true;
    		} else {
    			hideLabels();
    			labelsShown = false;
    		}
    	}
    
    	function download(filename, text) {
    	  var element = document.createElement('a');
    	  element.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(text));
    	  element.setAttribute('download', filename);
    
    	  element.style.display = 'none';
    	  document.body.appendChild(element);
    
    	  element.click();
    
    	  document.body.removeChild(element);
    	}
    
    var tempobj;
    tempobj = document.getElementById('explodeRange_1');
    if (tempobj) {
       tempobj.oninput = triggerExplode;
       document.getElementById('explodeCheckbox_1').onchange = triggerAutomaticExplode;
       document.getElementById('explodingSpeedRange_1').oninput = setExplodingSpeed;
    }
    tempobj = document.getElementById('foldRange_1');
    if (tempobj) {
       tempobj.oninput = fold;
    }
    document.getElementById('transparencyRange_1').oninput = changeTransparency;
    document.getElementById('changeRotationX_1').onchange = changeRotationX;
    document.getElementById('changeRotationY_1').onchange = changeRotationY;
    document.getElementById('changeRotationZ_1').onchange = changeRotationZ;
    document.getElementById('resetButton_1').onclick = resetScene;
    document.getElementById('rotationSpeedRange_1').oninput = changeRotationSpeedFactor;
    document.getElementById('labelsCheckboxInput_1').onchange = displayOrHideLabels;
    document.getElementById('takeScreenshot_1').onclick = takeSvgScreenshot;
    document.getElementById('showSettingsButton_1').onclick = showSettings;
    document.getElementById('hideSettingsButton_1').onclick = hideSettings;
    
    	
    
    // ------------------ SHORTCUTS --------------------------------------------
    // -------------------------------------------------------------------------
    
    /**
     * http://www.openjs.com/scripts/events/keyboard_shortcuts/
     * Version : 2.01.B
     * By Binny V A
     * License : BSD
     */
    shortcut = {
    	'all_shortcuts':{},//All the shortcuts are stored in this array
    	'add': function(shortcut_combination,callback,opt) {
    		//Provide a set of default options
    		var default_options = {
    			'type':'keydown',
    			'propagate':false,
    			'disable_in_input':false,
    			'target':document,
    			'keycode':false
    		}
    		if(!opt) opt = default_options;
    		else {
    			for(var dfo in default_options) {
    				if(typeof opt[dfo] == 'undefined') opt[dfo] = default_options[dfo];
    			}
    		}
    
    		var ele = opt.target;
    		if(typeof opt.target == 'string') ele = document.getElementById(opt.target);
    		var ths = this;
    		shortcut_combination = shortcut_combination.toLowerCase();
    
    		//The function to be called at keypress
    		var func = function(e) {
    			e = e || window.event;
    			
    			if(opt['disable_in_input']) { //Don't enable shortcut keys in Input, Textarea fields
    				var element;
    				if(e.target) element=e.target;
    				else if(e.srcElement) element=e.srcElement;
    				if(element.nodeType==3) element=element.parentNode;
    
    				if(element.tagName == 'INPUT' || element.tagName == 'TEXTAREA') return;
    			}
    	
    			//Find Which key is pressed
    			if (e.keyCode) code = e.keyCode;
    			else if (e.which) code = e.which;
    			var character = String.fromCharCode(code).toLowerCase();
    			
    			if(code == 188) character=","; //If the user presses , when the type is onkeydown
    			if(code == 190) character="."; //If the user presses , when the type is onkeydown
    
    			var keys = shortcut_combination.split("+");
    			//Key Pressed - counts the number of valid keypresses - if it is same as the number of keys, the shortcut function is invoked
    			var kp = 0;
    			
    			//Work around for stupid Shift key bug created by using lowercase - as a result the shift+num combination was broken
    			var shift_nums = {
    				"`":"~",
    				"1":"!",
    				"2":"@",
    				"3":"#",
    				"4":"$",
    				"5":"%",
    				"6":"^",
    				"7":"&",
    				"8":"*",
    				"9":"(",
    				"0":")",
    				"-":"_",
    				"=":"+",
    				";":":",
    				"'":"\"",
    				",":"<",
    				".":">",
    				"/":"?",
    				"\\":"|"
    			}
    			//Special Keys - and their codes
    			var special_keys = {
    				'esc':27,
    				'escape':27,
    				'tab':9,
    				'space':32,
    				'return':13,
    				'enter':13,
    				'backspace':8,
    	
    				'scrolllock':145,
    				'scroll_lock':145,
    				'scroll':145,
    				'capslock':20,
    				'caps_lock':20,
    				'caps':20,
    				'numlock':144,
    				'num_lock':144,
    				'num':144,
    				
    				'pause':19,
    				'break':19,
    				
    				'insert':45,
    				'home':36,
    				'delete':46,
    				'end':35,
    				
    				'pageup':33,
    				'page_up':33,
    				'pu':33,
    	
    				'pagedown':34,
    				'page_down':34,
    				'pd':34,
    	
    				'left':37,
    				'up':38,
    				'right':39,
    				'down':40,
    	
    				'f1':112,
    				'f2':113,
    				'f3':114,
    				'f4':115,
    				'f5':116,
    				'f6':117,
    				'f7':118,
    				'f8':119,
    				'f9':120,
    				'f10':121,
    				'f11':122,
    				'f12':123
    			}
    	
    			var modifiers = { 
    				shift: { wanted:false, pressed:false},
    				ctrl : { wanted:false, pressed:false},
    				alt  : { wanted:false, pressed:false},
    				meta : { wanted:false, pressed:false}	//Meta is Mac specific
    			};
                            
    			if(e.ctrlKey)	modifiers.ctrl.pressed = true;
    			if(e.shiftKey)	modifiers.shift.pressed = true;
    			if(e.altKey)	modifiers.alt.pressed = true;
    			if(e.metaKey)   modifiers.meta.pressed = true;
                            
    			for(var i=0; k=keys[i],i<keys.length; i++) {
    				//Modifiers
    				if(k == 'ctrl' || k == 'control') {
    					kp++;
    					modifiers.ctrl.wanted = true;
    
    				} else if(k == 'shift') {
    					kp++;
    					modifiers.shift.wanted = true;
    
    				} else if(k == 'alt') {
    					kp++;
    					modifiers.alt.wanted = true;
    				} else if(k == 'meta') {
    					kp++;
    					modifiers.meta.wanted = true;
    				} else if(k.length > 1) { //If it is a special key
    					if(special_keys[k] == code) kp++;
    					
    				} else if(opt['keycode']) {
    					if(opt['keycode'] == code) kp++;
    
    				} else { //The special keys did not match
    					if(character == k) kp++;
    					else {
    						if(shift_nums[character] && e.shiftKey) { //Stupid Shift key bug created by using lowercase
    							character = shift_nums[character]; 
    							if(character == k) kp++;
    						}
    					}
    				}
    			}
    			
    			if(kp == keys.length && 
    						modifiers.ctrl.pressed == modifiers.ctrl.wanted &&
    						modifiers.shift.pressed == modifiers.shift.wanted &&
    						modifiers.alt.pressed == modifiers.alt.wanted &&
    						modifiers.meta.pressed == modifiers.meta.wanted) {
    				callback(e);
    	
    				if(!opt['propagate']) { //Stop the event
    					//e.cancelBubble is supported by IE - this will kill the bubbling process.
    					e.cancelBubble = true;
    					e.returnValue = false;
    	
    					//e.stopPropagation works in Firefox.
    					if (e.stopPropagation) {
    						e.stopPropagation();
    						e.preventDefault();
    					}
    					return false;
    				}
    			}
    		}
    		this.all_shortcuts[shortcut_combination] = {
    			'callback':func, 
    			'target':ele, 
    			'event': opt['type']
    		};
    		//Attach the function with the event
    		if(ele.addEventListener) ele.addEventListener(opt['type'], func, false);
    		else if(ele.attachEvent) ele.attachEvent('on'+opt['type'], func);
    		else ele['on'+opt['type']] = func;
    	},
    
    	//Remove the shortcut - just specify the shortcut and I will remove the binding
    	'remove':function(shortcut_combination) {
    		shortcut_combination = shortcut_combination.toLowerCase();
    		var binding = this.all_shortcuts[shortcut_combination];
    		delete(this.all_shortcuts[shortcut_combination])
    		if(!binding) return;
    		var type = binding['event'];
    		var ele = binding['target'];
    		var callback = binding['callback'];
    
    		if(ele.detachEvent) ele.detachEvent('on'+type, callback);
    		else if(ele.removeEventListener) ele.removeEventListener(type, callback, false);
    		else ele['on'+type] = false;
    	}
    }
    
    shortcut.add("Alt+Left",function() {
    	var event = new Event('click');
    	if (settingsShown){
    		document.getElementById('hideSettingsButton_1').dispatchEvent(event);
    	} else{
    		document.getElementById('showSettingsButton_1').dispatchEvent(event);
    	}
    });
    
    if (foldable) moveToBaryCenter();
    
    
    });});
    // COMMON_CODE_BLOCK_END
    </script>
    
    </body>
    </html>



We may look at the GKZ domes of the individual Delaunay triangulations.


.. link

.. CODE-BLOCK:: perl

    polymake> $d0 = $s->gkz_dome(0,5);
    polymake> $d0->VISUAL(FacetColor=>'80 180 255');


.. raw:: html

    <!--
    polymake for loewe
    Fri Feb  9 13:50:10 2018
    pcom:d0
    -->
    
    
    <html>
       <head>
          <title>pcom:d0</title>
          <style>
    /*
    // COMMON_CODE_BLOCK_BEGIN
    */
             html{overflow: scroll;}
             body { font-family: Arial, Helvetica, sans-serif}
             strong{font-size: 18px;}
             canvas { z-index: 8; }
             input[type='range'] {}
             input[type='radio'] {margin-left:0;}
             input[type='checkbox'] {margin-right:7px; margin-left: 0px; padding-left:0px;}
             .group{padding-bottom: 40px;}
             .settings * {z-index: 11; }
             .settings{z-index: 10; margin-left: 30px; display: none; width: 14em; height: 90%; border: solid 1px silver; padding: 2px; overflow-y: scroll; background-color: white }
             .indented{margin-left: 20px; margin-top: 15px; padding-bottom: 0px;} 
             .shownObjectsList{overflow: auto; max-width: 150px; max-height: 150px;}
             .showSettingsButton{display: block; z-index: 12; position: absolute }
             .hideSettingsButton{display: none; z-index: 12; position: absolute; opacity: 0.5}
             .resetButton{margin-top: 20px;}
             button{margin-left: 0;}
             img{cursor: pointer;}
             .suboption{padding-top: 30px;}
             .transparency{display: none;}
             .labelsCheckbox{margin-top: 10px;}
    
    
             input[type=range] {
               -webkit-appearance: none;
               padding:0; 
               width:90%; 
               margin-left: auto;
               margin-right: auto;
               margin-top: 20px;
               display: block;	
             }
             input[type=range]:focus {
               outline: none;
             }
             input[type=range]::-webkit-slider-runnable-track {
               height: 4px;
               cursor: pointer;
               animate: 0.2s;
               box-shadow: 0px 0px 0px #000000;
               background: #E3E3E3;
               border-radius: 0px;
               border: 0px solid #000000;
             }
             input[type=range]::-webkit-slider-thumb {
               box-shadow: 1px 1px 2px #B8B8B8;
               border: 1px solid #ABABAB;
               height: 13px;
               width: 25px;
               border-radius: 20px;
               background: #E0E0E0;
               cursor: pointer;
               -webkit-appearance: none;
               margin-top: -5px;
             }
             input[type=range]:focus::-webkit-slider-runnable-track {
               background: #E3E3E3;
             }
             input[type=range]::-moz-range-track {
               height: 4px;
               cursor: pointer;
               animate: 0.2s;
               box-shadow: 0px 0px 0px #000000;
               background: #E3E3E3;
               border-radius: 0px;
               border: 0px solid #000000;
             }
             input[type=range]::-moz-range-thumb {
               box-shadow: 1px 1px 2px #B8B8B8;
               border: 1px solid #ABABAB;
               height: 13px;
               width: 25px;
               border-radius: 20px;
               background: #E0E0E0;
               cursor: pointer;
             }
             input[type=range]::-ms-track {
               height: 4px;
               cursor: pointer;
               animate: 0.2s;
               background: transparent;
               border-color: transparent;
               color: transparent;
             }
             input[type=range]::-ms-fill-lower {
               background: #E3E3E3;
               border: 0px solid #000000;
               border-radius: 0px;
               box-shadow: 0px 0px 0px #000000;
             }
             input[type=range]::-ms-fill-upper {
               background: #E3E3E3;
               border: 0px solid #000000;
               border-radius: 0px;
               box-shadow: 0px 0px 0px #000000;
             }
             input[type=range]::-ms-thumb {
               box-shadow: 1px 1px 2px #B8B8B8;
               border: 1px solid #ABABAB;
               height: 13px;
               width: 25px;
               border-radius: 20px;
               background: #E0E0E0;
               cursor: pointer;
             }
             input[type=range]:focus::-ms-fill-lower {
               background: #E3E3E3;
             }
             input[type=range]:focus::-ms-fill-upper {
               background: #E3E3E3;
             }
    /*
    // COMMON_CODE_BLOCK_END
    */
    		</style>
       </head>
    
    <body>
    
    		<div id='settings_2' class='settings'>
    			<div class=group id='explode_2'>
    				<strong>Explode</strong>
    				<input id='explodeRange_2' type='range' min=0 max=6 step=0.01 value=0>
    				<div class=indented><input id='explodeCheckbox_2' type='checkbox'>Automatic explosion</div>
    				<div class=suboption>Exploding speed</div>
    				<input id='explodingSpeedRange_2' type='range' min=0 max=0.5 step=0.001 value=0.05>
    			</div>
    
    			
    			<div class=group id='transparency_2' class='transparency'>
    				<strong>Transparency</strong>
    				<input id='transparencyRange_2' type='range' min=0 max=1 step=0.01 value=0>
    			</div>
    			
    			<div class=group id='rotation_2'>
    				<strong>Rotation</strong>
    				<div class=indented>
    					<div><input type='checkbox' id='changeRotationX_2'> x-axis</div>
    					<div><input type='checkbox' id='changeRotationY_2'> y-axis</div>
    					<div><input type='checkbox' id='changeRotationZ_2'> z-axis</div>
    					<button id='resetButton_2' class='resetButton' >Reset</button>
    				</div>
    
    				<div class=suboption>Rotation speed</div>
    				<input id='rotationSpeedRange_2' type='range' min=0 max=5 step=0.01 value=2>
    
    			</div>
    
    
    			<div class=group id='display_2'>
    				<strong>Display</strong>
    				<div class=indented>
    					<div id='shownObjectsList_2' class='shownObjectsList'></div>
    					<div class='labelsCheckbox'><input type='checkbox' id='labelsCheckboxInput_2' checked>Labels</div>
    				</div>
    			</div>
    
    
    			<div class=group id='svg_2'>
    				<strong>SVG</strong>
    				<div class=indented>
    					<form>
    						<input type="radio" name='screenshotMode' value='download' id='download_2' checked> Download<br>
    						<input type="radio" name='screenshotMode' value='tab' id='tab_2' > New tab<br>
    					</form>
    					<button id='takeScreenshot_2'>Screenshot</button>
    				</div>
    			</div>
    
    		</div>	<!-- end of settings -->
    		<img id='hideSettingsButton_2' style="display: none" class='hideSettingsButton' src='/kernelspecs/polymake/close.svg' width=20px">
    		<img id='showSettingsButton_2' class='showSettingsButton' src='/kernelspecs/polymake/menu.svg' width=20px">
    <div id="model79486694307"></div>
    
    <script>
    requirejs.config({
      paths: {
        three: '/kernelspecs/polymake/three',
        Detector: '/kernelspecs/polymake/Detector',
        SVGRenderer: '/kernelspecs/polymake/SVGRenderer',
        CanvasRenderer: '/kernelspecs/polymake/CanvasRenderer',
        Projector: '/kernelspecs/polymake/Projector',
        TrackballControls: '/kernelspecs/polymake/TrackballControls'
      },
      shim: {
        'three':
        {
          exports: 'THREE'
        },
        'Detector':
        {
          deps: [ 'three' ],
          exports: 'Detector'
        },
        'SVGRenderer':
        {
          deps: [ 'three' ],
          exports: 'THREE.SVGRenderer'
        },
        'CanvasRenderer':
        {
          deps: [ 'three' ],
          exports: 'THREE.CanvasRenderer'
        },
        'Projector':
        {
          deps: [ 'three' ],
          exports: 'THREE.Projector'
        },
        'TrackballControls':
        {
          deps: [ 'three' ],
          exports: 'THREE.TrackballControls'
        }
      }
    });
    require(['three'],function(THREE){
        window.THREE = THREE;
      require(['Detector','SVGRenderer','CanvasRenderer','Projector','TrackballControls'],function(Detector,SVGRenderer,CanvasRenderer,Projector,TrackballControls){
          THREE.SVGRenderer = SVGRenderer;
          THREE.CanvasRenderer = CanvasRenderer;
          THREE.Projector = Projector;
          THREE.TrackballControls = TrackballControls;
    
    // COMMON_CODE_BLOCK_BEGIN
    	var foldable = false;
       var container = document.getElementById( 'model79486694307' );
       var renderer = Detector.webgl? new THREE.WebGLRenderer({antialias: true}): new THREE.CanvasRenderer({antialias: true});
    	var svgRenderer = new THREE.SVGRenderer({antialias: true});
                var box = document.getElementsByClassName( 'output_subarea' )[0];
             var notebook = document.getElementById( 'notebook_panel' );
    
       var width = box.clientWidth - 25;
       var height = notebook.clientHeight * 0.8;
       renderer.setSize(width, height);
       svgRenderer.setSize(width, height);
       renderer.setClearColor(0xFFFFFF, 1);
       svgRenderer.setClearColor(0xFFFFFF, 1);
    
       container.appendChild(renderer.domElement);
    
       var scene = new THREE.Scene();
       var camera = new THREE.PerspectiveCamera(75, width/height, 0.1, 1000);
    
       var renderid;
    
       camera.position.set(0, 0, 5);
       camera.lookAt(0, 0, 0);
       camera.up.set(0, 1, 0);
    
       // class to allow move points together with labels and spheres
       var PMPoint = function (x,y,z) {
          this.vector = new THREE.Vector3(x,y,z);
          this.sprite = null;
          this.sphere = null;
       }
       PMPoint.prototype.makelabel = function(label) {
          this.sprite = textSprite( label );
          this.sprite.position.copy(this.vector);
       }
       PMPoint.prototype.makesphere = function(radius,material) {
          this.sphere = new THREE.Mesh(new THREE.SphereGeometry(radius), material);
          this.sphere.position.copy(this.vector);
       }
    
       PMPoint.prototype.setX = function(x) {
          this.vector.setX(x);
          if (this.sprite) {
             this.sprite.position.setX(x);
          }
          if (this.sphere) {
             this.sphere.position.setX(x);
          }
       };
       PMPoint.prototype.setY = function(y) {
          this.vector.setY(y);
          if (this.sprite) {
             this.sprite.position.setY(y);
          }
          if (this.sphere) {
             this.sphere.position.setY(y);
          }
       };
       PMPoint.prototype.setZ = function(z) {
          this.vector.setZ(z);
          if (this.sprite) {
             this.sprite.position.setZ(z);
          }
          if (this.sphere) {
             this.sphere.position.setZ(z);
          }
       };
       PMPoint.prototype.set = function(x,y,z) {
          this.vector.set(x,y,z);
          if (this.sprite) {
             this.sprite.position.set(x,y,z);
          }
          if (this.sphere) {
             this.sphere.position.set(x,y,z);
          }
       };
       PMPoint.prototype.add = function(o) {
          if (this.sprite) {
             o.add(this.sprite);
          }
          if (this.sphere) {
             o.add(this.sphere);
          }
       };
    
    
       var controls = new THREE.TrackballControls(camera, container);
    	controls.zoomSpeed = 0.2;
    	controls.rotateSpeed = 4;
    
       var all_objects = [];
       var centroids = [];
       // select the target node
       var target = document.querySelector('#model79486694307');
    
       // create an observer instance
       var observer = new MutationObserver(function(mutations) {
          mutations.forEach(function(mutation) {
             if (mutation.removedNodes && mutation.removedNodes.length > 0) {
                cancelAnimationFrame(renderId);
                observer.disconnect();
                console.log("cancelled frame "+renderId);
             }
          });
       });
    
       // configuration of the observer:
       var config = { childList: true, characterData: true }
    
       // pass in the target node, as well as the observer options
       while (target) {
          if (target.className=="output") {
             observer.observe(target, config);
             break;
          }
          target = target.parentNode;
       }
    
    // COMMON_CODE_BLOCK_END
    
       var objectnames = ["unnamed__1","unnamed__2","unnamed__3","unnamed__4","unnamed__5","unnamed__6","unnamed__7","unnamed__8","unnamed__9","unnamed__10","unnamed__11","unnamed__12","unnamed__13","unnamed__14","unnamed__15","unnamed__16","unnamed__17","unnamed__18","unnamed__19","unnamed__20","unnamed__21","unnamed__22","unnamed__23","unnamed__24","unnamed__25","unnamed__26","unnamed__27","unnamed__28","unnamed__29","unnamed__30","unnamed__31","unnamed__32","unnamed__33","unnamed__34","unnamed__35","unnamed__36","unnamed__37","unnamed__38","unnamed__39","unnamed__40","unnamed__41","unnamed__42","unnamed__43","unnamed__44","unnamed__45","unnamed__46","unnamed__47","unnamed__48","unnamed__49","unnamed__50","unnamed__51","unnamed__52","unnamed__53","unnamed__54","unnamed__55","unnamed__56","unnamed__57","unnamed__58","unnamed__59","unnamed__60","unnamed__61","unnamed__62","unnamed__63","unnamed__64","unnamed__65","unnamed__66","unnamed__67","unnamed__68","unnamed__69","unnamed__70","unnamed__71","unnamed__72","unnamed__73","unnamed__74","unnamed__75","unnamed__76","unnamed__77","unnamed__78","unnamed__79","unnamed__80","unnamed__81","unnamed__82","unnamed__83","unnamed__84","unnamed__85","unnamed__86","unnamed__87","unnamed__88","unnamed__89","unnamed__90","unnamed__91","unnamed__92","unnamed__93","unnamed__94"];
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-1, 0, 0.5));
       allpoints.push(new PMPoint(1, 0, 0.5));
       allpoints.push(new PMPoint(0, 1, 0.125));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-1, 0, 0.5));
       allpoints.push(new PMPoint(1, 0, 0.5));
       allpoints.push(new PMPoint(0, -1, 0.125));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(1, 0, 0.5));
       allpoints.push(new PMPoint(0, 1, 0.125));
       allpoints.push(new PMPoint(0.6, 0.8, 0.02));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-1, 0, 0.5));
       allpoints.push(new PMPoint(0, 1, 0.125));
       allpoints.push(new PMPoint(-0.6, 0.8, 0.02));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-1, 0, 0.5));
       allpoints.push(new PMPoint(0, -1, 0.125));
       allpoints.push(new PMPoint(-0.6, -0.8, 0.02));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(1, 0, 0.5));
       allpoints.push(new PMPoint(0, -1, 0.125));
       allpoints.push(new PMPoint(0.6, -0.8, 0.02));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(1, 0, 0.5));
       allpoints.push(new PMPoint(0.6, 0.8, 0.02));
       allpoints.push(new PMPoint(0.8, 0.6, 0.005));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0, 1, 0.125));
       allpoints.push(new PMPoint(0.6, 0.8, 0.02));
       allpoints.push(new PMPoint(0.384615, 0.923077, 0.00295858));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0, 1, 0.125));
       allpoints.push(new PMPoint(-0.6, 0.8, 0.02));
       allpoints.push(new PMPoint(-0.384615, 0.923077, 0.00295858));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-1, 0, 0.5));
       allpoints.push(new PMPoint(-0.6, 0.8, 0.02));
       allpoints.push(new PMPoint(-0.8, 0.6, 0.005));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-1, 0, 0.5));
       allpoints.push(new PMPoint(-0.6, -0.8, 0.02));
       allpoints.push(new PMPoint(-0.8, -0.6, 0.005));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0, -1, 0.125));
       allpoints.push(new PMPoint(-0.6, -0.8, 0.02));
       allpoints.push(new PMPoint(-0.384615, -0.923077, 0.00295858));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0, -1, 0.125));
       allpoints.push(new PMPoint(0.6, -0.8, 0.02));
       allpoints.push(new PMPoint(0.384615, -0.923077, 0.00295858));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(1, 0, 0.5));
       allpoints.push(new PMPoint(0.6, -0.8, 0.02));
       allpoints.push(new PMPoint(0.8, -0.6, 0.005));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(1, 0, 0.5));
       allpoints.push(new PMPoint(0.8, 0.6, 0.005));
       allpoints.push(new PMPoint(0.882353, 0.470588, 0.0017301));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0.6, 0.8, 0.02));
       allpoints.push(new PMPoint(0.8, 0.6, 0.005));
       allpoints.push(new PMPoint(0.724138, 0.689655, 0.00059453));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0.6, 0.8, 0.02));
       allpoints.push(new PMPoint(0.384615, 0.923077, 0.00295858));
       allpoints.push(new PMPoint(0.470588, 0.882353, 0.000432526));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0, 1, 0.125));
       allpoints.push(new PMPoint(0.384615, 0.923077, 0.00295858));
       allpoints.push(new PMPoint(0.28, 0.96, 0.0008));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0, 1, 0.125));
       allpoints.push(new PMPoint(-0.384615, 0.923077, 0.00295858));
       allpoints.push(new PMPoint(-0.28, 0.96, 0.0008));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-0.6, 0.8, 0.02));
       allpoints.push(new PMPoint(-0.384615, 0.923077, 0.00295858));
       allpoints.push(new PMPoint(-0.470588, 0.882353, 0.000432526));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-0.6, 0.8, 0.02));
       allpoints.push(new PMPoint(-0.8, 0.6, 0.005));
       allpoints.push(new PMPoint(-0.724138, 0.689655, 0.00059453));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-1, 0, 0.5));
       allpoints.push(new PMPoint(-0.8, 0.6, 0.005));
       allpoints.push(new PMPoint(-0.882353, 0.470588, 0.0017301));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-1, 0, 0.5));
       allpoints.push(new PMPoint(-0.8, -0.6, 0.005));
       allpoints.push(new PMPoint(-0.882353, -0.470588, 0.0017301));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-0.6, -0.8, 0.02));
       allpoints.push(new PMPoint(-0.8, -0.6, 0.005));
       allpoints.push(new PMPoint(-0.724138, -0.689655, 0.00059453));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-0.6, -0.8, 0.02));
       allpoints.push(new PMPoint(-0.384615, -0.923077, 0.00295858));
       allpoints.push(new PMPoint(-0.470588, -0.882353, 0.000432526));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0, -1, 0.125));
       allpoints.push(new PMPoint(-0.384615, -0.923077, 0.00295858));
       allpoints.push(new PMPoint(-0.28, -0.96, 0.0008));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0, -1, 0.125));
       allpoints.push(new PMPoint(0.384615, -0.923077, 0.00295858));
       allpoints.push(new PMPoint(0.28, -0.96, 0.0008));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0.6, -0.8, 0.02));
       allpoints.push(new PMPoint(0.384615, -0.923077, 0.00295858));
       allpoints.push(new PMPoint(0.470588, -0.882353, 0.000432526));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0.6, -0.8, 0.02));
       allpoints.push(new PMPoint(0.8, -0.6, 0.005));
       allpoints.push(new PMPoint(0.724138, -0.689655, 0.00059453));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(1, 0, 0.5));
       allpoints.push(new PMPoint(0.8, -0.6, 0.005));
       allpoints.push(new PMPoint(0.882353, -0.470588, 0.0017301));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(1, 0, 0.5));
       allpoints.push(new PMPoint(0.882353, 0.470588, 0.0017301));
       allpoints.push(new PMPoint(0.923077, 0.384615, 0.000739645));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0.8, 0.6, 0.005));
       allpoints.push(new PMPoint(0.882353, 0.470588, 0.0017301));
       allpoints.push(new PMPoint(0.849057, 0.528302, 0.000177999));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0.8, 0.6, 0.005));
       allpoints.push(new PMPoint(0.724138, 0.689655, 0.00059453));
       allpoints.push(new PMPoint(0.753425, 0.657534, 9.38262e-05));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0.6, 0.8, 0.02));
       allpoints.push(new PMPoint(0.724138, 0.689655, 0.00059453));
       allpoints.push(new PMPoint(0.689655, 0.724138, 0.000148633));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0.6, 0.8, 0.02));
       allpoints.push(new PMPoint(0.470588, 0.882353, 0.000432526));
       allpoints.push(new PMPoint(0.507692, 0.861538, 0.000118343));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0.384615, 0.923077, 0.00295858));
       allpoints.push(new PMPoint(0.470588, 0.882353, 0.000432526));
       allpoints.push(new PMPoint(0.438202, 0.898876, 6.31233e-05));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0.384615, 0.923077, 0.00295858));
       allpoints.push(new PMPoint(0.28, 0.96, 0.0008));
       allpoints.push(new PMPoint(0.324324, 0.945946, 9.13075e-05));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0, 1, 0.125));
       allpoints.push(new PMPoint(0.28, 0.96, 0.0008));
       allpoints.push(new PMPoint(0.219512, 0.97561, 0.000297442));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0, 1, 0.125));
       allpoints.push(new PMPoint(-0.28, 0.96, 0.0008));
       allpoints.push(new PMPoint(-0.219512, 0.97561, 0.000297442));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-0.384615, 0.923077, 0.00295858));
       allpoints.push(new PMPoint(-0.28, 0.96, 0.0008));
       allpoints.push(new PMPoint(-0.324324, 0.945946, 9.13075e-05));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-0.384615, 0.923077, 0.00295858));
       allpoints.push(new PMPoint(-0.470588, 0.882353, 0.000432526));
       allpoints.push(new PMPoint(-0.438202, 0.898876, 6.31233e-05));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-0.6, 0.8, 0.02));
       allpoints.push(new PMPoint(-0.470588, 0.882353, 0.000432526));
       allpoints.push(new PMPoint(-0.507692, 0.861538, 0.000118343));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-0.6, 0.8, 0.02));
       allpoints.push(new PMPoint(-0.724138, 0.689655, 0.00059453));
       allpoints.push(new PMPoint(-0.689655, 0.724138, 0.000148633));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-0.8, 0.6, 0.005));
       allpoints.push(new PMPoint(-0.724138, 0.689655, 0.00059453));
       allpoints.push(new PMPoint(-0.753425, 0.657534, 9.38262e-05));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-0.8, 0.6, 0.005));
       allpoints.push(new PMPoint(-0.882353, 0.470588, 0.0017301));
       allpoints.push(new PMPoint(-0.849057, 0.528302, 0.000177999));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-1, 0, 0.5));
       allpoints.push(new PMPoint(-0.882353, 0.470588, 0.0017301));
       allpoints.push(new PMPoint(-0.923077, 0.384615, 0.000739645));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-1, 0, 0.5));
       allpoints.push(new PMPoint(-0.882353, -0.470588, 0.0017301));
       allpoints.push(new PMPoint(-0.923077, -0.384615, 0.000739645));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-0.8, -0.6, 0.005));
       allpoints.push(new PMPoint(-0.882353, -0.470588, 0.0017301));
       allpoints.push(new PMPoint(-0.849057, -0.528302, 0.000177999));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-0.8, -0.6, 0.005));
       allpoints.push(new PMPoint(-0.724138, -0.689655, 0.00059453));
       allpoints.push(new PMPoint(-0.753425, -0.657534, 9.38262e-05));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-0.6, -0.8, 0.02));
       allpoints.push(new PMPoint(-0.724138, -0.689655, 0.00059453));
       allpoints.push(new PMPoint(-0.689655, -0.724138, 0.000148633));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-0.6, -0.8, 0.02));
       allpoints.push(new PMPoint(-0.470588, -0.882353, 0.000432526));
       allpoints.push(new PMPoint(-0.507692, -0.861538, 0.000118343));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-0.384615, -0.923077, 0.00295858));
       allpoints.push(new PMPoint(-0.470588, -0.882353, 0.000432526));
       allpoints.push(new PMPoint(-0.438202, -0.898876, 6.31233e-05));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-0.384615, -0.923077, 0.00295858));
       allpoints.push(new PMPoint(-0.28, -0.96, 0.0008));
       allpoints.push(new PMPoint(-0.324324, -0.945946, 9.13075e-05));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0, -1, 0.125));
       allpoints.push(new PMPoint(-0.28, -0.96, 0.0008));
       allpoints.push(new PMPoint(-0.219512, -0.97561, 0.000297442));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0, -1, 0.125));
       allpoints.push(new PMPoint(0.28, -0.96, 0.0008));
       allpoints.push(new PMPoint(0.219512, -0.97561, 0.000297442));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0.384615, -0.923077, 0.00295858));
       allpoints.push(new PMPoint(0.28, -0.96, 0.0008));
       allpoints.push(new PMPoint(0.324324, -0.945946, 9.13075e-05));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0.384615, -0.923077, 0.00295858));
       allpoints.push(new PMPoint(0.470588, -0.882353, 0.000432526));
       allpoints.push(new PMPoint(0.438202, -0.898876, 6.31233e-05));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0.6, -0.8, 0.02));
       allpoints.push(new PMPoint(0.470588, -0.882353, 0.000432526));
       allpoints.push(new PMPoint(0.507692, -0.861538, 0.000118343));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0.6, -0.8, 0.02));
       allpoints.push(new PMPoint(0.724138, -0.689655, 0.00059453));
       allpoints.push(new PMPoint(0.689655, -0.724138, 0.000148633));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0.8, -0.6, 0.005));
       allpoints.push(new PMPoint(0.724138, -0.689655, 0.00059453));
       allpoints.push(new PMPoint(0.753425, -0.657534, 9.38262e-05));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0.8, -0.6, 0.005));
       allpoints.push(new PMPoint(0.882353, -0.470588, 0.0017301));
       allpoints.push(new PMPoint(0.849057, -0.528302, 0.000177999));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(1, 0, 0.5));
       allpoints.push(new PMPoint(0.882353, -0.470588, 0.0017301));
       allpoints.push(new PMPoint(0.923077, -0.384615, 0.000739645));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(1, 0, 0.5));
       allpoints.push(new PMPoint(0.923077, 0.384615, 0.000739645));
       allpoints.push(new PMPoint(0.945946, 0.324324, 0.00036523));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0.882353, 0.470588, 0.0017301));
       allpoints.push(new PMPoint(0.923077, 0.384615, 0.000739645));
       allpoints.push(new PMPoint(0.905882, 0.423529, 6.92042e-05));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0.882353, 0.470588, 0.0017301));
       allpoints.push(new PMPoint(0.849057, 0.528302, 0.000177999));
       allpoints.push(new PMPoint(0.861538, 0.507692, 2.95858e-05));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0.8, 0.6, 0.005));
       allpoints.push(new PMPoint(0.849057, 0.528302, 0.000177999));
       allpoints.push(new PMPoint(0.834862, 0.550459, 4.2084e-05));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0.8, 0.6, 0.005));
       allpoints.push(new PMPoint(0.753425, 0.657534, 9.38262e-05));
       allpoints.push(new PMPoint(0.766423, 0.642336, 2.66397e-05));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0.724138, 0.689655, 0.00059453));
       allpoints.push(new PMPoint(0.753425, 0.657534, 9.38262e-05));
       allpoints.push(new PMPoint(0.742268, 0.670103, 1.32852e-05));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0.724138, 0.689655, 0.00059453));
       allpoints.push(new PMPoint(0.689655, 0.724138, 0.000148633));
       allpoints.push(new PMPoint(0.704142, 0.710059, 1.75064e-05));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0.6, 0.8, 0.02));
       allpoints.push(new PMPoint(0.689655, 0.724138, 0.000148633));
       allpoints.push(new PMPoint(0.670103, 0.742268, 5.31406e-05));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0.6, 0.8, 0.02));
       allpoints.push(new PMPoint(0.507692, 0.861538, 0.000118343));
       allpoints.push(new PMPoint(0.528302, 0.849057, 4.44998e-05));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0.470588, 0.882353, 0.000432526));
       allpoints.push(new PMPoint(0.507692, 0.861538, 0.000118343));
       allpoints.push(new PMPoint(0.492228, 0.870466, 1.34232e-05));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0.470588, 0.882353, 0.000432526));
       allpoints.push(new PMPoint(0.438202, 0.898876, 6.31233e-05));
       allpoints.push(new PMPoint(0.450644, 0.892704, 0));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0.384615, 0.923077, 0.00295858));
       allpoints.push(new PMPoint(0.438202, 0.898876, 6.31233e-05));
       allpoints.push(new PMPoint(0.423529, 0.905882, 1.7301e-05));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0.384615, 0.923077, 0.00295858));
       allpoints.push(new PMPoint(0.324324, 0.945946, 9.13075e-05));
       allpoints.push(new PMPoint(0.342282, 0.939597, 2.25215e-05));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0.28, 0.96, 0.0008));
       allpoints.push(new PMPoint(0.324324, 0.945946, 9.13075e-05));
       allpoints.push(new PMPoint(0.308108, 0.951351, 1.46092e-05));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0.28, 0.96, 0.0008));
       allpoints.push(new PMPoint(0.219512, 0.97561, 0.000297442));
       allpoints.push(new PMPoint(0.246154, 0.969231, 2.95858e-05));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0, 1, 0.125));
       allpoints.push(new PMPoint(0.219512, 0.97561, 0.000297442));
       allpoints.push(new PMPoint(0.180328, 0.983607, 0.000134372));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0, 1, 0.125));
       allpoints.push(new PMPoint(-0.219512, 0.97561, 0.000297442));
       allpoints.push(new PMPoint(-0.180328, 0.983607, 0.000134372));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-0.28, 0.96, 0.0008));
       allpoints.push(new PMPoint(-0.219512, 0.97561, 0.000297442));
       allpoints.push(new PMPoint(-0.246154, 0.969231, 2.95858e-05));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-0.28, 0.96, 0.0008));
       allpoints.push(new PMPoint(-0.324324, 0.945946, 9.13075e-05));
       allpoints.push(new PMPoint(-0.308108, 0.951351, 1.46092e-05));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-0.384615, 0.923077, 0.00295858));
       allpoints.push(new PMPoint(-0.324324, 0.945946, 9.13075e-05));
       allpoints.push(new PMPoint(-0.342282, 0.939597, 2.25215e-05));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-0.384615, 0.923077, 0.00295858));
       allpoints.push(new PMPoint(-0.438202, 0.898876, 6.31233e-05));
       allpoints.push(new PMPoint(-0.423529, 0.905882, 1.7301e-05));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-0.470588, 0.882353, 0.000432526));
       allpoints.push(new PMPoint(-0.438202, 0.898876, 6.31233e-05));
       allpoints.push(new PMPoint(-0.450644, 0.892704, 0));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-0.470588, 0.882353, 0.000432526));
       allpoints.push(new PMPoint(-0.507692, 0.861538, 0.000118343));
       allpoints.push(new PMPoint(-0.492228, 0.870466, 1.34232e-05));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-0.6, 0.8, 0.02));
       allpoints.push(new PMPoint(-0.507692, 0.861538, 0.000118343));
       allpoints.push(new PMPoint(-0.528302, 0.849057, 4.44998e-05));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-0.6, 0.8, 0.02));
       allpoints.push(new PMPoint(-0.689655, 0.724138, 0.000148633));
       allpoints.push(new PMPoint(-0.670103, 0.742268, 5.31406e-05));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-0.724138, 0.689655, 0.00059453));
       allpoints.push(new PMPoint(-0.689655, 0.724138, 0.000148633));
       allpoints.push(new PMPoint(-0.704142, 0.710059, 1.75064e-05));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-0.724138, 0.689655, 0.00059453));
       allpoints.push(new PMPoint(-0.753425, 0.657534, 9.38262e-05));
       allpoints.push(new PMPoint(-0.742268, 0.670103, 1.32852e-05));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-0.8, 0.6, 0.005));
       allpoints.push(new PMPoint(-0.753425, 0.657534, 9.38262e-05));
       allpoints.push(new PMPoint(-0.766423, 0.642336, 2.66397e-05));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-0.8, 0.6, 0.005));
       allpoints.push(new PMPoint(-0.849057, 0.528302, 0.000177999));
       allpoints.push(new PMPoint(-0.834862, 0.550459, 4.2084e-05));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-0.882353, 0.470588, 0.0017301));
       allpoints.push(new PMPoint(-0.849057, 0.528302, 0.000177999));
       allpoints.push(new PMPoint(-0.861538, 0.507692, 2.95858e-05));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-0.882353, 0.470588, 0.0017301));
       allpoints.push(new PMPoint(-0.923077, 0.384615, 0.000739645));
       allpoints.push(new PMPoint(-0.905882, 0.423529, 6.92042e-05));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-1, 0, 0.5));
       allpoints.push(new PMPoint(-0.923077, 0.384615, 0.000739645));
       allpoints.push(new PMPoint(-0.945946, 0.324324, 0.00036523));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
    // COMMON_CODE_BLOCK_BEGIN
    var xRotationEnabled = false;
    var yRotationEnabled = false;
    var zRotationEnabled = false;
    var rotationSpeedFactor = 1;
    var settingsShown = false;
    var labelsShown = true;
    var intervals = [];
    var timeouts = [];
    var explodingSpeed = 0.05;
    var explodeScale = 0;
    var XMLS = new XMLSerializer();
    var svgElement;
    var renderId;
    
    	var render = function () {
    
    		renderId = requestAnimationFrame(render);
    
    //		comment in for automatic explosion
    //		explode(updateFactor());
    
    		var phi = 0.02 * rotationSpeedFactor;
    
    		if (xRotationEnabled){
    			scene.rotation.x += phi;
    		}
    		if(yRotationEnabled){
    			scene.rotation.y += phi;
    		}
    		if(zRotationEnabled){
    			scene.rotation.z += phi;
    		}
    
    		controls.update();
    		renderer.render(scene, camera);
    	};
    
    	render();
    
    	function computeCentroid(geom) {
    		centroid = new THREE.Vector3();
    		geom.vertices.forEach(function(v) {
    			centroid.add(v);			
    		});
    		centroid.divideScalar(geom.vertices.length);
    		return centroid;
    	}
    
    	function changeTransparency(event){
    		var opacity = 1-Number(event.currentTarget.value);
    		for (var i=0; i<all_objects.length; i++){
    			for (var j=0; j<all_objects[i].children.length; j++){
    				if (all_objects[i].children[j].material.type == "MultiMaterial") {
    					for (var k=0; k<all_objects[i].children[j].material.materials.length; k++){
    						all_objects[i].children[j].material.materials[k].opacity = opacity;
    						all_objects[i].children[j].material.materials[k].depthWrite = opacity < 0.5 ? false : true;
    						all_objects[i].children[j].material.materials[k].depthTest = opacity < 0.5 ? false : true;
    					}
    				} else if (all_objects[i].children[j].material.transparent && 
    							  all_objects[i].children[j].material.type == "MeshBasicMaterial" &&
    							  all_objects[i].children[j].geometry.type == "Geometry"){
    					all_objects[i].children[j].material.opacity = opacity;
    					all_objects[i].children[j].material.depthWrite = opacity < 0.5 ? false : true;
    					all_objects[i].children[j].material.depthTest = opacity < 0.5 ? false : true;
    				}
    			}
    		}
    	}
    
    	function changeRotationX(event){
    		xRotationEnabled = event.currentTarget.checked;
    	}	
    
    	function changeRotationY(event){
    		yRotationEnabled = event.currentTarget.checked;
    	}	
    
    	function changeRotationZ(event){
    		zRotationEnabled = event.currentTarget.checked;
    	}	
    
    
    	function changeRotationSpeedFactor(event){
    		rotationSpeedFactor = Number(event.currentTarget.value);
    	}
    
    	function resetScene(){
    		scene.rotation.set(0,0,0);
    		camera.position.set(0,0,5);
    		camera.up.set(0,1,0);
    	}
    
    	function showSettings(event){
    		event.currentTarget.style.display = 'none';
    		document.getElementById('settings_2').style.position = 'absolute';
    		document.getElementById('settings_2').style.display = 'block';
    		document.getElementById('showSettingsButton_2').style.display = 'none';
    		document.getElementById('hideSettingsButton_2').style.display = 'block';
    		settingsShown = true;
    	}
    
    	function hideSettings(event){
    		event.currentTarget.style.display = 'none';
    		document.getElementById('settings_2').style.display = 'none';
    		document.getElementById('hideSettingsButton_2').style.display = 'none';
    		document.getElementById('showSettingsButton_2').style.display = 'block';
    		settingsShown = false;
    	}
    
    
    
    	var pos = 150* Math.PI;
    
    	function updateFactor() {
    		pos++;
    		return Math.sin(.01*pos)+1;
    	}
    
    	function makelabel(message, x, y, z, params) {
    		var spritey = textSprite( message, params );
    		spritey.position.set(x, y, z);
    		obj.add(spritey);
    	}
    
    	function textSprite(message, parameters)
    	{
    		if ( parameters === undefined ) parameters = {};
    
    		var fontface = "Helvetica";
    
    		var fontsize = parameters.hasOwnProperty("fontsize") ? 
    			parameters["fontsize"] : 18;
    		fontsize = fontsize*10;
    
    		var canvas = document.createElement('canvas');
    		var size = 1024;
    		canvas.width = size;
    		canvas.height = size;
    		var context = canvas.getContext('2d');
    		context.font = fontsize + "px " + fontface;
    
    		// text color
    		context.fillStyle = "rgba(0, 0, 0, 1.0)";
    
    		context.fillText(message, size/2, size/2);
    
    		// canvas contents will be used for a texture
    		var texture = new THREE.Texture(canvas);
    		texture.needsUpdate = true;
    
    		var spriteMaterial = new THREE.SpriteMaterial(
    			{map: texture, useScreenCoordinates: false});
    		var sprite = new THREE.Sprite(spriteMaterial);
    		return sprite;
    	}
    
    	function takeSvgScreenshot(){
    		if (labelsShown){
    			hideLabels();
    		}
    		svgRenderer.render(scene,camera);
    		svgElement = XMLS.serializeToString(svgRenderer.domElement);
    		
    		if (labelsShown){
    			displayLabels();
    		}
    
    		if (document.getElementById('tab_2').checked){
    			//show in new tab
    			var myWindow = window.open("","");
    			myWindow.document.body.innerHTML = svgElement;
    		} else{
    			// download svg file 
    			download("screenshot.svg", svgElement);
    		}
    	}
    		
    
    	function showOrHideObject(event){
    		var nr = Number(event.currentTarget.name);
    		all_objects[nr].visible = event.currentTarget.checked;
    	}
    
    
    	function displayOrHideOptions(){
    		for (var i=0; i<all_objects.length; i++){
    			for (var j=0; j<all_objects[i].children.length; j++){
    				if (all_objects[i].children[j].material.type == "MultiMaterial") {
    					for (var k=0; k<all_objects[i].children[j].material.materials.length; k++){
    						if (all_objects[i].children[j].material.materials[k].transparent) {
    							document.getElementById('transparency_2').style.display = 'block';
    							document.getElementById('transparencyRange_2').value = 1 - 
    							    all_objects[i].children[j].material.materials[k].opacity;
    							return;
    						}
    					}
    				} else if (all_objects[i].children[j].material.transparent && 
    							  all_objects[i].children[j].material.type == "MeshBasicMaterial" &&
    							  all_objects[i].children[j].geometry.type == "Geometry"){
    					document.getElementById('transparency_2').style.display = 'block';
    					return;
    				}
    			}
    		}
    	}
    
    	displayOrHideOptions()
    
    
    
    
    // ---------------------- EXPLOSION ------------------------------------------------
    // ---------------------------------------------------------------------------------
    
    	function explode(factor) {
    		var obj, c;
    		var c0 = centroids[0];
    		for (var i = 0; i<centroids.length; ++i) {
    			c = centroids[i];
    			obj = all_objects[all_objects.length - centroids.length + i];
    			obj.position.set(c.x*factor, c.y*factor, c.z*factor);
    		}	
    	}
    
    	function triggerExplode(event){
    		explodeScale = Number(event.currentTarget.value);
    		explode(explodeScale);
    	}
    
    	function setExplodingSpeed(event){
    		explodingSpeed = Number(event.currentTarget.value);
    	}
    
    	function triggerAutomaticExplode(event){
    		if (event.currentTarget.checked){
    			startExploding();
    		} else {
    			clearIntervals();
    		}	
    	}
    
    	function startExploding(){
    		intervals.push(setInterval(explodingInterval, 25));
    	}
    
    
    	function explodingInterval(){
    		explodeScale += explodingSpeed;
    		if (explodeScale <= 6){ 
    			explode(explodeScale);
    		}
    		else{
    			explode(6);
    			explodeScale = 6;
    			clearIntervals();
    			timeouts.push(setTimeout(startUnexploding, 3000));
    		}
    		document.getElementById('explodeRange_2').value = explodeScale;
    	}
    
    
    	function startUnexploding(){
    		intervals.push(setInterval(unexplodingInterval, 25));
    	}
    
    	function unexplodingInterval(){
    		explodeScale -= explodingSpeed;
    		if (explodeScale >= 0){	
    			explode(explodeScale);
    		}
    		else {
    			explode(0);
    			explodeScale = 0;
    			clearIntervals();
    			timeouts.push(setTimeout(startExploding, 3000));
    		}
    		document.getElementById('explodeRange_2').value = explodeScale;
    	}
    
    	function clearIntervals(){
    		intervals.forEach(function(interval){
    			clearInterval(interval);
    		});
    		intervals = [];
    		timeouts.forEach(function(timeout){
    			clearTimeout(timeout);
    		});
    		timeouts = [];
    	}
    
    			
    
    	// append checkboxes for displaying or hiding objects
    	var shownObjectsList = document.getElementById('shownObjectsList_2');
    	for (var i=0; i<all_objects.length; i++){
    		var objNode = document.createElement('span');
    		objNode.innerHTML = objectnames[i] + '<br>';
    		var checkbox = document.createElement('input');
    		checkbox.type = 'checkbox';
    		checkbox.checked = true;
    		checkbox.name = String(i);
    		checkbox.onchange = showOrHideObject;
    		shownObjectsList.appendChild(checkbox);
    		shownObjectsList.appendChild(objNode);
    	}
    
    	function displayLabels(){
    		for (var i=0; i<all_objects.length; i++){
    			for (var j=0; j<all_objects[i].children.length; j++){
    				var child = all_objects[i].children[j];
    				if (child.type == 'Sprite'){
    					child.visible = true;
    				}
    			}
    		}
    	}
    
    	function hideLabels(){
    		for (var i=0; i<all_objects.length; i++){
    			for (var j=0; j<all_objects[i].children.length; j++){
    				var child = all_objects[i].children[j];
    				if (child.type == 'Sprite'){
    					child.visible = false;
    				}
    			}
    		}
    	}
    
    	function displayOrHideLabels(event){
    		if (event.currentTarget.checked){
    			displayLabels();
    			labelsShown = true;
    		} else {
    			hideLabels();
    			labelsShown = false;
    		}
    	}
    
    	function download(filename, text) {
    	  var element = document.createElement('a');
    	  element.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(text));
    	  element.setAttribute('download', filename);
    
    	  element.style.display = 'none';
    	  document.body.appendChild(element);
    
    	  element.click();
    
    	  document.body.removeChild(element);
    	}
    
    var tempobj;
    tempobj = document.getElementById('explodeRange_2');
    if (tempobj) {
       tempobj.oninput = triggerExplode;
       document.getElementById('explodeCheckbox_2').onchange = triggerAutomaticExplode;
       document.getElementById('explodingSpeedRange_2').oninput = setExplodingSpeed;
    }
    tempobj = document.getElementById('foldRange_2');
    if (tempobj) {
       tempobj.oninput = fold;
    }
    document.getElementById('transparencyRange_2').oninput = changeTransparency;
    document.getElementById('changeRotationX_2').onchange = changeRotationX;
    document.getElementById('changeRotationY_2').onchange = changeRotationY;
    document.getElementById('changeRotationZ_2').onchange = changeRotationZ;
    document.getElementById('resetButton_2').onclick = resetScene;
    document.getElementById('rotationSpeedRange_2').oninput = changeRotationSpeedFactor;
    document.getElementById('labelsCheckboxInput_2').onchange = displayOrHideLabels;
    document.getElementById('takeScreenshot_2').onclick = takeSvgScreenshot;
    document.getElementById('showSettingsButton_2').onclick = showSettings;
    document.getElementById('hideSettingsButton_2').onclick = hideSettings;
    
    	
    
    // ------------------ SHORTCUTS --------------------------------------------
    // -------------------------------------------------------------------------
    
    /**
     * http://www.openjs.com/scripts/events/keyboard_shortcuts/
     * Version : 2.01.B
     * By Binny V A
     * License : BSD
     */
    shortcut = {
    	'all_shortcuts':{},//All the shortcuts are stored in this array
    	'add': function(shortcut_combination,callback,opt) {
    		//Provide a set of default options
    		var default_options = {
    			'type':'keydown',
    			'propagate':false,
    			'disable_in_input':false,
    			'target':document,
    			'keycode':false
    		}
    		if(!opt) opt = default_options;
    		else {
    			for(var dfo in default_options) {
    				if(typeof opt[dfo] == 'undefined') opt[dfo] = default_options[dfo];
    			}
    		}
    
    		var ele = opt.target;
    		if(typeof opt.target == 'string') ele = document.getElementById(opt.target);
    		var ths = this;
    		shortcut_combination = shortcut_combination.toLowerCase();
    
    		//The function to be called at keypress
    		var func = function(e) {
    			e = e || window.event;
    			
    			if(opt['disable_in_input']) { //Don't enable shortcut keys in Input, Textarea fields
    				var element;
    				if(e.target) element=e.target;
    				else if(e.srcElement) element=e.srcElement;
    				if(element.nodeType==3) element=element.parentNode;
    
    				if(element.tagName == 'INPUT' || element.tagName == 'TEXTAREA') return;
    			}
    	
    			//Find Which key is pressed
    			if (e.keyCode) code = e.keyCode;
    			else if (e.which) code = e.which;
    			var character = String.fromCharCode(code).toLowerCase();
    			
    			if(code == 188) character=","; //If the user presses , when the type is onkeydown
    			if(code == 190) character="."; //If the user presses , when the type is onkeydown
    
    			var keys = shortcut_combination.split("+");
    			//Key Pressed - counts the number of valid keypresses - if it is same as the number of keys, the shortcut function is invoked
    			var kp = 0;
    			
    			//Work around for stupid Shift key bug created by using lowercase - as a result the shift+num combination was broken
    			var shift_nums = {
    				"`":"~",
    				"1":"!",
    				"2":"@",
    				"3":"#",
    				"4":"$",
    				"5":"%",
    				"6":"^",
    				"7":"&",
    				"8":"*",
    				"9":"(",
    				"0":")",
    				"-":"_",
    				"=":"+",
    				";":":",
    				"'":"\"",
    				",":"<",
    				".":">",
    				"/":"?",
    				"\\":"|"
    			}
    			//Special Keys - and their codes
    			var special_keys = {
    				'esc':27,
    				'escape':27,
    				'tab':9,
    				'space':32,
    				'return':13,
    				'enter':13,
    				'backspace':8,
    	
    				'scrolllock':145,
    				'scroll_lock':145,
    				'scroll':145,
    				'capslock':20,
    				'caps_lock':20,
    				'caps':20,
    				'numlock':144,
    				'num_lock':144,
    				'num':144,
    				
    				'pause':19,
    				'break':19,
    				
    				'insert':45,
    				'home':36,
    				'delete':46,
    				'end':35,
    				
    				'pageup':33,
    				'page_up':33,
    				'pu':33,
    	
    				'pagedown':34,
    				'page_down':34,
    				'pd':34,
    	
    				'left':37,
    				'up':38,
    				'right':39,
    				'down':40,
    	
    				'f1':112,
    				'f2':113,
    				'f3':114,
    				'f4':115,
    				'f5':116,
    				'f6':117,
    				'f7':118,
    				'f8':119,
    				'f9':120,
    				'f10':121,
    				'f11':122,
    				'f12':123
    			}
    	
    			var modifiers = { 
    				shift: { wanted:false, pressed:false},
    				ctrl : { wanted:false, pressed:false},
    				alt  : { wanted:false, pressed:false},
    				meta : { wanted:false, pressed:false}	//Meta is Mac specific
    			};
                            
    			if(e.ctrlKey)	modifiers.ctrl.pressed = true;
    			if(e.shiftKey)	modifiers.shift.pressed = true;
    			if(e.altKey)	modifiers.alt.pressed = true;
    			if(e.metaKey)   modifiers.meta.pressed = true;
                            
    			for(var i=0; k=keys[i],i<keys.length; i++) {
    				//Modifiers
    				if(k == 'ctrl' || k == 'control') {
    					kp++;
    					modifiers.ctrl.wanted = true;
    
    				} else if(k == 'shift') {
    					kp++;
    					modifiers.shift.wanted = true;
    
    				} else if(k == 'alt') {
    					kp++;
    					modifiers.alt.wanted = true;
    				} else if(k == 'meta') {
    					kp++;
    					modifiers.meta.wanted = true;
    				} else if(k.length > 1) { //If it is a special key
    					if(special_keys[k] == code) kp++;
    					
    				} else if(opt['keycode']) {
    					if(opt['keycode'] == code) kp++;
    
    				} else { //The special keys did not match
    					if(character == k) kp++;
    					else {
    						if(shift_nums[character] && e.shiftKey) { //Stupid Shift key bug created by using lowercase
    							character = shift_nums[character]; 
    							if(character == k) kp++;
    						}
    					}
    				}
    			}
    			
    			if(kp == keys.length && 
    						modifiers.ctrl.pressed == modifiers.ctrl.wanted &&
    						modifiers.shift.pressed == modifiers.shift.wanted &&
    						modifiers.alt.pressed == modifiers.alt.wanted &&
    						modifiers.meta.pressed == modifiers.meta.wanted) {
    				callback(e);
    	
    				if(!opt['propagate']) { //Stop the event
    					//e.cancelBubble is supported by IE - this will kill the bubbling process.
    					e.cancelBubble = true;
    					e.returnValue = false;
    	
    					//e.stopPropagation works in Firefox.
    					if (e.stopPropagation) {
    						e.stopPropagation();
    						e.preventDefault();
    					}
    					return false;
    				}
    			}
    		}
    		this.all_shortcuts[shortcut_combination] = {
    			'callback':func, 
    			'target':ele, 
    			'event': opt['type']
    		};
    		//Attach the function with the event
    		if(ele.addEventListener) ele.addEventListener(opt['type'], func, false);
    		else if(ele.attachEvent) ele.attachEvent('on'+opt['type'], func);
    		else ele['on'+opt['type']] = func;
    	},
    
    	//Remove the shortcut - just specify the shortcut and I will remove the binding
    	'remove':function(shortcut_combination) {
    		shortcut_combination = shortcut_combination.toLowerCase();
    		var binding = this.all_shortcuts[shortcut_combination];
    		delete(this.all_shortcuts[shortcut_combination])
    		if(!binding) return;
    		var type = binding['event'];
    		var ele = binding['target'];
    		var callback = binding['callback'];
    
    		if(ele.detachEvent) ele.detachEvent('on'+type, callback);
    		else if(ele.removeEventListener) ele.removeEventListener(type, callback, false);
    		else ele['on'+type] = false;
    	}
    }
    
    shortcut.add("Alt+Left",function() {
    	var event = new Event('click');
    	if (settingsShown){
    		document.getElementById('hideSettingsButton_2').dispatchEvent(event);
    	} else{
    		document.getElementById('showSettingsButton_2').dispatchEvent(event);
    	}
    });
    
    if (foldable) moveToBaryCenter();
    
    
    });});
    // COMMON_CODE_BLOCK_END
    </script>
    
    </body>
    </html>



.. link

.. CODE-BLOCK:: perl

    polymake> $d1 = $s->gkz_dome(1,5);
    polymake> $d1->VISUAL(FacetColor=>'80 180 255');


.. raw:: html

    <!--
    polymake for loewe
    Fri Feb  9 13:50:15 2018
    pcom:d1
    -->
    
    
    <html>
       <head>
          <title>pcom:d1</title>
          <style>
    /*
    // COMMON_CODE_BLOCK_BEGIN
    */
             html{overflow: scroll;}
             body { font-family: Arial, Helvetica, sans-serif}
             strong{font-size: 18px;}
             canvas { z-index: 8; }
             input[type='range'] {}
             input[type='radio'] {margin-left:0;}
             input[type='checkbox'] {margin-right:7px; margin-left: 0px; padding-left:0px;}
             .group{padding-bottom: 40px;}
             .settings * {z-index: 11; }
             .settings{z-index: 10; margin-left: 30px; display: none; width: 14em; height: 90%; border: solid 1px silver; padding: 2px; overflow-y: scroll; background-color: white }
             .indented{margin-left: 20px; margin-top: 15px; padding-bottom: 0px;} 
             .shownObjectsList{overflow: auto; max-width: 150px; max-height: 150px;}
             .showSettingsButton{display: block; z-index: 12; position: absolute }
             .hideSettingsButton{display: none; z-index: 12; position: absolute; opacity: 0.5}
             .resetButton{margin-top: 20px;}
             button{margin-left: 0;}
             img{cursor: pointer;}
             .suboption{padding-top: 30px;}
             .transparency{display: none;}
             .labelsCheckbox{margin-top: 10px;}
    
    
             input[type=range] {
               -webkit-appearance: none;
               padding:0; 
               width:90%; 
               margin-left: auto;
               margin-right: auto;
               margin-top: 20px;
               display: block;	
             }
             input[type=range]:focus {
               outline: none;
             }
             input[type=range]::-webkit-slider-runnable-track {
               height: 4px;
               cursor: pointer;
               animate: 0.2s;
               box-shadow: 0px 0px 0px #000000;
               background: #E3E3E3;
               border-radius: 0px;
               border: 0px solid #000000;
             }
             input[type=range]::-webkit-slider-thumb {
               box-shadow: 1px 1px 2px #B8B8B8;
               border: 1px solid #ABABAB;
               height: 13px;
               width: 25px;
               border-radius: 20px;
               background: #E0E0E0;
               cursor: pointer;
               -webkit-appearance: none;
               margin-top: -5px;
             }
             input[type=range]:focus::-webkit-slider-runnable-track {
               background: #E3E3E3;
             }
             input[type=range]::-moz-range-track {
               height: 4px;
               cursor: pointer;
               animate: 0.2s;
               box-shadow: 0px 0px 0px #000000;
               background: #E3E3E3;
               border-radius: 0px;
               border: 0px solid #000000;
             }
             input[type=range]::-moz-range-thumb {
               box-shadow: 1px 1px 2px #B8B8B8;
               border: 1px solid #ABABAB;
               height: 13px;
               width: 25px;
               border-radius: 20px;
               background: #E0E0E0;
               cursor: pointer;
             }
             input[type=range]::-ms-track {
               height: 4px;
               cursor: pointer;
               animate: 0.2s;
               background: transparent;
               border-color: transparent;
               color: transparent;
             }
             input[type=range]::-ms-fill-lower {
               background: #E3E3E3;
               border: 0px solid #000000;
               border-radius: 0px;
               box-shadow: 0px 0px 0px #000000;
             }
             input[type=range]::-ms-fill-upper {
               background: #E3E3E3;
               border: 0px solid #000000;
               border-radius: 0px;
               box-shadow: 0px 0px 0px #000000;
             }
             input[type=range]::-ms-thumb {
               box-shadow: 1px 1px 2px #B8B8B8;
               border: 1px solid #ABABAB;
               height: 13px;
               width: 25px;
               border-radius: 20px;
               background: #E0E0E0;
               cursor: pointer;
             }
             input[type=range]:focus::-ms-fill-lower {
               background: #E3E3E3;
             }
             input[type=range]:focus::-ms-fill-upper {
               background: #E3E3E3;
             }
    /*
    // COMMON_CODE_BLOCK_END
    */
    		</style>
       </head>
    
    <body>
    
    		<div id='settings_3' class='settings'>
    			<div class=group id='explode_3'>
    				<strong>Explode</strong>
    				<input id='explodeRange_3' type='range' min=0 max=6 step=0.01 value=0>
    				<div class=indented><input id='explodeCheckbox_3' type='checkbox'>Automatic explosion</div>
    				<div class=suboption>Exploding speed</div>
    				<input id='explodingSpeedRange_3' type='range' min=0 max=0.5 step=0.001 value=0.05>
    			</div>
    
    			
    			<div class=group id='transparency_3' class='transparency'>
    				<strong>Transparency</strong>
    				<input id='transparencyRange_3' type='range' min=0 max=1 step=0.01 value=0>
    			</div>
    			
    			<div class=group id='rotation_3'>
    				<strong>Rotation</strong>
    				<div class=indented>
    					<div><input type='checkbox' id='changeRotationX_3'> x-axis</div>
    					<div><input type='checkbox' id='changeRotationY_3'> y-axis</div>
    					<div><input type='checkbox' id='changeRotationZ_3'> z-axis</div>
    					<button id='resetButton_3' class='resetButton' >Reset</button>
    				</div>
    
    				<div class=suboption>Rotation speed</div>
    				<input id='rotationSpeedRange_3' type='range' min=0 max=5 step=0.01 value=2>
    
    			</div>
    
    
    			<div class=group id='display_3'>
    				<strong>Display</strong>
    				<div class=indented>
    					<div id='shownObjectsList_3' class='shownObjectsList'></div>
    					<div class='labelsCheckbox'><input type='checkbox' id='labelsCheckboxInput_3' checked>Labels</div>
    				</div>
    			</div>
    
    
    			<div class=group id='svg_3'>
    				<strong>SVG</strong>
    				<div class=indented>
    					<form>
    						<input type="radio" name='screenshotMode' value='download' id='download_3' checked> Download<br>
    						<input type="radio" name='screenshotMode' value='tab' id='tab_3' > New tab<br>
    					</form>
    					<button id='takeScreenshot_3'>Screenshot</button>
    				</div>
    			</div>
    
    		</div>	<!-- end of settings -->
    		<img id='hideSettingsButton_3' style="display: none" class='hideSettingsButton' src='/kernelspecs/polymake/close.svg' width=20px">
    		<img id='showSettingsButton_3' class='showSettingsButton' src='/kernelspecs/polymake/menu.svg' width=20px">
    <div id="model35331244449"></div>
    
    <script>
    requirejs.config({
      paths: {
        three: '/kernelspecs/polymake/three',
        Detector: '/kernelspecs/polymake/Detector',
        SVGRenderer: '/kernelspecs/polymake/SVGRenderer',
        CanvasRenderer: '/kernelspecs/polymake/CanvasRenderer',
        Projector: '/kernelspecs/polymake/Projector',
        TrackballControls: '/kernelspecs/polymake/TrackballControls'
      },
      shim: {
        'three':
        {
          exports: 'THREE'
        },
        'Detector':
        {
          deps: [ 'three' ],
          exports: 'Detector'
        },
        'SVGRenderer':
        {
          deps: [ 'three' ],
          exports: 'THREE.SVGRenderer'
        },
        'CanvasRenderer':
        {
          deps: [ 'three' ],
          exports: 'THREE.CanvasRenderer'
        },
        'Projector':
        {
          deps: [ 'three' ],
          exports: 'THREE.Projector'
        },
        'TrackballControls':
        {
          deps: [ 'three' ],
          exports: 'THREE.TrackballControls'
        }
      }
    });
    require(['three'],function(THREE){
        window.THREE = THREE;
      require(['Detector','SVGRenderer','CanvasRenderer','Projector','TrackballControls'],function(Detector,SVGRenderer,CanvasRenderer,Projector,TrackballControls){
          THREE.SVGRenderer = SVGRenderer;
          THREE.CanvasRenderer = CanvasRenderer;
          THREE.Projector = Projector;
          THREE.TrackballControls = TrackballControls;
    
    // COMMON_CODE_BLOCK_BEGIN
    	var foldable = false;
       var container = document.getElementById( 'model35331244449' );
       var renderer = Detector.webgl? new THREE.WebGLRenderer({antialias: true}): new THREE.CanvasRenderer({antialias: true});
    	var svgRenderer = new THREE.SVGRenderer({antialias: true});
                var box = document.getElementsByClassName( 'output_subarea' )[0];
             var notebook = document.getElementById( 'notebook_panel' );
    
       var width = box.clientWidth - 25;
       var height = notebook.clientHeight * 0.8;
       renderer.setSize(width, height);
       svgRenderer.setSize(width, height);
       renderer.setClearColor(0xFFFFFF, 1);
       svgRenderer.setClearColor(0xFFFFFF, 1);
    
       container.appendChild(renderer.domElement);
    
       var scene = new THREE.Scene();
       var camera = new THREE.PerspectiveCamera(75, width/height, 0.1, 1000);
    
       var renderid;
    
       camera.position.set(0, 0, 5);
       camera.lookAt(0, 0, 0);
       camera.up.set(0, 1, 0);
    
       // class to allow move points together with labels and spheres
       var PMPoint = function (x,y,z) {
          this.vector = new THREE.Vector3(x,y,z);
          this.sprite = null;
          this.sphere = null;
       }
       PMPoint.prototype.makelabel = function(label) {
          this.sprite = textSprite( label );
          this.sprite.position.copy(this.vector);
       }
       PMPoint.prototype.makesphere = function(radius,material) {
          this.sphere = new THREE.Mesh(new THREE.SphereGeometry(radius), material);
          this.sphere.position.copy(this.vector);
       }
    
       PMPoint.prototype.setX = function(x) {
          this.vector.setX(x);
          if (this.sprite) {
             this.sprite.position.setX(x);
          }
          if (this.sphere) {
             this.sphere.position.setX(x);
          }
       };
       PMPoint.prototype.setY = function(y) {
          this.vector.setY(y);
          if (this.sprite) {
             this.sprite.position.setY(y);
          }
          if (this.sphere) {
             this.sphere.position.setY(y);
          }
       };
       PMPoint.prototype.setZ = function(z) {
          this.vector.setZ(z);
          if (this.sprite) {
             this.sprite.position.setZ(z);
          }
          if (this.sphere) {
             this.sphere.position.setZ(z);
          }
       };
       PMPoint.prototype.set = function(x,y,z) {
          this.vector.set(x,y,z);
          if (this.sprite) {
             this.sprite.position.set(x,y,z);
          }
          if (this.sphere) {
             this.sphere.position.set(x,y,z);
          }
       };
       PMPoint.prototype.add = function(o) {
          if (this.sprite) {
             o.add(this.sprite);
          }
          if (this.sphere) {
             o.add(this.sphere);
          }
       };
    
    
       var controls = new THREE.TrackballControls(camera, container);
    	controls.zoomSpeed = 0.2;
    	controls.rotateSpeed = 4;
    
       var all_objects = [];
       var centroids = [];
       // select the target node
       var target = document.querySelector('#model35331244449');
    
       // create an observer instance
       var observer = new MutationObserver(function(mutations) {
          mutations.forEach(function(mutation) {
             if (mutation.removedNodes && mutation.removedNodes.length > 0) {
                cancelAnimationFrame(renderId);
                observer.disconnect();
                console.log("cancelled frame "+renderId);
             }
          });
       });
    
       // configuration of the observer:
       var config = { childList: true, characterData: true }
    
       // pass in the target node, as well as the observer options
       while (target) {
          if (target.className=="output") {
             observer.observe(target, config);
             break;
          }
          target = target.parentNode;
       }
    
    // COMMON_CODE_BLOCK_END
    
       var objectnames = ["unnamed__1","unnamed__2","unnamed__3","unnamed__4","unnamed__5","unnamed__6","unnamed__7","unnamed__8","unnamed__9","unnamed__10","unnamed__11","unnamed__12","unnamed__13","unnamed__14","unnamed__15","unnamed__16","unnamed__17","unnamed__18","unnamed__19","unnamed__20","unnamed__21","unnamed__22","unnamed__23","unnamed__24","unnamed__25","unnamed__26","unnamed__27","unnamed__28","unnamed__29","unnamed__30","unnamed__31","unnamed__32","unnamed__33","unnamed__34","unnamed__35","unnamed__36","unnamed__37","unnamed__38","unnamed__39","unnamed__40","unnamed__41","unnamed__42","unnamed__43","unnamed__44","unnamed__45","unnamed__46","unnamed__47","unnamed__48","unnamed__49","unnamed__50","unnamed__51","unnamed__52","unnamed__53","unnamed__54","unnamed__55","unnamed__56","unnamed__57","unnamed__58","unnamed__59","unnamed__60","unnamed__61","unnamed__62","unnamed__63","unnamed__64","unnamed__65","unnamed__66","unnamed__67","unnamed__68","unnamed__69","unnamed__70","unnamed__71","unnamed__72","unnamed__73","unnamed__74","unnamed__75","unnamed__76","unnamed__77","unnamed__78","unnamed__79","unnamed__80","unnamed__81","unnamed__82","unnamed__83","unnamed__84","unnamed__85","unnamed__86","unnamed__87","unnamed__88","unnamed__89","unnamed__90","unnamed__91","unnamed__92","unnamed__93","unnamed__94"];
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0, -1, 0.125));
       allpoints.push(new PMPoint(0, 1, 0.125));
       allpoints.push(new PMPoint(-1, 0, 0.5));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 2, 1, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0, -1, 0.125));
       allpoints.push(new PMPoint(0, 1, 0.125));
       allpoints.push(new PMPoint(1, 0, 0.5));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0, 1, 0.125));
       allpoints.push(new PMPoint(-1, 0, 0.5));
       allpoints.push(new PMPoint(-0.8, 0.6, 0.005));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0, -1, 0.125));
       allpoints.push(new PMPoint(-1, 0, 0.5));
       allpoints.push(new PMPoint(-0.8, -0.6, 0.005));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0, -1, 0.125));
       allpoints.push(new PMPoint(1, 0, 0.5));
       allpoints.push(new PMPoint(0.8, -0.6, 0.005));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0, 1, 0.125));
       allpoints.push(new PMPoint(1, 0, 0.5));
       allpoints.push(new PMPoint(0.8, 0.6, 0.005));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0, 1, 0.125));
       allpoints.push(new PMPoint(-0.8, 0.6, 0.005));
       allpoints.push(new PMPoint(-0.6, 0.8, 0.02));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-1, 0, 0.5));
       allpoints.push(new PMPoint(-0.8, 0.6, 0.005));
       allpoints.push(new PMPoint(-0.923077, 0.384615, 0.000739645));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-1, 0, 0.5));
       allpoints.push(new PMPoint(-0.8, -0.6, 0.005));
       allpoints.push(new PMPoint(-0.923077, -0.384615, 0.000739645));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0, -1, 0.125));
       allpoints.push(new PMPoint(-0.8, -0.6, 0.005));
       allpoints.push(new PMPoint(-0.6, -0.8, 0.02));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0, -1, 0.125));
       allpoints.push(new PMPoint(0.8, -0.6, 0.005));
       allpoints.push(new PMPoint(0.6, -0.8, 0.02));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(1, 0, 0.5));
       allpoints.push(new PMPoint(0.8, -0.6, 0.005));
       allpoints.push(new PMPoint(0.923077, -0.384615, 0.000739645));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(1, 0, 0.5));
       allpoints.push(new PMPoint(0.8, 0.6, 0.005));
       allpoints.push(new PMPoint(0.923077, 0.384615, 0.000739645));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0, 1, 0.125));
       allpoints.push(new PMPoint(0.8, 0.6, 0.005));
       allpoints.push(new PMPoint(0.6, 0.8, 0.02));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0, 1, 0.125));
       allpoints.push(new PMPoint(-0.6, 0.8, 0.02));
       allpoints.push(new PMPoint(-0.470588, 0.882353, 0.000432526));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-0.8, 0.6, 0.005));
       allpoints.push(new PMPoint(-0.6, 0.8, 0.02));
       allpoints.push(new PMPoint(-0.689655, 0.724138, 0.000148633));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-0.8, 0.6, 0.005));
       allpoints.push(new PMPoint(-0.923077, 0.384615, 0.000739645));
       allpoints.push(new PMPoint(-0.882353, 0.470588, 0.0017301));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-1, 0, 0.5));
       allpoints.push(new PMPoint(-0.923077, 0.384615, 0.000739645));
       allpoints.push(new PMPoint(-0.96, 0.28, 0.0002));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-1, 0, 0.5));
       allpoints.push(new PMPoint(-0.923077, -0.384615, 0.000739645));
       allpoints.push(new PMPoint(-0.96, -0.28, 0.0002));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-0.8, -0.6, 0.005));
       allpoints.push(new PMPoint(-0.923077, -0.384615, 0.000739645));
       allpoints.push(new PMPoint(-0.882353, -0.470588, 0.0017301));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-0.8, -0.6, 0.005));
       allpoints.push(new PMPoint(-0.6, -0.8, 0.02));
       allpoints.push(new PMPoint(-0.689655, -0.724138, 0.000148633));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0, -1, 0.125));
       allpoints.push(new PMPoint(-0.6, -0.8, 0.02));
       allpoints.push(new PMPoint(-0.470588, -0.882353, 0.000432526));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0, -1, 0.125));
       allpoints.push(new PMPoint(0.6, -0.8, 0.02));
       allpoints.push(new PMPoint(0.470588, -0.882353, 0.000432526));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0.8, -0.6, 0.005));
       allpoints.push(new PMPoint(0.6, -0.8, 0.02));
       allpoints.push(new PMPoint(0.689655, -0.724138, 0.000148633));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0.8, -0.6, 0.005));
       allpoints.push(new PMPoint(0.923077, -0.384615, 0.000739645));
       allpoints.push(new PMPoint(0.882353, -0.470588, 0.0017301));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(1, 0, 0.5));
       allpoints.push(new PMPoint(0.923077, -0.384615, 0.000739645));
       allpoints.push(new PMPoint(0.96, -0.28, 0.0002));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(1, 0, 0.5));
       allpoints.push(new PMPoint(0.923077, 0.384615, 0.000739645));
       allpoints.push(new PMPoint(0.96, 0.28, 0.0002));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0.8, 0.6, 0.005));
       allpoints.push(new PMPoint(0.923077, 0.384615, 0.000739645));
       allpoints.push(new PMPoint(0.882353, 0.470588, 0.0017301));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0.8, 0.6, 0.005));
       allpoints.push(new PMPoint(0.6, 0.8, 0.02));
       allpoints.push(new PMPoint(0.689655, 0.724138, 0.000148633));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0, 1, 0.125));
       allpoints.push(new PMPoint(0.6, 0.8, 0.02));
       allpoints.push(new PMPoint(0.470588, 0.882353, 0.000432526));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0, 1, 0.125));
       allpoints.push(new PMPoint(-0.470588, 0.882353, 0.000432526));
       allpoints.push(new PMPoint(-0.384615, 0.923077, 0.00295858));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-0.6, 0.8, 0.02));
       allpoints.push(new PMPoint(-0.470588, 0.882353, 0.000432526));
       allpoints.push(new PMPoint(-0.528302, 0.849057, 4.44998e-05));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-0.6, 0.8, 0.02));
       allpoints.push(new PMPoint(-0.689655, 0.724138, 0.000148633));
       allpoints.push(new PMPoint(-0.657534, 0.753425, 2.34566e-05));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-0.8, 0.6, 0.005));
       allpoints.push(new PMPoint(-0.689655, 0.724138, 0.000148633));
       allpoints.push(new PMPoint(-0.724138, 0.689655, 0.00059453));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-0.8, 0.6, 0.005));
       allpoints.push(new PMPoint(-0.882353, 0.470588, 0.0017301));
       allpoints.push(new PMPoint(-0.861538, 0.507692, 2.95858e-05));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-0.923077, 0.384615, 0.000739645));
       allpoints.push(new PMPoint(-0.882353, 0.470588, 0.0017301));
       allpoints.push(new PMPoint(-0.898876, 0.438202, 1.57808e-05));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-0.923077, 0.384615, 0.000739645));
       allpoints.push(new PMPoint(-0.96, 0.28, 0.0002));
       allpoints.push(new PMPoint(-0.945946, 0.324324, 0.00036523));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-1, 0, 0.5));
       allpoints.push(new PMPoint(-0.96, 0.28, 0.0002));
       allpoints.push(new PMPoint(-0.97561, 0.219512, 7.43605e-05));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-1, 0, 0.5));
       allpoints.push(new PMPoint(-0.96, -0.28, 0.0002));
       allpoints.push(new PMPoint(-0.97561, -0.219512, 7.43605e-05));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-0.923077, -0.384615, 0.000739645));
       allpoints.push(new PMPoint(-0.96, -0.28, 0.0002));
       allpoints.push(new PMPoint(-0.945946, -0.324324, 0.00036523));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-0.923077, -0.384615, 0.000739645));
       allpoints.push(new PMPoint(-0.882353, -0.470588, 0.0017301));
       allpoints.push(new PMPoint(-0.898876, -0.438202, 1.57808e-05));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-0.8, -0.6, 0.005));
       allpoints.push(new PMPoint(-0.882353, -0.470588, 0.0017301));
       allpoints.push(new PMPoint(-0.861538, -0.507692, 2.95858e-05));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-0.8, -0.6, 0.005));
       allpoints.push(new PMPoint(-0.689655, -0.724138, 0.000148633));
       allpoints.push(new PMPoint(-0.724138, -0.689655, 0.00059453));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-0.6, -0.8, 0.02));
       allpoints.push(new PMPoint(-0.689655, -0.724138, 0.000148633));
       allpoints.push(new PMPoint(-0.657534, -0.753425, 2.34566e-05));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-0.6, -0.8, 0.02));
       allpoints.push(new PMPoint(-0.470588, -0.882353, 0.000432526));
       allpoints.push(new PMPoint(-0.528302, -0.849057, 4.44998e-05));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0, -1, 0.125));
       allpoints.push(new PMPoint(-0.470588, -0.882353, 0.000432526));
       allpoints.push(new PMPoint(-0.384615, -0.923077, 0.00295858));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0, -1, 0.125));
       allpoints.push(new PMPoint(0.470588, -0.882353, 0.000432526));
       allpoints.push(new PMPoint(0.384615, -0.923077, 0.00295858));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0.6, -0.8, 0.02));
       allpoints.push(new PMPoint(0.470588, -0.882353, 0.000432526));
       allpoints.push(new PMPoint(0.528302, -0.849057, 4.44998e-05));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0.6, -0.8, 0.02));
       allpoints.push(new PMPoint(0.689655, -0.724138, 0.000148633));
       allpoints.push(new PMPoint(0.657534, -0.753425, 2.34566e-05));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0.8, -0.6, 0.005));
       allpoints.push(new PMPoint(0.689655, -0.724138, 0.000148633));
       allpoints.push(new PMPoint(0.724138, -0.689655, 0.00059453));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0.8, -0.6, 0.005));
       allpoints.push(new PMPoint(0.882353, -0.470588, 0.0017301));
       allpoints.push(new PMPoint(0.861538, -0.507692, 2.95858e-05));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0.923077, -0.384615, 0.000739645));
       allpoints.push(new PMPoint(0.882353, -0.470588, 0.0017301));
       allpoints.push(new PMPoint(0.898876, -0.438202, 1.57808e-05));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0.923077, -0.384615, 0.000739645));
       allpoints.push(new PMPoint(0.96, -0.28, 0.0002));
       allpoints.push(new PMPoint(0.945946, -0.324324, 0.00036523));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(1, 0, 0.5));
       allpoints.push(new PMPoint(0.96, -0.28, 0.0002));
       allpoints.push(new PMPoint(0.97561, -0.219512, 7.43605e-05));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(1, 0, 0.5));
       allpoints.push(new PMPoint(0.96, 0.28, 0.0002));
       allpoints.push(new PMPoint(0.97561, 0.219512, 7.43605e-05));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0.923077, 0.384615, 0.000739645));
       allpoints.push(new PMPoint(0.96, 0.28, 0.0002));
       allpoints.push(new PMPoint(0.945946, 0.324324, 0.00036523));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0.923077, 0.384615, 0.000739645));
       allpoints.push(new PMPoint(0.882353, 0.470588, 0.0017301));
       allpoints.push(new PMPoint(0.898876, 0.438202, 1.57808e-05));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0.8, 0.6, 0.005));
       allpoints.push(new PMPoint(0.882353, 0.470588, 0.0017301));
       allpoints.push(new PMPoint(0.861538, 0.507692, 2.95858e-05));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0.8, 0.6, 0.005));
       allpoints.push(new PMPoint(0.689655, 0.724138, 0.000148633));
       allpoints.push(new PMPoint(0.724138, 0.689655, 0.00059453));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0.6, 0.8, 0.02));
       allpoints.push(new PMPoint(0.689655, 0.724138, 0.000148633));
       allpoints.push(new PMPoint(0.657534, 0.753425, 2.34566e-05));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0.6, 0.8, 0.02));
       allpoints.push(new PMPoint(0.470588, 0.882353, 0.000432526));
       allpoints.push(new PMPoint(0.528302, 0.849057, 4.44998e-05));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0, 1, 0.125));
       allpoints.push(new PMPoint(0.470588, 0.882353, 0.000432526));
       allpoints.push(new PMPoint(0.384615, 0.923077, 0.00295858));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0, 1, 0.125));
       allpoints.push(new PMPoint(-0.384615, 0.923077, 0.00295858));
       allpoints.push(new PMPoint(-0.324324, 0.945946, 9.13075e-05));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-0.470588, 0.882353, 0.000432526));
       allpoints.push(new PMPoint(-0.384615, 0.923077, 0.00295858));
       allpoints.push(new PMPoint(-0.423529, 0.905882, 1.7301e-05));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-0.470588, 0.882353, 0.000432526));
       allpoints.push(new PMPoint(-0.528302, 0.849057, 4.44998e-05));
       allpoints.push(new PMPoint(-0.507692, 0.861538, 0.000118343));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-0.6, 0.8, 0.02));
       allpoints.push(new PMPoint(-0.528302, 0.849057, 4.44998e-05));
       allpoints.push(new PMPoint(-0.550459, 0.834862, 1.0521e-05));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-0.6, 0.8, 0.02));
       allpoints.push(new PMPoint(-0.657534, 0.753425, 2.34566e-05));
       allpoints.push(new PMPoint(-0.642336, 0.766423, 0));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-0.689655, 0.724138, 0.000148633));
       allpoints.push(new PMPoint(-0.657534, 0.753425, 2.34566e-05));
       allpoints.push(new PMPoint(-0.670103, 0.742268, 5.31406e-05));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-0.689655, 0.724138, 0.000148633));
       allpoints.push(new PMPoint(-0.724138, 0.689655, 0.00059453));
       allpoints.push(new PMPoint(-0.710059, 0.704142, 0));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-0.8, 0.6, 0.005));
       allpoints.push(new PMPoint(-0.724138, 0.689655, 0.00059453));
       allpoints.push(new PMPoint(-0.742268, 0.670103, 1.32852e-05));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-0.8, 0.6, 0.005));
       allpoints.push(new PMPoint(-0.861538, 0.507692, 2.95858e-05));
       allpoints.push(new PMPoint(-0.849057, 0.528302, 0.000177999));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-0.882353, 0.470588, 0.0017301));
       allpoints.push(new PMPoint(-0.861538, 0.507692, 2.95858e-05));
       allpoints.push(new PMPoint(-0.870466, 0.492228, 0));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-0.882353, 0.470588, 0.0017301));
       allpoints.push(new PMPoint(-0.898876, 0.438202, 1.57808e-05));
       allpoints.push(new PMPoint(-0.892704, 0.450644, 0));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-0.923077, 0.384615, 0.000739645));
       allpoints.push(new PMPoint(-0.898876, 0.438202, 1.57808e-05));
       allpoints.push(new PMPoint(-0.905882, 0.423529, 6.92042e-05));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-0.923077, 0.384615, 0.000739645));
       allpoints.push(new PMPoint(-0.945946, 0.324324, 0.00036523));
       allpoints.push(new PMPoint(-0.939597, 0.342282, 0));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-0.96, 0.28, 0.0002));
       allpoints.push(new PMPoint(-0.945946, 0.324324, 0.00036523));
       allpoints.push(new PMPoint(-0.951351, 0.308108, 0));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-0.96, 0.28, 0.0002));
       allpoints.push(new PMPoint(-0.97561, 0.219512, 7.43605e-05));
       allpoints.push(new PMPoint(-0.969231, 0.246154, 0.000118343));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-1, 0, 0.5));
       allpoints.push(new PMPoint(-0.97561, 0.219512, 7.43605e-05));
       allpoints.push(new PMPoint(-0.983607, 0.180328, 3.35931e-05));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-1, 0, 0.5));
       allpoints.push(new PMPoint(-0.97561, -0.219512, 7.43605e-05));
       allpoints.push(new PMPoint(-0.983607, -0.180328, 3.35931e-05));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-0.96, -0.28, 0.0002));
       allpoints.push(new PMPoint(-0.97561, -0.219512, 7.43605e-05));
       allpoints.push(new PMPoint(-0.969231, -0.246154, 0.000118343));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-0.96, -0.28, 0.0002));
       allpoints.push(new PMPoint(-0.945946, -0.324324, 0.00036523));
       allpoints.push(new PMPoint(-0.951351, -0.308108, 0));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-0.923077, -0.384615, 0.000739645));
       allpoints.push(new PMPoint(-0.945946, -0.324324, 0.00036523));
       allpoints.push(new PMPoint(-0.939597, -0.342282, 0));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-0.923077, -0.384615, 0.000739645));
       allpoints.push(new PMPoint(-0.898876, -0.438202, 1.57808e-05));
       allpoints.push(new PMPoint(-0.905882, -0.423529, 6.92042e-05));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-0.882353, -0.470588, 0.0017301));
       allpoints.push(new PMPoint(-0.898876, -0.438202, 1.57808e-05));
       allpoints.push(new PMPoint(-0.892704, -0.450644, 0));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-0.882353, -0.470588, 0.0017301));
       allpoints.push(new PMPoint(-0.861538, -0.507692, 2.95858e-05));
       allpoints.push(new PMPoint(-0.870466, -0.492228, 0));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-0.8, -0.6, 0.005));
       allpoints.push(new PMPoint(-0.861538, -0.507692, 2.95858e-05));
       allpoints.push(new PMPoint(-0.849057, -0.528302, 0.000177999));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-0.8, -0.6, 0.005));
       allpoints.push(new PMPoint(-0.724138, -0.689655, 0.00059453));
       allpoints.push(new PMPoint(-0.742268, -0.670103, 1.32852e-05));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-0.689655, -0.724138, 0.000148633));
       allpoints.push(new PMPoint(-0.724138, -0.689655, 0.00059453));
       allpoints.push(new PMPoint(-0.710059, -0.704142, 0));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-0.689655, -0.724138, 0.000148633));
       allpoints.push(new PMPoint(-0.657534, -0.753425, 2.34566e-05));
       allpoints.push(new PMPoint(-0.670103, -0.742268, 5.31406e-05));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-0.6, -0.8, 0.02));
       allpoints.push(new PMPoint(-0.657534, -0.753425, 2.34566e-05));
       allpoints.push(new PMPoint(-0.642336, -0.766423, 0));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-0.6, -0.8, 0.02));
       allpoints.push(new PMPoint(-0.528302, -0.849057, 4.44998e-05));
       allpoints.push(new PMPoint(-0.550459, -0.834862, 1.0521e-05));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-0.470588, -0.882353, 0.000432526));
       allpoints.push(new PMPoint(-0.528302, -0.849057, 4.44998e-05));
       allpoints.push(new PMPoint(-0.507692, -0.861538, 0.000118343));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-0.470588, -0.882353, 0.000432526));
       allpoints.push(new PMPoint(-0.384615, -0.923077, 0.00295858));
       allpoints.push(new PMPoint(-0.423529, -0.905882, 1.7301e-05));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0, -1, 0.125));
       allpoints.push(new PMPoint(-0.384615, -0.923077, 0.00295858));
       allpoints.push(new PMPoint(-0.324324, -0.945946, 9.13075e-05));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
    // COMMON_CODE_BLOCK_BEGIN
    var xRotationEnabled = false;
    var yRotationEnabled = false;
    var zRotationEnabled = false;
    var rotationSpeedFactor = 1;
    var settingsShown = false;
    var labelsShown = true;
    var intervals = [];
    var timeouts = [];
    var explodingSpeed = 0.05;
    var explodeScale = 0;
    var XMLS = new XMLSerializer();
    var svgElement;
    var renderId;
    
    	var render = function () {
    
    		renderId = requestAnimationFrame(render);
    
    //		comment in for automatic explosion
    //		explode(updateFactor());
    
    		var phi = 0.02 * rotationSpeedFactor;
    
    		if (xRotationEnabled){
    			scene.rotation.x += phi;
    		}
    		if(yRotationEnabled){
    			scene.rotation.y += phi;
    		}
    		if(zRotationEnabled){
    			scene.rotation.z += phi;
    		}
    
    		controls.update();
    		renderer.render(scene, camera);
    	};
    
    	render();
    
    	function computeCentroid(geom) {
    		centroid = new THREE.Vector3();
    		geom.vertices.forEach(function(v) {
    			centroid.add(v);			
    		});
    		centroid.divideScalar(geom.vertices.length);
    		return centroid;
    	}
    
    	function changeTransparency(event){
    		var opacity = 1-Number(event.currentTarget.value);
    		for (var i=0; i<all_objects.length; i++){
    			for (var j=0; j<all_objects[i].children.length; j++){
    				if (all_objects[i].children[j].material.type == "MultiMaterial") {
    					for (var k=0; k<all_objects[i].children[j].material.materials.length; k++){
    						all_objects[i].children[j].material.materials[k].opacity = opacity;
    						all_objects[i].children[j].material.materials[k].depthWrite = opacity < 0.5 ? false : true;
    						all_objects[i].children[j].material.materials[k].depthTest = opacity < 0.5 ? false : true;
    					}
    				} else if (all_objects[i].children[j].material.transparent && 
    							  all_objects[i].children[j].material.type == "MeshBasicMaterial" &&
    							  all_objects[i].children[j].geometry.type == "Geometry"){
    					all_objects[i].children[j].material.opacity = opacity;
    					all_objects[i].children[j].material.depthWrite = opacity < 0.5 ? false : true;
    					all_objects[i].children[j].material.depthTest = opacity < 0.5 ? false : true;
    				}
    			}
    		}
    	}
    
    	function changeRotationX(event){
    		xRotationEnabled = event.currentTarget.checked;
    	}	
    
    	function changeRotationY(event){
    		yRotationEnabled = event.currentTarget.checked;
    	}	
    
    	function changeRotationZ(event){
    		zRotationEnabled = event.currentTarget.checked;
    	}	
    
    
    	function changeRotationSpeedFactor(event){
    		rotationSpeedFactor = Number(event.currentTarget.value);
    	}
    
    	function resetScene(){
    		scene.rotation.set(0,0,0);
    		camera.position.set(0,0,5);
    		camera.up.set(0,1,0);
    	}
    
    	function showSettings(event){
    		event.currentTarget.style.display = 'none';
    		document.getElementById('settings_3').style.position = 'absolute';
    		document.getElementById('settings_3').style.display = 'block';
    		document.getElementById('showSettingsButton_3').style.display = 'none';
    		document.getElementById('hideSettingsButton_3').style.display = 'block';
    		settingsShown = true;
    	}
    
    	function hideSettings(event){
    		event.currentTarget.style.display = 'none';
    		document.getElementById('settings_3').style.display = 'none';
    		document.getElementById('hideSettingsButton_3').style.display = 'none';
    		document.getElementById('showSettingsButton_3').style.display = 'block';
    		settingsShown = false;
    	}
    
    
    
    	var pos = 150* Math.PI;
    
    	function updateFactor() {
    		pos++;
    		return Math.sin(.01*pos)+1;
    	}
    
    	function makelabel(message, x, y, z, params) {
    		var spritey = textSprite( message, params );
    		spritey.position.set(x, y, z);
    		obj.add(spritey);
    	}
    
    	function textSprite(message, parameters)
    	{
    		if ( parameters === undefined ) parameters = {};
    
    		var fontface = "Helvetica";
    
    		var fontsize = parameters.hasOwnProperty("fontsize") ? 
    			parameters["fontsize"] : 18;
    		fontsize = fontsize*10;
    
    		var canvas = document.createElement('canvas');
    		var size = 1024;
    		canvas.width = size;
    		canvas.height = size;
    		var context = canvas.getContext('2d');
    		context.font = fontsize + "px " + fontface;
    
    		// text color
    		context.fillStyle = "rgba(0, 0, 0, 1.0)";
    
    		context.fillText(message, size/2, size/2);
    
    		// canvas contents will be used for a texture
    		var texture = new THREE.Texture(canvas);
    		texture.needsUpdate = true;
    
    		var spriteMaterial = new THREE.SpriteMaterial(
    			{map: texture, useScreenCoordinates: false});
    		var sprite = new THREE.Sprite(spriteMaterial);
    		return sprite;
    	}
    
    	function takeSvgScreenshot(){
    		if (labelsShown){
    			hideLabels();
    		}
    		svgRenderer.render(scene,camera);
    		svgElement = XMLS.serializeToString(svgRenderer.domElement);
    		
    		if (labelsShown){
    			displayLabels();
    		}
    
    		if (document.getElementById('tab_3').checked){
    			//show in new tab
    			var myWindow = window.open("","");
    			myWindow.document.body.innerHTML = svgElement;
    		} else{
    			// download svg file 
    			download("screenshot.svg", svgElement);
    		}
    	}
    		
    
    	function showOrHideObject(event){
    		var nr = Number(event.currentTarget.name);
    		all_objects[nr].visible = event.currentTarget.checked;
    	}
    
    
    	function displayOrHideOptions(){
    		for (var i=0; i<all_objects.length; i++){
    			for (var j=0; j<all_objects[i].children.length; j++){
    				if (all_objects[i].children[j].material.type == "MultiMaterial") {
    					for (var k=0; k<all_objects[i].children[j].material.materials.length; k++){
    						if (all_objects[i].children[j].material.materials[k].transparent) {
    							document.getElementById('transparency_3').style.display = 'block';
    							document.getElementById('transparencyRange_3').value = 1 - 
    							    all_objects[i].children[j].material.materials[k].opacity;
    							return;
    						}
    					}
    				} else if (all_objects[i].children[j].material.transparent && 
    							  all_objects[i].children[j].material.type == "MeshBasicMaterial" &&
    							  all_objects[i].children[j].geometry.type == "Geometry"){
    					document.getElementById('transparency_3').style.display = 'block';
    					return;
    				}
    			}
    		}
    	}
    
    	displayOrHideOptions()
    
    
    
    
    // ---------------------- EXPLOSION ------------------------------------------------
    // ---------------------------------------------------------------------------------
    
    	function explode(factor) {
    		var obj, c;
    		var c0 = centroids[0];
    		for (var i = 0; i<centroids.length; ++i) {
    			c = centroids[i];
    			obj = all_objects[all_objects.length - centroids.length + i];
    			obj.position.set(c.x*factor, c.y*factor, c.z*factor);
    		}	
    	}
    
    	function triggerExplode(event){
    		explodeScale = Number(event.currentTarget.value);
    		explode(explodeScale);
    	}
    
    	function setExplodingSpeed(event){
    		explodingSpeed = Number(event.currentTarget.value);
    	}
    
    	function triggerAutomaticExplode(event){
    		if (event.currentTarget.checked){
    			startExploding();
    		} else {
    			clearIntervals();
    		}	
    	}
    
    	function startExploding(){
    		intervals.push(setInterval(explodingInterval, 25));
    	}
    
    
    	function explodingInterval(){
    		explodeScale += explodingSpeed;
    		if (explodeScale <= 6){ 
    			explode(explodeScale);
    		}
    		else{
    			explode(6);
    			explodeScale = 6;
    			clearIntervals();
    			timeouts.push(setTimeout(startUnexploding, 3000));
    		}
    		document.getElementById('explodeRange_3').value = explodeScale;
    	}
    
    
    	function startUnexploding(){
    		intervals.push(setInterval(unexplodingInterval, 25));
    	}
    
    	function unexplodingInterval(){
    		explodeScale -= explodingSpeed;
    		if (explodeScale >= 0){	
    			explode(explodeScale);
    		}
    		else {
    			explode(0);
    			explodeScale = 0;
    			clearIntervals();
    			timeouts.push(setTimeout(startExploding, 3000));
    		}
    		document.getElementById('explodeRange_3').value = explodeScale;
    	}
    
    	function clearIntervals(){
    		intervals.forEach(function(interval){
    			clearInterval(interval);
    		});
    		intervals = [];
    		timeouts.forEach(function(timeout){
    			clearTimeout(timeout);
    		});
    		timeouts = [];
    	}
    
    			
    
    	// append checkboxes for displaying or hiding objects
    	var shownObjectsList = document.getElementById('shownObjectsList_3');
    	for (var i=0; i<all_objects.length; i++){
    		var objNode = document.createElement('span');
    		objNode.innerHTML = objectnames[i] + '<br>';
    		var checkbox = document.createElement('input');
    		checkbox.type = 'checkbox';
    		checkbox.checked = true;
    		checkbox.name = String(i);
    		checkbox.onchange = showOrHideObject;
    		shownObjectsList.appendChild(checkbox);
    		shownObjectsList.appendChild(objNode);
    	}
    
    	function displayLabels(){
    		for (var i=0; i<all_objects.length; i++){
    			for (var j=0; j<all_objects[i].children.length; j++){
    				var child = all_objects[i].children[j];
    				if (child.type == 'Sprite'){
    					child.visible = true;
    				}
    			}
    		}
    	}
    
    	function hideLabels(){
    		for (var i=0; i<all_objects.length; i++){
    			for (var j=0; j<all_objects[i].children.length; j++){
    				var child = all_objects[i].children[j];
    				if (child.type == 'Sprite'){
    					child.visible = false;
    				}
    			}
    		}
    	}
    
    	function displayOrHideLabels(event){
    		if (event.currentTarget.checked){
    			displayLabels();
    			labelsShown = true;
    		} else {
    			hideLabels();
    			labelsShown = false;
    		}
    	}
    
    	function download(filename, text) {
    	  var element = document.createElement('a');
    	  element.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(text));
    	  element.setAttribute('download', filename);
    
    	  element.style.display = 'none';
    	  document.body.appendChild(element);
    
    	  element.click();
    
    	  document.body.removeChild(element);
    	}
    
    var tempobj;
    tempobj = document.getElementById('explodeRange_3');
    if (tempobj) {
       tempobj.oninput = triggerExplode;
       document.getElementById('explodeCheckbox_3').onchange = triggerAutomaticExplode;
       document.getElementById('explodingSpeedRange_3').oninput = setExplodingSpeed;
    }
    tempobj = document.getElementById('foldRange_3');
    if (tempobj) {
       tempobj.oninput = fold;
    }
    document.getElementById('transparencyRange_3').oninput = changeTransparency;
    document.getElementById('changeRotationX_3').onchange = changeRotationX;
    document.getElementById('changeRotationY_3').onchange = changeRotationY;
    document.getElementById('changeRotationZ_3').onchange = changeRotationZ;
    document.getElementById('resetButton_3').onclick = resetScene;
    document.getElementById('rotationSpeedRange_3').oninput = changeRotationSpeedFactor;
    document.getElementById('labelsCheckboxInput_3').onchange = displayOrHideLabels;
    document.getElementById('takeScreenshot_3').onclick = takeSvgScreenshot;
    document.getElementById('showSettingsButton_3').onclick = showSettings;
    document.getElementById('hideSettingsButton_3').onclick = hideSettings;
    
    	
    
    // ------------------ SHORTCUTS --------------------------------------------
    // -------------------------------------------------------------------------
    
    /**
     * http://www.openjs.com/scripts/events/keyboard_shortcuts/
     * Version : 2.01.B
     * By Binny V A
     * License : BSD
     */
    shortcut = {
    	'all_shortcuts':{},//All the shortcuts are stored in this array
    	'add': function(shortcut_combination,callback,opt) {
    		//Provide a set of default options
    		var default_options = {
    			'type':'keydown',
    			'propagate':false,
    			'disable_in_input':false,
    			'target':document,
    			'keycode':false
    		}
    		if(!opt) opt = default_options;
    		else {
    			for(var dfo in default_options) {
    				if(typeof opt[dfo] == 'undefined') opt[dfo] = default_options[dfo];
    			}
    		}
    
    		var ele = opt.target;
    		if(typeof opt.target == 'string') ele = document.getElementById(opt.target);
    		var ths = this;
    		shortcut_combination = shortcut_combination.toLowerCase();
    
    		//The function to be called at keypress
    		var func = function(e) {
    			e = e || window.event;
    			
    			if(opt['disable_in_input']) { //Don't enable shortcut keys in Input, Textarea fields
    				var element;
    				if(e.target) element=e.target;
    				else if(e.srcElement) element=e.srcElement;
    				if(element.nodeType==3) element=element.parentNode;
    
    				if(element.tagName == 'INPUT' || element.tagName == 'TEXTAREA') return;
    			}
    	
    			//Find Which key is pressed
    			if (e.keyCode) code = e.keyCode;
    			else if (e.which) code = e.which;
    			var character = String.fromCharCode(code).toLowerCase();
    			
    			if(code == 188) character=","; //If the user presses , when the type is onkeydown
    			if(code == 190) character="."; //If the user presses , when the type is onkeydown
    
    			var keys = shortcut_combination.split("+");
    			//Key Pressed - counts the number of valid keypresses - if it is same as the number of keys, the shortcut function is invoked
    			var kp = 0;
    			
    			//Work around for stupid Shift key bug created by using lowercase - as a result the shift+num combination was broken
    			var shift_nums = {
    				"`":"~",
    				"1":"!",
    				"2":"@",
    				"3":"#",
    				"4":"$",
    				"5":"%",
    				"6":"^",
    				"7":"&",
    				"8":"*",
    				"9":"(",
    				"0":")",
    				"-":"_",
    				"=":"+",
    				";":":",
    				"'":"\"",
    				",":"<",
    				".":">",
    				"/":"?",
    				"\\":"|"
    			}
    			//Special Keys - and their codes
    			var special_keys = {
    				'esc':27,
    				'escape':27,
    				'tab':9,
    				'space':32,
    				'return':13,
    				'enter':13,
    				'backspace':8,
    	
    				'scrolllock':145,
    				'scroll_lock':145,
    				'scroll':145,
    				'capslock':20,
    				'caps_lock':20,
    				'caps':20,
    				'numlock':144,
    				'num_lock':144,
    				'num':144,
    				
    				'pause':19,
    				'break':19,
    				
    				'insert':45,
    				'home':36,
    				'delete':46,
    				'end':35,
    				
    				'pageup':33,
    				'page_up':33,
    				'pu':33,
    	
    				'pagedown':34,
    				'page_down':34,
    				'pd':34,
    	
    				'left':37,
    				'up':38,
    				'right':39,
    				'down':40,
    	
    				'f1':112,
    				'f2':113,
    				'f3':114,
    				'f4':115,
    				'f5':116,
    				'f6':117,
    				'f7':118,
    				'f8':119,
    				'f9':120,
    				'f10':121,
    				'f11':122,
    				'f12':123
    			}
    	
    			var modifiers = { 
    				shift: { wanted:false, pressed:false},
    				ctrl : { wanted:false, pressed:false},
    				alt  : { wanted:false, pressed:false},
    				meta : { wanted:false, pressed:false}	//Meta is Mac specific
    			};
                            
    			if(e.ctrlKey)	modifiers.ctrl.pressed = true;
    			if(e.shiftKey)	modifiers.shift.pressed = true;
    			if(e.altKey)	modifiers.alt.pressed = true;
    			if(e.metaKey)   modifiers.meta.pressed = true;
                            
    			for(var i=0; k=keys[i],i<keys.length; i++) {
    				//Modifiers
    				if(k == 'ctrl' || k == 'control') {
    					kp++;
    					modifiers.ctrl.wanted = true;
    
    				} else if(k == 'shift') {
    					kp++;
    					modifiers.shift.wanted = true;
    
    				} else if(k == 'alt') {
    					kp++;
    					modifiers.alt.wanted = true;
    				} else if(k == 'meta') {
    					kp++;
    					modifiers.meta.wanted = true;
    				} else if(k.length > 1) { //If it is a special key
    					if(special_keys[k] == code) kp++;
    					
    				} else if(opt['keycode']) {
    					if(opt['keycode'] == code) kp++;
    
    				} else { //The special keys did not match
    					if(character == k) kp++;
    					else {
    						if(shift_nums[character] && e.shiftKey) { //Stupid Shift key bug created by using lowercase
    							character = shift_nums[character]; 
    							if(character == k) kp++;
    						}
    					}
    				}
    			}
    			
    			if(kp == keys.length && 
    						modifiers.ctrl.pressed == modifiers.ctrl.wanted &&
    						modifiers.shift.pressed == modifiers.shift.wanted &&
    						modifiers.alt.pressed == modifiers.alt.wanted &&
    						modifiers.meta.pressed == modifiers.meta.wanted) {
    				callback(e);
    	
    				if(!opt['propagate']) { //Stop the event
    					//e.cancelBubble is supported by IE - this will kill the bubbling process.
    					e.cancelBubble = true;
    					e.returnValue = false;
    	
    					//e.stopPropagation works in Firefox.
    					if (e.stopPropagation) {
    						e.stopPropagation();
    						e.preventDefault();
    					}
    					return false;
    				}
    			}
    		}
    		this.all_shortcuts[shortcut_combination] = {
    			'callback':func, 
    			'target':ele, 
    			'event': opt['type']
    		};
    		//Attach the function with the event
    		if(ele.addEventListener) ele.addEventListener(opt['type'], func, false);
    		else if(ele.attachEvent) ele.attachEvent('on'+opt['type'], func);
    		else ele['on'+opt['type']] = func;
    	},
    
    	//Remove the shortcut - just specify the shortcut and I will remove the binding
    	'remove':function(shortcut_combination) {
    		shortcut_combination = shortcut_combination.toLowerCase();
    		var binding = this.all_shortcuts[shortcut_combination];
    		delete(this.all_shortcuts[shortcut_combination])
    		if(!binding) return;
    		var type = binding['event'];
    		var ele = binding['target'];
    		var callback = binding['callback'];
    
    		if(ele.detachEvent) ele.detachEvent('on'+type, callback);
    		else if(ele.removeEventListener) ele.removeEventListener(type, callback, false);
    		else ele['on'+type] = false;
    	}
    }
    
    shortcut.add("Alt+Left",function() {
    	var event = new Event('click');
    	if (settingsShown){
    		document.getElementById('hideSettingsButton_3').dispatchEvent(event);
    	} else{
    		document.getElementById('showSettingsButton_3').dispatchEvent(event);
    	}
    });
    
    if (foldable) moveToBaryCenter();
    
    
    });});
    // COMMON_CODE_BLOCK_END
    </script>
    
    </body>
    </html>



Example 2: a hyperbolic torus with three cusps
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


.. link

.. CODE-BLOCK:: perl

    polymake> $T3 = new Array<Array<Int>>([[1,0,2,17],[2,1,4,14],[0,2,0,6],[1,2,8,16],[0,1,5,10],[2,1,12,1],[0,2,9,3],[0,1,13,7],[0,2,15,11]]);
    polymake> $s = new HyperbolicSurface(DCEL_DATA=>$T3, PENNER_COORDINATES=>[2,1,1,1,1,1,1,1,1], SPECIAL_POINT=>[1,0]);

.. figure:: attachment:Paper.Skizzen.3%281%29.png
   :alt: Paper.Skizzen.3%281%29.png

   Paper.Skizzen.3%281%29.png


.. link

.. CODE-BLOCK:: perl

    polymake> $f = $s->SECONDARY_FAN;
    polymake> $f->VISUAL;


.. raw:: html

    <!--
    polymake for loewe
    Fri Feb  9 13:50:17 2018
    fan:
    -->
    
    
    <html>
       <head>
          <title>fan:</title>
          <style>
    /*
    // COMMON_CODE_BLOCK_BEGIN
    */
             html{overflow: scroll;}
             body { font-family: Arial, Helvetica, sans-serif}
             strong{font-size: 18px;}
             canvas { z-index: 8; }
             input[type='range'] {}
             input[type='radio'] {margin-left:0;}
             input[type='checkbox'] {margin-right:7px; margin-left: 0px; padding-left:0px;}
             .group{padding-bottom: 40px;}
             .settings * {z-index: 11; }
             .settings{z-index: 10; margin-left: 30px; display: none; width: 14em; height: 90%; border: solid 1px silver; padding: 2px; overflow-y: scroll; background-color: white }
             .indented{margin-left: 20px; margin-top: 15px; padding-bottom: 0px;} 
             .shownObjectsList{overflow: auto; max-width: 150px; max-height: 150px;}
             .showSettingsButton{display: block; z-index: 12; position: absolute }
             .hideSettingsButton{display: none; z-index: 12; position: absolute; opacity: 0.5}
             .resetButton{margin-top: 20px;}
             button{margin-left: 0;}
             img{cursor: pointer;}
             .suboption{padding-top: 30px;}
             .transparency{display: none;}
             .labelsCheckbox{margin-top: 10px;}
    
    
             input[type=range] {
               -webkit-appearance: none;
               padding:0; 
               width:90%; 
               margin-left: auto;
               margin-right: auto;
               margin-top: 20px;
               display: block;	
             }
             input[type=range]:focus {
               outline: none;
             }
             input[type=range]::-webkit-slider-runnable-track {
               height: 4px;
               cursor: pointer;
               animate: 0.2s;
               box-shadow: 0px 0px 0px #000000;
               background: #E3E3E3;
               border-radius: 0px;
               border: 0px solid #000000;
             }
             input[type=range]::-webkit-slider-thumb {
               box-shadow: 1px 1px 2px #B8B8B8;
               border: 1px solid #ABABAB;
               height: 13px;
               width: 25px;
               border-radius: 20px;
               background: #E0E0E0;
               cursor: pointer;
               -webkit-appearance: none;
               margin-top: -5px;
             }
             input[type=range]:focus::-webkit-slider-runnable-track {
               background: #E3E3E3;
             }
             input[type=range]::-moz-range-track {
               height: 4px;
               cursor: pointer;
               animate: 0.2s;
               box-shadow: 0px 0px 0px #000000;
               background: #E3E3E3;
               border-radius: 0px;
               border: 0px solid #000000;
             }
             input[type=range]::-moz-range-thumb {
               box-shadow: 1px 1px 2px #B8B8B8;
               border: 1px solid #ABABAB;
               height: 13px;
               width: 25px;
               border-radius: 20px;
               background: #E0E0E0;
               cursor: pointer;
             }
             input[type=range]::-ms-track {
               height: 4px;
               cursor: pointer;
               animate: 0.2s;
               background: transparent;
               border-color: transparent;
               color: transparent;
             }
             input[type=range]::-ms-fill-lower {
               background: #E3E3E3;
               border: 0px solid #000000;
               border-radius: 0px;
               box-shadow: 0px 0px 0px #000000;
             }
             input[type=range]::-ms-fill-upper {
               background: #E3E3E3;
               border: 0px solid #000000;
               border-radius: 0px;
               box-shadow: 0px 0px 0px #000000;
             }
             input[type=range]::-ms-thumb {
               box-shadow: 1px 1px 2px #B8B8B8;
               border: 1px solid #ABABAB;
               height: 13px;
               width: 25px;
               border-radius: 20px;
               background: #E0E0E0;
               cursor: pointer;
             }
             input[type=range]:focus::-ms-fill-lower {
               background: #E3E3E3;
             }
             input[type=range]:focus::-ms-fill-upper {
               background: #E3E3E3;
             }
    /*
    // COMMON_CODE_BLOCK_END
    */
    		</style>
       </head>
    
    <body>
    
    		<div id='settings_4' class='settings'>
    			<div class=group id='explode_4'>
    				<strong>Explode</strong>
    				<input id='explodeRange_4' type='range' min=0 max=6 step=0.01 value=0>
    				<div class=indented><input id='explodeCheckbox_4' type='checkbox'>Automatic explosion</div>
    				<div class=suboption>Exploding speed</div>
    				<input id='explodingSpeedRange_4' type='range' min=0 max=0.5 step=0.001 value=0.05>
    			</div>
    
    			
    			<div class=group id='transparency_4' class='transparency'>
    				<strong>Transparency</strong>
    				<input id='transparencyRange_4' type='range' min=0 max=1 step=0.01 value=0>
    			</div>
    			
    			<div class=group id='rotation_4'>
    				<strong>Rotation</strong>
    				<div class=indented>
    					<div><input type='checkbox' id='changeRotationX_4'> x-axis</div>
    					<div><input type='checkbox' id='changeRotationY_4'> y-axis</div>
    					<div><input type='checkbox' id='changeRotationZ_4'> z-axis</div>
    					<button id='resetButton_4' class='resetButton' >Reset</button>
    				</div>
    
    				<div class=suboption>Rotation speed</div>
    				<input id='rotationSpeedRange_4' type='range' min=0 max=5 step=0.01 value=2>
    
    			</div>
    
    
    			<div class=group id='display_4'>
    				<strong>Display</strong>
    				<div class=indented>
    					<div id='shownObjectsList_4' class='shownObjectsList'></div>
    					<div class='labelsCheckbox'><input type='checkbox' id='labelsCheckboxInput_4' checked>Labels</div>
    				</div>
    			</div>
    
    
    			<div class=group id='svg_4'>
    				<strong>SVG</strong>
    				<div class=indented>
    					<form>
    						<input type="radio" name='screenshotMode' value='download' id='download_4' checked> Download<br>
    						<input type="radio" name='screenshotMode' value='tab' id='tab_4' > New tab<br>
    					</form>
    					<button id='takeScreenshot_4'>Screenshot</button>
    				</div>
    			</div>
    
    		</div>	<!-- end of settings -->
    		<img id='hideSettingsButton_4' style="display: none" class='hideSettingsButton' src='/kernelspecs/polymake/close.svg' width=20px">
    		<img id='showSettingsButton_4' class='showSettingsButton' src='/kernelspecs/polymake/menu.svg' width=20px">
    <div id="model68443205616"></div>
    
    <script>
    requirejs.config({
      paths: {
        three: '/kernelspecs/polymake/three',
        Detector: '/kernelspecs/polymake/Detector',
        SVGRenderer: '/kernelspecs/polymake/SVGRenderer',
        CanvasRenderer: '/kernelspecs/polymake/CanvasRenderer',
        Projector: '/kernelspecs/polymake/Projector',
        TrackballControls: '/kernelspecs/polymake/TrackballControls'
      },
      shim: {
        'three':
        {
          exports: 'THREE'
        },
        'Detector':
        {
          deps: [ 'three' ],
          exports: 'Detector'
        },
        'SVGRenderer':
        {
          deps: [ 'three' ],
          exports: 'THREE.SVGRenderer'
        },
        'CanvasRenderer':
        {
          deps: [ 'three' ],
          exports: 'THREE.CanvasRenderer'
        },
        'Projector':
        {
          deps: [ 'three' ],
          exports: 'THREE.Projector'
        },
        'TrackballControls':
        {
          deps: [ 'three' ],
          exports: 'THREE.TrackballControls'
        }
      }
    });
    require(['three'],function(THREE){
        window.THREE = THREE;
      require(['Detector','SVGRenderer','CanvasRenderer','Projector','TrackballControls'],function(Detector,SVGRenderer,CanvasRenderer,Projector,TrackballControls){
          THREE.SVGRenderer = SVGRenderer;
          THREE.CanvasRenderer = CanvasRenderer;
          THREE.Projector = Projector;
          THREE.TrackballControls = TrackballControls;
    
    // COMMON_CODE_BLOCK_BEGIN
    	var foldable = false;
       var container = document.getElementById( 'model68443205616' );
       var renderer = Detector.webgl? new THREE.WebGLRenderer({antialias: true}): new THREE.CanvasRenderer({antialias: true});
    	var svgRenderer = new THREE.SVGRenderer({antialias: true});
                var box = document.getElementsByClassName( 'output_subarea' )[0];
             var notebook = document.getElementById( 'notebook_panel' );
    
       var width = box.clientWidth - 25;
       var height = notebook.clientHeight * 0.8;
       renderer.setSize(width, height);
       svgRenderer.setSize(width, height);
       renderer.setClearColor(0xFFFFFF, 1);
       svgRenderer.setClearColor(0xFFFFFF, 1);
    
       container.appendChild(renderer.domElement);
    
       var scene = new THREE.Scene();
       var camera = new THREE.PerspectiveCamera(75, width/height, 0.1, 1000);
    
       var renderid;
    
       camera.position.set(0, 0, 5);
       camera.lookAt(0, 0, 0);
       camera.up.set(0, 1, 0);
    
       // class to allow move points together with labels and spheres
       var PMPoint = function (x,y,z) {
          this.vector = new THREE.Vector3(x,y,z);
          this.sprite = null;
          this.sphere = null;
       }
       PMPoint.prototype.makelabel = function(label) {
          this.sprite = textSprite( label );
          this.sprite.position.copy(this.vector);
       }
       PMPoint.prototype.makesphere = function(radius,material) {
          this.sphere = new THREE.Mesh(new THREE.SphereGeometry(radius), material);
          this.sphere.position.copy(this.vector);
       }
    
       PMPoint.prototype.setX = function(x) {
          this.vector.setX(x);
          if (this.sprite) {
             this.sprite.position.setX(x);
          }
          if (this.sphere) {
             this.sphere.position.setX(x);
          }
       };
       PMPoint.prototype.setY = function(y) {
          this.vector.setY(y);
          if (this.sprite) {
             this.sprite.position.setY(y);
          }
          if (this.sphere) {
             this.sphere.position.setY(y);
          }
       };
       PMPoint.prototype.setZ = function(z) {
          this.vector.setZ(z);
          if (this.sprite) {
             this.sprite.position.setZ(z);
          }
          if (this.sphere) {
             this.sphere.position.setZ(z);
          }
       };
       PMPoint.prototype.set = function(x,y,z) {
          this.vector.set(x,y,z);
          if (this.sprite) {
             this.sprite.position.set(x,y,z);
          }
          if (this.sphere) {
             this.sphere.position.set(x,y,z);
          }
       };
       PMPoint.prototype.add = function(o) {
          if (this.sprite) {
             o.add(this.sprite);
          }
          if (this.sphere) {
             o.add(this.sphere);
          }
       };
    
    
       var controls = new THREE.TrackballControls(camera, container);
    	controls.zoomSpeed = 0.2;
    	controls.rotateSpeed = 4;
    
       var all_objects = [];
       var centroids = [];
       // select the target node
       var target = document.querySelector('#model68443205616');
    
       // create an observer instance
       var observer = new MutationObserver(function(mutations) {
          mutations.forEach(function(mutation) {
             if (mutation.removedNodes && mutation.removedNodes.length > 0) {
                cancelAnimationFrame(renderId);
                observer.disconnect();
                console.log("cancelled frame "+renderId);
             }
          });
       });
    
       // configuration of the observer:
       var config = { childList: true, characterData: true }
    
       // pass in the target node, as well as the observer options
       while (target) {
          if (target.className=="output") {
             observer.observe(target, config);
             break;
          }
          target = target.parentNode;
       }
    
    // COMMON_CODE_BLOCK_END
    
       var objectnames = ["Rays","unnamed__1","unnamed__2","unnamed__3","unnamed__4","unnamed__5","unnamed__6","unnamed__7","unnamed__8","unnamed__9","unnamed__10","unnamed__11","unnamed__12","unnamed__13"];
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0, 0, 0));
       allpoints.push(new PMPoint(0, 0.529999, 0.847998));
       allpoints.push(new PMPoint(0.451039, 0.751731, 0.481108));
       allpoints.push(new PMPoint(0.529999, 0, 0.847998));
       allpoints.push(new PMPoint(0.751731, 0.451039, 0.481108));
       allpoints.push(new PMPoint(0.707107, 0.707107, 0));
       allpoints.push(new PMPoint(0.846499, 0.282166, 0.451466));
       allpoints.push(new PMPoint(0, 0, 1));
       allpoints.push(new PMPoint(0.282166, 0.846499, 0.451466));
       allpoints.push(new PMPoint(0.882353, 0, 0.470588));
       allpoints.push(new PMPoint(0, 0.882353, 0.470588));
       allpoints.push(new PMPoint(0.948683, 0.316228, 0));
       allpoints.push(new PMPoint(0.316228, 0.948683, 0));
       allpoints.push(new PMPoint(1, 0, 0));
       allpoints.push(new PMPoint(0, 1, 0));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
       allpoints[3].makesphere(0.02,points_material);
       allpoints[4].makesphere(0.02,points_material);
       allpoints[5].makesphere(0.02,points_material);
       allpoints[6].makesphere(0.02,points_material);
       allpoints[7].makesphere(0.02,points_material);
       allpoints[8].makesphere(0.02,points_material);
       allpoints[9].makesphere(0.02,points_material);
       allpoints[10].makesphere(0.02,points_material);
       allpoints[11].makesphere(0.02,points_material);
       allpoints[12].makesphere(0.02,points_material);
       allpoints[13].makesphere(0.02,points_material);
       allpoints[14].makesphere(0.02,points_material);
       allpoints[0].makelabel(" ");
       allpoints[1].makelabel("0");
       allpoints[2].makelabel("1");
       allpoints[3].makelabel("2");
       allpoints[4].makelabel("3");
       allpoints[5].makelabel("4");
       allpoints[6].makelabel("5");
       allpoints[7].makelabel("6");
       allpoints[8].makelabel("7");
       allpoints[9].makelabel("8");
       allpoints[10].makelabel("9");
       allpoints[11].makelabel("10");
       allpoints[12].makelabel("11");
       allpoints[13].makelabel("12");
       allpoints[14].makelabel("13");
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES -->
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[4].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[5].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[6].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[7].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[8].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[9].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[10].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[11].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[12].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[13].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[14].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0, 0.529999, 0.847998));
       allpoints.push(new PMPoint(0.451039, 0.751731, 0.481108));
       allpoints.push(new PMPoint(0.529999, 0, 0.847998));
       allpoints.push(new PMPoint(0.751731, 0.451039, 0.481108));
       allpoints.push(new PMPoint(0, 0, 0));
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
       faces.vertices.push(allpoints[3].vector);
       faces.vertices.push(allpoints[4].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var materials = [
          new THREE.MeshBasicMaterial({ transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, color: 0x77EC9E, }),
          new THREE.MeshBasicMaterial({ transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, color: 0x77EC9E, }),
          new THREE.MeshBasicMaterial({ transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, color: 0x77EC9E, }),
          new THREE.MeshBasicMaterial({ transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, color: 0x77EC9E, }),
          new THREE.MeshBasicMaterial({ transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, color: 0xFF0000, }),
       ];
       for (index = 0; index < materials.length; ++index) {
          materials[index].side = THREE.DoubleSide;
       }
       var faces_material = new THREE.MeshFaceMaterial ( materials );
    
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(4, 2, 0, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(3, 2, 4, undefined, undefined, 1));
    
       faces.faces.push(new THREE.Face3(1, 3, 4, undefined, undefined, 2));
    
       faces.faces.push(new THREE.Face3(4, 0, 1, undefined, undefined, 3));
    
       faces.faces.push(new THREE.Face3(0, 2, 3, undefined, undefined, 4));
       faces.faces.push(new THREE.Face3(0, 3, 1, undefined, undefined, 4));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[4].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[4].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[4].vector);
       line.vertices.push(allpoints[3].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[4].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[4].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[4].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0.451039, 0.751731, 0.481108));
       allpoints.push(new PMPoint(0.751731, 0.451039, 0.481108));
       allpoints.push(new PMPoint(0.707107, 0.707107, 0));
       allpoints.push(new PMPoint(0, 0, 0));
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
       faces.vertices.push(allpoints[3].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var materials = [
          new THREE.MeshBasicMaterial({ transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, color: 0x77EC9E, }),
          new THREE.MeshBasicMaterial({ transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, color: 0x77EC9E, }),
          new THREE.MeshBasicMaterial({ transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, color: 0x77EC9E, }),
          new THREE.MeshBasicMaterial({ transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, color: 0xFF0000, }),
       ];
       for (index = 0; index < materials.length; ++index) {
          materials[index].side = THREE.DoubleSide;
       }
       var faces_material = new THREE.MeshFaceMaterial ( materials );
    
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 3, 2, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(0, 3, 1, undefined, undefined, 1));
    
       faces.faces.push(new THREE.Face3(2, 3, 0, undefined, undefined, 2));
    
       faces.faces.push(new THREE.Face3(1, 2, 0, undefined, undefined, 3));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0.529999, 0, 0.847998));
       allpoints.push(new PMPoint(0.751731, 0.451039, 0.481108));
       allpoints.push(new PMPoint(0.846499, 0.282166, 0.451466));
       allpoints.push(new PMPoint(0, 0, 0));
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
       faces.vertices.push(allpoints[3].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var materials = [
          new THREE.MeshBasicMaterial({ transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, color: 0x77EC9E, }),
          new THREE.MeshBasicMaterial({ transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, color: 0x77EC9E, }),
          new THREE.MeshBasicMaterial({ transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, color: 0x77EC9E, }),
          new THREE.MeshBasicMaterial({ transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, color: 0xFF0000, }),
       ];
       for (index = 0; index < materials.length; ++index) {
          materials[index].side = THREE.DoubleSide;
       }
       var faces_material = new THREE.MeshFaceMaterial ( materials );
    
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 3, 0, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(2, 3, 1, undefined, undefined, 1));
    
       faces.faces.push(new THREE.Face3(0, 3, 2, undefined, undefined, 2));
    
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 3));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0, 0.529999, 0.847998));
       allpoints.push(new PMPoint(0.529999, 0, 0.847998));
       allpoints.push(new PMPoint(0, 0, 1));
       allpoints.push(new PMPoint(0, 0, 0));
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
       faces.vertices.push(allpoints[3].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var materials = [
          new THREE.MeshBasicMaterial({ transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, color: 0x77EC9E, }),
          new THREE.MeshBasicMaterial({ transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, color: 0x77EC9E, }),
          new THREE.MeshBasicMaterial({ transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, color: 0x77EC9E, }),
          new THREE.MeshBasicMaterial({ transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, color: 0xFF0000, }),
       ];
       for (index = 0; index < materials.length; ++index) {
          materials[index].side = THREE.DoubleSide;
       }
       var faces_material = new THREE.MeshFaceMaterial ( materials );
    
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(3, 0, 1, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(2, 0, 3, undefined, undefined, 1));
    
       faces.faces.push(new THREE.Face3(3, 1, 2, undefined, undefined, 2));
    
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 3));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[3].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[2].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[3].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0, 0.529999, 0.847998));
       allpoints.push(new PMPoint(0.451039, 0.751731, 0.481108));
       allpoints.push(new PMPoint(0.282166, 0.846499, 0.451466));
       allpoints.push(new PMPoint(0, 0, 0));
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
       faces.vertices.push(allpoints[3].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var materials = [
          new THREE.MeshBasicMaterial({ transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, color: 0x77EC9E, }),
          new THREE.MeshBasicMaterial({ transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, color: 0x77EC9E, }),
          new THREE.MeshBasicMaterial({ transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, color: 0x77EC9E, }),
          new THREE.MeshBasicMaterial({ transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, color: 0xFF0000, }),
       ];
       for (index = 0; index < materials.length; ++index) {
          materials[index].side = THREE.DoubleSide;
       }
       var faces_material = new THREE.MeshFaceMaterial ( materials );
    
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 3, 2, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(0, 3, 1, undefined, undefined, 1));
    
       faces.faces.push(new THREE.Face3(2, 3, 0, undefined, undefined, 2));
    
       faces.faces.push(new THREE.Face3(1, 2, 0, undefined, undefined, 3));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0.751731, 0.451039, 0.481108));
       allpoints.push(new PMPoint(0.707107, 0.707107, 0));
       allpoints.push(new PMPoint(0.846499, 0.282166, 0.451466));
       allpoints.push(new PMPoint(0, 0, 0));
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
       faces.vertices.push(allpoints[3].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var materials = [
          new THREE.MeshBasicMaterial({ transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, color: 0x77EC9E, }),
          new THREE.MeshBasicMaterial({ transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, color: 0x77EC9E, }),
          new THREE.MeshBasicMaterial({ transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, color: 0x77EC9E, }),
          new THREE.MeshBasicMaterial({ transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, color: 0xFF0000, }),
       ];
       for (index = 0; index < materials.length; ++index) {
          materials[index].side = THREE.DoubleSide;
       }
       var faces_material = new THREE.MeshFaceMaterial ( materials );
    
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(3, 0, 1, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(2, 0, 3, undefined, undefined, 1));
    
       faces.faces.push(new THREE.Face3(3, 1, 2, undefined, undefined, 2));
    
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 3));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[3].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[2].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[3].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0.451039, 0.751731, 0.481108));
       allpoints.push(new PMPoint(0.707107, 0.707107, 0));
       allpoints.push(new PMPoint(0.282166, 0.846499, 0.451466));
       allpoints.push(new PMPoint(0, 0, 0));
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
       faces.vertices.push(allpoints[3].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var materials = [
          new THREE.MeshBasicMaterial({ transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, color: 0x77EC9E, }),
          new THREE.MeshBasicMaterial({ transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, color: 0x77EC9E, }),
          new THREE.MeshBasicMaterial({ transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, color: 0x77EC9E, }),
          new THREE.MeshBasicMaterial({ transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, color: 0xFF0000, }),
       ];
       for (index = 0; index < materials.length; ++index) {
          materials[index].side = THREE.DoubleSide;
       }
       var faces_material = new THREE.MeshFaceMaterial ( materials );
    
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(3, 0, 2, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(1, 0, 3, undefined, undefined, 1));
    
       faces.faces.push(new THREE.Face3(3, 2, 1, undefined, undefined, 2));
    
       faces.faces.push(new THREE.Face3(2, 0, 1, undefined, undefined, 3));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[3].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[3].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0.529999, 0, 0.847998));
       allpoints.push(new PMPoint(0.846499, 0.282166, 0.451466));
       allpoints.push(new PMPoint(0.882353, 0, 0.470588));
       allpoints.push(new PMPoint(0, 0, 0));
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
       faces.vertices.push(allpoints[3].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var materials = [
          new THREE.MeshBasicMaterial({ transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, color: 0x77EC9E, }),
          new THREE.MeshBasicMaterial({ transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, color: 0x77EC9E, }),
          new THREE.MeshBasicMaterial({ transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, color: 0x77EC9E, }),
          new THREE.MeshBasicMaterial({ transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, color: 0xFF0000, }),
       ];
       for (index = 0; index < materials.length; ++index) {
          materials[index].side = THREE.DoubleSide;
       }
       var faces_material = new THREE.MeshFaceMaterial ( materials );
    
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(3, 0, 1, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(2, 0, 3, undefined, undefined, 1));
    
       faces.faces.push(new THREE.Face3(3, 1, 2, undefined, undefined, 2));
    
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 3));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[3].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[2].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[3].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0, 0.529999, 0.847998));
       allpoints.push(new PMPoint(0.282166, 0.846499, 0.451466));
       allpoints.push(new PMPoint(0, 0.882353, 0.470588));
       allpoints.push(new PMPoint(0, 0, 0));
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
       faces.vertices.push(allpoints[3].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var materials = [
          new THREE.MeshBasicMaterial({ transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, color: 0x77EC9E, }),
          new THREE.MeshBasicMaterial({ transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, color: 0x77EC9E, }),
          new THREE.MeshBasicMaterial({ transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, color: 0x77EC9E, }),
          new THREE.MeshBasicMaterial({ transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, color: 0xFF0000, }),
       ];
       for (index = 0; index < materials.length; ++index) {
          materials[index].side = THREE.DoubleSide;
       }
       var faces_material = new THREE.MeshFaceMaterial ( materials );
    
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(3, 0, 2, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(1, 0, 3, undefined, undefined, 1));
    
       faces.faces.push(new THREE.Face3(3, 2, 1, undefined, undefined, 2));
    
       faces.faces.push(new THREE.Face3(2, 0, 1, undefined, undefined, 3));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[3].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[3].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0.707107, 0.707107, 0));
       allpoints.push(new PMPoint(0.846499, 0.282166, 0.451466));
       allpoints.push(new PMPoint(0.948683, 0.316228, 0));
       allpoints.push(new PMPoint(0, 0, 0));
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
       faces.vertices.push(allpoints[3].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var materials = [
          new THREE.MeshBasicMaterial({ transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, color: 0x77EC9E, }),
          new THREE.MeshBasicMaterial({ transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, color: 0x77EC9E, }),
          new THREE.MeshBasicMaterial({ transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, color: 0x77EC9E, }),
          new THREE.MeshBasicMaterial({ transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, color: 0xFF0000, }),
       ];
       for (index = 0; index < materials.length; ++index) {
          materials[index].side = THREE.DoubleSide;
       }
       var faces_material = new THREE.MeshFaceMaterial ( materials );
    
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(3, 1, 0, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(2, 1, 3, undefined, undefined, 1));
    
       faces.faces.push(new THREE.Face3(3, 0, 2, undefined, undefined, 2));
    
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 3));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[3].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[2].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[3].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0.707107, 0.707107, 0));
       allpoints.push(new PMPoint(0.282166, 0.846499, 0.451466));
       allpoints.push(new PMPoint(0.316228, 0.948683, 0));
       allpoints.push(new PMPoint(0, 0, 0));
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
       faces.vertices.push(allpoints[3].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var materials = [
          new THREE.MeshBasicMaterial({ transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, color: 0x77EC9E, }),
          new THREE.MeshBasicMaterial({ transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, color: 0x77EC9E, }),
          new THREE.MeshBasicMaterial({ transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, color: 0x77EC9E, }),
          new THREE.MeshBasicMaterial({ transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, color: 0xFF0000, }),
       ];
       for (index = 0; index < materials.length; ++index) {
          materials[index].side = THREE.DoubleSide;
       }
       var faces_material = new THREE.MeshFaceMaterial ( materials );
    
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(3, 0, 1, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(2, 0, 3, undefined, undefined, 1));
    
       faces.faces.push(new THREE.Face3(3, 1, 2, undefined, undefined, 2));
    
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 3));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[3].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[2].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[3].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0.846499, 0.282166, 0.451466));
       allpoints.push(new PMPoint(0.882353, 0, 0.470588));
       allpoints.push(new PMPoint(0.948683, 0.316228, 0));
       allpoints.push(new PMPoint(1, 0, 0));
       allpoints.push(new PMPoint(0, 0, 0));
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
       faces.vertices.push(allpoints[3].vector);
       faces.vertices.push(allpoints[4].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var materials = [
          new THREE.MeshBasicMaterial({ transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, color: 0x77EC9E, }),
          new THREE.MeshBasicMaterial({ transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, color: 0x77EC9E, }),
          new THREE.MeshBasicMaterial({ transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, color: 0x77EC9E, }),
          new THREE.MeshBasicMaterial({ transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, color: 0x77EC9E, }),
          new THREE.MeshBasicMaterial({ transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, color: 0xFF0000, }),
       ];
       for (index = 0; index < materials.length; ++index) {
          materials[index].side = THREE.DoubleSide;
       }
       var faces_material = new THREE.MeshFaceMaterial ( materials );
    
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 4, 3, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(1, 0, 4, undefined, undefined, 1));
    
       faces.faces.push(new THREE.Face3(2, 4, 0, undefined, undefined, 2));
    
       faces.faces.push(new THREE.Face3(3, 4, 2, undefined, undefined, 3));
    
       faces.faces.push(new THREE.Face3(1, 3, 2, undefined, undefined, 4));
       faces.faces.push(new THREE.Face3(1, 2, 0, undefined, undefined, 4));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[4].vector);
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[4].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[4].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[4].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[3].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0.282166, 0.846499, 0.451466));
       allpoints.push(new PMPoint(0, 0.882353, 0.470588));
       allpoints.push(new PMPoint(0.316228, 0.948683, 0));
       allpoints.push(new PMPoint(0, 1, 0));
       allpoints.push(new PMPoint(0, 0, 0));
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
       faces.vertices.push(allpoints[3].vector);
       faces.vertices.push(allpoints[4].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var materials = [
          new THREE.MeshBasicMaterial({ transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, color: 0x77EC9E, }),
          new THREE.MeshBasicMaterial({ transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, color: 0x77EC9E, }),
          new THREE.MeshBasicMaterial({ transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, color: 0x77EC9E, }),
          new THREE.MeshBasicMaterial({ transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, color: 0x77EC9E, }),
          new THREE.MeshBasicMaterial({ transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, color: 0xFF0000, }),
       ];
       for (index = 0; index < materials.length; ++index) {
          materials[index].side = THREE.DoubleSide;
       }
       var faces_material = new THREE.MeshFaceMaterial ( materials );
    
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(4, 1, 3, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(0, 1, 4, undefined, undefined, 1));
    
       faces.faces.push(new THREE.Face3(4, 3, 2, undefined, undefined, 2));
    
       faces.faces.push(new THREE.Face3(2, 0, 4, undefined, undefined, 3));
    
       faces.faces.push(new THREE.Face3(3, 1, 0, undefined, undefined, 4));
       faces.faces.push(new THREE.Face3(3, 0, 2, undefined, undefined, 4));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[4].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[4].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[4].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[4].vector);
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[4].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[4].vector);
       line.vertices.push(allpoints[2].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[3].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
    // COMMON_CODE_BLOCK_BEGIN
    var xRotationEnabled = false;
    var yRotationEnabled = false;
    var zRotationEnabled = false;
    var rotationSpeedFactor = 1;
    var settingsShown = false;
    var labelsShown = true;
    var intervals = [];
    var timeouts = [];
    var explodingSpeed = 0.05;
    var explodeScale = 0;
    var XMLS = new XMLSerializer();
    var svgElement;
    var renderId;
    
    	var render = function () {
    
    		renderId = requestAnimationFrame(render);
    
    //		comment in for automatic explosion
    //		explode(updateFactor());
    
    		var phi = 0.02 * rotationSpeedFactor;
    
    		if (xRotationEnabled){
    			scene.rotation.x += phi;
    		}
    		if(yRotationEnabled){
    			scene.rotation.y += phi;
    		}
    		if(zRotationEnabled){
    			scene.rotation.z += phi;
    		}
    
    		controls.update();
    		renderer.render(scene, camera);
    	};
    
    	render();
    
    	function computeCentroid(geom) {
    		centroid = new THREE.Vector3();
    		geom.vertices.forEach(function(v) {
    			centroid.add(v);			
    		});
    		centroid.divideScalar(geom.vertices.length);
    		return centroid;
    	}
    
    	function changeTransparency(event){
    		var opacity = 1-Number(event.currentTarget.value);
    		for (var i=0; i<all_objects.length; i++){
    			for (var j=0; j<all_objects[i].children.length; j++){
    				if (all_objects[i].children[j].material.type == "MultiMaterial") {
    					for (var k=0; k<all_objects[i].children[j].material.materials.length; k++){
    						all_objects[i].children[j].material.materials[k].opacity = opacity;
    						all_objects[i].children[j].material.materials[k].depthWrite = opacity < 0.5 ? false : true;
    						all_objects[i].children[j].material.materials[k].depthTest = opacity < 0.5 ? false : true;
    					}
    				} else if (all_objects[i].children[j].material.transparent && 
    							  all_objects[i].children[j].material.type == "MeshBasicMaterial" &&
    							  all_objects[i].children[j].geometry.type == "Geometry"){
    					all_objects[i].children[j].material.opacity = opacity;
    					all_objects[i].children[j].material.depthWrite = opacity < 0.5 ? false : true;
    					all_objects[i].children[j].material.depthTest = opacity < 0.5 ? false : true;
    				}
    			}
    		}
    	}
    
    	function changeRotationX(event){
    		xRotationEnabled = event.currentTarget.checked;
    	}	
    
    	function changeRotationY(event){
    		yRotationEnabled = event.currentTarget.checked;
    	}	
    
    	function changeRotationZ(event){
    		zRotationEnabled = event.currentTarget.checked;
    	}	
    
    
    	function changeRotationSpeedFactor(event){
    		rotationSpeedFactor = Number(event.currentTarget.value);
    	}
    
    	function resetScene(){
    		scene.rotation.set(0,0,0);
    		camera.position.set(0,0,5);
    		camera.up.set(0,1,0);
    	}
    
    	function showSettings(event){
    		event.currentTarget.style.display = 'none';
    		document.getElementById('settings_4').style.position = 'absolute';
    		document.getElementById('settings_4').style.display = 'block';
    		document.getElementById('showSettingsButton_4').style.display = 'none';
    		document.getElementById('hideSettingsButton_4').style.display = 'block';
    		settingsShown = true;
    	}
    
    	function hideSettings(event){
    		event.currentTarget.style.display = 'none';
    		document.getElementById('settings_4').style.display = 'none';
    		document.getElementById('hideSettingsButton_4').style.display = 'none';
    		document.getElementById('showSettingsButton_4').style.display = 'block';
    		settingsShown = false;
    	}
    
    
    
    	var pos = 150* Math.PI;
    
    	function updateFactor() {
    		pos++;
    		return Math.sin(.01*pos)+1;
    	}
    
    	function makelabel(message, x, y, z, params) {
    		var spritey = textSprite( message, params );
    		spritey.position.set(x, y, z);
    		obj.add(spritey);
    	}
    
    	function textSprite(message, parameters)
    	{
    		if ( parameters === undefined ) parameters = {};
    
    		var fontface = "Helvetica";
    
    		var fontsize = parameters.hasOwnProperty("fontsize") ? 
    			parameters["fontsize"] : 18;
    		fontsize = fontsize*10;
    
    		var canvas = document.createElement('canvas');
    		var size = 1024;
    		canvas.width = size;
    		canvas.height = size;
    		var context = canvas.getContext('2d');
    		context.font = fontsize + "px " + fontface;
    
    		// text color
    		context.fillStyle = "rgba(0, 0, 0, 1.0)";
    
    		context.fillText(message, size/2, size/2);
    
    		// canvas contents will be used for a texture
    		var texture = new THREE.Texture(canvas);
    		texture.needsUpdate = true;
    
    		var spriteMaterial = new THREE.SpriteMaterial(
    			{map: texture, useScreenCoordinates: false});
    		var sprite = new THREE.Sprite(spriteMaterial);
    		return sprite;
    	}
    
    	function takeSvgScreenshot(){
    		if (labelsShown){
    			hideLabels();
    		}
    		svgRenderer.render(scene,camera);
    		svgElement = XMLS.serializeToString(svgRenderer.domElement);
    		
    		if (labelsShown){
    			displayLabels();
    		}
    
    		if (document.getElementById('tab_4').checked){
    			//show in new tab
    			var myWindow = window.open("","");
    			myWindow.document.body.innerHTML = svgElement;
    		} else{
    			// download svg file 
    			download("screenshot.svg", svgElement);
    		}
    	}
    		
    
    	function showOrHideObject(event){
    		var nr = Number(event.currentTarget.name);
    		all_objects[nr].visible = event.currentTarget.checked;
    	}
    
    
    	function displayOrHideOptions(){
    		for (var i=0; i<all_objects.length; i++){
    			for (var j=0; j<all_objects[i].children.length; j++){
    				if (all_objects[i].children[j].material.type == "MultiMaterial") {
    					for (var k=0; k<all_objects[i].children[j].material.materials.length; k++){
    						if (all_objects[i].children[j].material.materials[k].transparent) {
    							document.getElementById('transparency_4').style.display = 'block';
    							document.getElementById('transparencyRange_4').value = 1 - 
    							    all_objects[i].children[j].material.materials[k].opacity;
    							return;
    						}
    					}
    				} else if (all_objects[i].children[j].material.transparent && 
    							  all_objects[i].children[j].material.type == "MeshBasicMaterial" &&
    							  all_objects[i].children[j].geometry.type == "Geometry"){
    					document.getElementById('transparency_4').style.display = 'block';
    					return;
    				}
    			}
    		}
    	}
    
    	displayOrHideOptions()
    
    
    
    
    // ---------------------- EXPLOSION ------------------------------------------------
    // ---------------------------------------------------------------------------------
    
    	function explode(factor) {
    		var obj, c;
    		var c0 = centroids[0];
    		for (var i = 0; i<centroids.length; ++i) {
    			c = centroids[i];
    			obj = all_objects[all_objects.length - centroids.length + i];
    			obj.position.set(c.x*factor, c.y*factor, c.z*factor);
    		}	
    	}
    
    	function triggerExplode(event){
    		explodeScale = Number(event.currentTarget.value);
    		explode(explodeScale);
    	}
    
    	function setExplodingSpeed(event){
    		explodingSpeed = Number(event.currentTarget.value);
    	}
    
    	function triggerAutomaticExplode(event){
    		if (event.currentTarget.checked){
    			startExploding();
    		} else {
    			clearIntervals();
    		}	
    	}
    
    	function startExploding(){
    		intervals.push(setInterval(explodingInterval, 25));
    	}
    
    
    	function explodingInterval(){
    		explodeScale += explodingSpeed;
    		if (explodeScale <= 6){ 
    			explode(explodeScale);
    		}
    		else{
    			explode(6);
    			explodeScale = 6;
    			clearIntervals();
    			timeouts.push(setTimeout(startUnexploding, 3000));
    		}
    		document.getElementById('explodeRange_4').value = explodeScale;
    	}
    
    
    	function startUnexploding(){
    		intervals.push(setInterval(unexplodingInterval, 25));
    	}
    
    	function unexplodingInterval(){
    		explodeScale -= explodingSpeed;
    		if (explodeScale >= 0){	
    			explode(explodeScale);
    		}
    		else {
    			explode(0);
    			explodeScale = 0;
    			clearIntervals();
    			timeouts.push(setTimeout(startExploding, 3000));
    		}
    		document.getElementById('explodeRange_4').value = explodeScale;
    	}
    
    	function clearIntervals(){
    		intervals.forEach(function(interval){
    			clearInterval(interval);
    		});
    		intervals = [];
    		timeouts.forEach(function(timeout){
    			clearTimeout(timeout);
    		});
    		timeouts = [];
    	}
    
    			
    
    	// append checkboxes for displaying or hiding objects
    	var shownObjectsList = document.getElementById('shownObjectsList_4');
    	for (var i=0; i<all_objects.length; i++){
    		var objNode = document.createElement('span');
    		objNode.innerHTML = objectnames[i] + '<br>';
    		var checkbox = document.createElement('input');
    		checkbox.type = 'checkbox';
    		checkbox.checked = true;
    		checkbox.name = String(i);
    		checkbox.onchange = showOrHideObject;
    		shownObjectsList.appendChild(checkbox);
    		shownObjectsList.appendChild(objNode);
    	}
    
    	function displayLabels(){
    		for (var i=0; i<all_objects.length; i++){
    			for (var j=0; j<all_objects[i].children.length; j++){
    				var child = all_objects[i].children[j];
    				if (child.type == 'Sprite'){
    					child.visible = true;
    				}
    			}
    		}
    	}
    
    	function hideLabels(){
    		for (var i=0; i<all_objects.length; i++){
    			for (var j=0; j<all_objects[i].children.length; j++){
    				var child = all_objects[i].children[j];
    				if (child.type == 'Sprite'){
    					child.visible = false;
    				}
    			}
    		}
    	}
    
    	function displayOrHideLabels(event){
    		if (event.currentTarget.checked){
    			displayLabels();
    			labelsShown = true;
    		} else {
    			hideLabels();
    			labelsShown = false;
    		}
    	}
    
    	function download(filename, text) {
    	  var element = document.createElement('a');
    	  element.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(text));
    	  element.setAttribute('download', filename);
    
    	  element.style.display = 'none';
    	  document.body.appendChild(element);
    
    	  element.click();
    
    	  document.body.removeChild(element);
    	}
    
    var tempobj;
    tempobj = document.getElementById('explodeRange_4');
    if (tempobj) {
       tempobj.oninput = triggerExplode;
       document.getElementById('explodeCheckbox_4').onchange = triggerAutomaticExplode;
       document.getElementById('explodingSpeedRange_4').oninput = setExplodingSpeed;
    }
    tempobj = document.getElementById('foldRange_4');
    if (tempobj) {
       tempobj.oninput = fold;
    }
    document.getElementById('transparencyRange_4').oninput = changeTransparency;
    document.getElementById('changeRotationX_4').onchange = changeRotationX;
    document.getElementById('changeRotationY_4').onchange = changeRotationY;
    document.getElementById('changeRotationZ_4').onchange = changeRotationZ;
    document.getElementById('resetButton_4').onclick = resetScene;
    document.getElementById('rotationSpeedRange_4').oninput = changeRotationSpeedFactor;
    document.getElementById('labelsCheckboxInput_4').onchange = displayOrHideLabels;
    document.getElementById('takeScreenshot_4').onclick = takeSvgScreenshot;
    document.getElementById('showSettingsButton_4').onclick = showSettings;
    document.getElementById('hideSettingsButton_4').onclick = hideSettings;
    
    	
    
    // ------------------ SHORTCUTS --------------------------------------------
    // -------------------------------------------------------------------------
    
    /**
     * http://www.openjs.com/scripts/events/keyboard_shortcuts/
     * Version : 2.01.B
     * By Binny V A
     * License : BSD
     */
    shortcut = {
    	'all_shortcuts':{},//All the shortcuts are stored in this array
    	'add': function(shortcut_combination,callback,opt) {
    		//Provide a set of default options
    		var default_options = {
    			'type':'keydown',
    			'propagate':false,
    			'disable_in_input':false,
    			'target':document,
    			'keycode':false
    		}
    		if(!opt) opt = default_options;
    		else {
    			for(var dfo in default_options) {
    				if(typeof opt[dfo] == 'undefined') opt[dfo] = default_options[dfo];
    			}
    		}
    
    		var ele = opt.target;
    		if(typeof opt.target == 'string') ele = document.getElementById(opt.target);
    		var ths = this;
    		shortcut_combination = shortcut_combination.toLowerCase();
    
    		//The function to be called at keypress
    		var func = function(e) {
    			e = e || window.event;
    			
    			if(opt['disable_in_input']) { //Don't enable shortcut keys in Input, Textarea fields
    				var element;
    				if(e.target) element=e.target;
    				else if(e.srcElement) element=e.srcElement;
    				if(element.nodeType==3) element=element.parentNode;
    
    				if(element.tagName == 'INPUT' || element.tagName == 'TEXTAREA') return;
    			}
    	
    			//Find Which key is pressed
    			if (e.keyCode) code = e.keyCode;
    			else if (e.which) code = e.which;
    			var character = String.fromCharCode(code).toLowerCase();
    			
    			if(code == 188) character=","; //If the user presses , when the type is onkeydown
    			if(code == 190) character="."; //If the user presses , when the type is onkeydown
    
    			var keys = shortcut_combination.split("+");
    			//Key Pressed - counts the number of valid keypresses - if it is same as the number of keys, the shortcut function is invoked
    			var kp = 0;
    			
    			//Work around for stupid Shift key bug created by using lowercase - as a result the shift+num combination was broken
    			var shift_nums = {
    				"`":"~",
    				"1":"!",
    				"2":"@",
    				"3":"#",
    				"4":"$",
    				"5":"%",
    				"6":"^",
    				"7":"&",
    				"8":"*",
    				"9":"(",
    				"0":")",
    				"-":"_",
    				"=":"+",
    				";":":",
    				"'":"\"",
    				",":"<",
    				".":">",
    				"/":"?",
    				"\\":"|"
    			}
    			//Special Keys - and their codes
    			var special_keys = {
    				'esc':27,
    				'escape':27,
    				'tab':9,
    				'space':32,
    				'return':13,
    				'enter':13,
    				'backspace':8,
    	
    				'scrolllock':145,
    				'scroll_lock':145,
    				'scroll':145,
    				'capslock':20,
    				'caps_lock':20,
    				'caps':20,
    				'numlock':144,
    				'num_lock':144,
    				'num':144,
    				
    				'pause':19,
    				'break':19,
    				
    				'insert':45,
    				'home':36,
    				'delete':46,
    				'end':35,
    				
    				'pageup':33,
    				'page_up':33,
    				'pu':33,
    	
    				'pagedown':34,
    				'page_down':34,
    				'pd':34,
    	
    				'left':37,
    				'up':38,
    				'right':39,
    				'down':40,
    	
    				'f1':112,
    				'f2':113,
    				'f3':114,
    				'f4':115,
    				'f5':116,
    				'f6':117,
    				'f7':118,
    				'f8':119,
    				'f9':120,
    				'f10':121,
    				'f11':122,
    				'f12':123
    			}
    	
    			var modifiers = { 
    				shift: { wanted:false, pressed:false},
    				ctrl : { wanted:false, pressed:false},
    				alt  : { wanted:false, pressed:false},
    				meta : { wanted:false, pressed:false}	//Meta is Mac specific
    			};
                            
    			if(e.ctrlKey)	modifiers.ctrl.pressed = true;
    			if(e.shiftKey)	modifiers.shift.pressed = true;
    			if(e.altKey)	modifiers.alt.pressed = true;
    			if(e.metaKey)   modifiers.meta.pressed = true;
                            
    			for(var i=0; k=keys[i],i<keys.length; i++) {
    				//Modifiers
    				if(k == 'ctrl' || k == 'control') {
    					kp++;
    					modifiers.ctrl.wanted = true;
    
    				} else if(k == 'shift') {
    					kp++;
    					modifiers.shift.wanted = true;
    
    				} else if(k == 'alt') {
    					kp++;
    					modifiers.alt.wanted = true;
    				} else if(k == 'meta') {
    					kp++;
    					modifiers.meta.wanted = true;
    				} else if(k.length > 1) { //If it is a special key
    					if(special_keys[k] == code) kp++;
    					
    				} else if(opt['keycode']) {
    					if(opt['keycode'] == code) kp++;
    
    				} else { //The special keys did not match
    					if(character == k) kp++;
    					else {
    						if(shift_nums[character] && e.shiftKey) { //Stupid Shift key bug created by using lowercase
    							character = shift_nums[character]; 
    							if(character == k) kp++;
    						}
    					}
    				}
    			}
    			
    			if(kp == keys.length && 
    						modifiers.ctrl.pressed == modifiers.ctrl.wanted &&
    						modifiers.shift.pressed == modifiers.shift.wanted &&
    						modifiers.alt.pressed == modifiers.alt.wanted &&
    						modifiers.meta.pressed == modifiers.meta.wanted) {
    				callback(e);
    	
    				if(!opt['propagate']) { //Stop the event
    					//e.cancelBubble is supported by IE - this will kill the bubbling process.
    					e.cancelBubble = true;
    					e.returnValue = false;
    	
    					//e.stopPropagation works in Firefox.
    					if (e.stopPropagation) {
    						e.stopPropagation();
    						e.preventDefault();
    					}
    					return false;
    				}
    			}
    		}
    		this.all_shortcuts[shortcut_combination] = {
    			'callback':func, 
    			'target':ele, 
    			'event': opt['type']
    		};
    		//Attach the function with the event
    		if(ele.addEventListener) ele.addEventListener(opt['type'], func, false);
    		else if(ele.attachEvent) ele.attachEvent('on'+opt['type'], func);
    		else ele['on'+opt['type']] = func;
    	},
    
    	//Remove the shortcut - just specify the shortcut and I will remove the binding
    	'remove':function(shortcut_combination) {
    		shortcut_combination = shortcut_combination.toLowerCase();
    		var binding = this.all_shortcuts[shortcut_combination];
    		delete(this.all_shortcuts[shortcut_combination])
    		if(!binding) return;
    		var type = binding['event'];
    		var ele = binding['target'];
    		var callback = binding['callback'];
    
    		if(ele.detachEvent) ele.detachEvent('on'+type, callback);
    		else if(ele.removeEventListener) ele.removeEventListener(type, callback, false);
    		else ele['on'+type] = false;
    	}
    }
    
    shortcut.add("Alt+Left",function() {
    	var event = new Event('click');
    	if (settingsShown){
    		document.getElementById('hideSettingsButton_4').dispatchEvent(event);
    	} else{
    		document.getElementById('showSettingsButton_4').dispatchEvent(event);
    	}
    });
    
    if (foldable) moveToBaryCenter();
    
    
    });});
    // COMMON_CODE_BLOCK_END
    </script>
    
    </body>
    </html>



.. link

.. CODE-BLOCK:: perl

    polymake> $s->properties;
    name: s
    type: HyperbolicSurface
    
    DCEL_DATA
    1 0 2 17
    2 1 4 14
    0 2 0 6
    1 2 8 16
    0 1 5 10
    2 1 12 1
    0 2 9 3
    0 1 13 7
    0 2 15 11
    
    
    PENNER_COORDINATES
    2 1 1 1 1 1 1 1 1
    
    SPECIAL_POINT
    1 0
    
    SECONDARY_FAN
    type: PolyhedralFan<Rational>
    
    FLIP_WORDS
    {0}
    {}
    {0 3}
    {0 4 7}
    {0 6}
    {3}
    {6}
    {0 3 1 5}
    {0 6 2 8}
    {3 1 5}
    {6 2 8}
    {0 3 1 5 0 1}
    {0 6 2 8 0 2}
    





.. link

.. CODE-BLOCK:: perl

    polymake> $p = secondary_polyhedron($s,7);
    polymake> $p->VISUAL(FacetColor=>'255 180 80');


.. raw:: html

    <!--
    polymake for loewe
    Fri Feb  9 13:50:17 2018
    p_bounded
    -->
    
    
    <html>
       <head>
          <title>p_bounded</title>
          <style>
    /*
    // COMMON_CODE_BLOCK_BEGIN
    */
             html{overflow: scroll;}
             body { font-family: Arial, Helvetica, sans-serif}
             strong{font-size: 18px;}
             canvas { z-index: 8; }
             input[type='range'] {}
             input[type='radio'] {margin-left:0;}
             input[type='checkbox'] {margin-right:7px; margin-left: 0px; padding-left:0px;}
             .group{padding-bottom: 40px;}
             .settings * {z-index: 11; }
             .settings{z-index: 10; margin-left: 30px; display: none; width: 14em; height: 90%; border: solid 1px silver; padding: 2px; overflow-y: scroll; background-color: white }
             .indented{margin-left: 20px; margin-top: 15px; padding-bottom: 0px;} 
             .shownObjectsList{overflow: auto; max-width: 150px; max-height: 150px;}
             .showSettingsButton{display: block; z-index: 12; position: absolute }
             .hideSettingsButton{display: none; z-index: 12; position: absolute; opacity: 0.5}
             .resetButton{margin-top: 20px;}
             button{margin-left: 0;}
             img{cursor: pointer;}
             .suboption{padding-top: 30px;}
             .transparency{display: none;}
             .labelsCheckbox{margin-top: 10px;}
    
    
             input[type=range] {
               -webkit-appearance: none;
               padding:0; 
               width:90%; 
               margin-left: auto;
               margin-right: auto;
               margin-top: 20px;
               display: block;	
             }
             input[type=range]:focus {
               outline: none;
             }
             input[type=range]::-webkit-slider-runnable-track {
               height: 4px;
               cursor: pointer;
               animate: 0.2s;
               box-shadow: 0px 0px 0px #000000;
               background: #E3E3E3;
               border-radius: 0px;
               border: 0px solid #000000;
             }
             input[type=range]::-webkit-slider-thumb {
               box-shadow: 1px 1px 2px #B8B8B8;
               border: 1px solid #ABABAB;
               height: 13px;
               width: 25px;
               border-radius: 20px;
               background: #E0E0E0;
               cursor: pointer;
               -webkit-appearance: none;
               margin-top: -5px;
             }
             input[type=range]:focus::-webkit-slider-runnable-track {
               background: #E3E3E3;
             }
             input[type=range]::-moz-range-track {
               height: 4px;
               cursor: pointer;
               animate: 0.2s;
               box-shadow: 0px 0px 0px #000000;
               background: #E3E3E3;
               border-radius: 0px;
               border: 0px solid #000000;
             }
             input[type=range]::-moz-range-thumb {
               box-shadow: 1px 1px 2px #B8B8B8;
               border: 1px solid #ABABAB;
               height: 13px;
               width: 25px;
               border-radius: 20px;
               background: #E0E0E0;
               cursor: pointer;
             }
             input[type=range]::-ms-track {
               height: 4px;
               cursor: pointer;
               animate: 0.2s;
               background: transparent;
               border-color: transparent;
               color: transparent;
             }
             input[type=range]::-ms-fill-lower {
               background: #E3E3E3;
               border: 0px solid #000000;
               border-radius: 0px;
               box-shadow: 0px 0px 0px #000000;
             }
             input[type=range]::-ms-fill-upper {
               background: #E3E3E3;
               border: 0px solid #000000;
               border-radius: 0px;
               box-shadow: 0px 0px 0px #000000;
             }
             input[type=range]::-ms-thumb {
               box-shadow: 1px 1px 2px #B8B8B8;
               border: 1px solid #ABABAB;
               height: 13px;
               width: 25px;
               border-radius: 20px;
               background: #E0E0E0;
               cursor: pointer;
             }
             input[type=range]:focus::-ms-fill-lower {
               background: #E3E3E3;
             }
             input[type=range]:focus::-ms-fill-upper {
               background: #E3E3E3;
             }
    /*
    // COMMON_CODE_BLOCK_END
    */
    		</style>
       </head>
    
    <body>
    
    		<div id='settings_5' class='settings'>
    			<div class=group id='transparency_5' class='transparency'>
    				<strong>Transparency</strong>
    				<input id='transparencyRange_5' type='range' min=0 max=1 step=0.01 value=0>
    			</div>
    			
    			<div class=group id='rotation_5'>
    				<strong>Rotation</strong>
    				<div class=indented>
    					<div><input type='checkbox' id='changeRotationX_5'> x-axis</div>
    					<div><input type='checkbox' id='changeRotationY_5'> y-axis</div>
    					<div><input type='checkbox' id='changeRotationZ_5'> z-axis</div>
    					<button id='resetButton_5' class='resetButton' >Reset</button>
    				</div>
    
    				<div class=suboption>Rotation speed</div>
    				<input id='rotationSpeedRange_5' type='range' min=0 max=5 step=0.01 value=2>
    
    			</div>
    
    
    			<div class=group id='display_5'>
    				<strong>Display</strong>
    				<div class=indented>
    					<div id='shownObjectsList_5' class='shownObjectsList'></div>
    					<div class='labelsCheckbox'><input type='checkbox' id='labelsCheckboxInput_5' checked>Labels</div>
    				</div>
    			</div>
    
    
    			<div class=group id='svg_5'>
    				<strong>SVG</strong>
    				<div class=indented>
    					<form>
    						<input type="radio" name='screenshotMode' value='download' id='download_5' checked> Download<br>
    						<input type="radio" name='screenshotMode' value='tab' id='tab_5' > New tab<br>
    					</form>
    					<button id='takeScreenshot_5'>Screenshot</button>
    				</div>
    			</div>
    
    		</div>	<!-- end of settings -->
    		<img id='hideSettingsButton_5' style="display: none" class='hideSettingsButton' src='/kernelspecs/polymake/close.svg' width=20px">
    		<img id='showSettingsButton_5' class='showSettingsButton' src='/kernelspecs/polymake/menu.svg' width=20px">
    <div id="model84707131747"></div>
    
    <script>
    requirejs.config({
      paths: {
        three: '/kernelspecs/polymake/three',
        Detector: '/kernelspecs/polymake/Detector',
        SVGRenderer: '/kernelspecs/polymake/SVGRenderer',
        CanvasRenderer: '/kernelspecs/polymake/CanvasRenderer',
        Projector: '/kernelspecs/polymake/Projector',
        TrackballControls: '/kernelspecs/polymake/TrackballControls'
      },
      shim: {
        'three':
        {
          exports: 'THREE'
        },
        'Detector':
        {
          deps: [ 'three' ],
          exports: 'Detector'
        },
        'SVGRenderer':
        {
          deps: [ 'three' ],
          exports: 'THREE.SVGRenderer'
        },
        'CanvasRenderer':
        {
          deps: [ 'three' ],
          exports: 'THREE.CanvasRenderer'
        },
        'Projector':
        {
          deps: [ 'three' ],
          exports: 'THREE.Projector'
        },
        'TrackballControls':
        {
          deps: [ 'three' ],
          exports: 'THREE.TrackballControls'
        }
      }
    });
    require(['three'],function(THREE){
        window.THREE = THREE;
      require(['Detector','SVGRenderer','CanvasRenderer','Projector','TrackballControls'],function(Detector,SVGRenderer,CanvasRenderer,Projector,TrackballControls){
          THREE.SVGRenderer = SVGRenderer;
          THREE.CanvasRenderer = CanvasRenderer;
          THREE.Projector = Projector;
          THREE.TrackballControls = TrackballControls;
    
    // COMMON_CODE_BLOCK_BEGIN
    	var foldable = false;
       var container = document.getElementById( 'model84707131747' );
       var renderer = Detector.webgl? new THREE.WebGLRenderer({antialias: true}): new THREE.CanvasRenderer({antialias: true});
    	var svgRenderer = new THREE.SVGRenderer({antialias: true});
                var box = document.getElementsByClassName( 'output_subarea' )[0];
             var notebook = document.getElementById( 'notebook_panel' );
    
       var width = box.clientWidth - 25;
       var height = notebook.clientHeight * 0.8;
       renderer.setSize(width, height);
       svgRenderer.setSize(width, height);
       renderer.setClearColor(0xFFFFFF, 1);
       svgRenderer.setClearColor(0xFFFFFF, 1);
    
       container.appendChild(renderer.domElement);
    
       var scene = new THREE.Scene();
       var camera = new THREE.PerspectiveCamera(75, width/height, 0.1, 1000);
    
       var renderid;
    
       camera.position.set(0, 0, 5);
       camera.lookAt(0, 0, 0);
       camera.up.set(0, 1, 0);
    
       // class to allow move points together with labels and spheres
       var PMPoint = function (x,y,z) {
          this.vector = new THREE.Vector3(x,y,z);
          this.sprite = null;
          this.sphere = null;
       }
       PMPoint.prototype.makelabel = function(label) {
          this.sprite = textSprite( label );
          this.sprite.position.copy(this.vector);
       }
       PMPoint.prototype.makesphere = function(radius,material) {
          this.sphere = new THREE.Mesh(new THREE.SphereGeometry(radius), material);
          this.sphere.position.copy(this.vector);
       }
    
       PMPoint.prototype.setX = function(x) {
          this.vector.setX(x);
          if (this.sprite) {
             this.sprite.position.setX(x);
          }
          if (this.sphere) {
             this.sphere.position.setX(x);
          }
       };
       PMPoint.prototype.setY = function(y) {
          this.vector.setY(y);
          if (this.sprite) {
             this.sprite.position.setY(y);
          }
          if (this.sphere) {
             this.sphere.position.setY(y);
          }
       };
       PMPoint.prototype.setZ = function(z) {
          this.vector.setZ(z);
          if (this.sprite) {
             this.sprite.position.setZ(z);
          }
          if (this.sphere) {
             this.sphere.position.setZ(z);
          }
       };
       PMPoint.prototype.set = function(x,y,z) {
          this.vector.set(x,y,z);
          if (this.sprite) {
             this.sprite.position.set(x,y,z);
          }
          if (this.sphere) {
             this.sphere.position.set(x,y,z);
          }
       };
       PMPoint.prototype.add = function(o) {
          if (this.sprite) {
             o.add(this.sprite);
          }
          if (this.sphere) {
             o.add(this.sphere);
          }
       };
    
    
       var controls = new THREE.TrackballControls(camera, container);
    	controls.zoomSpeed = 0.2;
    	controls.rotateSpeed = 4;
    
       var all_objects = [];
       var centroids = [];
       // select the target node
       var target = document.querySelector('#model84707131747');
    
       // create an observer instance
       var observer = new MutationObserver(function(mutations) {
          mutations.forEach(function(mutation) {
             if (mutation.removedNodes && mutation.removedNodes.length > 0) {
                cancelAnimationFrame(renderId);
                observer.disconnect();
                console.log("cancelled frame "+renderId);
             }
          });
       });
    
       // configuration of the observer:
       var config = { childList: true, characterData: true }
    
       // pass in the target node, as well as the observer options
       while (target) {
          if (target.className=="output") {
             observer.observe(target, config);
             break;
          }
          target = target.parentNode;
       }
    
    // COMMON_CODE_BLOCK_END
    
       var objectnames = ["p_bounded"];
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0.562776, 0.0304074, 0.414416));
       allpoints.push(new PMPoint(0.562802, -0.433532, 0.414364));
       allpoints.push(new PMPoint(0.677206, -0.433532, 0.191283));
       allpoints.push(new PMPoint(0.677206, 0.0253675, 0.191283));
       allpoints.push(new PMPoint(0.553167, 0.055381, 0.420578));
       allpoints.push(new PMPoint(0.448757, -0.433532, 0.487473));
       allpoints.push(new PMPoint(0.507199, 0.10215, 0.450049));
       allpoints.push(new PMPoint(0.506217, 0.10236, 0.450678));
       allpoints.push(new PMPoint(0.448813, 0.0432627, 0.487473));
       allpoints.push(new PMPoint(0.61824, 0.115444, 0.261454));
       allpoints.push(new PMPoint(0.569479, 0.16546, 0.292339));
       allpoints.push(new PMPoint(-0.468309, -0.433532, 0.487473));
       allpoints.push(new PMPoint(-0.468309, 0.0431831, 0.487473));
       allpoints.push(new PMPoint(0.499967, 0.108988, 0.446551));
       allpoints.push(new PMPoint(0.156563, 0.409597, -0.370202));
       allpoints.push(new PMPoint(-0.468309, 0.409597, -0.370202));
       allpoints.push(new PMPoint(-0.468309, -0.433532, -0.370202));
       allpoints.push(new PMPoint(0.415509, 0.323237, 0.0975608));
       allpoints.push(new PMPoint(0.415143, 0.323359, -0.370202));
       allpoints.push(new PMPoint(0.562545, 0.172568, 0.288137));
       allpoints.push(new PMPoint(0.677206, -0.433532, -0.370202));
       allpoints.push(new PMPoint(0.156563, 0.409597, 0.0976341));
       allpoints.push(new PMPoint(0.156563, 0.280528, 0.339719));
       allpoints.push(new PMPoint(-0.468309, 0.409597, 0.0976341));
       allpoints.push(new PMPoint(-0.468309, 0.280555, 0.339668));
       allpoints.push(new PMPoint(0.15657, 0.409594, 0.0976391));
       allpoints.push(new PMPoint(0.666751, 0.0653579, -0.370202));
       allpoints.push(new PMPoint(0.677206, 0.0263565, -0.370202));
       allpoints.push(new PMPoint(0.666638, 0.0657773, 0.191429));
       allpoints.push(new PMPoint(0.677206, 0.0263565, 0.190776));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makelabel(" ");
       allpoints[1].makelabel(" ");
       allpoints[2].makelabel(" ");
       allpoints[3].makelabel(" ");
       allpoints[4].makelabel(" ");
       allpoints[5].makelabel(" ");
       allpoints[6].makelabel(" ");
       allpoints[7].makelabel(" ");
       allpoints[8].makelabel(" ");
       allpoints[9].makelabel(" ");
       allpoints[10].makelabel(" ");
       allpoints[11].makelabel(" ");
       allpoints[12].makelabel(" ");
       allpoints[13].makelabel(" ");
       allpoints[14].makelabel(" ");
       allpoints[15].makelabel(" ");
       allpoints[16].makelabel(" ");
       allpoints[17].makelabel(" ");
       allpoints[18].makelabel(" ");
       allpoints[19].makelabel(" ");
       allpoints[20].makelabel(" ");
       allpoints[21].makelabel(" ");
       allpoints[22].makelabel(" ");
       allpoints[23].makelabel(" ");
       allpoints[24].makelabel(" ");
       allpoints[25].makelabel(" ");
       allpoints[26].makelabel(" ");
       allpoints[27].makelabel(" ");
       allpoints[28].makelabel(" ");
       allpoints[29].makelabel(" ");
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
       faces.vertices.push(allpoints[3].vector);
       faces.vertices.push(allpoints[4].vector);
       faces.vertices.push(allpoints[5].vector);
       faces.vertices.push(allpoints[6].vector);
       faces.vertices.push(allpoints[7].vector);
       faces.vertices.push(allpoints[8].vector);
       faces.vertices.push(allpoints[9].vector);
       faces.vertices.push(allpoints[10].vector);
       faces.vertices.push(allpoints[11].vector);
       faces.vertices.push(allpoints[12].vector);
       faces.vertices.push(allpoints[13].vector);
       faces.vertices.push(allpoints[14].vector);
       faces.vertices.push(allpoints[15].vector);
       faces.vertices.push(allpoints[16].vector);
       faces.vertices.push(allpoints[17].vector);
       faces.vertices.push(allpoints[18].vector);
       faces.vertices.push(allpoints[19].vector);
       faces.vertices.push(allpoints[20].vector);
       faces.vertices.push(allpoints[21].vector);
       faces.vertices.push(allpoints[22].vector);
       faces.vertices.push(allpoints[23].vector);
       faces.vertices.push(allpoints[24].vector);
       faces.vertices.push(allpoints[25].vector);
       faces.vertices.push(allpoints[26].vector);
       faces.vertices.push(allpoints[27].vector);
       faces.vertices.push(allpoints[28].vector);
       faces.vertices.push(allpoints[29].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var materials = [
          new THREE.MeshBasicMaterial({ transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, color: 0xFFB450, }),
          new THREE.MeshBasicMaterial({ transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, color: 0xFFB450, }),
          new THREE.MeshBasicMaterial({ transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, color: 0xFFB450, }),
          new THREE.MeshBasicMaterial({ transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, color: 0xFFB450, }),
          new THREE.MeshBasicMaterial({ transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, color: 0xFFB450, }),
          new THREE.MeshBasicMaterial({ transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, color: 0xFFB450, }),
          new THREE.MeshBasicMaterial({ transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, color: 0xFFB450, }),
          new THREE.MeshBasicMaterial({ transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, color: 0xFFB450, }),
          new THREE.MeshBasicMaterial({ transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, color: 0xFFB450, }),
          new THREE.MeshBasicMaterial({ transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, color: 0xFFB450, }),
          new THREE.MeshBasicMaterial({ transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, color: 0xFFB450, }),
          new THREE.MeshBasicMaterial({ transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, color: 0xFFB450, }),
          new THREE.MeshBasicMaterial({ transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, color: 0xFFB450, }),
          new THREE.MeshBasicMaterial({ transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, color: 0xFFB450, }),
          new THREE.MeshBasicMaterial({ transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, color: 0xFF0000, }),
          new THREE.MeshBasicMaterial({ transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, color: 0xFF0000, }),
          new THREE.MeshBasicMaterial({ transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, color: 0xFF0000, }),
       ];
       for (index = 0; index < materials.length; ++index) {
          materials[index].side = THREE.DoubleSide;
       }
       var faces_material = new THREE.MeshFaceMaterial ( materials );
    
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(7, 13, 22, undefined, undefined, 0));
       faces.faces.push(new THREE.Face3(7, 22, 24, undefined, undefined, 0));
       faces.faces.push(new THREE.Face3(7, 24, 12, undefined, undefined, 0));
       faces.faces.push(new THREE.Face3(7, 12, 8, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(19, 13, 7, undefined, undefined, 1));
       faces.faces.push(new THREE.Face3(19, 7, 6, undefined, undefined, 1));
       faces.faces.push(new THREE.Face3(19, 6, 10, undefined, undefined, 1));
    
       faces.faces.push(new THREE.Face3(7, 8, 5, undefined, undefined, 2));
       faces.faces.push(new THREE.Face3(7, 5, 1, undefined, undefined, 2));
       faces.faces.push(new THREE.Face3(7, 1, 0, undefined, undefined, 2));
       faces.faces.push(new THREE.Face3(7, 0, 4, undefined, undefined, 2));
       faces.faces.push(new THREE.Face3(7, 4, 6, undefined, undefined, 2));
    
       faces.faces.push(new THREE.Face3(6, 4, 9, undefined, undefined, 3));
       faces.faces.push(new THREE.Face3(6, 9, 10, undefined, undefined, 3));
    
       faces.faces.push(new THREE.Face3(17, 19, 10, undefined, undefined, 4));
       faces.faces.push(new THREE.Face3(17, 10, 9, undefined, undefined, 4));
       faces.faces.push(new THREE.Face3(17, 9, 28, undefined, undefined, 4));
       faces.faces.push(new THREE.Face3(17, 28, 26, undefined, undefined, 4));
       faces.faces.push(new THREE.Face3(17, 26, 18, undefined, undefined, 4));
    
       faces.faces.push(new THREE.Face3(4, 0, 3, undefined, undefined, 5));
       faces.faces.push(new THREE.Face3(4, 3, 29, undefined, undefined, 5));
       faces.faces.push(new THREE.Face3(4, 29, 28, undefined, undefined, 5));
       faces.faces.push(new THREE.Face3(4, 28, 9, undefined, undefined, 5));
    
       faces.faces.push(new THREE.Face3(8, 12, 11, undefined, undefined, 6));
       faces.faces.push(new THREE.Face3(8, 11, 5, undefined, undefined, 6));
    
       faces.faces.push(new THREE.Face3(22, 13, 19, undefined, undefined, 7));
       faces.faces.push(new THREE.Face3(22, 19, 17, undefined, undefined, 7));
       faces.faces.push(new THREE.Face3(22, 17, 25, undefined, undefined, 7));
    
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 8));
       faces.faces.push(new THREE.Face3(0, 2, 3, undefined, undefined, 8));
    
       faces.faces.push(new THREE.Face3(24, 22, 25, undefined, undefined, 9));
       faces.faces.push(new THREE.Face3(24, 25, 21, undefined, undefined, 9));
       faces.faces.push(new THREE.Face3(24, 21, 23, undefined, undefined, 9));
    
       faces.faces.push(new THREE.Face3(26, 28, 29, undefined, undefined, 10));
       faces.faces.push(new THREE.Face3(26, 29, 27, undefined, undefined, 10));
    
       faces.faces.push(new THREE.Face3(25, 17, 18, undefined, undefined, 11));
       faces.faces.push(new THREE.Face3(25, 18, 14, undefined, undefined, 11));
       faces.faces.push(new THREE.Face3(25, 14, 21, undefined, undefined, 11));
    
       faces.faces.push(new THREE.Face3(20, 27, 29, undefined, undefined, 12));
       faces.faces.push(new THREE.Face3(20, 29, 3, undefined, undefined, 12));
       faces.faces.push(new THREE.Face3(20, 3, 2, undefined, undefined, 12));
    
       faces.faces.push(new THREE.Face3(23, 21, 14, undefined, undefined, 13));
       faces.faces.push(new THREE.Face3(23, 14, 15, undefined, undefined, 13));
    
       faces.faces.push(new THREE.Face3(12, 24, 23, undefined, undefined, 14));
       faces.faces.push(new THREE.Face3(12, 23, 15, undefined, undefined, 14));
       faces.faces.push(new THREE.Face3(12, 15, 16, undefined, undefined, 14));
       faces.faces.push(new THREE.Face3(12, 16, 11, undefined, undefined, 14));
    
       faces.faces.push(new THREE.Face3(11, 16, 20, undefined, undefined, 15));
       faces.faces.push(new THREE.Face3(11, 20, 2, undefined, undefined, 15));
       faces.faces.push(new THREE.Face3(11, 2, 1, undefined, undefined, 15));
       faces.faces.push(new THREE.Face3(11, 1, 5, undefined, undefined, 15));
    
       faces.faces.push(new THREE.Face3(16, 15, 14, undefined, undefined, 16));
       faces.faces.push(new THREE.Face3(16, 14, 18, undefined, undefined, 16));
       faces.faces.push(new THREE.Face3(16, 18, 26, undefined, undefined, 16));
       faces.faces.push(new THREE.Face3(16, 26, 27, undefined, undefined, 16));
       faces.faces.push(new THREE.Face3(16, 27, 20, undefined, undefined, 16));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[7].vector);
       line.vertices.push(allpoints[13].vector);
       line.vertices.push(allpoints[22].vector);
       line.vertices.push(allpoints[24].vector);
       line.vertices.push(allpoints[12].vector);
       line.vertices.push(allpoints[8].vector);
       line.vertices.push(allpoints[7].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[19].vector);
       line.vertices.push(allpoints[13].vector);
       line.vertices.push(allpoints[7].vector);
       line.vertices.push(allpoints[6].vector);
       line.vertices.push(allpoints[10].vector);
       line.vertices.push(allpoints[19].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[7].vector);
       line.vertices.push(allpoints[8].vector);
       line.vertices.push(allpoints[5].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[4].vector);
       line.vertices.push(allpoints[6].vector);
       line.vertices.push(allpoints[7].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[6].vector);
       line.vertices.push(allpoints[4].vector);
       line.vertices.push(allpoints[9].vector);
       line.vertices.push(allpoints[10].vector);
       line.vertices.push(allpoints[6].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[17].vector);
       line.vertices.push(allpoints[19].vector);
       line.vertices.push(allpoints[10].vector);
       line.vertices.push(allpoints[9].vector);
       line.vertices.push(allpoints[28].vector);
       line.vertices.push(allpoints[26].vector);
       line.vertices.push(allpoints[18].vector);
       line.vertices.push(allpoints[17].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[4].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[29].vector);
       line.vertices.push(allpoints[28].vector);
       line.vertices.push(allpoints[9].vector);
       line.vertices.push(allpoints[4].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[8].vector);
       line.vertices.push(allpoints[12].vector);
       line.vertices.push(allpoints[11].vector);
       line.vertices.push(allpoints[5].vector);
       line.vertices.push(allpoints[8].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[22].vector);
       line.vertices.push(allpoints[13].vector);
       line.vertices.push(allpoints[19].vector);
       line.vertices.push(allpoints[17].vector);
       line.vertices.push(allpoints[25].vector);
       line.vertices.push(allpoints[22].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[24].vector);
       line.vertices.push(allpoints[22].vector);
       line.vertices.push(allpoints[25].vector);
       line.vertices.push(allpoints[21].vector);
       line.vertices.push(allpoints[23].vector);
       line.vertices.push(allpoints[24].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[26].vector);
       line.vertices.push(allpoints[28].vector);
       line.vertices.push(allpoints[29].vector);
       line.vertices.push(allpoints[27].vector);
       line.vertices.push(allpoints[26].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[25].vector);
       line.vertices.push(allpoints[17].vector);
       line.vertices.push(allpoints[18].vector);
       line.vertices.push(allpoints[14].vector);
       line.vertices.push(allpoints[21].vector);
       line.vertices.push(allpoints[25].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[20].vector);
       line.vertices.push(allpoints[27].vector);
       line.vertices.push(allpoints[29].vector);
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[20].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[23].vector);
       line.vertices.push(allpoints[21].vector);
       line.vertices.push(allpoints[14].vector);
       line.vertices.push(allpoints[15].vector);
       line.vertices.push(allpoints[23].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[12].vector);
       line.vertices.push(allpoints[24].vector);
       line.vertices.push(allpoints[23].vector);
       line.vertices.push(allpoints[15].vector);
       line.vertices.push(allpoints[16].vector);
       line.vertices.push(allpoints[11].vector);
       line.vertices.push(allpoints[12].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[11].vector);
       line.vertices.push(allpoints[16].vector);
       line.vertices.push(allpoints[20].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[5].vector);
       line.vertices.push(allpoints[11].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[16].vector);
       line.vertices.push(allpoints[15].vector);
       line.vertices.push(allpoints[14].vector);
       line.vertices.push(allpoints[18].vector);
       line.vertices.push(allpoints[26].vector);
       line.vertices.push(allpoints[27].vector);
       line.vertices.push(allpoints[20].vector);
       line.vertices.push(allpoints[16].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
    // COMMON_CODE_BLOCK_BEGIN
    var xRotationEnabled = false;
    var yRotationEnabled = false;
    var zRotationEnabled = false;
    var rotationSpeedFactor = 1;
    var settingsShown = false;
    var labelsShown = true;
    var intervals = [];
    var timeouts = [];
    var explodingSpeed = 0.05;
    var explodeScale = 0;
    var XMLS = new XMLSerializer();
    var svgElement;
    var renderId;
    
    	var render = function () {
    
    		renderId = requestAnimationFrame(render);
    
    //		comment in for automatic explosion
    //		explode(updateFactor());
    
    		var phi = 0.02 * rotationSpeedFactor;
    
    		if (xRotationEnabled){
    			scene.rotation.x += phi;
    		}
    		if(yRotationEnabled){
    			scene.rotation.y += phi;
    		}
    		if(zRotationEnabled){
    			scene.rotation.z += phi;
    		}
    
    		controls.update();
    		renderer.render(scene, camera);
    	};
    
    	render();
    
    	function computeCentroid(geom) {
    		centroid = new THREE.Vector3();
    		geom.vertices.forEach(function(v) {
    			centroid.add(v);			
    		});
    		centroid.divideScalar(geom.vertices.length);
    		return centroid;
    	}
    
    	function changeTransparency(event){
    		var opacity = 1-Number(event.currentTarget.value);
    		for (var i=0; i<all_objects.length; i++){
    			for (var j=0; j<all_objects[i].children.length; j++){
    				if (all_objects[i].children[j].material.type == "MultiMaterial") {
    					for (var k=0; k<all_objects[i].children[j].material.materials.length; k++){
    						all_objects[i].children[j].material.materials[k].opacity = opacity;
    						all_objects[i].children[j].material.materials[k].depthWrite = opacity < 0.5 ? false : true;
    						all_objects[i].children[j].material.materials[k].depthTest = opacity < 0.5 ? false : true;
    					}
    				} else if (all_objects[i].children[j].material.transparent && 
    							  all_objects[i].children[j].material.type == "MeshBasicMaterial" &&
    							  all_objects[i].children[j].geometry.type == "Geometry"){
    					all_objects[i].children[j].material.opacity = opacity;
    					all_objects[i].children[j].material.depthWrite = opacity < 0.5 ? false : true;
    					all_objects[i].children[j].material.depthTest = opacity < 0.5 ? false : true;
    				}
    			}
    		}
    	}
    
    	function changeRotationX(event){
    		xRotationEnabled = event.currentTarget.checked;
    	}	
    
    	function changeRotationY(event){
    		yRotationEnabled = event.currentTarget.checked;
    	}	
    
    	function changeRotationZ(event){
    		zRotationEnabled = event.currentTarget.checked;
    	}	
    
    
    	function changeRotationSpeedFactor(event){
    		rotationSpeedFactor = Number(event.currentTarget.value);
    	}
    
    	function resetScene(){
    		scene.rotation.set(0,0,0);
    		camera.position.set(0,0,5);
    		camera.up.set(0,1,0);
    	}
    
    	function showSettings(event){
    		event.currentTarget.style.display = 'none';
    		document.getElementById('settings_5').style.position = 'absolute';
    		document.getElementById('settings_5').style.display = 'block';
    		document.getElementById('showSettingsButton_5').style.display = 'none';
    		document.getElementById('hideSettingsButton_5').style.display = 'block';
    		settingsShown = true;
    	}
    
    	function hideSettings(event){
    		event.currentTarget.style.display = 'none';
    		document.getElementById('settings_5').style.display = 'none';
    		document.getElementById('hideSettingsButton_5').style.display = 'none';
    		document.getElementById('showSettingsButton_5').style.display = 'block';
    		settingsShown = false;
    	}
    
    
    
    	var pos = 150* Math.PI;
    
    	function updateFactor() {
    		pos++;
    		return Math.sin(.01*pos)+1;
    	}
    
    	function makelabel(message, x, y, z, params) {
    		var spritey = textSprite( message, params );
    		spritey.position.set(x, y, z);
    		obj.add(spritey);
    	}
    
    	function textSprite(message, parameters)
    	{
    		if ( parameters === undefined ) parameters = {};
    
    		var fontface = "Helvetica";
    
    		var fontsize = parameters.hasOwnProperty("fontsize") ? 
    			parameters["fontsize"] : 18;
    		fontsize = fontsize*10;
    
    		var canvas = document.createElement('canvas');
    		var size = 1024;
    		canvas.width = size;
    		canvas.height = size;
    		var context = canvas.getContext('2d');
    		context.font = fontsize + "px " + fontface;
    
    		// text color
    		context.fillStyle = "rgba(0, 0, 0, 1.0)";
    
    		context.fillText(message, size/2, size/2);
    
    		// canvas contents will be used for a texture
    		var texture = new THREE.Texture(canvas);
    		texture.needsUpdate = true;
    
    		var spriteMaterial = new THREE.SpriteMaterial(
    			{map: texture, useScreenCoordinates: false});
    		var sprite = new THREE.Sprite(spriteMaterial);
    		return sprite;
    	}
    
    	function takeSvgScreenshot(){
    		if (labelsShown){
    			hideLabels();
    		}
    		svgRenderer.render(scene,camera);
    		svgElement = XMLS.serializeToString(svgRenderer.domElement);
    		
    		if (labelsShown){
    			displayLabels();
    		}
    
    		if (document.getElementById('tab_5').checked){
    			//show in new tab
    			var myWindow = window.open("","");
    			myWindow.document.body.innerHTML = svgElement;
    		} else{
    			// download svg file 
    			download("screenshot.svg", svgElement);
    		}
    	}
    		
    
    	function showOrHideObject(event){
    		var nr = Number(event.currentTarget.name);
    		all_objects[nr].visible = event.currentTarget.checked;
    	}
    
    
    	function displayOrHideOptions(){
    		for (var i=0; i<all_objects.length; i++){
    			for (var j=0; j<all_objects[i].children.length; j++){
    				if (all_objects[i].children[j].material.type == "MultiMaterial") {
    					for (var k=0; k<all_objects[i].children[j].material.materials.length; k++){
    						if (all_objects[i].children[j].material.materials[k].transparent) {
    							document.getElementById('transparency_5').style.display = 'block';
    							document.getElementById('transparencyRange_5').value = 1 - 
    							    all_objects[i].children[j].material.materials[k].opacity;
    							return;
    						}
    					}
    				} else if (all_objects[i].children[j].material.transparent && 
    							  all_objects[i].children[j].material.type == "MeshBasicMaterial" &&
    							  all_objects[i].children[j].geometry.type == "Geometry"){
    					document.getElementById('transparency_5').style.display = 'block';
    					return;
    				}
    			}
    		}
    	}
    
    	displayOrHideOptions()
    
    
    
    
    // ---------------------- EXPLOSION ------------------------------------------------
    // ---------------------------------------------------------------------------------
    
    	function explode(factor) {
    		var obj, c;
    		var c0 = centroids[0];
    		for (var i = 0; i<centroids.length; ++i) {
    			c = centroids[i];
    			obj = all_objects[all_objects.length - centroids.length + i];
    			obj.position.set(c.x*factor, c.y*factor, c.z*factor);
    		}	
    	}
    
    	function triggerExplode(event){
    		explodeScale = Number(event.currentTarget.value);
    		explode(explodeScale);
    	}
    
    	function setExplodingSpeed(event){
    		explodingSpeed = Number(event.currentTarget.value);
    	}
    
    	function triggerAutomaticExplode(event){
    		if (event.currentTarget.checked){
    			startExploding();
    		} else {
    			clearIntervals();
    		}	
    	}
    
    	function startExploding(){
    		intervals.push(setInterval(explodingInterval, 25));
    	}
    
    
    	function explodingInterval(){
    		explodeScale += explodingSpeed;
    		if (explodeScale <= 6){ 
    			explode(explodeScale);
    		}
    		else{
    			explode(6);
    			explodeScale = 6;
    			clearIntervals();
    			timeouts.push(setTimeout(startUnexploding, 3000));
    		}
    		document.getElementById('explodeRange_5').value = explodeScale;
    	}
    
    
    	function startUnexploding(){
    		intervals.push(setInterval(unexplodingInterval, 25));
    	}
    
    	function unexplodingInterval(){
    		explodeScale -= explodingSpeed;
    		if (explodeScale >= 0){	
    			explode(explodeScale);
    		}
    		else {
    			explode(0);
    			explodeScale = 0;
    			clearIntervals();
    			timeouts.push(setTimeout(startExploding, 3000));
    		}
    		document.getElementById('explodeRange_5').value = explodeScale;
    	}
    
    	function clearIntervals(){
    		intervals.forEach(function(interval){
    			clearInterval(interval);
    		});
    		intervals = [];
    		timeouts.forEach(function(timeout){
    			clearTimeout(timeout);
    		});
    		timeouts = [];
    	}
    
    			
    
    	// append checkboxes for displaying or hiding objects
    	var shownObjectsList = document.getElementById('shownObjectsList_5');
    	for (var i=0; i<all_objects.length; i++){
    		var objNode = document.createElement('span');
    		objNode.innerHTML = objectnames[i] + '<br>';
    		var checkbox = document.createElement('input');
    		checkbox.type = 'checkbox';
    		checkbox.checked = true;
    		checkbox.name = String(i);
    		checkbox.onchange = showOrHideObject;
    		shownObjectsList.appendChild(checkbox);
    		shownObjectsList.appendChild(objNode);
    	}
    
    	function displayLabels(){
    		for (var i=0; i<all_objects.length; i++){
    			for (var j=0; j<all_objects[i].children.length; j++){
    				var child = all_objects[i].children[j];
    				if (child.type == 'Sprite'){
    					child.visible = true;
    				}
    			}
    		}
    	}
    
    	function hideLabels(){
    		for (var i=0; i<all_objects.length; i++){
    			for (var j=0; j<all_objects[i].children.length; j++){
    				var child = all_objects[i].children[j];
    				if (child.type == 'Sprite'){
    					child.visible = false;
    				}
    			}
    		}
    	}
    
    	function displayOrHideLabels(event){
    		if (event.currentTarget.checked){
    			displayLabels();
    			labelsShown = true;
    		} else {
    			hideLabels();
    			labelsShown = false;
    		}
    	}
    
    	function download(filename, text) {
    	  var element = document.createElement('a');
    	  element.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(text));
    	  element.setAttribute('download', filename);
    
    	  element.style.display = 'none';
    	  document.body.appendChild(element);
    
    	  element.click();
    
    	  document.body.removeChild(element);
    	}
    
    var tempobj;
    tempobj = document.getElementById('explodeRange_5');
    if (tempobj) {
       tempobj.oninput = triggerExplode;
       document.getElementById('explodeCheckbox_5').onchange = triggerAutomaticExplode;
       document.getElementById('explodingSpeedRange_5').oninput = setExplodingSpeed;
    }
    tempobj = document.getElementById('foldRange_5');
    if (tempobj) {
       tempobj.oninput = fold;
    }
    document.getElementById('transparencyRange_5').oninput = changeTransparency;
    document.getElementById('changeRotationX_5').onchange = changeRotationX;
    document.getElementById('changeRotationY_5').onchange = changeRotationY;
    document.getElementById('changeRotationZ_5').onchange = changeRotationZ;
    document.getElementById('resetButton_5').onclick = resetScene;
    document.getElementById('rotationSpeedRange_5').oninput = changeRotationSpeedFactor;
    document.getElementById('labelsCheckboxInput_5').onchange = displayOrHideLabels;
    document.getElementById('takeScreenshot_5').onclick = takeSvgScreenshot;
    document.getElementById('showSettingsButton_5').onclick = showSettings;
    document.getElementById('hideSettingsButton_5').onclick = hideSettings;
    
    	
    
    // ------------------ SHORTCUTS --------------------------------------------
    // -------------------------------------------------------------------------
    
    /**
     * http://www.openjs.com/scripts/events/keyboard_shortcuts/
     * Version : 2.01.B
     * By Binny V A
     * License : BSD
     */
    shortcut = {
    	'all_shortcuts':{},//All the shortcuts are stored in this array
    	'add': function(shortcut_combination,callback,opt) {
    		//Provide a set of default options
    		var default_options = {
    			'type':'keydown',
    			'propagate':false,
    			'disable_in_input':false,
    			'target':document,
    			'keycode':false
    		}
    		if(!opt) opt = default_options;
    		else {
    			for(var dfo in default_options) {
    				if(typeof opt[dfo] == 'undefined') opt[dfo] = default_options[dfo];
    			}
    		}
    
    		var ele = opt.target;
    		if(typeof opt.target == 'string') ele = document.getElementById(opt.target);
    		var ths = this;
    		shortcut_combination = shortcut_combination.toLowerCase();
    
    		//The function to be called at keypress
    		var func = function(e) {
    			e = e || window.event;
    			
    			if(opt['disable_in_input']) { //Don't enable shortcut keys in Input, Textarea fields
    				var element;
    				if(e.target) element=e.target;
    				else if(e.srcElement) element=e.srcElement;
    				if(element.nodeType==3) element=element.parentNode;
    
    				if(element.tagName == 'INPUT' || element.tagName == 'TEXTAREA') return;
    			}
    	
    			//Find Which key is pressed
    			if (e.keyCode) code = e.keyCode;
    			else if (e.which) code = e.which;
    			var character = String.fromCharCode(code).toLowerCase();
    			
    			if(code == 188) character=","; //If the user presses , when the type is onkeydown
    			if(code == 190) character="."; //If the user presses , when the type is onkeydown
    
    			var keys = shortcut_combination.split("+");
    			//Key Pressed - counts the number of valid keypresses - if it is same as the number of keys, the shortcut function is invoked
    			var kp = 0;
    			
    			//Work around for stupid Shift key bug created by using lowercase - as a result the shift+num combination was broken
    			var shift_nums = {
    				"`":"~",
    				"1":"!",
    				"2":"@",
    				"3":"#",
    				"4":"$",
    				"5":"%",
    				"6":"^",
    				"7":"&",
    				"8":"*",
    				"9":"(",
    				"0":")",
    				"-":"_",
    				"=":"+",
    				";":":",
    				"'":"\"",
    				",":"<",
    				".":">",
    				"/":"?",
    				"\\":"|"
    			}
    			//Special Keys - and their codes
    			var special_keys = {
    				'esc':27,
    				'escape':27,
    				'tab':9,
    				'space':32,
    				'return':13,
    				'enter':13,
    				'backspace':8,
    	
    				'scrolllock':145,
    				'scroll_lock':145,
    				'scroll':145,
    				'capslock':20,
    				'caps_lock':20,
    				'caps':20,
    				'numlock':144,
    				'num_lock':144,
    				'num':144,
    				
    				'pause':19,
    				'break':19,
    				
    				'insert':45,
    				'home':36,
    				'delete':46,
    				'end':35,
    				
    				'pageup':33,
    				'page_up':33,
    				'pu':33,
    	
    				'pagedown':34,
    				'page_down':34,
    				'pd':34,
    	
    				'left':37,
    				'up':38,
    				'right':39,
    				'down':40,
    	
    				'f1':112,
    				'f2':113,
    				'f3':114,
    				'f4':115,
    				'f5':116,
    				'f6':117,
    				'f7':118,
    				'f8':119,
    				'f9':120,
    				'f10':121,
    				'f11':122,
    				'f12':123
    			}
    	
    			var modifiers = { 
    				shift: { wanted:false, pressed:false},
    				ctrl : { wanted:false, pressed:false},
    				alt  : { wanted:false, pressed:false},
    				meta : { wanted:false, pressed:false}	//Meta is Mac specific
    			};
                            
    			if(e.ctrlKey)	modifiers.ctrl.pressed = true;
    			if(e.shiftKey)	modifiers.shift.pressed = true;
    			if(e.altKey)	modifiers.alt.pressed = true;
    			if(e.metaKey)   modifiers.meta.pressed = true;
                            
    			for(var i=0; k=keys[i],i<keys.length; i++) {
    				//Modifiers
    				if(k == 'ctrl' || k == 'control') {
    					kp++;
    					modifiers.ctrl.wanted = true;
    
    				} else if(k == 'shift') {
    					kp++;
    					modifiers.shift.wanted = true;
    
    				} else if(k == 'alt') {
    					kp++;
    					modifiers.alt.wanted = true;
    				} else if(k == 'meta') {
    					kp++;
    					modifiers.meta.wanted = true;
    				} else if(k.length > 1) { //If it is a special key
    					if(special_keys[k] == code) kp++;
    					
    				} else if(opt['keycode']) {
    					if(opt['keycode'] == code) kp++;
    
    				} else { //The special keys did not match
    					if(character == k) kp++;
    					else {
    						if(shift_nums[character] && e.shiftKey) { //Stupid Shift key bug created by using lowercase
    							character = shift_nums[character]; 
    							if(character == k) kp++;
    						}
    					}
    				}
    			}
    			
    			if(kp == keys.length && 
    						modifiers.ctrl.pressed == modifiers.ctrl.wanted &&
    						modifiers.shift.pressed == modifiers.shift.wanted &&
    						modifiers.alt.pressed == modifiers.alt.wanted &&
    						modifiers.meta.pressed == modifiers.meta.wanted) {
    				callback(e);
    	
    				if(!opt['propagate']) { //Stop the event
    					//e.cancelBubble is supported by IE - this will kill the bubbling process.
    					e.cancelBubble = true;
    					e.returnValue = false;
    	
    					//e.stopPropagation works in Firefox.
    					if (e.stopPropagation) {
    						e.stopPropagation();
    						e.preventDefault();
    					}
    					return false;
    				}
    			}
    		}
    		this.all_shortcuts[shortcut_combination] = {
    			'callback':func, 
    			'target':ele, 
    			'event': opt['type']
    		};
    		//Attach the function with the event
    		if(ele.addEventListener) ele.addEventListener(opt['type'], func, false);
    		else if(ele.attachEvent) ele.attachEvent('on'+opt['type'], func);
    		else ele['on'+opt['type']] = func;
    	},
    
    	//Remove the shortcut - just specify the shortcut and I will remove the binding
    	'remove':function(shortcut_combination) {
    		shortcut_combination = shortcut_combination.toLowerCase();
    		var binding = this.all_shortcuts[shortcut_combination];
    		delete(this.all_shortcuts[shortcut_combination])
    		if(!binding) return;
    		var type = binding['event'];
    		var ele = binding['target'];
    		var callback = binding['callback'];
    
    		if(ele.detachEvent) ele.detachEvent('on'+type, callback);
    		else if(ele.removeEventListener) ele.removeEventListener(type, callback, false);
    		else ele['on'+type] = false;
    	}
    }
    
    shortcut.add("Alt+Left",function() {
    	var event = new Event('click');
    	if (settingsShown){
    		document.getElementById('hideSettingsButton_5').dispatchEvent(event);
    	} else{
    		document.getElementById('showSettingsButton_5').dispatchEvent(event);
    	}
    });
    
    if (foldable) moveToBaryCenter();
    
    
    });});
    // COMMON_CODE_BLOCK_END
    </script>
    
    </body>
    </html>



.. link

.. CODE-BLOCK:: perl

    polymake> $d0 = $s->gkz_dome(0,5);
    polymake> $d0->VISUAL(FacetColor=>'80 180 255');


.. raw:: html

    <!--
    polymake for loewe
    Fri Feb  9 13:50:22 2018
    pcom:d0
    -->
    
    
    <html>
       <head>
          <title>pcom:d0</title>
          <style>
    /*
    // COMMON_CODE_BLOCK_BEGIN
    */
             html{overflow: scroll;}
             body { font-family: Arial, Helvetica, sans-serif}
             strong{font-size: 18px;}
             canvas { z-index: 8; }
             input[type='range'] {}
             input[type='radio'] {margin-left:0;}
             input[type='checkbox'] {margin-right:7px; margin-left: 0px; padding-left:0px;}
             .group{padding-bottom: 40px;}
             .settings * {z-index: 11; }
             .settings{z-index: 10; margin-left: 30px; display: none; width: 14em; height: 90%; border: solid 1px silver; padding: 2px; overflow-y: scroll; background-color: white }
             .indented{margin-left: 20px; margin-top: 15px; padding-bottom: 0px;} 
             .shownObjectsList{overflow: auto; max-width: 150px; max-height: 150px;}
             .showSettingsButton{display: block; z-index: 12; position: absolute }
             .hideSettingsButton{display: none; z-index: 12; position: absolute; opacity: 0.5}
             .resetButton{margin-top: 20px;}
             button{margin-left: 0;}
             img{cursor: pointer;}
             .suboption{padding-top: 30px;}
             .transparency{display: none;}
             .labelsCheckbox{margin-top: 10px;}
    
    
             input[type=range] {
               -webkit-appearance: none;
               padding:0; 
               width:90%; 
               margin-left: auto;
               margin-right: auto;
               margin-top: 20px;
               display: block;	
             }
             input[type=range]:focus {
               outline: none;
             }
             input[type=range]::-webkit-slider-runnable-track {
               height: 4px;
               cursor: pointer;
               animate: 0.2s;
               box-shadow: 0px 0px 0px #000000;
               background: #E3E3E3;
               border-radius: 0px;
               border: 0px solid #000000;
             }
             input[type=range]::-webkit-slider-thumb {
               box-shadow: 1px 1px 2px #B8B8B8;
               border: 1px solid #ABABAB;
               height: 13px;
               width: 25px;
               border-radius: 20px;
               background: #E0E0E0;
               cursor: pointer;
               -webkit-appearance: none;
               margin-top: -5px;
             }
             input[type=range]:focus::-webkit-slider-runnable-track {
               background: #E3E3E3;
             }
             input[type=range]::-moz-range-track {
               height: 4px;
               cursor: pointer;
               animate: 0.2s;
               box-shadow: 0px 0px 0px #000000;
               background: #E3E3E3;
               border-radius: 0px;
               border: 0px solid #000000;
             }
             input[type=range]::-moz-range-thumb {
               box-shadow: 1px 1px 2px #B8B8B8;
               border: 1px solid #ABABAB;
               height: 13px;
               width: 25px;
               border-radius: 20px;
               background: #E0E0E0;
               cursor: pointer;
             }
             input[type=range]::-ms-track {
               height: 4px;
               cursor: pointer;
               animate: 0.2s;
               background: transparent;
               border-color: transparent;
               color: transparent;
             }
             input[type=range]::-ms-fill-lower {
               background: #E3E3E3;
               border: 0px solid #000000;
               border-radius: 0px;
               box-shadow: 0px 0px 0px #000000;
             }
             input[type=range]::-ms-fill-upper {
               background: #E3E3E3;
               border: 0px solid #000000;
               border-radius: 0px;
               box-shadow: 0px 0px 0px #000000;
             }
             input[type=range]::-ms-thumb {
               box-shadow: 1px 1px 2px #B8B8B8;
               border: 1px solid #ABABAB;
               height: 13px;
               width: 25px;
               border-radius: 20px;
               background: #E0E0E0;
               cursor: pointer;
             }
             input[type=range]:focus::-ms-fill-lower {
               background: #E3E3E3;
             }
             input[type=range]:focus::-ms-fill-upper {
               background: #E3E3E3;
             }
    /*
    // COMMON_CODE_BLOCK_END
    */
    		</style>
       </head>
    
    <body>
    
    		<div id='settings_6' class='settings'>
    			<div class=group id='explode_6'>
    				<strong>Explode</strong>
    				<input id='explodeRange_6' type='range' min=0 max=6 step=0.01 value=0>
    				<div class=indented><input id='explodeCheckbox_6' type='checkbox'>Automatic explosion</div>
    				<div class=suboption>Exploding speed</div>
    				<input id='explodingSpeedRange_6' type='range' min=0 max=0.5 step=0.001 value=0.05>
    			</div>
    
    			
    			<div class=group id='transparency_6' class='transparency'>
    				<strong>Transparency</strong>
    				<input id='transparencyRange_6' type='range' min=0 max=1 step=0.01 value=0>
    			</div>
    			
    			<div class=group id='rotation_6'>
    				<strong>Rotation</strong>
    				<div class=indented>
    					<div><input type='checkbox' id='changeRotationX_6'> x-axis</div>
    					<div><input type='checkbox' id='changeRotationY_6'> y-axis</div>
    					<div><input type='checkbox' id='changeRotationZ_6'> z-axis</div>
    					<button id='resetButton_6' class='resetButton' >Reset</button>
    				</div>
    
    				<div class=suboption>Rotation speed</div>
    				<input id='rotationSpeedRange_6' type='range' min=0 max=5 step=0.01 value=2>
    
    			</div>
    
    
    			<div class=group id='display_6'>
    				<strong>Display</strong>
    				<div class=indented>
    					<div id='shownObjectsList_6' class='shownObjectsList'></div>
    					<div class='labelsCheckbox'><input type='checkbox' id='labelsCheckboxInput_6' checked>Labels</div>
    				</div>
    			</div>
    
    
    			<div class=group id='svg_6'>
    				<strong>SVG</strong>
    				<div class=indented>
    					<form>
    						<input type="radio" name='screenshotMode' value='download' id='download_6' checked> Download<br>
    						<input type="radio" name='screenshotMode' value='tab' id='tab_6' > New tab<br>
    					</form>
    					<button id='takeScreenshot_6'>Screenshot</button>
    				</div>
    			</div>
    
    		</div>	<!-- end of settings -->
    		<img id='hideSettingsButton_6' style="display: none" class='hideSettingsButton' src='/kernelspecs/polymake/close.svg' width=20px">
    		<img id='showSettingsButton_6' class='showSettingsButton' src='/kernelspecs/polymake/menu.svg' width=20px">
    <div id="model99446571701"></div>
    
    <script>
    requirejs.config({
      paths: {
        three: '/kernelspecs/polymake/three',
        Detector: '/kernelspecs/polymake/Detector',
        SVGRenderer: '/kernelspecs/polymake/SVGRenderer',
        CanvasRenderer: '/kernelspecs/polymake/CanvasRenderer',
        Projector: '/kernelspecs/polymake/Projector',
        TrackballControls: '/kernelspecs/polymake/TrackballControls'
      },
      shim: {
        'three':
        {
          exports: 'THREE'
        },
        'Detector':
        {
          deps: [ 'three' ],
          exports: 'Detector'
        },
        'SVGRenderer':
        {
          deps: [ 'three' ],
          exports: 'THREE.SVGRenderer'
        },
        'CanvasRenderer':
        {
          deps: [ 'three' ],
          exports: 'THREE.CanvasRenderer'
        },
        'Projector':
        {
          deps: [ 'three' ],
          exports: 'THREE.Projector'
        },
        'TrackballControls':
        {
          deps: [ 'three' ],
          exports: 'THREE.TrackballControls'
        }
      }
    });
    require(['three'],function(THREE){
        window.THREE = THREE;
      require(['Detector','SVGRenderer','CanvasRenderer','Projector','TrackballControls'],function(Detector,SVGRenderer,CanvasRenderer,Projector,TrackballControls){
          THREE.SVGRenderer = SVGRenderer;
          THREE.CanvasRenderer = CanvasRenderer;
          THREE.Projector = Projector;
          THREE.TrackballControls = TrackballControls;
    
    // COMMON_CODE_BLOCK_BEGIN
    	var foldable = false;
       var container = document.getElementById( 'model99446571701' );
       var renderer = Detector.webgl? new THREE.WebGLRenderer({antialias: true}): new THREE.CanvasRenderer({antialias: true});
    	var svgRenderer = new THREE.SVGRenderer({antialias: true});
                var box = document.getElementsByClassName( 'output_subarea' )[0];
             var notebook = document.getElementById( 'notebook_panel' );
    
       var width = box.clientWidth - 25;
       var height = notebook.clientHeight * 0.8;
       renderer.setSize(width, height);
       svgRenderer.setSize(width, height);
       renderer.setClearColor(0xFFFFFF, 1);
       svgRenderer.setClearColor(0xFFFFFF, 1);
    
       container.appendChild(renderer.domElement);
    
       var scene = new THREE.Scene();
       var camera = new THREE.PerspectiveCamera(75, width/height, 0.1, 1000);
    
       var renderid;
    
       camera.position.set(0, 0, 5);
       camera.lookAt(0, 0, 0);
       camera.up.set(0, 1, 0);
    
       // class to allow move points together with labels and spheres
       var PMPoint = function (x,y,z) {
          this.vector = new THREE.Vector3(x,y,z);
          this.sprite = null;
          this.sphere = null;
       }
       PMPoint.prototype.makelabel = function(label) {
          this.sprite = textSprite( label );
          this.sprite.position.copy(this.vector);
       }
       PMPoint.prototype.makesphere = function(radius,material) {
          this.sphere = new THREE.Mesh(new THREE.SphereGeometry(radius), material);
          this.sphere.position.copy(this.vector);
       }
    
       PMPoint.prototype.setX = function(x) {
          this.vector.setX(x);
          if (this.sprite) {
             this.sprite.position.setX(x);
          }
          if (this.sphere) {
             this.sphere.position.setX(x);
          }
       };
       PMPoint.prototype.setY = function(y) {
          this.vector.setY(y);
          if (this.sprite) {
             this.sprite.position.setY(y);
          }
          if (this.sphere) {
             this.sphere.position.setY(y);
          }
       };
       PMPoint.prototype.setZ = function(z) {
          this.vector.setZ(z);
          if (this.sprite) {
             this.sprite.position.setZ(z);
          }
          if (this.sphere) {
             this.sphere.position.setZ(z);
          }
       };
       PMPoint.prototype.set = function(x,y,z) {
          this.vector.set(x,y,z);
          if (this.sprite) {
             this.sprite.position.set(x,y,z);
          }
          if (this.sphere) {
             this.sphere.position.set(x,y,z);
          }
       };
       PMPoint.prototype.add = function(o) {
          if (this.sprite) {
             o.add(this.sprite);
          }
          if (this.sphere) {
             o.add(this.sphere);
          }
       };
    
    
       var controls = new THREE.TrackballControls(camera, container);
    	controls.zoomSpeed = 0.2;
    	controls.rotateSpeed = 4;
    
       var all_objects = [];
       var centroids = [];
       // select the target node
       var target = document.querySelector('#model99446571701');
    
       // create an observer instance
       var observer = new MutationObserver(function(mutations) {
          mutations.forEach(function(mutation) {
             if (mutation.removedNodes && mutation.removedNodes.length > 0) {
                cancelAnimationFrame(renderId);
                observer.disconnect();
                console.log("cancelled frame "+renderId);
             }
          });
       });
    
       // configuration of the observer:
       var config = { childList: true, characterData: true }
    
       // pass in the target node, as well as the observer options
       while (target) {
          if (target.className=="output") {
             observer.observe(target, config);
             break;
          }
          target = target.parentNode;
       }
    
    // COMMON_CODE_BLOCK_END
    
       var objectnames = ["unnamed__1","unnamed__2","unnamed__3","unnamed__4","unnamed__5","unnamed__6","unnamed__7","unnamed__8","unnamed__9","unnamed__10","unnamed__11","unnamed__12","unnamed__13","unnamed__14","unnamed__15","unnamed__16","unnamed__17","unnamed__18","unnamed__19","unnamed__20","unnamed__21","unnamed__22","unnamed__23","unnamed__24","unnamed__25","unnamed__26","unnamed__27","unnamed__28","unnamed__29","unnamed__30","unnamed__31","unnamed__32","unnamed__33","unnamed__34","unnamed__35","unnamed__36","unnamed__37","unnamed__38","unnamed__39","unnamed__40","unnamed__41","unnamed__42","unnamed__43","unnamed__44","unnamed__45","unnamed__46","unnamed__47","unnamed__48","unnamed__49","unnamed__50","unnamed__51","unnamed__52","unnamed__53","unnamed__54","unnamed__55","unnamed__56","unnamed__57","unnamed__58","unnamed__59","unnamed__60","unnamed__61","unnamed__62","unnamed__63","unnamed__64","unnamed__65","unnamed__66","unnamed__67","unnamed__68","unnamed__69","unnamed__70","unnamed__71","unnamed__72","unnamed__73","unnamed__74","unnamed__75","unnamed__76","unnamed__77","unnamed__78","unnamed__79","unnamed__80","unnamed__81","unnamed__82","unnamed__83","unnamed__84","unnamed__85","unnamed__86","unnamed__87","unnamed__88","unnamed__89","unnamed__90","unnamed__91","unnamed__92","unnamed__93","unnamed__94"];
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0.6, -0.8, 0.128));
       allpoints.push(new PMPoint(0.6, 0.8, 0.128));
       allpoints.push(new PMPoint(-1, 0, 0.2));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 2, 1, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0.6, -0.8, 0.128));
       allpoints.push(new PMPoint(0.6, 0.8, 0.128));
       allpoints.push(new PMPoint(1, 0, 0.0125));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0.6, 0.8, 0.128));
       allpoints.push(new PMPoint(-1, 0, 0.2));
       allpoints.push(new PMPoint(-0.384615, 0.923077, 0.0189349));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0.6, -0.8, 0.128));
       allpoints.push(new PMPoint(-1, 0, 0.2));
       allpoints.push(new PMPoint(-0.384615, -0.923077, 0.0189349));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0.6, -0.8, 0.128));
       allpoints.push(new PMPoint(1, 0, 0.0125));
       allpoints.push(new PMPoint(0.945946, -0.324324, 0.00233747));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0.6, 0.8, 0.128));
       allpoints.push(new PMPoint(1, 0, 0.0125));
       allpoints.push(new PMPoint(0.945946, 0.324324, 0.00233747));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0.6, 0.8, 0.128));
       allpoints.push(new PMPoint(-0.384615, 0.923077, 0.0189349));
       allpoints.push(new PMPoint(0, 1, 0.003125));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-1, 0, 0.2));
       allpoints.push(new PMPoint(-0.384615, 0.923077, 0.0189349));
       allpoints.push(new PMPoint(-0.724138, 0.689655, 0.00237812));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-1, 0, 0.2));
       allpoints.push(new PMPoint(-0.384615, -0.923077, 0.0189349));
       allpoints.push(new PMPoint(-0.724138, -0.689655, 0.00237812));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0.6, -0.8, 0.128));
       allpoints.push(new PMPoint(-0.384615, -0.923077, 0.0189349));
       allpoints.push(new PMPoint(0, -1, 0.003125));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0.6, -0.8, 0.128));
       allpoints.push(new PMPoint(0.945946, -0.324324, 0.00233747));
       allpoints.push(new PMPoint(0.882353, -0.470588, 0.000692042));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(1, 0, 0.0125));
       allpoints.push(new PMPoint(0.945946, -0.324324, 0.00233747));
       allpoints.push(new PMPoint(0.980198, -0.19802, 0.000196059));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(1, 0, 0.0125));
       allpoints.push(new PMPoint(0.945946, 0.324324, 0.00233747));
       allpoints.push(new PMPoint(0.980198, 0.19802, 0.000196059));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0.6, 0.8, 0.128));
       allpoints.push(new PMPoint(0.945946, 0.324324, 0.00233747));
       allpoints.push(new PMPoint(0.882353, 0.470588, 0.000692042));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0.6, 0.8, 0.128));
       allpoints.push(new PMPoint(0, 1, 0.003125));
       allpoints.push(new PMPoint(0.180328, 0.983607, 0.00053749));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-0.384615, 0.923077, 0.0189349));
       allpoints.push(new PMPoint(0, 1, 0.003125));
       allpoints.push(new PMPoint(-0.152941, 0.988235, 0.000276817));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-0.384615, 0.923077, 0.0189349));
       allpoints.push(new PMPoint(-0.724138, 0.689655, 0.00237812));
       allpoints.push(new PMPoint(-0.6, 0.8, 0.0003125));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-1, 0, 0.2));
       allpoints.push(new PMPoint(-0.724138, 0.689655, 0.00237812));
       allpoints.push(new PMPoint(-0.849057, 0.528302, 0.0011392));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-1, 0, 0.2));
       allpoints.push(new PMPoint(-0.724138, -0.689655, 0.00237812));
       allpoints.push(new PMPoint(-0.849057, -0.528302, 0.0011392));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-0.384615, -0.923077, 0.0189349));
       allpoints.push(new PMPoint(-0.724138, -0.689655, 0.00237812));
       allpoints.push(new PMPoint(-0.6, -0.8, 0.0003125));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-0.384615, -0.923077, 0.0189349));
       allpoints.push(new PMPoint(0, -1, 0.003125));
       allpoints.push(new PMPoint(-0.152941, -0.988235, 0.000276817));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0.6, -0.8, 0.128));
       allpoints.push(new PMPoint(0, -1, 0.003125));
       allpoints.push(new PMPoint(0.180328, -0.983607, 0.00053749));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0.6, -0.8, 0.128));
       allpoints.push(new PMPoint(0.882353, -0.470588, 0.000692042));
       allpoints.push(new PMPoint(0.834862, -0.550459, 0.000168336));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0.945946, -0.324324, 0.00233747));
       allpoints.push(new PMPoint(0.882353, -0.470588, 0.000692042));
       allpoints.push(new PMPoint(0.912195, -0.409756, 4.75907e-05));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0.945946, -0.324324, 0.00233747));
       allpoints.push(new PMPoint(0.980198, -0.19802, 0.000196059));
       allpoints.push(new PMPoint(0.969231, -0.246154, 2.95858e-05));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(1, 0, 0.0125));
       allpoints.push(new PMPoint(0.980198, -0.19802, 0.000196059));
       allpoints.push(new PMPoint(0.989848, -0.142132, 8.24551e-05));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(1, 0, 0.0125));
       allpoints.push(new PMPoint(0.980198, 0.19802, 0.000196059));
       allpoints.push(new PMPoint(0.989848, 0.142132, 8.24551e-05));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0.945946, 0.324324, 0.00233747));
       allpoints.push(new PMPoint(0.980198, 0.19802, 0.000196059));
       allpoints.push(new PMPoint(0.969231, 0.246154, 2.95858e-05));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0.945946, 0.324324, 0.00233747));
       allpoints.push(new PMPoint(0.882353, 0.470588, 0.000692042));
       allpoints.push(new PMPoint(0.912195, 0.409756, 4.75907e-05));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0.6, 0.8, 0.128));
       allpoints.push(new PMPoint(0.882353, 0.470588, 0.000692042));
       allpoints.push(new PMPoint(0.834862, 0.550459, 0.000168336));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0.6, 0.8, 0.128));
       allpoints.push(new PMPoint(0.180328, 0.983607, 0.00053749));
       allpoints.push(new PMPoint(0.28, 0.96, 0.00032));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0, 1, 0.003125));
       allpoints.push(new PMPoint(0.180328, 0.983607, 0.00053749));
       allpoints.push(new PMPoint(0.104972, 0.994475, 9.76771e-05));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0, 1, 0.003125));
       allpoints.push(new PMPoint(-0.152941, 0.988235, 0.000276817));
       allpoints.push(new PMPoint(-0.0950226, 0.995475, 6.55187e-05));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-0.384615, 0.923077, 0.0189349));
       allpoints.push(new PMPoint(-0.152941, 0.988235, 0.000276817));
       allpoints.push(new PMPoint(-0.219512, 0.97561, 7.43605e-05));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-0.384615, 0.923077, 0.0189349));
       allpoints.push(new PMPoint(-0.6, 0.8, 0.0003125));
       allpoints.push(new PMPoint(-0.541401, 0.840764, 0.000129823));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-0.724138, 0.689655, 0.00237812));
       allpoints.push(new PMPoint(-0.6, 0.8, 0.0003125));
       allpoints.push(new PMPoint(-0.64878, 0.760976, 7.61452e-05));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-0.724138, 0.689655, 0.00237812));
       allpoints.push(new PMPoint(-0.849057, 0.528302, 0.0011392));
       allpoints.push(new PMPoint(-0.8, 0.6, 7.8125e-05));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-1, 0, 0.2));
       allpoints.push(new PMPoint(-0.849057, 0.528302, 0.0011392));
       allpoints.push(new PMPoint(-0.905882, 0.423529, 0.000276817));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-1, 0, 0.2));
       allpoints.push(new PMPoint(-0.849057, -0.528302, 0.0011392));
       allpoints.push(new PMPoint(-0.905882, -0.423529, 0.000276817));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-0.724138, -0.689655, 0.00237812));
       allpoints.push(new PMPoint(-0.849057, -0.528302, 0.0011392));
       allpoints.push(new PMPoint(-0.8, -0.6, 7.8125e-05));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-0.724138, -0.689655, 0.00237812));
       allpoints.push(new PMPoint(-0.6, -0.8, 0.0003125));
       allpoints.push(new PMPoint(-0.64878, -0.760976, 7.61452e-05));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-0.384615, -0.923077, 0.0189349));
       allpoints.push(new PMPoint(-0.6, -0.8, 0.0003125));
       allpoints.push(new PMPoint(-0.541401, -0.840764, 0.000129823));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-0.384615, -0.923077, 0.0189349));
       allpoints.push(new PMPoint(-0.152941, -0.988235, 0.000276817));
       allpoints.push(new PMPoint(-0.219512, -0.97561, 7.43605e-05));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0, -1, 0.003125));
       allpoints.push(new PMPoint(-0.152941, -0.988235, 0.000276817));
       allpoints.push(new PMPoint(-0.0950226, -0.995475, 6.55187e-05));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0, -1, 0.003125));
       allpoints.push(new PMPoint(0.180328, -0.983607, 0.00053749));
       allpoints.push(new PMPoint(0.104972, -0.994475, 9.76771e-05));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0.6, -0.8, 0.128));
       allpoints.push(new PMPoint(0.180328, -0.983607, 0.00053749));
       allpoints.push(new PMPoint(0.28, -0.96, 0.00032));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0.6, -0.8, 0.128));
       allpoints.push(new PMPoint(0.834862, -0.550459, 0.000168336));
       allpoints.push(new PMPoint(0.8, -0.6, 0.000125));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0.882353, -0.470588, 0.000692042));
       allpoints.push(new PMPoint(0.834862, -0.550459, 0.000168336));
       allpoints.push(new PMPoint(0.856734, -0.515759, 2.62724e-05));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0.882353, -0.470588, 0.000692042));
       allpoints.push(new PMPoint(0.912195, -0.409756, 4.75907e-05));
       allpoints.push(new PMPoint(0.901768, -0.43222, 1.23513e-05));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0.945946, -0.324324, 0.00233747));
       allpoints.push(new PMPoint(0.912195, -0.409756, 4.75907e-05));
       allpoints.push(new PMPoint(0.923077, -0.384615, 1.1557e-05));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0.945946, -0.324324, 0.00233747));
       allpoints.push(new PMPoint(0.969231, -0.246154, 2.95858e-05));
       allpoints.push(new PMPoint(0.963489, -0.267748, 1.31661e-05));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0.980198, -0.19802, 0.000196059));
       allpoints.push(new PMPoint(0.969231, -0.246154, 2.95858e-05));
       allpoints.push(new PMPoint(0.973723, -0.227737, 0));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0.980198, -0.19802, 0.000196059));
       allpoints.push(new PMPoint(0.989848, -0.142132, 8.24551e-05));
       allpoints.push(new PMPoint(0.986207, -0.165517, 0));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(1, 0, 0.0125));
       allpoints.push(new PMPoint(0.989848, -0.142132, 8.24551e-05));
       allpoints.push(new PMPoint(0.993846, -0.110769, 1.89349e-05));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(1, 0, 0.0125));
       allpoints.push(new PMPoint(0.989848, 0.142132, 8.24551e-05));
       allpoints.push(new PMPoint(0.993846, 0.110769, 1.89349e-05));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0.980198, 0.19802, 0.000196059));
       allpoints.push(new PMPoint(0.989848, 0.142132, 8.24551e-05));
       allpoints.push(new PMPoint(0.986207, 0.165517, 0));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0.980198, 0.19802, 0.000196059));
       allpoints.push(new PMPoint(0.969231, 0.246154, 2.95858e-05));
       allpoints.push(new PMPoint(0.973723, 0.227737, 0));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0.945946, 0.324324, 0.00233747));
       allpoints.push(new PMPoint(0.969231, 0.246154, 2.95858e-05));
       allpoints.push(new PMPoint(0.963489, 0.267748, 1.31661e-05));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0.945946, 0.324324, 0.00233747));
       allpoints.push(new PMPoint(0.912195, 0.409756, 4.75907e-05));
       allpoints.push(new PMPoint(0.923077, 0.384615, 1.1557e-05));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0.882353, 0.470588, 0.000692042));
       allpoints.push(new PMPoint(0.912195, 0.409756, 4.75907e-05));
       allpoints.push(new PMPoint(0.901768, 0.43222, 1.23513e-05));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0.882353, 0.470588, 0.000692042));
       allpoints.push(new PMPoint(0.834862, 0.550459, 0.000168336));
       allpoints.push(new PMPoint(0.856734, 0.515759, 2.62724e-05));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0.6, 0.8, 0.128));
       allpoints.push(new PMPoint(0.834862, 0.550459, 0.000168336));
       allpoints.push(new PMPoint(0.8, 0.6, 0.000125));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0.6, 0.8, 0.128));
       allpoints.push(new PMPoint(0.28, 0.96, 0.00032));
       allpoints.push(new PMPoint(0.342282, 0.939597, 0.000144138));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0.180328, 0.983607, 0.00053749));
       allpoints.push(new PMPoint(0.28, 0.96, 0.00032));
       allpoints.push(new PMPoint(0.236593, 0.971609, 3.18443e-05));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0.180328, 0.983607, 0.00053749));
       allpoints.push(new PMPoint(0.104972, 0.994475, 9.76771e-05));
       allpoints.push(new PMPoint(0.132743, 0.99115, 1.56629e-05));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0, 1, 0.003125));
       allpoints.push(new PMPoint(0.104972, 0.994475, 9.76771e-05));
       allpoints.push(new PMPoint(0.0739726, 0.99726, 1.50122e-05));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0, 1, 0.003125));
       allpoints.push(new PMPoint(-0.0950226, 0.995475, 6.55187e-05));
       allpoints.push(new PMPoint(-0.0688836, 0.997625, 1.12841e-05));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-0.152941, 0.988235, 0.000276817));
       allpoints.push(new PMPoint(-0.0950226, 0.995475, 6.55187e-05));
       allpoints.push(new PMPoint(-0.117241, 0.993103, 0));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-0.152941, 0.988235, 0.000276817));
       allpoints.push(new PMPoint(-0.219512, 0.97561, 7.43605e-05));
       allpoints.push(new PMPoint(-0.191753, 0.981443, 1.3604e-05));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-0.384615, 0.923077, 0.0189349));
       allpoints.push(new PMPoint(-0.219512, 0.97561, 7.43605e-05));
       allpoints.push(new PMPoint(-0.256506, 0.966543, 4.42227e-05));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-0.384615, 0.923077, 0.0189349));
       allpoints.push(new PMPoint(-0.541401, 0.840764, 0.000129823));
       allpoints.push(new PMPoint(-0.507692, 0.861538, 2.95858e-05));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-0.6, 0.8, 0.0003125));
       allpoints.push(new PMPoint(-0.541401, 0.840764, 0.000129823));
       allpoints.push(new PMPoint(-0.566161, 0.824295, 1.50573e-05));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-0.6, 0.8, 0.0003125));
       allpoints.push(new PMPoint(-0.64878, 0.760976, 7.61452e-05));
       allpoints.push(new PMPoint(-0.630314, 0.77634, 1.09334e-05));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-0.724138, 0.689655, 0.00237812));
       allpoints.push(new PMPoint(-0.64878, 0.760976, 7.61452e-05));
       allpoints.push(new PMPoint(-0.670103, 0.742268, 2.12562e-05));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-0.724138, 0.689655, 0.00237812));
       allpoints.push(new PMPoint(-0.8, 0.6, 7.8125e-05));
       allpoints.push(new PMPoint(-0.778462, 0.627692, 3.02959e-05));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-0.849057, 0.528302, 0.0011392));
       allpoints.push(new PMPoint(-0.8, 0.6, 7.8125e-05));
       allpoints.push(new PMPoint(-0.81864, 0.574307, 2.03034e-05));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-0.849057, 0.528302, 0.0011392));
       allpoints.push(new PMPoint(-0.905882, 0.423529, 0.000276817));
       allpoints.push(new PMPoint(-0.882353, 0.470588, 4.32526e-05));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-1, 0, 0.2));
       allpoints.push(new PMPoint(-0.905882, 0.423529, 0.000276817));
       allpoints.push(new PMPoint(-0.936, 0.352, 0.000128));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-1, 0, 0.2));
       allpoints.push(new PMPoint(-0.905882, -0.423529, 0.000276817));
       allpoints.push(new PMPoint(-0.936, -0.352, 0.000128));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-0.849057, -0.528302, 0.0011392));
       allpoints.push(new PMPoint(-0.905882, -0.423529, 0.000276817));
       allpoints.push(new PMPoint(-0.882353, -0.470588, 4.32526e-05));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-0.849057, -0.528302, 0.0011392));
       allpoints.push(new PMPoint(-0.8, -0.6, 7.8125e-05));
       allpoints.push(new PMPoint(-0.81864, -0.574307, 2.03034e-05));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-0.724138, -0.689655, 0.00237812));
       allpoints.push(new PMPoint(-0.8, -0.6, 7.8125e-05));
       allpoints.push(new PMPoint(-0.778462, -0.627692, 3.02959e-05));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-0.724138, -0.689655, 0.00237812));
       allpoints.push(new PMPoint(-0.64878, -0.760976, 7.61452e-05));
       allpoints.push(new PMPoint(-0.670103, -0.742268, 2.12562e-05));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-0.6, -0.8, 0.0003125));
       allpoints.push(new PMPoint(-0.64878, -0.760976, 7.61452e-05));
       allpoints.push(new PMPoint(-0.630314, -0.77634, 1.09334e-05));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-0.6, -0.8, 0.0003125));
       allpoints.push(new PMPoint(-0.541401, -0.840764, 0.000129823));
       allpoints.push(new PMPoint(-0.566161, -0.824295, 1.50573e-05));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-0.384615, -0.923077, 0.0189349));
       allpoints.push(new PMPoint(-0.541401, -0.840764, 0.000129823));
       allpoints.push(new PMPoint(-0.507692, -0.861538, 2.95858e-05));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-0.384615, -0.923077, 0.0189349));
       allpoints.push(new PMPoint(-0.219512, -0.97561, 7.43605e-05));
       allpoints.push(new PMPoint(-0.256506, -0.966543, 4.42227e-05));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-0.152941, -0.988235, 0.000276817));
       allpoints.push(new PMPoint(-0.219512, -0.97561, 7.43605e-05));
       allpoints.push(new PMPoint(-0.191753, -0.981443, 1.3604e-05));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-0.152941, -0.988235, 0.000276817));
       allpoints.push(new PMPoint(-0.0950226, -0.995475, 6.55187e-05));
       allpoints.push(new PMPoint(-0.117241, -0.993103, 0));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0, -1, 0.003125));
       allpoints.push(new PMPoint(-0.0950226, -0.995475, 6.55187e-05));
       allpoints.push(new PMPoint(-0.0688836, -0.997625, 1.12841e-05));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0, -1, 0.003125));
       allpoints.push(new PMPoint(0.104972, -0.994475, 9.76771e-05));
       allpoints.push(new PMPoint(0.0739726, -0.99726, 1.50122e-05));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0.180328, -0.983607, 0.00053749));
       allpoints.push(new PMPoint(0.104972, -0.994475, 9.76771e-05));
       allpoints.push(new PMPoint(0.132743, -0.99115, 1.56629e-05));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0.180328, -0.983607, 0.00053749));
       allpoints.push(new PMPoint(0.28, -0.96, 0.00032));
       allpoints.push(new PMPoint(0.236593, -0.971609, 3.18443e-05));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0.6, -0.8, 0.128));
       allpoints.push(new PMPoint(0.28, -0.96, 0.00032));
       allpoints.push(new PMPoint(0.342282, -0.939597, 0.000144138));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
    // COMMON_CODE_BLOCK_BEGIN
    var xRotationEnabled = false;
    var yRotationEnabled = false;
    var zRotationEnabled = false;
    var rotationSpeedFactor = 1;
    var settingsShown = false;
    var labelsShown = true;
    var intervals = [];
    var timeouts = [];
    var explodingSpeed = 0.05;
    var explodeScale = 0;
    var XMLS = new XMLSerializer();
    var svgElement;
    var renderId;
    
    	var render = function () {
    
    		renderId = requestAnimationFrame(render);
    
    //		comment in for automatic explosion
    //		explode(updateFactor());
    
    		var phi = 0.02 * rotationSpeedFactor;
    
    		if (xRotationEnabled){
    			scene.rotation.x += phi;
    		}
    		if(yRotationEnabled){
    			scene.rotation.y += phi;
    		}
    		if(zRotationEnabled){
    			scene.rotation.z += phi;
    		}
    
    		controls.update();
    		renderer.render(scene, camera);
    	};
    
    	render();
    
    	function computeCentroid(geom) {
    		centroid = new THREE.Vector3();
    		geom.vertices.forEach(function(v) {
    			centroid.add(v);			
    		});
    		centroid.divideScalar(geom.vertices.length);
    		return centroid;
    	}
    
    	function changeTransparency(event){
    		var opacity = 1-Number(event.currentTarget.value);
    		for (var i=0; i<all_objects.length; i++){
    			for (var j=0; j<all_objects[i].children.length; j++){
    				if (all_objects[i].children[j].material.type == "MultiMaterial") {
    					for (var k=0; k<all_objects[i].children[j].material.materials.length; k++){
    						all_objects[i].children[j].material.materials[k].opacity = opacity;
    						all_objects[i].children[j].material.materials[k].depthWrite = opacity < 0.5 ? false : true;
    						all_objects[i].children[j].material.materials[k].depthTest = opacity < 0.5 ? false : true;
    					}
    				} else if (all_objects[i].children[j].material.transparent && 
    							  all_objects[i].children[j].material.type == "MeshBasicMaterial" &&
    							  all_objects[i].children[j].geometry.type == "Geometry"){
    					all_objects[i].children[j].material.opacity = opacity;
    					all_objects[i].children[j].material.depthWrite = opacity < 0.5 ? false : true;
    					all_objects[i].children[j].material.depthTest = opacity < 0.5 ? false : true;
    				}
    			}
    		}
    	}
    
    	function changeRotationX(event){
    		xRotationEnabled = event.currentTarget.checked;
    	}	
    
    	function changeRotationY(event){
    		yRotationEnabled = event.currentTarget.checked;
    	}	
    
    	function changeRotationZ(event){
    		zRotationEnabled = event.currentTarget.checked;
    	}	
    
    
    	function changeRotationSpeedFactor(event){
    		rotationSpeedFactor = Number(event.currentTarget.value);
    	}
    
    	function resetScene(){
    		scene.rotation.set(0,0,0);
    		camera.position.set(0,0,5);
    		camera.up.set(0,1,0);
    	}
    
    	function showSettings(event){
    		event.currentTarget.style.display = 'none';
    		document.getElementById('settings_6').style.position = 'absolute';
    		document.getElementById('settings_6').style.display = 'block';
    		document.getElementById('showSettingsButton_6').style.display = 'none';
    		document.getElementById('hideSettingsButton_6').style.display = 'block';
    		settingsShown = true;
    	}
    
    	function hideSettings(event){
    		event.currentTarget.style.display = 'none';
    		document.getElementById('settings_6').style.display = 'none';
    		document.getElementById('hideSettingsButton_6').style.display = 'none';
    		document.getElementById('showSettingsButton_6').style.display = 'block';
    		settingsShown = false;
    	}
    
    
    
    	var pos = 150* Math.PI;
    
    	function updateFactor() {
    		pos++;
    		return Math.sin(.01*pos)+1;
    	}
    
    	function makelabel(message, x, y, z, params) {
    		var spritey = textSprite( message, params );
    		spritey.position.set(x, y, z);
    		obj.add(spritey);
    	}
    
    	function textSprite(message, parameters)
    	{
    		if ( parameters === undefined ) parameters = {};
    
    		var fontface = "Helvetica";
    
    		var fontsize = parameters.hasOwnProperty("fontsize") ? 
    			parameters["fontsize"] : 18;
    		fontsize = fontsize*10;
    
    		var canvas = document.createElement('canvas');
    		var size = 1024;
    		canvas.width = size;
    		canvas.height = size;
    		var context = canvas.getContext('2d');
    		context.font = fontsize + "px " + fontface;
    
    		// text color
    		context.fillStyle = "rgba(0, 0, 0, 1.0)";
    
    		context.fillText(message, size/2, size/2);
    
    		// canvas contents will be used for a texture
    		var texture = new THREE.Texture(canvas);
    		texture.needsUpdate = true;
    
    		var spriteMaterial = new THREE.SpriteMaterial(
    			{map: texture, useScreenCoordinates: false});
    		var sprite = new THREE.Sprite(spriteMaterial);
    		return sprite;
    	}
    
    	function takeSvgScreenshot(){
    		if (labelsShown){
    			hideLabels();
    		}
    		svgRenderer.render(scene,camera);
    		svgElement = XMLS.serializeToString(svgRenderer.domElement);
    		
    		if (labelsShown){
    			displayLabels();
    		}
    
    		if (document.getElementById('tab_6').checked){
    			//show in new tab
    			var myWindow = window.open("","");
    			myWindow.document.body.innerHTML = svgElement;
    		} else{
    			// download svg file 
    			download("screenshot.svg", svgElement);
    		}
    	}
    		
    
    	function showOrHideObject(event){
    		var nr = Number(event.currentTarget.name);
    		all_objects[nr].visible = event.currentTarget.checked;
    	}
    
    
    	function displayOrHideOptions(){
    		for (var i=0; i<all_objects.length; i++){
    			for (var j=0; j<all_objects[i].children.length; j++){
    				if (all_objects[i].children[j].material.type == "MultiMaterial") {
    					for (var k=0; k<all_objects[i].children[j].material.materials.length; k++){
    						if (all_objects[i].children[j].material.materials[k].transparent) {
    							document.getElementById('transparency_6').style.display = 'block';
    							document.getElementById('transparencyRange_6').value = 1 - 
    							    all_objects[i].children[j].material.materials[k].opacity;
    							return;
    						}
    					}
    				} else if (all_objects[i].children[j].material.transparent && 
    							  all_objects[i].children[j].material.type == "MeshBasicMaterial" &&
    							  all_objects[i].children[j].geometry.type == "Geometry"){
    					document.getElementById('transparency_6').style.display = 'block';
    					return;
    				}
    			}
    		}
    	}
    
    	displayOrHideOptions()
    
    
    
    
    // ---------------------- EXPLOSION ------------------------------------------------
    // ---------------------------------------------------------------------------------
    
    	function explode(factor) {
    		var obj, c;
    		var c0 = centroids[0];
    		for (var i = 0; i<centroids.length; ++i) {
    			c = centroids[i];
    			obj = all_objects[all_objects.length - centroids.length + i];
    			obj.position.set(c.x*factor, c.y*factor, c.z*factor);
    		}	
    	}
    
    	function triggerExplode(event){
    		explodeScale = Number(event.currentTarget.value);
    		explode(explodeScale);
    	}
    
    	function setExplodingSpeed(event){
    		explodingSpeed = Number(event.currentTarget.value);
    	}
    
    	function triggerAutomaticExplode(event){
    		if (event.currentTarget.checked){
    			startExploding();
    		} else {
    			clearIntervals();
    		}	
    	}
    
    	function startExploding(){
    		intervals.push(setInterval(explodingInterval, 25));
    	}
    
    
    	function explodingInterval(){
    		explodeScale += explodingSpeed;
    		if (explodeScale <= 6){ 
    			explode(explodeScale);
    		}
    		else{
    			explode(6);
    			explodeScale = 6;
    			clearIntervals();
    			timeouts.push(setTimeout(startUnexploding, 3000));
    		}
    		document.getElementById('explodeRange_6').value = explodeScale;
    	}
    
    
    	function startUnexploding(){
    		intervals.push(setInterval(unexplodingInterval, 25));
    	}
    
    	function unexplodingInterval(){
    		explodeScale -= explodingSpeed;
    		if (explodeScale >= 0){	
    			explode(explodeScale);
    		}
    		else {
    			explode(0);
    			explodeScale = 0;
    			clearIntervals();
    			timeouts.push(setTimeout(startExploding, 3000));
    		}
    		document.getElementById('explodeRange_6').value = explodeScale;
    	}
    
    	function clearIntervals(){
    		intervals.forEach(function(interval){
    			clearInterval(interval);
    		});
    		intervals = [];
    		timeouts.forEach(function(timeout){
    			clearTimeout(timeout);
    		});
    		timeouts = [];
    	}
    
    			
    
    	// append checkboxes for displaying or hiding objects
    	var shownObjectsList = document.getElementById('shownObjectsList_6');
    	for (var i=0; i<all_objects.length; i++){
    		var objNode = document.createElement('span');
    		objNode.innerHTML = objectnames[i] + '<br>';
    		var checkbox = document.createElement('input');
    		checkbox.type = 'checkbox';
    		checkbox.checked = true;
    		checkbox.name = String(i);
    		checkbox.onchange = showOrHideObject;
    		shownObjectsList.appendChild(checkbox);
    		shownObjectsList.appendChild(objNode);
    	}
    
    	function displayLabels(){
    		for (var i=0; i<all_objects.length; i++){
    			for (var j=0; j<all_objects[i].children.length; j++){
    				var child = all_objects[i].children[j];
    				if (child.type == 'Sprite'){
    					child.visible = true;
    				}
    			}
    		}
    	}
    
    	function hideLabels(){
    		for (var i=0; i<all_objects.length; i++){
    			for (var j=0; j<all_objects[i].children.length; j++){
    				var child = all_objects[i].children[j];
    				if (child.type == 'Sprite'){
    					child.visible = false;
    				}
    			}
    		}
    	}
    
    	function displayOrHideLabels(event){
    		if (event.currentTarget.checked){
    			displayLabels();
    			labelsShown = true;
    		} else {
    			hideLabels();
    			labelsShown = false;
    		}
    	}
    
    	function download(filename, text) {
    	  var element = document.createElement('a');
    	  element.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(text));
    	  element.setAttribute('download', filename);
    
    	  element.style.display = 'none';
    	  document.body.appendChild(element);
    
    	  element.click();
    
    	  document.body.removeChild(element);
    	}
    
    var tempobj;
    tempobj = document.getElementById('explodeRange_6');
    if (tempobj) {
       tempobj.oninput = triggerExplode;
       document.getElementById('explodeCheckbox_6').onchange = triggerAutomaticExplode;
       document.getElementById('explodingSpeedRange_6').oninput = setExplodingSpeed;
    }
    tempobj = document.getElementById('foldRange_6');
    if (tempobj) {
       tempobj.oninput = fold;
    }
    document.getElementById('transparencyRange_6').oninput = changeTransparency;
    document.getElementById('changeRotationX_6').onchange = changeRotationX;
    document.getElementById('changeRotationY_6').onchange = changeRotationY;
    document.getElementById('changeRotationZ_6').onchange = changeRotationZ;
    document.getElementById('resetButton_6').onclick = resetScene;
    document.getElementById('rotationSpeedRange_6').oninput = changeRotationSpeedFactor;
    document.getElementById('labelsCheckboxInput_6').onchange = displayOrHideLabels;
    document.getElementById('takeScreenshot_6').onclick = takeSvgScreenshot;
    document.getElementById('showSettingsButton_6').onclick = showSettings;
    document.getElementById('hideSettingsButton_6').onclick = hideSettings;
    
    	
    
    // ------------------ SHORTCUTS --------------------------------------------
    // -------------------------------------------------------------------------
    
    /**
     * http://www.openjs.com/scripts/events/keyboard_shortcuts/
     * Version : 2.01.B
     * By Binny V A
     * License : BSD
     */
    shortcut = {
    	'all_shortcuts':{},//All the shortcuts are stored in this array
    	'add': function(shortcut_combination,callback,opt) {
    		//Provide a set of default options
    		var default_options = {
    			'type':'keydown',
    			'propagate':false,
    			'disable_in_input':false,
    			'target':document,
    			'keycode':false
    		}
    		if(!opt) opt = default_options;
    		else {
    			for(var dfo in default_options) {
    				if(typeof opt[dfo] == 'undefined') opt[dfo] = default_options[dfo];
    			}
    		}
    
    		var ele = opt.target;
    		if(typeof opt.target == 'string') ele = document.getElementById(opt.target);
    		var ths = this;
    		shortcut_combination = shortcut_combination.toLowerCase();
    
    		//The function to be called at keypress
    		var func = function(e) {
    			e = e || window.event;
    			
    			if(opt['disable_in_input']) { //Don't enable shortcut keys in Input, Textarea fields
    				var element;
    				if(e.target) element=e.target;
    				else if(e.srcElement) element=e.srcElement;
    				if(element.nodeType==3) element=element.parentNode;
    
    				if(element.tagName == 'INPUT' || element.tagName == 'TEXTAREA') return;
    			}
    	
    			//Find Which key is pressed
    			if (e.keyCode) code = e.keyCode;
    			else if (e.which) code = e.which;
    			var character = String.fromCharCode(code).toLowerCase();
    			
    			if(code == 188) character=","; //If the user presses , when the type is onkeydown
    			if(code == 190) character="."; //If the user presses , when the type is onkeydown
    
    			var keys = shortcut_combination.split("+");
    			//Key Pressed - counts the number of valid keypresses - if it is same as the number of keys, the shortcut function is invoked
    			var kp = 0;
    			
    			//Work around for stupid Shift key bug created by using lowercase - as a result the shift+num combination was broken
    			var shift_nums = {
    				"`":"~",
    				"1":"!",
    				"2":"@",
    				"3":"#",
    				"4":"$",
    				"5":"%",
    				"6":"^",
    				"7":"&",
    				"8":"*",
    				"9":"(",
    				"0":")",
    				"-":"_",
    				"=":"+",
    				";":":",
    				"'":"\"",
    				",":"<",
    				".":">",
    				"/":"?",
    				"\\":"|"
    			}
    			//Special Keys - and their codes
    			var special_keys = {
    				'esc':27,
    				'escape':27,
    				'tab':9,
    				'space':32,
    				'return':13,
    				'enter':13,
    				'backspace':8,
    	
    				'scrolllock':145,
    				'scroll_lock':145,
    				'scroll':145,
    				'capslock':20,
    				'caps_lock':20,
    				'caps':20,
    				'numlock':144,
    				'num_lock':144,
    				'num':144,
    				
    				'pause':19,
    				'break':19,
    				
    				'insert':45,
    				'home':36,
    				'delete':46,
    				'end':35,
    				
    				'pageup':33,
    				'page_up':33,
    				'pu':33,
    	
    				'pagedown':34,
    				'page_down':34,
    				'pd':34,
    	
    				'left':37,
    				'up':38,
    				'right':39,
    				'down':40,
    	
    				'f1':112,
    				'f2':113,
    				'f3':114,
    				'f4':115,
    				'f5':116,
    				'f6':117,
    				'f7':118,
    				'f8':119,
    				'f9':120,
    				'f10':121,
    				'f11':122,
    				'f12':123
    			}
    	
    			var modifiers = { 
    				shift: { wanted:false, pressed:false},
    				ctrl : { wanted:false, pressed:false},
    				alt  : { wanted:false, pressed:false},
    				meta : { wanted:false, pressed:false}	//Meta is Mac specific
    			};
                            
    			if(e.ctrlKey)	modifiers.ctrl.pressed = true;
    			if(e.shiftKey)	modifiers.shift.pressed = true;
    			if(e.altKey)	modifiers.alt.pressed = true;
    			if(e.metaKey)   modifiers.meta.pressed = true;
                            
    			for(var i=0; k=keys[i],i<keys.length; i++) {
    				//Modifiers
    				if(k == 'ctrl' || k == 'control') {
    					kp++;
    					modifiers.ctrl.wanted = true;
    
    				} else if(k == 'shift') {
    					kp++;
    					modifiers.shift.wanted = true;
    
    				} else if(k == 'alt') {
    					kp++;
    					modifiers.alt.wanted = true;
    				} else if(k == 'meta') {
    					kp++;
    					modifiers.meta.wanted = true;
    				} else if(k.length > 1) { //If it is a special key
    					if(special_keys[k] == code) kp++;
    					
    				} else if(opt['keycode']) {
    					if(opt['keycode'] == code) kp++;
    
    				} else { //The special keys did not match
    					if(character == k) kp++;
    					else {
    						if(shift_nums[character] && e.shiftKey) { //Stupid Shift key bug created by using lowercase
    							character = shift_nums[character]; 
    							if(character == k) kp++;
    						}
    					}
    				}
    			}
    			
    			if(kp == keys.length && 
    						modifiers.ctrl.pressed == modifiers.ctrl.wanted &&
    						modifiers.shift.pressed == modifiers.shift.wanted &&
    						modifiers.alt.pressed == modifiers.alt.wanted &&
    						modifiers.meta.pressed == modifiers.meta.wanted) {
    				callback(e);
    	
    				if(!opt['propagate']) { //Stop the event
    					//e.cancelBubble is supported by IE - this will kill the bubbling process.
    					e.cancelBubble = true;
    					e.returnValue = false;
    	
    					//e.stopPropagation works in Firefox.
    					if (e.stopPropagation) {
    						e.stopPropagation();
    						e.preventDefault();
    					}
    					return false;
    				}
    			}
    		}
    		this.all_shortcuts[shortcut_combination] = {
    			'callback':func, 
    			'target':ele, 
    			'event': opt['type']
    		};
    		//Attach the function with the event
    		if(ele.addEventListener) ele.addEventListener(opt['type'], func, false);
    		else if(ele.attachEvent) ele.attachEvent('on'+opt['type'], func);
    		else ele['on'+opt['type']] = func;
    	},
    
    	//Remove the shortcut - just specify the shortcut and I will remove the binding
    	'remove':function(shortcut_combination) {
    		shortcut_combination = shortcut_combination.toLowerCase();
    		var binding = this.all_shortcuts[shortcut_combination];
    		delete(this.all_shortcuts[shortcut_combination])
    		if(!binding) return;
    		var type = binding['event'];
    		var ele = binding['target'];
    		var callback = binding['callback'];
    
    		if(ele.detachEvent) ele.detachEvent('on'+type, callback);
    		else if(ele.removeEventListener) ele.removeEventListener(type, callback, false);
    		else ele['on'+type] = false;
    	}
    }
    
    shortcut.add("Alt+Left",function() {
    	var event = new Event('click');
    	if (settingsShown){
    		document.getElementById('hideSettingsButton_6').dispatchEvent(event);
    	} else{
    		document.getElementById('showSettingsButton_6').dispatchEvent(event);
    	}
    });
    
    if (foldable) moveToBaryCenter();
    
    
    });});
    // COMMON_CODE_BLOCK_END
    </script>
    
    </body>
    </html>



.. link

.. CODE-BLOCK:: perl

    polymake> $s = new HyperbolicSurface(DCEL_DATA=>$T3, PENNER_COORDINATES=>[2,1,1,1,1,1,1,1,1], SPECIAL_POINT=>[new Rational(1.5196714),new Rational(-0.5773503)]);
    polymake> $p = secondary_polyhedron($s,7);
    polymake> $p->VISUAL(FacetColor=>'255 180 80');


.. raw:: html

    <!--
    polymake for loewe
    Fri Feb  9 13:50:25 2018
    p_bounded
    -->
    
    
    <html>
       <head>
          <title>p_bounded</title>
          <style>
    /*
    // COMMON_CODE_BLOCK_BEGIN
    */
             html{overflow: scroll;}
             body { font-family: Arial, Helvetica, sans-serif}
             strong{font-size: 18px;}
             canvas { z-index: 8; }
             input[type='range'] {}
             input[type='radio'] {margin-left:0;}
             input[type='checkbox'] {margin-right:7px; margin-left: 0px; padding-left:0px;}
             .group{padding-bottom: 40px;}
             .settings * {z-index: 11; }
             .settings{z-index: 10; margin-left: 30px; display: none; width: 14em; height: 90%; border: solid 1px silver; padding: 2px; overflow-y: scroll; background-color: white }
             .indented{margin-left: 20px; margin-top: 15px; padding-bottom: 0px;} 
             .shownObjectsList{overflow: auto; max-width: 150px; max-height: 150px;}
             .showSettingsButton{display: block; z-index: 12; position: absolute }
             .hideSettingsButton{display: none; z-index: 12; position: absolute; opacity: 0.5}
             .resetButton{margin-top: 20px;}
             button{margin-left: 0;}
             img{cursor: pointer;}
             .suboption{padding-top: 30px;}
             .transparency{display: none;}
             .labelsCheckbox{margin-top: 10px;}
    
    
             input[type=range] {
               -webkit-appearance: none;
               padding:0; 
               width:90%; 
               margin-left: auto;
               margin-right: auto;
               margin-top: 20px;
               display: block;	
             }
             input[type=range]:focus {
               outline: none;
             }
             input[type=range]::-webkit-slider-runnable-track {
               height: 4px;
               cursor: pointer;
               animate: 0.2s;
               box-shadow: 0px 0px 0px #000000;
               background: #E3E3E3;
               border-radius: 0px;
               border: 0px solid #000000;
             }
             input[type=range]::-webkit-slider-thumb {
               box-shadow: 1px 1px 2px #B8B8B8;
               border: 1px solid #ABABAB;
               height: 13px;
               width: 25px;
               border-radius: 20px;
               background: #E0E0E0;
               cursor: pointer;
               -webkit-appearance: none;
               margin-top: -5px;
             }
             input[type=range]:focus::-webkit-slider-runnable-track {
               background: #E3E3E3;
             }
             input[type=range]::-moz-range-track {
               height: 4px;
               cursor: pointer;
               animate: 0.2s;
               box-shadow: 0px 0px 0px #000000;
               background: #E3E3E3;
               border-radius: 0px;
               border: 0px solid #000000;
             }
             input[type=range]::-moz-range-thumb {
               box-shadow: 1px 1px 2px #B8B8B8;
               border: 1px solid #ABABAB;
               height: 13px;
               width: 25px;
               border-radius: 20px;
               background: #E0E0E0;
               cursor: pointer;
             }
             input[type=range]::-ms-track {
               height: 4px;
               cursor: pointer;
               animate: 0.2s;
               background: transparent;
               border-color: transparent;
               color: transparent;
             }
             input[type=range]::-ms-fill-lower {
               background: #E3E3E3;
               border: 0px solid #000000;
               border-radius: 0px;
               box-shadow: 0px 0px 0px #000000;
             }
             input[type=range]::-ms-fill-upper {
               background: #E3E3E3;
               border: 0px solid #000000;
               border-radius: 0px;
               box-shadow: 0px 0px 0px #000000;
             }
             input[type=range]::-ms-thumb {
               box-shadow: 1px 1px 2px #B8B8B8;
               border: 1px solid #ABABAB;
               height: 13px;
               width: 25px;
               border-radius: 20px;
               background: #E0E0E0;
               cursor: pointer;
             }
             input[type=range]:focus::-ms-fill-lower {
               background: #E3E3E3;
             }
             input[type=range]:focus::-ms-fill-upper {
               background: #E3E3E3;
             }
    /*
    // COMMON_CODE_BLOCK_END
    */
    		</style>
       </head>
    
    <body>
    
    		<div id='settings_7' class='settings'>
    			<div class=group id='transparency_7' class='transparency'>
    				<strong>Transparency</strong>
    				<input id='transparencyRange_7' type='range' min=0 max=1 step=0.01 value=0>
    			</div>
    			
    			<div class=group id='rotation_7'>
    				<strong>Rotation</strong>
    				<div class=indented>
    					<div><input type='checkbox' id='changeRotationX_7'> x-axis</div>
    					<div><input type='checkbox' id='changeRotationY_7'> y-axis</div>
    					<div><input type='checkbox' id='changeRotationZ_7'> z-axis</div>
    					<button id='resetButton_7' class='resetButton' >Reset</button>
    				</div>
    
    				<div class=suboption>Rotation speed</div>
    				<input id='rotationSpeedRange_7' type='range' min=0 max=5 step=0.01 value=2>
    
    			</div>
    
    
    			<div class=group id='display_7'>
    				<strong>Display</strong>
    				<div class=indented>
    					<div id='shownObjectsList_7' class='shownObjectsList'></div>
    					<div class='labelsCheckbox'><input type='checkbox' id='labelsCheckboxInput_7' checked>Labels</div>
    				</div>
    			</div>
    
    
    			<div class=group id='svg_7'>
    				<strong>SVG</strong>
    				<div class=indented>
    					<form>
    						<input type="radio" name='screenshotMode' value='download' id='download_7' checked> Download<br>
    						<input type="radio" name='screenshotMode' value='tab' id='tab_7' > New tab<br>
    					</form>
    					<button id='takeScreenshot_7'>Screenshot</button>
    				</div>
    			</div>
    
    		</div>	<!-- end of settings -->
    		<img id='hideSettingsButton_7' style="display: none" class='hideSettingsButton' src='/kernelspecs/polymake/close.svg' width=20px">
    		<img id='showSettingsButton_7' class='showSettingsButton' src='/kernelspecs/polymake/menu.svg' width=20px">
    <div id="model36974003472"></div>
    
    <script>
    requirejs.config({
      paths: {
        three: '/kernelspecs/polymake/three',
        Detector: '/kernelspecs/polymake/Detector',
        SVGRenderer: '/kernelspecs/polymake/SVGRenderer',
        CanvasRenderer: '/kernelspecs/polymake/CanvasRenderer',
        Projector: '/kernelspecs/polymake/Projector',
        TrackballControls: '/kernelspecs/polymake/TrackballControls'
      },
      shim: {
        'three':
        {
          exports: 'THREE'
        },
        'Detector':
        {
          deps: [ 'three' ],
          exports: 'Detector'
        },
        'SVGRenderer':
        {
          deps: [ 'three' ],
          exports: 'THREE.SVGRenderer'
        },
        'CanvasRenderer':
        {
          deps: [ 'three' ],
          exports: 'THREE.CanvasRenderer'
        },
        'Projector':
        {
          deps: [ 'three' ],
          exports: 'THREE.Projector'
        },
        'TrackballControls':
        {
          deps: [ 'three' ],
          exports: 'THREE.TrackballControls'
        }
      }
    });
    require(['three'],function(THREE){
        window.THREE = THREE;
      require(['Detector','SVGRenderer','CanvasRenderer','Projector','TrackballControls'],function(Detector,SVGRenderer,CanvasRenderer,Projector,TrackballControls){
          THREE.SVGRenderer = SVGRenderer;
          THREE.CanvasRenderer = CanvasRenderer;
          THREE.Projector = Projector;
          THREE.TrackballControls = TrackballControls;
    
    // COMMON_CODE_BLOCK_BEGIN
    	var foldable = false;
       var container = document.getElementById( 'model36974003472' );
       var renderer = Detector.webgl? new THREE.WebGLRenderer({antialias: true}): new THREE.CanvasRenderer({antialias: true});
    	var svgRenderer = new THREE.SVGRenderer({antialias: true});
                var box = document.getElementsByClassName( 'output_subarea' )[0];
             var notebook = document.getElementById( 'notebook_panel' );
    
       var width = box.clientWidth - 25;
       var height = notebook.clientHeight * 0.8;
       renderer.setSize(width, height);
       svgRenderer.setSize(width, height);
       renderer.setClearColor(0xFFFFFF, 1);
       svgRenderer.setClearColor(0xFFFFFF, 1);
    
       container.appendChild(renderer.domElement);
    
       var scene = new THREE.Scene();
       var camera = new THREE.PerspectiveCamera(75, width/height, 0.1, 1000);
    
       var renderid;
    
       camera.position.set(0, 0, 5);
       camera.lookAt(0, 0, 0);
       camera.up.set(0, 1, 0);
    
       // class to allow move points together with labels and spheres
       var PMPoint = function (x,y,z) {
          this.vector = new THREE.Vector3(x,y,z);
          this.sprite = null;
          this.sphere = null;
       }
       PMPoint.prototype.makelabel = function(label) {
          this.sprite = textSprite( label );
          this.sprite.position.copy(this.vector);
       }
       PMPoint.prototype.makesphere = function(radius,material) {
          this.sphere = new THREE.Mesh(new THREE.SphereGeometry(radius), material);
          this.sphere.position.copy(this.vector);
       }
    
       PMPoint.prototype.setX = function(x) {
          this.vector.setX(x);
          if (this.sprite) {
             this.sprite.position.setX(x);
          }
          if (this.sphere) {
             this.sphere.position.setX(x);
          }
       };
       PMPoint.prototype.setY = function(y) {
          this.vector.setY(y);
          if (this.sprite) {
             this.sprite.position.setY(y);
          }
          if (this.sphere) {
             this.sphere.position.setY(y);
          }
       };
       PMPoint.prototype.setZ = function(z) {
          this.vector.setZ(z);
          if (this.sprite) {
             this.sprite.position.setZ(z);
          }
          if (this.sphere) {
             this.sphere.position.setZ(z);
          }
       };
       PMPoint.prototype.set = function(x,y,z) {
          this.vector.set(x,y,z);
          if (this.sprite) {
             this.sprite.position.set(x,y,z);
          }
          if (this.sphere) {
             this.sphere.position.set(x,y,z);
          }
       };
       PMPoint.prototype.add = function(o) {
          if (this.sprite) {
             o.add(this.sprite);
          }
          if (this.sphere) {
             o.add(this.sphere);
          }
       };
    
    
       var controls = new THREE.TrackballControls(camera, container);
    	controls.zoomSpeed = 0.2;
    	controls.rotateSpeed = 4;
    
       var all_objects = [];
       var centroids = [];
       // select the target node
       var target = document.querySelector('#model36974003472');
    
       // create an observer instance
       var observer = new MutationObserver(function(mutations) {
          mutations.forEach(function(mutation) {
             if (mutation.removedNodes && mutation.removedNodes.length > 0) {
                cancelAnimationFrame(renderId);
                observer.disconnect();
                console.log("cancelled frame "+renderId);
             }
          });
       });
    
       // configuration of the observer:
       var config = { childList: true, characterData: true }
    
       // pass in the target node, as well as the observer options
       while (target) {
          if (target.className=="output") {
             observer.observe(target, config);
             break;
          }
          target = target.parentNode;
       }
    
    // COMMON_CODE_BLOCK_END
    
       var objectnames = ["p_bounded"];
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0.120339, 0.120455, 0.777622));
       allpoints.push(new PMPoint(0.150264, 0.150243, 0.760835));
       allpoints.push(new PMPoint(0.22754, -0.43769, 0.717368));
       allpoints.push(new PMPoint(0.22748, 0.0136946, 0.71748));
       allpoints.push(new PMPoint(0.120167, -0.43769, 0.777622));
       allpoints.push(new PMPoint(0.174312, 0.125425, 0.747335));
       allpoints.push(new PMPoint(0.390909, -0.43769, 0.411662));
       allpoints.push(new PMPoint(0.202302, 0.248431, 0.561138));
       allpoints.push(new PMPoint(0.0823926, 0.368335, 0.411682));
       allpoints.push(new PMPoint(0.225353, 0.225381, 0.574804));
       allpoints.push(new PMPoint(-0.437693, -0.43769, -0.0274964));
       allpoints.push(new PMPoint(-0.437693, 0.390909, -0.0274964));
       allpoints.push(new PMPoint(0.0823657, 0.368344, -0.0274964));
       allpoints.push(new PMPoint(0.0142733, 0.390909, -0.0274964));
       allpoints.push(new PMPoint(0.390909, -0.43769, -0.0274964));
       allpoints.push(new PMPoint(0.248336, 0.202397, 0.56121));
       allpoints.push(new PMPoint(-0.437693, -0.43769, 0.777622));
       allpoints.push(new PMPoint(-0.437693, 0.390909, 0.411662));
       allpoints.push(new PMPoint(0.0142733, 0.390909, 0.411662));
       allpoints.push(new PMPoint(0.0144763, 0.390842, 0.411788));
       allpoints.push(new PMPoint(0.12563, 0.174143, 0.747357));
       allpoints.push(new PMPoint(0.150263, 0.150246, 0.760833));
       allpoints.push(new PMPoint(-0.437693, 0.120281, 0.777622));
       allpoints.push(new PMPoint(0.013813, 0.227381, 0.717324));
       allpoints.push(new PMPoint(-0.437693, 0.227442, 0.71721));
       allpoints.push(new PMPoint(0.368344, 0.0823657, -0.0274964));
       allpoints.push(new PMPoint(0.390909, 0.0142733, -0.0274964));
       allpoints.push(new PMPoint(0.368335, 0.0823926, 0.411662));
       allpoints.push(new PMPoint(0.390909, 0.0142733, 0.411662));
       allpoints.push(new PMPoint(0.390814, 0.0145615, 0.411841));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makelabel(" ");
       allpoints[1].makelabel(" ");
       allpoints[2].makelabel(" ");
       allpoints[3].makelabel(" ");
       allpoints[4].makelabel(" ");
       allpoints[5].makelabel(" ");
       allpoints[6].makelabel(" ");
       allpoints[7].makelabel(" ");
       allpoints[8].makelabel(" ");
       allpoints[9].makelabel(" ");
       allpoints[10].makelabel(" ");
       allpoints[11].makelabel(" ");
       allpoints[12].makelabel(" ");
       allpoints[13].makelabel(" ");
       allpoints[14].makelabel(" ");
       allpoints[15].makelabel(" ");
       allpoints[16].makelabel(" ");
       allpoints[17].makelabel(" ");
       allpoints[18].makelabel(" ");
       allpoints[19].makelabel(" ");
       allpoints[20].makelabel(" ");
       allpoints[21].makelabel(" ");
       allpoints[22].makelabel(" ");
       allpoints[23].makelabel(" ");
       allpoints[24].makelabel(" ");
       allpoints[25].makelabel(" ");
       allpoints[26].makelabel(" ");
       allpoints[27].makelabel(" ");
       allpoints[28].makelabel(" ");
       allpoints[29].makelabel(" ");
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
       faces.vertices.push(allpoints[3].vector);
       faces.vertices.push(allpoints[4].vector);
       faces.vertices.push(allpoints[5].vector);
       faces.vertices.push(allpoints[6].vector);
       faces.vertices.push(allpoints[7].vector);
       faces.vertices.push(allpoints[8].vector);
       faces.vertices.push(allpoints[9].vector);
       faces.vertices.push(allpoints[10].vector);
       faces.vertices.push(allpoints[11].vector);
       faces.vertices.push(allpoints[12].vector);
       faces.vertices.push(allpoints[13].vector);
       faces.vertices.push(allpoints[14].vector);
       faces.vertices.push(allpoints[15].vector);
       faces.vertices.push(allpoints[16].vector);
       faces.vertices.push(allpoints[17].vector);
       faces.vertices.push(allpoints[18].vector);
       faces.vertices.push(allpoints[19].vector);
       faces.vertices.push(allpoints[20].vector);
       faces.vertices.push(allpoints[21].vector);
       faces.vertices.push(allpoints[22].vector);
       faces.vertices.push(allpoints[23].vector);
       faces.vertices.push(allpoints[24].vector);
       faces.vertices.push(allpoints[25].vector);
       faces.vertices.push(allpoints[26].vector);
       faces.vertices.push(allpoints[27].vector);
       faces.vertices.push(allpoints[28].vector);
       faces.vertices.push(allpoints[29].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var materials = [
          new THREE.MeshBasicMaterial({ transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, color: 0xFFB450, }),
          new THREE.MeshBasicMaterial({ transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, color: 0xFFB450, }),
          new THREE.MeshBasicMaterial({ transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, color: 0xFFB450, }),
          new THREE.MeshBasicMaterial({ transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, color: 0xFFB450, }),
          new THREE.MeshBasicMaterial({ transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, color: 0xFFB450, }),
          new THREE.MeshBasicMaterial({ transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, color: 0xFFB450, }),
          new THREE.MeshBasicMaterial({ transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, color: 0xFFB450, }),
          new THREE.MeshBasicMaterial({ transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, color: 0xFFB450, }),
          new THREE.MeshBasicMaterial({ transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, color: 0xFFB450, }),
          new THREE.MeshBasicMaterial({ transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, color: 0xFFB450, }),
          new THREE.MeshBasicMaterial({ transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, color: 0xFFB450, }),
          new THREE.MeshBasicMaterial({ transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, color: 0xFFB450, }),
          new THREE.MeshBasicMaterial({ transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, color: 0xFFB450, }),
          new THREE.MeshBasicMaterial({ transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, color: 0xFFB450, }),
          new THREE.MeshBasicMaterial({ transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, color: 0xFF0000, }),
          new THREE.MeshBasicMaterial({ transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, color: 0xFF0000, }),
          new THREE.MeshBasicMaterial({ transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, color: 0xFF0000, }),
       ];
       for (index = 0; index < materials.length; ++index) {
          materials[index].side = THREE.DoubleSide;
       }
       var faces_material = new THREE.MeshFaceMaterial ( materials );
    
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(21, 20, 23, undefined, undefined, 0));
       faces.faces.push(new THREE.Face3(21, 23, 24, undefined, undefined, 0));
       faces.faces.push(new THREE.Face3(21, 24, 22, undefined, undefined, 0));
       faces.faces.push(new THREE.Face3(21, 22, 0, undefined, undefined, 0));
       faces.faces.push(new THREE.Face3(21, 0, 1, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(7, 20, 21, undefined, undefined, 1));
       faces.faces.push(new THREE.Face3(7, 21, 9, undefined, undefined, 1));
    
       faces.faces.push(new THREE.Face3(1, 0, 4, undefined, undefined, 2));
       faces.faces.push(new THREE.Face3(1, 4, 2, undefined, undefined, 2));
       faces.faces.push(new THREE.Face3(1, 2, 3, undefined, undefined, 2));
       faces.faces.push(new THREE.Face3(1, 3, 5, undefined, undefined, 2));
    
       faces.faces.push(new THREE.Face3(21, 1, 5, undefined, undefined, 3));
       faces.faces.push(new THREE.Face3(21, 5, 15, undefined, undefined, 3));
       faces.faces.push(new THREE.Face3(21, 15, 9, undefined, undefined, 3));
    
       faces.faces.push(new THREE.Face3(8, 7, 9, undefined, undefined, 4));
       faces.faces.push(new THREE.Face3(8, 9, 15, undefined, undefined, 4));
       faces.faces.push(new THREE.Face3(8, 15, 27, undefined, undefined, 4));
       faces.faces.push(new THREE.Face3(8, 27, 25, undefined, undefined, 4));
       faces.faces.push(new THREE.Face3(8, 25, 12, undefined, undefined, 4));
    
       faces.faces.push(new THREE.Face3(5, 3, 29, undefined, undefined, 5));
       faces.faces.push(new THREE.Face3(5, 29, 27, undefined, undefined, 5));
       faces.faces.push(new THREE.Face3(5, 27, 15, undefined, undefined, 5));
    
       faces.faces.push(new THREE.Face3(0, 22, 16, undefined, undefined, 6));
       faces.faces.push(new THREE.Face3(0, 16, 4, undefined, undefined, 6));
    
       faces.faces.push(new THREE.Face3(23, 20, 7, undefined, undefined, 7));
       faces.faces.push(new THREE.Face3(23, 7, 8, undefined, undefined, 7));
       faces.faces.push(new THREE.Face3(23, 8, 19, undefined, undefined, 7));
    
       faces.faces.push(new THREE.Face3(3, 2, 6, undefined, undefined, 8));
       faces.faces.push(new THREE.Face3(3, 6, 28, undefined, undefined, 8));
       faces.faces.push(new THREE.Face3(3, 28, 29, undefined, undefined, 8));
    
       faces.faces.push(new THREE.Face3(24, 23, 19, undefined, undefined, 9));
       faces.faces.push(new THREE.Face3(24, 19, 18, undefined, undefined, 9));
       faces.faces.push(new THREE.Face3(24, 18, 17, undefined, undefined, 9));
    
       faces.faces.push(new THREE.Face3(25, 27, 29, undefined, undefined, 10));
       faces.faces.push(new THREE.Face3(25, 29, 28, undefined, undefined, 10));
       faces.faces.push(new THREE.Face3(25, 28, 26, undefined, undefined, 10));
    
       faces.faces.push(new THREE.Face3(19, 8, 12, undefined, undefined, 11));
       faces.faces.push(new THREE.Face3(19, 12, 13, undefined, undefined, 11));
       faces.faces.push(new THREE.Face3(19, 13, 18, undefined, undefined, 11));
    
       faces.faces.push(new THREE.Face3(14, 26, 28, undefined, undefined, 12));
       faces.faces.push(new THREE.Face3(14, 28, 6, undefined, undefined, 12));
    
       faces.faces.push(new THREE.Face3(17, 18, 13, undefined, undefined, 13));
       faces.faces.push(new THREE.Face3(17, 13, 11, undefined, undefined, 13));
    
       faces.faces.push(new THREE.Face3(22, 24, 17, undefined, undefined, 14));
       faces.faces.push(new THREE.Face3(22, 17, 11, undefined, undefined, 14));
       faces.faces.push(new THREE.Face3(22, 11, 10, undefined, undefined, 14));
       faces.faces.push(new THREE.Face3(22, 10, 16, undefined, undefined, 14));
    
       faces.faces.push(new THREE.Face3(16, 10, 14, undefined, undefined, 15));
       faces.faces.push(new THREE.Face3(16, 14, 6, undefined, undefined, 15));
       faces.faces.push(new THREE.Face3(16, 6, 2, undefined, undefined, 15));
       faces.faces.push(new THREE.Face3(16, 2, 4, undefined, undefined, 15));
    
       faces.faces.push(new THREE.Face3(10, 11, 13, undefined, undefined, 16));
       faces.faces.push(new THREE.Face3(10, 13, 12, undefined, undefined, 16));
       faces.faces.push(new THREE.Face3(10, 12, 25, undefined, undefined, 16));
       faces.faces.push(new THREE.Face3(10, 25, 26, undefined, undefined, 16));
       faces.faces.push(new THREE.Face3(10, 26, 14, undefined, undefined, 16));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[21].vector);
       line.vertices.push(allpoints[20].vector);
       line.vertices.push(allpoints[23].vector);
       line.vertices.push(allpoints[24].vector);
       line.vertices.push(allpoints[22].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[21].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[7].vector);
       line.vertices.push(allpoints[20].vector);
       line.vertices.push(allpoints[21].vector);
       line.vertices.push(allpoints[9].vector);
       line.vertices.push(allpoints[7].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[4].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[5].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[21].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[5].vector);
       line.vertices.push(allpoints[15].vector);
       line.vertices.push(allpoints[9].vector);
       line.vertices.push(allpoints[21].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[8].vector);
       line.vertices.push(allpoints[7].vector);
       line.vertices.push(allpoints[9].vector);
       line.vertices.push(allpoints[15].vector);
       line.vertices.push(allpoints[27].vector);
       line.vertices.push(allpoints[25].vector);
       line.vertices.push(allpoints[12].vector);
       line.vertices.push(allpoints[8].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[5].vector);
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[29].vector);
       line.vertices.push(allpoints[27].vector);
       line.vertices.push(allpoints[15].vector);
       line.vertices.push(allpoints[5].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[22].vector);
       line.vertices.push(allpoints[16].vector);
       line.vertices.push(allpoints[4].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[23].vector);
       line.vertices.push(allpoints[20].vector);
       line.vertices.push(allpoints[7].vector);
       line.vertices.push(allpoints[8].vector);
       line.vertices.push(allpoints[19].vector);
       line.vertices.push(allpoints[23].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[6].vector);
       line.vertices.push(allpoints[28].vector);
       line.vertices.push(allpoints[29].vector);
       line.vertices.push(allpoints[3].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[24].vector);
       line.vertices.push(allpoints[23].vector);
       line.vertices.push(allpoints[19].vector);
       line.vertices.push(allpoints[18].vector);
       line.vertices.push(allpoints[17].vector);
       line.vertices.push(allpoints[24].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[25].vector);
       line.vertices.push(allpoints[27].vector);
       line.vertices.push(allpoints[29].vector);
       line.vertices.push(allpoints[28].vector);
       line.vertices.push(allpoints[26].vector);
       line.vertices.push(allpoints[25].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[19].vector);
       line.vertices.push(allpoints[8].vector);
       line.vertices.push(allpoints[12].vector);
       line.vertices.push(allpoints[13].vector);
       line.vertices.push(allpoints[18].vector);
       line.vertices.push(allpoints[19].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[14].vector);
       line.vertices.push(allpoints[26].vector);
       line.vertices.push(allpoints[28].vector);
       line.vertices.push(allpoints[6].vector);
       line.vertices.push(allpoints[14].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[17].vector);
       line.vertices.push(allpoints[18].vector);
       line.vertices.push(allpoints[13].vector);
       line.vertices.push(allpoints[11].vector);
       line.vertices.push(allpoints[17].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[22].vector);
       line.vertices.push(allpoints[24].vector);
       line.vertices.push(allpoints[17].vector);
       line.vertices.push(allpoints[11].vector);
       line.vertices.push(allpoints[10].vector);
       line.vertices.push(allpoints[16].vector);
       line.vertices.push(allpoints[22].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[16].vector);
       line.vertices.push(allpoints[10].vector);
       line.vertices.push(allpoints[14].vector);
       line.vertices.push(allpoints[6].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[4].vector);
       line.vertices.push(allpoints[16].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[10].vector);
       line.vertices.push(allpoints[11].vector);
       line.vertices.push(allpoints[13].vector);
       line.vertices.push(allpoints[12].vector);
       line.vertices.push(allpoints[25].vector);
       line.vertices.push(allpoints[26].vector);
       line.vertices.push(allpoints[14].vector);
       line.vertices.push(allpoints[10].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
    // COMMON_CODE_BLOCK_BEGIN
    var xRotationEnabled = false;
    var yRotationEnabled = false;
    var zRotationEnabled = false;
    var rotationSpeedFactor = 1;
    var settingsShown = false;
    var labelsShown = true;
    var intervals = [];
    var timeouts = [];
    var explodingSpeed = 0.05;
    var explodeScale = 0;
    var XMLS = new XMLSerializer();
    var svgElement;
    var renderId;
    
    	var render = function () {
    
    		renderId = requestAnimationFrame(render);
    
    //		comment in for automatic explosion
    //		explode(updateFactor());
    
    		var phi = 0.02 * rotationSpeedFactor;
    
    		if (xRotationEnabled){
    			scene.rotation.x += phi;
    		}
    		if(yRotationEnabled){
    			scene.rotation.y += phi;
    		}
    		if(zRotationEnabled){
    			scene.rotation.z += phi;
    		}
    
    		controls.update();
    		renderer.render(scene, camera);
    	};
    
    	render();
    
    	function computeCentroid(geom) {
    		centroid = new THREE.Vector3();
    		geom.vertices.forEach(function(v) {
    			centroid.add(v);			
    		});
    		centroid.divideScalar(geom.vertices.length);
    		return centroid;
    	}
    
    	function changeTransparency(event){
    		var opacity = 1-Number(event.currentTarget.value);
    		for (var i=0; i<all_objects.length; i++){
    			for (var j=0; j<all_objects[i].children.length; j++){
    				if (all_objects[i].children[j].material.type == "MultiMaterial") {
    					for (var k=0; k<all_objects[i].children[j].material.materials.length; k++){
    						all_objects[i].children[j].material.materials[k].opacity = opacity;
    						all_objects[i].children[j].material.materials[k].depthWrite = opacity < 0.5 ? false : true;
    						all_objects[i].children[j].material.materials[k].depthTest = opacity < 0.5 ? false : true;
    					}
    				} else if (all_objects[i].children[j].material.transparent && 
    							  all_objects[i].children[j].material.type == "MeshBasicMaterial" &&
    							  all_objects[i].children[j].geometry.type == "Geometry"){
    					all_objects[i].children[j].material.opacity = opacity;
    					all_objects[i].children[j].material.depthWrite = opacity < 0.5 ? false : true;
    					all_objects[i].children[j].material.depthTest = opacity < 0.5 ? false : true;
    				}
    			}
    		}
    	}
    
    	function changeRotationX(event){
    		xRotationEnabled = event.currentTarget.checked;
    	}	
    
    	function changeRotationY(event){
    		yRotationEnabled = event.currentTarget.checked;
    	}	
    
    	function changeRotationZ(event){
    		zRotationEnabled = event.currentTarget.checked;
    	}	
    
    
    	function changeRotationSpeedFactor(event){
    		rotationSpeedFactor = Number(event.currentTarget.value);
    	}
    
    	function resetScene(){
    		scene.rotation.set(0,0,0);
    		camera.position.set(0,0,5);
    		camera.up.set(0,1,0);
    	}
    
    	function showSettings(event){
    		event.currentTarget.style.display = 'none';
    		document.getElementById('settings_7').style.position = 'absolute';
    		document.getElementById('settings_7').style.display = 'block';
    		document.getElementById('showSettingsButton_7').style.display = 'none';
    		document.getElementById('hideSettingsButton_7').style.display = 'block';
    		settingsShown = true;
    	}
    
    	function hideSettings(event){
    		event.currentTarget.style.display = 'none';
    		document.getElementById('settings_7').style.display = 'none';
    		document.getElementById('hideSettingsButton_7').style.display = 'none';
    		document.getElementById('showSettingsButton_7').style.display = 'block';
    		settingsShown = false;
    	}
    
    
    
    	var pos = 150* Math.PI;
    
    	function updateFactor() {
    		pos++;
    		return Math.sin(.01*pos)+1;
    	}
    
    	function makelabel(message, x, y, z, params) {
    		var spritey = textSprite( message, params );
    		spritey.position.set(x, y, z);
    		obj.add(spritey);
    	}
    
    	function textSprite(message, parameters)
    	{
    		if ( parameters === undefined ) parameters = {};
    
    		var fontface = "Helvetica";
    
    		var fontsize = parameters.hasOwnProperty("fontsize") ? 
    			parameters["fontsize"] : 18;
    		fontsize = fontsize*10;
    
    		var canvas = document.createElement('canvas');
    		var size = 1024;
    		canvas.width = size;
    		canvas.height = size;
    		var context = canvas.getContext('2d');
    		context.font = fontsize + "px " + fontface;
    
    		// text color
    		context.fillStyle = "rgba(0, 0, 0, 1.0)";
    
    		context.fillText(message, size/2, size/2);
    
    		// canvas contents will be used for a texture
    		var texture = new THREE.Texture(canvas);
    		texture.needsUpdate = true;
    
    		var spriteMaterial = new THREE.SpriteMaterial(
    			{map: texture, useScreenCoordinates: false});
    		var sprite = new THREE.Sprite(spriteMaterial);
    		return sprite;
    	}
    
    	function takeSvgScreenshot(){
    		if (labelsShown){
    			hideLabels();
    		}
    		svgRenderer.render(scene,camera);
    		svgElement = XMLS.serializeToString(svgRenderer.domElement);
    		
    		if (labelsShown){
    			displayLabels();
    		}
    
    		if (document.getElementById('tab_7').checked){
    			//show in new tab
    			var myWindow = window.open("","");
    			myWindow.document.body.innerHTML = svgElement;
    		} else{
    			// download svg file 
    			download("screenshot.svg", svgElement);
    		}
    	}
    		
    
    	function showOrHideObject(event){
    		var nr = Number(event.currentTarget.name);
    		all_objects[nr].visible = event.currentTarget.checked;
    	}
    
    
    	function displayOrHideOptions(){
    		for (var i=0; i<all_objects.length; i++){
    			for (var j=0; j<all_objects[i].children.length; j++){
    				if (all_objects[i].children[j].material.type == "MultiMaterial") {
    					for (var k=0; k<all_objects[i].children[j].material.materials.length; k++){
    						if (all_objects[i].children[j].material.materials[k].transparent) {
    							document.getElementById('transparency_7').style.display = 'block';
    							document.getElementById('transparencyRange_7').value = 1 - 
    							    all_objects[i].children[j].material.materials[k].opacity;
    							return;
    						}
    					}
    				} else if (all_objects[i].children[j].material.transparent && 
    							  all_objects[i].children[j].material.type == "MeshBasicMaterial" &&
    							  all_objects[i].children[j].geometry.type == "Geometry"){
    					document.getElementById('transparency_7').style.display = 'block';
    					return;
    				}
    			}
    		}
    	}
    
    	displayOrHideOptions()
    
    
    
    
    // ---------------------- EXPLOSION ------------------------------------------------
    // ---------------------------------------------------------------------------------
    
    	function explode(factor) {
    		var obj, c;
    		var c0 = centroids[0];
    		for (var i = 0; i<centroids.length; ++i) {
    			c = centroids[i];
    			obj = all_objects[all_objects.length - centroids.length + i];
    			obj.position.set(c.x*factor, c.y*factor, c.z*factor);
    		}	
    	}
    
    	function triggerExplode(event){
    		explodeScale = Number(event.currentTarget.value);
    		explode(explodeScale);
    	}
    
    	function setExplodingSpeed(event){
    		explodingSpeed = Number(event.currentTarget.value);
    	}
    
    	function triggerAutomaticExplode(event){
    		if (event.currentTarget.checked){
    			startExploding();
    		} else {
    			clearIntervals();
    		}	
    	}
    
    	function startExploding(){
    		intervals.push(setInterval(explodingInterval, 25));
    	}
    
    
    	function explodingInterval(){
    		explodeScale += explodingSpeed;
    		if (explodeScale <= 6){ 
    			explode(explodeScale);
    		}
    		else{
    			explode(6);
    			explodeScale = 6;
    			clearIntervals();
    			timeouts.push(setTimeout(startUnexploding, 3000));
    		}
    		document.getElementById('explodeRange_7').value = explodeScale;
    	}
    
    
    	function startUnexploding(){
    		intervals.push(setInterval(unexplodingInterval, 25));
    	}
    
    	function unexplodingInterval(){
    		explodeScale -= explodingSpeed;
    		if (explodeScale >= 0){	
    			explode(explodeScale);
    		}
    		else {
    			explode(0);
    			explodeScale = 0;
    			clearIntervals();
    			timeouts.push(setTimeout(startExploding, 3000));
    		}
    		document.getElementById('explodeRange_7').value = explodeScale;
    	}
    
    	function clearIntervals(){
    		intervals.forEach(function(interval){
    			clearInterval(interval);
    		});
    		intervals = [];
    		timeouts.forEach(function(timeout){
    			clearTimeout(timeout);
    		});
    		timeouts = [];
    	}
    
    			
    
    	// append checkboxes for displaying or hiding objects
    	var shownObjectsList = document.getElementById('shownObjectsList_7');
    	for (var i=0; i<all_objects.length; i++){
    		var objNode = document.createElement('span');
    		objNode.innerHTML = objectnames[i] + '<br>';
    		var checkbox = document.createElement('input');
    		checkbox.type = 'checkbox';
    		checkbox.checked = true;
    		checkbox.name = String(i);
    		checkbox.onchange = showOrHideObject;
    		shownObjectsList.appendChild(checkbox);
    		shownObjectsList.appendChild(objNode);
    	}
    
    	function displayLabels(){
    		for (var i=0; i<all_objects.length; i++){
    			for (var j=0; j<all_objects[i].children.length; j++){
    				var child = all_objects[i].children[j];
    				if (child.type == 'Sprite'){
    					child.visible = true;
    				}
    			}
    		}
    	}
    
    	function hideLabels(){
    		for (var i=0; i<all_objects.length; i++){
    			for (var j=0; j<all_objects[i].children.length; j++){
    				var child = all_objects[i].children[j];
    				if (child.type == 'Sprite'){
    					child.visible = false;
    				}
    			}
    		}
    	}
    
    	function displayOrHideLabels(event){
    		if (event.currentTarget.checked){
    			displayLabels();
    			labelsShown = true;
    		} else {
    			hideLabels();
    			labelsShown = false;
    		}
    	}
    
    	function download(filename, text) {
    	  var element = document.createElement('a');
    	  element.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(text));
    	  element.setAttribute('download', filename);
    
    	  element.style.display = 'none';
    	  document.body.appendChild(element);
    
    	  element.click();
    
    	  document.body.removeChild(element);
    	}
    
    var tempobj;
    tempobj = document.getElementById('explodeRange_7');
    if (tempobj) {
       tempobj.oninput = triggerExplode;
       document.getElementById('explodeCheckbox_7').onchange = triggerAutomaticExplode;
       document.getElementById('explodingSpeedRange_7').oninput = setExplodingSpeed;
    }
    tempobj = document.getElementById('foldRange_7');
    if (tempobj) {
       tempobj.oninput = fold;
    }
    document.getElementById('transparencyRange_7').oninput = changeTransparency;
    document.getElementById('changeRotationX_7').onchange = changeRotationX;
    document.getElementById('changeRotationY_7').onchange = changeRotationY;
    document.getElementById('changeRotationZ_7').onchange = changeRotationZ;
    document.getElementById('resetButton_7').onclick = resetScene;
    document.getElementById('rotationSpeedRange_7').oninput = changeRotationSpeedFactor;
    document.getElementById('labelsCheckboxInput_7').onchange = displayOrHideLabels;
    document.getElementById('takeScreenshot_7').onclick = takeSvgScreenshot;
    document.getElementById('showSettingsButton_7').onclick = showSettings;
    document.getElementById('hideSettingsButton_7').onclick = hideSettings;
    
    	
    
    // ------------------ SHORTCUTS --------------------------------------------
    // -------------------------------------------------------------------------
    
    /**
     * http://www.openjs.com/scripts/events/keyboard_shortcuts/
     * Version : 2.01.B
     * By Binny V A
     * License : BSD
     */
    shortcut = {
    	'all_shortcuts':{},//All the shortcuts are stored in this array
    	'add': function(shortcut_combination,callback,opt) {
    		//Provide a set of default options
    		var default_options = {
    			'type':'keydown',
    			'propagate':false,
    			'disable_in_input':false,
    			'target':document,
    			'keycode':false
    		}
    		if(!opt) opt = default_options;
    		else {
    			for(var dfo in default_options) {
    				if(typeof opt[dfo] == 'undefined') opt[dfo] = default_options[dfo];
    			}
    		}
    
    		var ele = opt.target;
    		if(typeof opt.target == 'string') ele = document.getElementById(opt.target);
    		var ths = this;
    		shortcut_combination = shortcut_combination.toLowerCase();
    
    		//The function to be called at keypress
    		var func = function(e) {
    			e = e || window.event;
    			
    			if(opt['disable_in_input']) { //Don't enable shortcut keys in Input, Textarea fields
    				var element;
    				if(e.target) element=e.target;
    				else if(e.srcElement) element=e.srcElement;
    				if(element.nodeType==3) element=element.parentNode;
    
    				if(element.tagName == 'INPUT' || element.tagName == 'TEXTAREA') return;
    			}
    	
    			//Find Which key is pressed
    			if (e.keyCode) code = e.keyCode;
    			else if (e.which) code = e.which;
    			var character = String.fromCharCode(code).toLowerCase();
    			
    			if(code == 188) character=","; //If the user presses , when the type is onkeydown
    			if(code == 190) character="."; //If the user presses , when the type is onkeydown
    
    			var keys = shortcut_combination.split("+");
    			//Key Pressed - counts the number of valid keypresses - if it is same as the number of keys, the shortcut function is invoked
    			var kp = 0;
    			
    			//Work around for stupid Shift key bug created by using lowercase - as a result the shift+num combination was broken
    			var shift_nums = {
    				"`":"~",
    				"1":"!",
    				"2":"@",
    				"3":"#",
    				"4":"$",
    				"5":"%",
    				"6":"^",
    				"7":"&",
    				"8":"*",
    				"9":"(",
    				"0":")",
    				"-":"_",
    				"=":"+",
    				";":":",
    				"'":"\"",
    				",":"<",
    				".":">",
    				"/":"?",
    				"\\":"|"
    			}
    			//Special Keys - and their codes
    			var special_keys = {
    				'esc':27,
    				'escape':27,
    				'tab':9,
    				'space':32,
    				'return':13,
    				'enter':13,
    				'backspace':8,
    	
    				'scrolllock':145,
    				'scroll_lock':145,
    				'scroll':145,
    				'capslock':20,
    				'caps_lock':20,
    				'caps':20,
    				'numlock':144,
    				'num_lock':144,
    				'num':144,
    				
    				'pause':19,
    				'break':19,
    				
    				'insert':45,
    				'home':36,
    				'delete':46,
    				'end':35,
    				
    				'pageup':33,
    				'page_up':33,
    				'pu':33,
    	
    				'pagedown':34,
    				'page_down':34,
    				'pd':34,
    	
    				'left':37,
    				'up':38,
    				'right':39,
    				'down':40,
    	
    				'f1':112,
    				'f2':113,
    				'f3':114,
    				'f4':115,
    				'f5':116,
    				'f6':117,
    				'f7':118,
    				'f8':119,
    				'f9':120,
    				'f10':121,
    				'f11':122,
    				'f12':123
    			}
    	
    			var modifiers = { 
    				shift: { wanted:false, pressed:false},
    				ctrl : { wanted:false, pressed:false},
    				alt  : { wanted:false, pressed:false},
    				meta : { wanted:false, pressed:false}	//Meta is Mac specific
    			};
                            
    			if(e.ctrlKey)	modifiers.ctrl.pressed = true;
    			if(e.shiftKey)	modifiers.shift.pressed = true;
    			if(e.altKey)	modifiers.alt.pressed = true;
    			if(e.metaKey)   modifiers.meta.pressed = true;
                            
    			for(var i=0; k=keys[i],i<keys.length; i++) {
    				//Modifiers
    				if(k == 'ctrl' || k == 'control') {
    					kp++;
    					modifiers.ctrl.wanted = true;
    
    				} else if(k == 'shift') {
    					kp++;
    					modifiers.shift.wanted = true;
    
    				} else if(k == 'alt') {
    					kp++;
    					modifiers.alt.wanted = true;
    				} else if(k == 'meta') {
    					kp++;
    					modifiers.meta.wanted = true;
    				} else if(k.length > 1) { //If it is a special key
    					if(special_keys[k] == code) kp++;
    					
    				} else if(opt['keycode']) {
    					if(opt['keycode'] == code) kp++;
    
    				} else { //The special keys did not match
    					if(character == k) kp++;
    					else {
    						if(shift_nums[character] && e.shiftKey) { //Stupid Shift key bug created by using lowercase
    							character = shift_nums[character]; 
    							if(character == k) kp++;
    						}
    					}
    				}
    			}
    			
    			if(kp == keys.length && 
    						modifiers.ctrl.pressed == modifiers.ctrl.wanted &&
    						modifiers.shift.pressed == modifiers.shift.wanted &&
    						modifiers.alt.pressed == modifiers.alt.wanted &&
    						modifiers.meta.pressed == modifiers.meta.wanted) {
    				callback(e);
    	
    				if(!opt['propagate']) { //Stop the event
    					//e.cancelBubble is supported by IE - this will kill the bubbling process.
    					e.cancelBubble = true;
    					e.returnValue = false;
    	
    					//e.stopPropagation works in Firefox.
    					if (e.stopPropagation) {
    						e.stopPropagation();
    						e.preventDefault();
    					}
    					return false;
    				}
    			}
    		}
    		this.all_shortcuts[shortcut_combination] = {
    			'callback':func, 
    			'target':ele, 
    			'event': opt['type']
    		};
    		//Attach the function with the event
    		if(ele.addEventListener) ele.addEventListener(opt['type'], func, false);
    		else if(ele.attachEvent) ele.attachEvent('on'+opt['type'], func);
    		else ele['on'+opt['type']] = func;
    	},
    
    	//Remove the shortcut - just specify the shortcut and I will remove the binding
    	'remove':function(shortcut_combination) {
    		shortcut_combination = shortcut_combination.toLowerCase();
    		var binding = this.all_shortcuts[shortcut_combination];
    		delete(this.all_shortcuts[shortcut_combination])
    		if(!binding) return;
    		var type = binding['event'];
    		var ele = binding['target'];
    		var callback = binding['callback'];
    
    		if(ele.detachEvent) ele.detachEvent('on'+type, callback);
    		else if(ele.removeEventListener) ele.removeEventListener(type, callback, false);
    		else ele['on'+type] = false;
    	}
    }
    
    shortcut.add("Alt+Left",function() {
    	var event = new Event('click');
    	if (settingsShown){
    		document.getElementById('hideSettingsButton_7').dispatchEvent(event);
    	} else{
    		document.getElementById('showSettingsButton_7').dispatchEvent(event);
    	}
    });
    
    if (foldable) moveToBaryCenter();
    
    
    });});
    // COMMON_CODE_BLOCK_END
    </script>
    
    </body>
    </html>



.. link

.. CODE-BLOCK:: perl

    polymake> $d0 = $s->gkz_dome(0,5);
    polymake> $d0->VISUAL(FacetColor=>'80 180 255');


.. raw:: html

    <!--
    polymake for loewe
    Fri Feb  9 13:50:30 2018
    pcom:d0
    -->
    
    
    <html>
       <head>
          <title>pcom:d0</title>
          <style>
    /*
    // COMMON_CODE_BLOCK_BEGIN
    */
             html{overflow: scroll;}
             body { font-family: Arial, Helvetica, sans-serif}
             strong{font-size: 18px;}
             canvas { z-index: 8; }
             input[type='range'] {}
             input[type='radio'] {margin-left:0;}
             input[type='checkbox'] {margin-right:7px; margin-left: 0px; padding-left:0px;}
             .group{padding-bottom: 40px;}
             .settings * {z-index: 11; }
             .settings{z-index: 10; margin-left: 30px; display: none; width: 14em; height: 90%; border: solid 1px silver; padding: 2px; overflow-y: scroll; background-color: white }
             .indented{margin-left: 20px; margin-top: 15px; padding-bottom: 0px;} 
             .shownObjectsList{overflow: auto; max-width: 150px; max-height: 150px;}
             .showSettingsButton{display: block; z-index: 12; position: absolute }
             .hideSettingsButton{display: none; z-index: 12; position: absolute; opacity: 0.5}
             .resetButton{margin-top: 20px;}
             button{margin-left: 0;}
             img{cursor: pointer;}
             .suboption{padding-top: 30px;}
             .transparency{display: none;}
             .labelsCheckbox{margin-top: 10px;}
    
    
             input[type=range] {
               -webkit-appearance: none;
               padding:0; 
               width:90%; 
               margin-left: auto;
               margin-right: auto;
               margin-top: 20px;
               display: block;	
             }
             input[type=range]:focus {
               outline: none;
             }
             input[type=range]::-webkit-slider-runnable-track {
               height: 4px;
               cursor: pointer;
               animate: 0.2s;
               box-shadow: 0px 0px 0px #000000;
               background: #E3E3E3;
               border-radius: 0px;
               border: 0px solid #000000;
             }
             input[type=range]::-webkit-slider-thumb {
               box-shadow: 1px 1px 2px #B8B8B8;
               border: 1px solid #ABABAB;
               height: 13px;
               width: 25px;
               border-radius: 20px;
               background: #E0E0E0;
               cursor: pointer;
               -webkit-appearance: none;
               margin-top: -5px;
             }
             input[type=range]:focus::-webkit-slider-runnable-track {
               background: #E3E3E3;
             }
             input[type=range]::-moz-range-track {
               height: 4px;
               cursor: pointer;
               animate: 0.2s;
               box-shadow: 0px 0px 0px #000000;
               background: #E3E3E3;
               border-radius: 0px;
               border: 0px solid #000000;
             }
             input[type=range]::-moz-range-thumb {
               box-shadow: 1px 1px 2px #B8B8B8;
               border: 1px solid #ABABAB;
               height: 13px;
               width: 25px;
               border-radius: 20px;
               background: #E0E0E0;
               cursor: pointer;
             }
             input[type=range]::-ms-track {
               height: 4px;
               cursor: pointer;
               animate: 0.2s;
               background: transparent;
               border-color: transparent;
               color: transparent;
             }
             input[type=range]::-ms-fill-lower {
               background: #E3E3E3;
               border: 0px solid #000000;
               border-radius: 0px;
               box-shadow: 0px 0px 0px #000000;
             }
             input[type=range]::-ms-fill-upper {
               background: #E3E3E3;
               border: 0px solid #000000;
               border-radius: 0px;
               box-shadow: 0px 0px 0px #000000;
             }
             input[type=range]::-ms-thumb {
               box-shadow: 1px 1px 2px #B8B8B8;
               border: 1px solid #ABABAB;
               height: 13px;
               width: 25px;
               border-radius: 20px;
               background: #E0E0E0;
               cursor: pointer;
             }
             input[type=range]:focus::-ms-fill-lower {
               background: #E3E3E3;
             }
             input[type=range]:focus::-ms-fill-upper {
               background: #E3E3E3;
             }
    /*
    // COMMON_CODE_BLOCK_END
    */
    		</style>
       </head>
    
    <body>
    
    		<div id='settings_8' class='settings'>
    			<div class=group id='explode_8'>
    				<strong>Explode</strong>
    				<input id='explodeRange_8' type='range' min=0 max=6 step=0.01 value=0>
    				<div class=indented><input id='explodeCheckbox_8' type='checkbox'>Automatic explosion</div>
    				<div class=suboption>Exploding speed</div>
    				<input id='explodingSpeedRange_8' type='range' min=0 max=0.5 step=0.001 value=0.05>
    			</div>
    
    			
    			<div class=group id='transparency_8' class='transparency'>
    				<strong>Transparency</strong>
    				<input id='transparencyRange_8' type='range' min=0 max=1 step=0.01 value=0>
    			</div>
    			
    			<div class=group id='rotation_8'>
    				<strong>Rotation</strong>
    				<div class=indented>
    					<div><input type='checkbox' id='changeRotationX_8'> x-axis</div>
    					<div><input type='checkbox' id='changeRotationY_8'> y-axis</div>
    					<div><input type='checkbox' id='changeRotationZ_8'> z-axis</div>
    					<button id='resetButton_8' class='resetButton' >Reset</button>
    				</div>
    
    				<div class=suboption>Rotation speed</div>
    				<input id='rotationSpeedRange_8' type='range' min=0 max=5 step=0.01 value=2>
    
    			</div>
    
    
    			<div class=group id='display_8'>
    				<strong>Display</strong>
    				<div class=indented>
    					<div id='shownObjectsList_8' class='shownObjectsList'></div>
    					<div class='labelsCheckbox'><input type='checkbox' id='labelsCheckboxInput_8' checked>Labels</div>
    				</div>
    			</div>
    
    
    			<div class=group id='svg_8'>
    				<strong>SVG</strong>
    				<div class=indented>
    					<form>
    						<input type="radio" name='screenshotMode' value='download' id='download_8' checked> Download<br>
    						<input type="radio" name='screenshotMode' value='tab' id='tab_8' > New tab<br>
    					</form>
    					<button id='takeScreenshot_8'>Screenshot</button>
    				</div>
    			</div>
    
    		</div>	<!-- end of settings -->
    		<img id='hideSettingsButton_8' style="display: none" class='hideSettingsButton' src='/kernelspecs/polymake/close.svg' width=20px">
    		<img id='showSettingsButton_8' class='showSettingsButton' src='/kernelspecs/polymake/menu.svg' width=20px">
    <div id="model91980846365"></div>
    
    <script>
    requirejs.config({
      paths: {
        three: '/kernelspecs/polymake/three',
        Detector: '/kernelspecs/polymake/Detector',
        SVGRenderer: '/kernelspecs/polymake/SVGRenderer',
        CanvasRenderer: '/kernelspecs/polymake/CanvasRenderer',
        Projector: '/kernelspecs/polymake/Projector',
        TrackballControls: '/kernelspecs/polymake/TrackballControls'
      },
      shim: {
        'three':
        {
          exports: 'THREE'
        },
        'Detector':
        {
          deps: [ 'three' ],
          exports: 'Detector'
        },
        'SVGRenderer':
        {
          deps: [ 'three' ],
          exports: 'THREE.SVGRenderer'
        },
        'CanvasRenderer':
        {
          deps: [ 'three' ],
          exports: 'THREE.CanvasRenderer'
        },
        'Projector':
        {
          deps: [ 'three' ],
          exports: 'THREE.Projector'
        },
        'TrackballControls':
        {
          deps: [ 'three' ],
          exports: 'THREE.TrackballControls'
        }
      }
    });
    require(['three'],function(THREE){
        window.THREE = THREE;
      require(['Detector','SVGRenderer','CanvasRenderer','Projector','TrackballControls'],function(Detector,SVGRenderer,CanvasRenderer,Projector,TrackballControls){
          THREE.SVGRenderer = SVGRenderer;
          THREE.CanvasRenderer = CanvasRenderer;
          THREE.Projector = Projector;
          THREE.TrackballControls = TrackballControls;
    
    // COMMON_CODE_BLOCK_BEGIN
    	var foldable = false;
       var container = document.getElementById( 'model91980846365' );
       var renderer = Detector.webgl? new THREE.WebGLRenderer({antialias: true}): new THREE.CanvasRenderer({antialias: true});
    	var svgRenderer = new THREE.SVGRenderer({antialias: true});
                var box = document.getElementsByClassName( 'output_subarea' )[0];
             var notebook = document.getElementById( 'notebook_panel' );
    
       var width = box.clientWidth - 25;
       var height = notebook.clientHeight * 0.8;
       renderer.setSize(width, height);
       svgRenderer.setSize(width, height);
       renderer.setClearColor(0xFFFFFF, 1);
       svgRenderer.setClearColor(0xFFFFFF, 1);
    
       container.appendChild(renderer.domElement);
    
       var scene = new THREE.Scene();
       var camera = new THREE.PerspectiveCamera(75, width/height, 0.1, 1000);
    
       var renderid;
    
       camera.position.set(0, 0, 5);
       camera.lookAt(0, 0, 0);
       camera.up.set(0, 1, 0);
    
       // class to allow move points together with labels and spheres
       var PMPoint = function (x,y,z) {
          this.vector = new THREE.Vector3(x,y,z);
          this.sprite = null;
          this.sphere = null;
       }
       PMPoint.prototype.makelabel = function(label) {
          this.sprite = textSprite( label );
          this.sprite.position.copy(this.vector);
       }
       PMPoint.prototype.makesphere = function(radius,material) {
          this.sphere = new THREE.Mesh(new THREE.SphereGeometry(radius), material);
          this.sphere.position.copy(this.vector);
       }
    
       PMPoint.prototype.setX = function(x) {
          this.vector.setX(x);
          if (this.sprite) {
             this.sprite.position.setX(x);
          }
          if (this.sphere) {
             this.sphere.position.setX(x);
          }
       };
       PMPoint.prototype.setY = function(y) {
          this.vector.setY(y);
          if (this.sprite) {
             this.sprite.position.setY(y);
          }
          if (this.sphere) {
             this.sphere.position.setY(y);
          }
       };
       PMPoint.prototype.setZ = function(z) {
          this.vector.setZ(z);
          if (this.sprite) {
             this.sprite.position.setZ(z);
          }
          if (this.sphere) {
             this.sphere.position.setZ(z);
          }
       };
       PMPoint.prototype.set = function(x,y,z) {
          this.vector.set(x,y,z);
          if (this.sprite) {
             this.sprite.position.set(x,y,z);
          }
          if (this.sphere) {
             this.sphere.position.set(x,y,z);
          }
       };
       PMPoint.prototype.add = function(o) {
          if (this.sprite) {
             o.add(this.sprite);
          }
          if (this.sphere) {
             o.add(this.sphere);
          }
       };
    
    
       var controls = new THREE.TrackballControls(camera, container);
    	controls.zoomSpeed = 0.2;
    	controls.rotateSpeed = 4;
    
       var all_objects = [];
       var centroids = [];
       // select the target node
       var target = document.querySelector('#model91980846365');
    
       // create an observer instance
       var observer = new MutationObserver(function(mutations) {
          mutations.forEach(function(mutation) {
             if (mutation.removedNodes && mutation.removedNodes.length > 0) {
                cancelAnimationFrame(renderId);
                observer.disconnect();
                console.log("cancelled frame "+renderId);
             }
          });
       });
    
       // configuration of the observer:
       var config = { childList: true, characterData: true }
    
       // pass in the target node, as well as the observer options
       while (target) {
          if (target.className=="output") {
             observer.observe(target, config);
             break;
          }
          target = target.parentNode;
       }
    
    // COMMON_CODE_BLOCK_END
    
       var objectnames = ["unnamed__1","unnamed__2","unnamed__3","unnamed__4","unnamed__5","unnamed__6","unnamed__7","unnamed__8","unnamed__9","unnamed__10","unnamed__11","unnamed__12","unnamed__13","unnamed__14","unnamed__15","unnamed__16","unnamed__17","unnamed__18","unnamed__19","unnamed__20","unnamed__21","unnamed__22","unnamed__23","unnamed__24","unnamed__25","unnamed__26","unnamed__27","unnamed__28","unnamed__29","unnamed__30","unnamed__31","unnamed__32","unnamed__33","unnamed__34","unnamed__35","unnamed__36","unnamed__37","unnamed__38","unnamed__39","unnamed__40","unnamed__41","unnamed__42","unnamed__43","unnamed__44","unnamed__45","unnamed__46","unnamed__47","unnamed__48","unnamed__49","unnamed__50","unnamed__51","unnamed__52","unnamed__53","unnamed__54","unnamed__55","unnamed__56","unnamed__57","unnamed__58","unnamed__59","unnamed__60","unnamed__61","unnamed__62","unnamed__63","unnamed__64","unnamed__65","unnamed__66","unnamed__67","unnamed__68","unnamed__69","unnamed__70","unnamed__71","unnamed__72","unnamed__73","unnamed__74","unnamed__75","unnamed__76","unnamed__77","unnamed__78","unnamed__79","unnamed__80","unnamed__81","unnamed__82","unnamed__83","unnamed__84","unnamed__85","unnamed__86","unnamed__87","unnamed__88","unnamed__89","unnamed__90","unnamed__91","unnamed__92","unnamed__93","unnamed__94"];
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-0.5, -0.866025, 0.0666667));
       allpoints.push(new PMPoint(0.5, 0.866025, 0.6));
       allpoints.push(new PMPoint(-1, 0, 0.0375));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 2, 1, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-0.5, -0.866025, 0.0666667));
       allpoints.push(new PMPoint(0.5, 0.866025, 0.6));
       allpoints.push(new PMPoint(0.5, -0.866025, 0.0375));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0.5, 0.866025, 0.6));
       allpoints.push(new PMPoint(-1, 0, 0.0375));
       allpoints.push(new PMPoint(-0.785714, 0.61859, 0.0122449));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-0.5, -0.866025, 0.0666667));
       allpoints.push(new PMPoint(-1, 0, 0.0375));
       allpoints.push(new PMPoint(-0.884615, -0.466321, 0.0035503));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-0.5, -0.866025, 0.0666667));
       allpoints.push(new PMPoint(0.5, -0.866025, 0.0375));
       allpoints.push(new PMPoint(0.0384615, -0.99926, 0.0035503));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0.5, 0.866025, 0.6));
       allpoints.push(new PMPoint(0.5, -0.866025, 0.0375));
       allpoints.push(new PMPoint(0.928571, -0.371154, 0.0122449));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0.5, 0.866025, 0.6));
       allpoints.push(new PMPoint(-0.785714, 0.61859, 0.0122449));
       allpoints.push(new PMPoint(-0.5, 0.866025, 0.00416667));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-1, 0, 0.0375));
       allpoints.push(new PMPoint(-0.785714, 0.61859, 0.0122449));
       allpoints.push(new PMPoint(-0.928571, 0.371154, 0.00085034));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-1, 0, 0.0375));
       allpoints.push(new PMPoint(-0.884615, -0.466321, 0.0035503));
       allpoints.push(new PMPoint(-0.951613, -0.307299, 0.000390218));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-0.5, -0.866025, 0.0666667));
       allpoints.push(new PMPoint(-0.884615, -0.466321, 0.0035503));
       allpoints.push(new PMPoint(-0.785714, -0.61859, 0.000765306));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-0.5, -0.866025, 0.0666667));
       allpoints.push(new PMPoint(0.0384615, -0.99926, 0.0035503));
       allpoints.push(new PMPoint(-0.142857, -0.989743, 0.000765306));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0.5, -0.866025, 0.0375));
       allpoints.push(new PMPoint(0.0384615, -0.99926, 0.0035503));
       allpoints.push(new PMPoint(0.209677, -0.977771, 0.000390219));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0.5, -0.866025, 0.0375));
       allpoints.push(new PMPoint(0.928571, -0.371154, 0.0122449));
       allpoints.push(new PMPoint(0.785714, -0.61859, 0.00085034));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0.5, 0.866025, 0.6));
       allpoints.push(new PMPoint(0.928571, -0.371154, 0.0122449));
       allpoints.push(new PMPoint(1, 0, 0.00416667));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0.5, 0.866025, 0.6));
       allpoints.push(new PMPoint(-0.5, 0.866025, 0.00416667));
       allpoints.push(new PMPoint(-0.289474, 0.957186, 0.00103878));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-0.785714, 0.61859, 0.0122449));
       allpoints.push(new PMPoint(-0.5, 0.866025, 0.00416667));
       allpoints.push(new PMPoint(-0.635135, 0.772401, 0.000273923));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-0.785714, 0.61859, 0.0122449));
       allpoints.push(new PMPoint(-0.928571, 0.371154, 0.00085034));
       allpoints.push(new PMPoint(-0.884615, 0.466321, 0.000138683));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-1, 0, 0.0375));
       allpoints.push(new PMPoint(-0.928571, 0.371154, 0.00085034));
       allpoints.push(new PMPoint(-0.965116, 0.261822, 0.0003245));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-1, 0, 0.0375));
       allpoints.push(new PMPoint(-0.951613, -0.307299, 0.000390218));
       allpoints.push(new PMPoint(-0.973684, -0.227901, 0.000184672));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-0.884615, -0.466321, 0.0035503));
       allpoints.push(new PMPoint(-0.951613, -0.307299, 0.000390218));
       allpoints.push(new PMPoint(-0.928571, -0.371154, 5.31463e-05));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-0.884615, -0.466321, 0.0035503));
       allpoints.push(new PMPoint(-0.785714, -0.61859, 0.000765306));
       allpoints.push(new PMPoint(-0.829114, -0.55908, 6.00865e-05));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-0.5, -0.866025, 0.0666667));
       allpoints.push(new PMPoint(-0.785714, -0.61859, 0.000765306));
       allpoints.push(new PMPoint(-0.72449, -0.689286, 0.000156185));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-0.5, -0.866025, 0.0666667));
       allpoints.push(new PMPoint(-0.142857, -0.989743, 0.000765306));
       allpoints.push(new PMPoint(-0.234694, -0.972069, 0.000156185));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0.0384615, -0.99926, 0.0035503));
       allpoints.push(new PMPoint(-0.142857, -0.989743, 0.000765306));
       allpoints.push(new PMPoint(-0.0696203, -0.997574, 6.00865e-05));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0.0384615, -0.99926, 0.0035503));
       allpoints.push(new PMPoint(0.209677, -0.977771, 0.000390219));
       allpoints.push(new PMPoint(0.142857, -0.989743, 5.31463e-05));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0.5, -0.866025, 0.0375));
       allpoints.push(new PMPoint(0.209677, -0.977771, 0.000390219));
       allpoints.push(new PMPoint(0.289474, -0.957186, 0.000184672));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0.5, -0.866025, 0.0375));
       allpoints.push(new PMPoint(0.785714, -0.61859, 0.00085034));
       allpoints.push(new PMPoint(0.709302, -0.704904, 0.0003245));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0.928571, -0.371154, 0.0122449));
       allpoints.push(new PMPoint(0.785714, -0.61859, 0.00085034));
       allpoints.push(new PMPoint(0.846154, -0.532939, 0.000138683));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0.928571, -0.371154, 0.0122449));
       allpoints.push(new PMPoint(1, 0, 0.00416667));
       allpoints.push(new PMPoint(0.986486, -0.163843, 0.000273923));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0.5, 0.866025, 0.6));
       allpoints.push(new PMPoint(1, 0, 0.00416667));
       allpoints.push(new PMPoint(0.973684, 0.227901, 0.00103878));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0.5, 0.866025, 0.6));
       allpoints.push(new PMPoint(-0.289474, 0.957186, 0.00103878));
       allpoints.push(new PMPoint(-0.142857, 0.989743, 0.000765306));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-0.5, 0.866025, 0.00416667));
       allpoints.push(new PMPoint(-0.289474, 0.957186, 0.00103878));
       allpoints.push(new PMPoint(-0.385246, 0.922814, 0.000161247));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-0.5, 0.866025, 0.00416667));
       allpoints.push(new PMPoint(-0.635135, 0.772401, 0.000273923));
       allpoints.push(new PMPoint(-0.587912, 0.808925, 7.2455e-05));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-0.785714, 0.61859, 0.0122449));
       allpoints.push(new PMPoint(-0.635135, 0.772401, 0.000273923));
       allpoints.push(new PMPoint(-0.684211, 0.729285, 6.49238e-05));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-0.785714, 0.61859, 0.0122449));
       allpoints.push(new PMPoint(-0.884615, 0.466321, 0.000138683));
       allpoints.push(new PMPoint(-0.860825, 0.508902, 6.37687e-05));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-0.928571, 0.371154, 0.00085034));
       allpoints.push(new PMPoint(-0.884615, 0.466321, 0.000138683));
       allpoints.push(new PMPoint(-0.902878, 0.429897, 3.10543e-05));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-0.928571, 0.371154, 0.00085034));
       allpoints.push(new PMPoint(-0.965116, 0.261822, 0.0003245));
       allpoints.push(new PMPoint(-0.951613, 0.307299, 2.43887e-05));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-1, 0, 0.0375));
       allpoints.push(new PMPoint(-0.965116, 0.261822, 0.0003245));
       allpoints.push(new PMPoint(-0.979452, 0.201677, 7.03697e-05));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-1, 0, 0.0375));
       allpoints.push(new PMPoint(-0.973684, -0.227901, 0.000184672));
       allpoints.push(new PMPoint(-0.983516, -0.180818, 4.52844e-05));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-0.951613, -0.307299, 0.000390218));
       allpoints.push(new PMPoint(-0.973684, -0.227901, 0.000184672));
       allpoints.push(new PMPoint(-0.965116, -0.261822, 1.26758e-05));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-0.951613, -0.307299, 0.000390218));
       allpoints.push(new PMPoint(-0.928571, -0.371154, 5.31463e-05));
       allpoints.push(new PMPoint(-0.937788, -0.347208, 1.27418e-05));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-0.884615, -0.466321, 0.0035503));
       allpoints.push(new PMPoint(-0.928571, -0.371154, 5.31463e-05));
       allpoints.push(new PMPoint(-0.917178, -0.398478, 2.25827e-05));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-0.884615, -0.466321, 0.0035503));
       allpoints.push(new PMPoint(-0.829114, -0.55908, 6.00865e-05));
       allpoints.push(new PMPoint(-0.846154, -0.532939, 1.54093e-05));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-0.785714, -0.61859, 0.000765306));
       allpoints.push(new PMPoint(-0.829114, -0.55908, 6.00865e-05));
       allpoints.push(new PMPoint(-0.813433, -0.581659, 1.48511e-05));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-0.785714, -0.61859, 0.000765306));
       allpoints.push(new PMPoint(-0.72449, -0.689286, 0.000156185));
       allpoints.push(new PMPoint(-0.751656, -0.659556, 2.63146e-05));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-0.5, -0.866025, 0.0666667));
       allpoints.push(new PMPoint(-0.72449, -0.689286, 0.000156185));
       allpoints.push(new PMPoint(-0.684211, -0.729285, 0.000103878));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-0.5, -0.866025, 0.0666667));
       allpoints.push(new PMPoint(-0.234694, -0.972069, 0.000156185));
       allpoints.push(new PMPoint(-0.289474, -0.957186, 0.000103878));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-0.142857, -0.989743, 0.000765306));
       allpoints.push(new PMPoint(-0.234694, -0.972069, 0.000156185));
       allpoints.push(new PMPoint(-0.195364, -0.980731, 2.63146e-05));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-0.142857, -0.989743, 0.000765306));
       allpoints.push(new PMPoint(-0.0696203, -0.997574, 6.00865e-05));
       allpoints.push(new PMPoint(-0.097015, -0.995283, 1.48511e-05));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0.0384615, -0.99926, 0.0035503));
       allpoints.push(new PMPoint(-0.0696203, -0.997574, 6.00865e-05));
       allpoints.push(new PMPoint(-0.0384616, -0.99926, 1.54093e-05));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0.0384615, -0.99926, 0.0035503));
       allpoints.push(new PMPoint(0.142857, -0.989743, 5.31463e-05));
       allpoints.push(new PMPoint(0.113497, -0.993538, 2.25827e-05));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0.209677, -0.977771, 0.000390219));
       allpoints.push(new PMPoint(0.142857, -0.989743, 5.31463e-05));
       allpoints.push(new PMPoint(0.168203, -0.985752, 1.27418e-05));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0.209677, -0.977771, 0.000390219));
       allpoints.push(new PMPoint(0.289474, -0.957186, 0.000184672));
       allpoints.push(new PMPoint(0.255814, -0.966726, 1.26758e-05));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0.5, -0.866025, 0.0375));
       allpoints.push(new PMPoint(0.289474, -0.957186, 0.000184672));
       allpoints.push(new PMPoint(0.335165, -0.94216, 4.52844e-05));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0.5, -0.866025, 0.0375));
       allpoints.push(new PMPoint(0.709302, -0.704904, 0.0003245));
       allpoints.push(new PMPoint(0.664384, -0.747392, 7.03697e-05));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0.785714, -0.61859, 0.00085034));
       allpoints.push(new PMPoint(0.709302, -0.704904, 0.0003245));
       allpoints.push(new PMPoint(0.741935, -0.670471, 2.43887e-05));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0.785714, -0.61859, 0.00085034));
       allpoints.push(new PMPoint(0.846154, -0.532939, 0.000138683));
       allpoints.push(new PMPoint(0.823741, -0.566966, 3.10543e-05));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0.928571, -0.371154, 0.0122449));
       allpoints.push(new PMPoint(0.846154, -0.532939, 0.000138683));
       allpoints.push(new PMPoint(0.871134, -0.491045, 6.37687e-05));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0.928571, -0.371154, 0.0122449));
       allpoints.push(new PMPoint(0.986486, -0.163843, 0.000273923));
       allpoints.push(new PMPoint(0.973684, -0.227901, 6.49238e-05));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(1, 0, 0.00416667));
       allpoints.push(new PMPoint(0.986486, -0.163843, 0.000273923));
       allpoints.push(new PMPoint(0.994505, -0.104684, 7.2455e-05));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(1, 0, 0.00416667));
       allpoints.push(new PMPoint(0.973684, 0.227901, 0.00103878));
       allpoints.push(new PMPoint(0.991803, 0.127774, 0.000161247));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0.5, 0.866025, 0.6));
       allpoints.push(new PMPoint(0.973684, 0.227901, 0.00103878));
       allpoints.push(new PMPoint(0.928571, 0.371154, 0.000765306));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0.5, 0.866025, 0.6));
       allpoints.push(new PMPoint(-0.142857, 0.989743, 0.000765306));
       allpoints.push(new PMPoint(-0.0384616, 0.99926, 0.000394477));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-0.289474, 0.957186, 0.00103878));
       allpoints.push(new PMPoint(-0.142857, 0.989743, 0.000765306));
       allpoints.push(new PMPoint(-0.209677, 0.977771, 6.93722e-05));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-0.289474, 0.957186, 0.00103878));
       allpoints.push(new PMPoint(-0.385246, 0.922814, 0.000161247));
       allpoints.push(new PMPoint(-0.351351, 0.936244, 2.73923e-05));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-0.5, 0.866025, 0.00416667));
       allpoints.push(new PMPoint(-0.385246, 0.922814, 0.000161247));
       allpoints.push(new PMPoint(-0.42126, 0.90694, 2.325e-05));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-0.5, 0.866025, 0.00416667));
       allpoints.push(new PMPoint(-0.587912, 0.808925, 7.2455e-05));
       allpoints.push(new PMPoint(-0.565089, 0.82503, 1.31298e-05));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-0.635135, 0.772401, 0.000273923));
       allpoints.push(new PMPoint(-0.587912, 0.808925, 7.2455e-05));
       allpoints.push(new PMPoint(-0.606557, 0.79504, 0));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-0.635135, 0.772401, 0.000273923));
       allpoints.push(new PMPoint(-0.684211, 0.729285, 6.49238e-05));
       allpoints.push(new PMPoint(-0.664384, 0.747392, 1.25102e-05));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-0.785714, 0.61859, 0.0122449));
       allpoints.push(new PMPoint(-0.684211, 0.729285, 6.49238e-05));
       allpoints.push(new PMPoint(-0.709302, 0.704904, 3.60555e-05));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-0.785714, 0.61859, 0.0122449));
       allpoints.push(new PMPoint(-0.860825, 0.508902, 6.37687e-05));
       allpoints.push(new PMPoint(-0.846154, 0.532939, 1.54093e-05));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-0.884615, 0.466321, 0.000138683));
       allpoints.push(new PMPoint(-0.860825, 0.508902, 6.37687e-05));
       allpoints.push(new PMPoint(-0.871134, 0.491045, 0));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-0.884615, 0.466321, 0.000138683));
       allpoints.push(new PMPoint(-0.902878, 0.429897, 3.10543e-05));
       allpoints.push(new PMPoint(-0.896122, 0.443808, 0));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-0.928571, 0.371154, 0.00085034));
       allpoints.push(new PMPoint(-0.902878, 0.429897, 3.10543e-05));
       allpoints.push(new PMPoint(-0.910448, 0.413624, 0));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-0.928571, 0.371154, 0.00085034));
       allpoints.push(new PMPoint(-0.951613, 0.307299, 2.43887e-05));
       allpoints.push(new PMPoint(-0.945344, 0.326074, 0));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-0.965116, 0.261822, 0.0003245));
       allpoints.push(new PMPoint(-0.951613, 0.307299, 2.43887e-05));
       allpoints.push(new PMPoint(-0.956869, 0.29052, 0));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-0.965116, 0.261822, 0.0003245));
       allpoints.push(new PMPoint(-0.979452, 0.201677, 7.03697e-05));
       allpoints.push(new PMPoint(-0.973684, 0.227901, 1.1542e-05));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-1, 0, 0.0375));
       allpoints.push(new PMPoint(-0.979452, 0.201677, 7.03697e-05));
       allpoints.push(new PMPoint(-0.986486, 0.163843, 3.04358e-05));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-1, 0, 0.0375));
       allpoints.push(new PMPoint(-0.983516, -0.180818, 4.52844e-05));
       allpoints.push(new PMPoint(-0.988722, -0.149764, 2.11996e-05));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-0.973684, -0.227901, 0.000184672));
       allpoints.push(new PMPoint(-0.983516, -0.180818, 4.52844e-05));
       allpoints.push(new PMPoint(-0.979452, -0.201677, 0));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-0.973684, -0.227901, 0.000184672));
       allpoints.push(new PMPoint(-0.965116, -0.261822, 1.26758e-05));
       allpoints.push(new PMPoint(-0.968384, -0.249464, 0));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-0.951613, -0.307299, 0.000390218));
       allpoints.push(new PMPoint(-0.965116, -0.261822, 1.26758e-05));
       allpoints.push(new PMPoint(-0.961318, -0.275441, 0));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-0.951613, -0.307299, 0.000390218));
       allpoints.push(new PMPoint(-0.937788, -0.347208, 1.27418e-05));
       allpoints.push(new PMPoint(-0.941748, -0.336321, 0));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-0.928571, -0.371154, 5.31463e-05));
       allpoints.push(new PMPoint(-0.937788, -0.347208, 1.27418e-05));
       allpoints.push(new PMPoint(-0.934326, -0.35642, 0));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-0.928571, -0.371154, 5.31463e-05));
       allpoints.push(new PMPoint(-0.917178, -0.398478, 2.25827e-05));
       allpoints.push(new PMPoint(-0.922037, -0.387101, 0));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-0.884615, -0.466321, 0.0035503));
       allpoints.push(new PMPoint(-0.917178, -0.398478, 2.25827e-05));
       allpoints.push(new PMPoint(-0.910448, -0.413624, 0));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-0.884615, -0.466321, 0.0035503));
       allpoints.push(new PMPoint(-0.846154, -0.532939, 1.54093e-05));
       allpoints.push(new PMPoint(-0.855212, -0.518278, 0));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-0.829114, -0.55908, 6.00865e-05));
       allpoints.push(new PMPoint(-0.846154, -0.532939, 1.54093e-05));
       allpoints.push(new PMPoint(-0.839169, -0.543872, 0));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-0.829114, -0.55908, 6.00865e-05));
       allpoints.push(new PMPoint(-0.813433, -0.581659, 1.48511e-05));
       allpoints.push(new PMPoint(-0.819549, -0.573009, 0));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-0.785714, -0.61859, 0.000765306));
       allpoints.push(new PMPoint(-0.813433, -0.581659, 1.48511e-05));
       allpoints.push(new PMPoint(-0.806069, -0.591822, 0));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-0.785714, -0.61859, 0.000765306));
       allpoints.push(new PMPoint(-0.751656, -0.659556, 2.63146e-05));
       allpoints.push(new PMPoint(-0.762136, -0.647417, 0));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-0.72449, -0.689286, 0.000156185));
       allpoints.push(new PMPoint(-0.751656, -0.659556, 2.63146e-05));
       allpoints.push(new PMPoint(-0.741936, -0.670471, 0));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-0.72449, -0.689286, 0.000156185));
       allpoints.push(new PMPoint(-0.684211, -0.729285, 0.000103878));
       allpoints.push(new PMPoint(-0.702429, -0.711754, 0));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(-0.5, -0.866025, 0.0666667));
       allpoints.push(new PMPoint(-0.684211, -0.729285, 0.000103878));
       allpoints.push(new PMPoint(-0.655963, -0.754793, 5.05008e-05));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x50B4FF, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
    // COMMON_CODE_BLOCK_BEGIN
    var xRotationEnabled = false;
    var yRotationEnabled = false;
    var zRotationEnabled = false;
    var rotationSpeedFactor = 1;
    var settingsShown = false;
    var labelsShown = true;
    var intervals = [];
    var timeouts = [];
    var explodingSpeed = 0.05;
    var explodeScale = 0;
    var XMLS = new XMLSerializer();
    var svgElement;
    var renderId;
    
    	var render = function () {
    
    		renderId = requestAnimationFrame(render);
    
    //		comment in for automatic explosion
    //		explode(updateFactor());
    
    		var phi = 0.02 * rotationSpeedFactor;
    
    		if (xRotationEnabled){
    			scene.rotation.x += phi;
    		}
    		if(yRotationEnabled){
    			scene.rotation.y += phi;
    		}
    		if(zRotationEnabled){
    			scene.rotation.z += phi;
    		}
    
    		controls.update();
    		renderer.render(scene, camera);
    	};
    
    	render();
    
    	function computeCentroid(geom) {
    		centroid = new THREE.Vector3();
    		geom.vertices.forEach(function(v) {
    			centroid.add(v);			
    		});
    		centroid.divideScalar(geom.vertices.length);
    		return centroid;
    	}
    
    	function changeTransparency(event){
    		var opacity = 1-Number(event.currentTarget.value);
    		for (var i=0; i<all_objects.length; i++){
    			for (var j=0; j<all_objects[i].children.length; j++){
    				if (all_objects[i].children[j].material.type == "MultiMaterial") {
    					for (var k=0; k<all_objects[i].children[j].material.materials.length; k++){
    						all_objects[i].children[j].material.materials[k].opacity = opacity;
    						all_objects[i].children[j].material.materials[k].depthWrite = opacity < 0.5 ? false : true;
    						all_objects[i].children[j].material.materials[k].depthTest = opacity < 0.5 ? false : true;
    					}
    				} else if (all_objects[i].children[j].material.transparent && 
    							  all_objects[i].children[j].material.type == "MeshBasicMaterial" &&
    							  all_objects[i].children[j].geometry.type == "Geometry"){
    					all_objects[i].children[j].material.opacity = opacity;
    					all_objects[i].children[j].material.depthWrite = opacity < 0.5 ? false : true;
    					all_objects[i].children[j].material.depthTest = opacity < 0.5 ? false : true;
    				}
    			}
    		}
    	}
    
    	function changeRotationX(event){
    		xRotationEnabled = event.currentTarget.checked;
    	}	
    
    	function changeRotationY(event){
    		yRotationEnabled = event.currentTarget.checked;
    	}	
    
    	function changeRotationZ(event){
    		zRotationEnabled = event.currentTarget.checked;
    	}	
    
    
    	function changeRotationSpeedFactor(event){
    		rotationSpeedFactor = Number(event.currentTarget.value);
    	}
    
    	function resetScene(){
    		scene.rotation.set(0,0,0);
    		camera.position.set(0,0,5);
    		camera.up.set(0,1,0);
    	}
    
    	function showSettings(event){
    		event.currentTarget.style.display = 'none';
    		document.getElementById('settings_8').style.position = 'absolute';
    		document.getElementById('settings_8').style.display = 'block';
    		document.getElementById('showSettingsButton_8').style.display = 'none';
    		document.getElementById('hideSettingsButton_8').style.display = 'block';
    		settingsShown = true;
    	}
    
    	function hideSettings(event){
    		event.currentTarget.style.display = 'none';
    		document.getElementById('settings_8').style.display = 'none';
    		document.getElementById('hideSettingsButton_8').style.display = 'none';
    		document.getElementById('showSettingsButton_8').style.display = 'block';
    		settingsShown = false;
    	}
    
    
    
    	var pos = 150* Math.PI;
    
    	function updateFactor() {
    		pos++;
    		return Math.sin(.01*pos)+1;
    	}
    
    	function makelabel(message, x, y, z, params) {
    		var spritey = textSprite( message, params );
    		spritey.position.set(x, y, z);
    		obj.add(spritey);
    	}
    
    	function textSprite(message, parameters)
    	{
    		if ( parameters === undefined ) parameters = {};
    
    		var fontface = "Helvetica";
    
    		var fontsize = parameters.hasOwnProperty("fontsize") ? 
    			parameters["fontsize"] : 18;
    		fontsize = fontsize*10;
    
    		var canvas = document.createElement('canvas');
    		var size = 1024;
    		canvas.width = size;
    		canvas.height = size;
    		var context = canvas.getContext('2d');
    		context.font = fontsize + "px " + fontface;
    
    		// text color
    		context.fillStyle = "rgba(0, 0, 0, 1.0)";
    
    		context.fillText(message, size/2, size/2);
    
    		// canvas contents will be used for a texture
    		var texture = new THREE.Texture(canvas);
    		texture.needsUpdate = true;
    
    		var spriteMaterial = new THREE.SpriteMaterial(
    			{map: texture, useScreenCoordinates: false});
    		var sprite = new THREE.Sprite(spriteMaterial);
    		return sprite;
    	}
    
    	function takeSvgScreenshot(){
    		if (labelsShown){
    			hideLabels();
    		}
    		svgRenderer.render(scene,camera);
    		svgElement = XMLS.serializeToString(svgRenderer.domElement);
    		
    		if (labelsShown){
    			displayLabels();
    		}
    
    		if (document.getElementById('tab_8').checked){
    			//show in new tab
    			var myWindow = window.open("","");
    			myWindow.document.body.innerHTML = svgElement;
    		} else{
    			// download svg file 
    			download("screenshot.svg", svgElement);
    		}
    	}
    		
    
    	function showOrHideObject(event){
    		var nr = Number(event.currentTarget.name);
    		all_objects[nr].visible = event.currentTarget.checked;
    	}
    
    
    	function displayOrHideOptions(){
    		for (var i=0; i<all_objects.length; i++){
    			for (var j=0; j<all_objects[i].children.length; j++){
    				if (all_objects[i].children[j].material.type == "MultiMaterial") {
    					for (var k=0; k<all_objects[i].children[j].material.materials.length; k++){
    						if (all_objects[i].children[j].material.materials[k].transparent) {
    							document.getElementById('transparency_8').style.display = 'block';
    							document.getElementById('transparencyRange_8').value = 1 - 
    							    all_objects[i].children[j].material.materials[k].opacity;
    							return;
    						}
    					}
    				} else if (all_objects[i].children[j].material.transparent && 
    							  all_objects[i].children[j].material.type == "MeshBasicMaterial" &&
    							  all_objects[i].children[j].geometry.type == "Geometry"){
    					document.getElementById('transparency_8').style.display = 'block';
    					return;
    				}
    			}
    		}
    	}
    
    	displayOrHideOptions()
    
    
    
    
    // ---------------------- EXPLOSION ------------------------------------------------
    // ---------------------------------------------------------------------------------
    
    	function explode(factor) {
    		var obj, c;
    		var c0 = centroids[0];
    		for (var i = 0; i<centroids.length; ++i) {
    			c = centroids[i];
    			obj = all_objects[all_objects.length - centroids.length + i];
    			obj.position.set(c.x*factor, c.y*factor, c.z*factor);
    		}	
    	}
    
    	function triggerExplode(event){
    		explodeScale = Number(event.currentTarget.value);
    		explode(explodeScale);
    	}
    
    	function setExplodingSpeed(event){
    		explodingSpeed = Number(event.currentTarget.value);
    	}
    
    	function triggerAutomaticExplode(event){
    		if (event.currentTarget.checked){
    			startExploding();
    		} else {
    			clearIntervals();
    		}	
    	}
    
    	function startExploding(){
    		intervals.push(setInterval(explodingInterval, 25));
    	}
    
    
    	function explodingInterval(){
    		explodeScale += explodingSpeed;
    		if (explodeScale <= 6){ 
    			explode(explodeScale);
    		}
    		else{
    			explode(6);
    			explodeScale = 6;
    			clearIntervals();
    			timeouts.push(setTimeout(startUnexploding, 3000));
    		}
    		document.getElementById('explodeRange_8').value = explodeScale;
    	}
    
    
    	function startUnexploding(){
    		intervals.push(setInterval(unexplodingInterval, 25));
    	}
    
    	function unexplodingInterval(){
    		explodeScale -= explodingSpeed;
    		if (explodeScale >= 0){	
    			explode(explodeScale);
    		}
    		else {
    			explode(0);
    			explodeScale = 0;
    			clearIntervals();
    			timeouts.push(setTimeout(startExploding, 3000));
    		}
    		document.getElementById('explodeRange_8').value = explodeScale;
    	}
    
    	function clearIntervals(){
    		intervals.forEach(function(interval){
    			clearInterval(interval);
    		});
    		intervals = [];
    		timeouts.forEach(function(timeout){
    			clearTimeout(timeout);
    		});
    		timeouts = [];
    	}
    
    			
    
    	// append checkboxes for displaying or hiding objects
    	var shownObjectsList = document.getElementById('shownObjectsList_8');
    	for (var i=0; i<all_objects.length; i++){
    		var objNode = document.createElement('span');
    		objNode.innerHTML = objectnames[i] + '<br>';
    		var checkbox = document.createElement('input');
    		checkbox.type = 'checkbox';
    		checkbox.checked = true;
    		checkbox.name = String(i);
    		checkbox.onchange = showOrHideObject;
    		shownObjectsList.appendChild(checkbox);
    		shownObjectsList.appendChild(objNode);
    	}
    
    	function displayLabels(){
    		for (var i=0; i<all_objects.length; i++){
    			for (var j=0; j<all_objects[i].children.length; j++){
    				var child = all_objects[i].children[j];
    				if (child.type == 'Sprite'){
    					child.visible = true;
    				}
    			}
    		}
    	}
    
    	function hideLabels(){
    		for (var i=0; i<all_objects.length; i++){
    			for (var j=0; j<all_objects[i].children.length; j++){
    				var child = all_objects[i].children[j];
    				if (child.type == 'Sprite'){
    					child.visible = false;
    				}
    			}
    		}
    	}
    
    	function displayOrHideLabels(event){
    		if (event.currentTarget.checked){
    			displayLabels();
    			labelsShown = true;
    		} else {
    			hideLabels();
    			labelsShown = false;
    		}
    	}
    
    	function download(filename, text) {
    	  var element = document.createElement('a');
    	  element.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(text));
    	  element.setAttribute('download', filename);
    
    	  element.style.display = 'none';
    	  document.body.appendChild(element);
    
    	  element.click();
    
    	  document.body.removeChild(element);
    	}
    
    var tempobj;
    tempobj = document.getElementById('explodeRange_8');
    if (tempobj) {
       tempobj.oninput = triggerExplode;
       document.getElementById('explodeCheckbox_8').onchange = triggerAutomaticExplode;
       document.getElementById('explodingSpeedRange_8').oninput = setExplodingSpeed;
    }
    tempobj = document.getElementById('foldRange_8');
    if (tempobj) {
       tempobj.oninput = fold;
    }
    document.getElementById('transparencyRange_8').oninput = changeTransparency;
    document.getElementById('changeRotationX_8').onchange = changeRotationX;
    document.getElementById('changeRotationY_8').onchange = changeRotationY;
    document.getElementById('changeRotationZ_8').onchange = changeRotationZ;
    document.getElementById('resetButton_8').onclick = resetScene;
    document.getElementById('rotationSpeedRange_8').oninput = changeRotationSpeedFactor;
    document.getElementById('labelsCheckboxInput_8').onchange = displayOrHideLabels;
    document.getElementById('takeScreenshot_8').onclick = takeSvgScreenshot;
    document.getElementById('showSettingsButton_8').onclick = showSettings;
    document.getElementById('hideSettingsButton_8').onclick = hideSettings;
    
    	
    
    // ------------------ SHORTCUTS --------------------------------------------
    // -------------------------------------------------------------------------
    
    /**
     * http://www.openjs.com/scripts/events/keyboard_shortcuts/
     * Version : 2.01.B
     * By Binny V A
     * License : BSD
     */
    shortcut = {
    	'all_shortcuts':{},//All the shortcuts are stored in this array
    	'add': function(shortcut_combination,callback,opt) {
    		//Provide a set of default options
    		var default_options = {
    			'type':'keydown',
    			'propagate':false,
    			'disable_in_input':false,
    			'target':document,
    			'keycode':false
    		}
    		if(!opt) opt = default_options;
    		else {
    			for(var dfo in default_options) {
    				if(typeof opt[dfo] == 'undefined') opt[dfo] = default_options[dfo];
    			}
    		}
    
    		var ele = opt.target;
    		if(typeof opt.target == 'string') ele = document.getElementById(opt.target);
    		var ths = this;
    		shortcut_combination = shortcut_combination.toLowerCase();
    
    		//The function to be called at keypress
    		var func = function(e) {
    			e = e || window.event;
    			
    			if(opt['disable_in_input']) { //Don't enable shortcut keys in Input, Textarea fields
    				var element;
    				if(e.target) element=e.target;
    				else if(e.srcElement) element=e.srcElement;
    				if(element.nodeType==3) element=element.parentNode;
    
    				if(element.tagName == 'INPUT' || element.tagName == 'TEXTAREA') return;
    			}
    	
    			//Find Which key is pressed
    			if (e.keyCode) code = e.keyCode;
    			else if (e.which) code = e.which;
    			var character = String.fromCharCode(code).toLowerCase();
    			
    			if(code == 188) character=","; //If the user presses , when the type is onkeydown
    			if(code == 190) character="."; //If the user presses , when the type is onkeydown
    
    			var keys = shortcut_combination.split("+");
    			//Key Pressed - counts the number of valid keypresses - if it is same as the number of keys, the shortcut function is invoked
    			var kp = 0;
    			
    			//Work around for stupid Shift key bug created by using lowercase - as a result the shift+num combination was broken
    			var shift_nums = {
    				"`":"~",
    				"1":"!",
    				"2":"@",
    				"3":"#",
    				"4":"$",
    				"5":"%",
    				"6":"^",
    				"7":"&",
    				"8":"*",
    				"9":"(",
    				"0":")",
    				"-":"_",
    				"=":"+",
    				";":":",
    				"'":"\"",
    				",":"<",
    				".":">",
    				"/":"?",
    				"\\":"|"
    			}
    			//Special Keys - and their codes
    			var special_keys = {
    				'esc':27,
    				'escape':27,
    				'tab':9,
    				'space':32,
    				'return':13,
    				'enter':13,
    				'backspace':8,
    	
    				'scrolllock':145,
    				'scroll_lock':145,
    				'scroll':145,
    				'capslock':20,
    				'caps_lock':20,
    				'caps':20,
    				'numlock':144,
    				'num_lock':144,
    				'num':144,
    				
    				'pause':19,
    				'break':19,
    				
    				'insert':45,
    				'home':36,
    				'delete':46,
    				'end':35,
    				
    				'pageup':33,
    				'page_up':33,
    				'pu':33,
    	
    				'pagedown':34,
    				'page_down':34,
    				'pd':34,
    	
    				'left':37,
    				'up':38,
    				'right':39,
    				'down':40,
    	
    				'f1':112,
    				'f2':113,
    				'f3':114,
    				'f4':115,
    				'f5':116,
    				'f6':117,
    				'f7':118,
    				'f8':119,
    				'f9':120,
    				'f10':121,
    				'f11':122,
    				'f12':123
    			}
    	
    			var modifiers = { 
    				shift: { wanted:false, pressed:false},
    				ctrl : { wanted:false, pressed:false},
    				alt  : { wanted:false, pressed:false},
    				meta : { wanted:false, pressed:false}	//Meta is Mac specific
    			};
                            
    			if(e.ctrlKey)	modifiers.ctrl.pressed = true;
    			if(e.shiftKey)	modifiers.shift.pressed = true;
    			if(e.altKey)	modifiers.alt.pressed = true;
    			if(e.metaKey)   modifiers.meta.pressed = true;
                            
    			for(var i=0; k=keys[i],i<keys.length; i++) {
    				//Modifiers
    				if(k == 'ctrl' || k == 'control') {
    					kp++;
    					modifiers.ctrl.wanted = true;
    
    				} else if(k == 'shift') {
    					kp++;
    					modifiers.shift.wanted = true;
    
    				} else if(k == 'alt') {
    					kp++;
    					modifiers.alt.wanted = true;
    				} else if(k == 'meta') {
    					kp++;
    					modifiers.meta.wanted = true;
    				} else if(k.length > 1) { //If it is a special key
    					if(special_keys[k] == code) kp++;
    					
    				} else if(opt['keycode']) {
    					if(opt['keycode'] == code) kp++;
    
    				} else { //The special keys did not match
    					if(character == k) kp++;
    					else {
    						if(shift_nums[character] && e.shiftKey) { //Stupid Shift key bug created by using lowercase
    							character = shift_nums[character]; 
    							if(character == k) kp++;
    						}
    					}
    				}
    			}
    			
    			if(kp == keys.length && 
    						modifiers.ctrl.pressed == modifiers.ctrl.wanted &&
    						modifiers.shift.pressed == modifiers.shift.wanted &&
    						modifiers.alt.pressed == modifiers.alt.wanted &&
    						modifiers.meta.pressed == modifiers.meta.wanted) {
    				callback(e);
    	
    				if(!opt['propagate']) { //Stop the event
    					//e.cancelBubble is supported by IE - this will kill the bubbling process.
    					e.cancelBubble = true;
    					e.returnValue = false;
    	
    					//e.stopPropagation works in Firefox.
    					if (e.stopPropagation) {
    						e.stopPropagation();
    						e.preventDefault();
    					}
    					return false;
    				}
    			}
    		}
    		this.all_shortcuts[shortcut_combination] = {
    			'callback':func, 
    			'target':ele, 
    			'event': opt['type']
    		};
    		//Attach the function with the event
    		if(ele.addEventListener) ele.addEventListener(opt['type'], func, false);
    		else if(ele.attachEvent) ele.attachEvent('on'+opt['type'], func);
    		else ele['on'+opt['type']] = func;
    	},
    
    	//Remove the shortcut - just specify the shortcut and I will remove the binding
    	'remove':function(shortcut_combination) {
    		shortcut_combination = shortcut_combination.toLowerCase();
    		var binding = this.all_shortcuts[shortcut_combination];
    		delete(this.all_shortcuts[shortcut_combination])
    		if(!binding) return;
    		var type = binding['event'];
    		var ele = binding['target'];
    		var callback = binding['callback'];
    
    		if(ele.detachEvent) ele.detachEvent('on'+type, callback);
    		else if(ele.removeEventListener) ele.removeEventListener(type, callback, false);
    		else ele['on'+type] = false;
    	}
    }
    
    shortcut.add("Alt+Left",function() {
    	var event = new Event('click');
    	if (settingsShown){
    		document.getElementById('hideSettingsButton_8').dispatchEvent(event);
    	} else{
    		document.getElementById('showSettingsButton_8').dispatchEvent(event);
    	}
    });
    
    if (foldable) moveToBaryCenter();
    
    
    });});
    // COMMON_CODE_BLOCK_END
    </script>
    
    </body>
    </html>






More examples can be studied via the following:
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


.. link

.. CODE-BLOCK:: perl

    polymake> # a torus with two cusps (6 edges)
    polymake> $T2 = new Array<Array<Int>>([[0,0,6,5],[0,0,1,10],[0,0,8,2],[1,0,11,4],[1,0,7,3],[1,0,9,0]]);
    polymake> 
    polymake> # a sphere with four cusps (6 edges)
    polymake> $S4 = new Array<Array<Int>>([[1,0,2,6],[2,1,4,9],[0,2,0,11],[3,0,8,5],[1,3,1,10],[2,3,3,7]]);
    polymake> 
    polymake> # a double torus with two cusps (12 edges)
    polymake> $DT2 = new Array<Array<Int>>([[0,0,8,10],[0,0,12,14],[0,0,16,18],[0,0,20,22],[1,0,23,2],[1,0,13,3],[1,0,9,1],[1,0,11,4],[1,0,15,6],[1,0,21,7],[1,0,17,5],[1,0,19,0]]);

To study 4-dim. secondary fans the following method is useful. It
intersects the secondary fan with the 3-dim. standard simplex.


.. link

.. CODE-BLOCK:: perl

    polymake> sub norm($){
    polymake>    my $B = new Matrix(shift);
    polymake>    for (my $i = 0; $i < $B->rows(); ++$i) {
    polymake>       my $sum = 0;
    polymake>       for (my $j = 1; $j < $B->cols(); ++$j) {
    polymake>          $sum = $sum + $B->elem($i,$j);
    polymake>       }
    polymake>       $x = 1/$sum;
    polymake>       $B->row($i) = $x * $B->row($i);
    polymake>    }
    polymake>    return $B;
    polymake> }

.. link

.. CODE-BLOCK:: perl

    polymake> $s = new HyperbolicSurface(DCEL_DATA=>$S4,PENNER_COORDINATES=>[1,1,1,1,1,1],SPECIAL_POINT=>[1,0]);
    polymake> $f = $s->SECONDARY_FAN;
    polymake> $v = ones_vector | $f->RAYS;
    polymake> $a = norm($v);
    polymake> $b = $a->minor(All,~[0]);
    polymake> $c = ones_vector | $b;

.. link

.. CODE-BLOCK:: perl

    polymake> $q = new fan::PolyhedralComplex(POINTS=>$c,INPUT_POLYTOPES=>rows($f->MAXIMAL_CONES));
    polymake> $pro = fan::project_full($q);
    polymake> $pro->VISUAL;


.. raw:: html

    <!--
    polymake for loewe
    Fri Feb  9 13:51:05 2018
    pcom:pro
    -->
    
    
    <html>
       <head>
          <title>pcom:pro</title>
          <style>
    /*
    // COMMON_CODE_BLOCK_BEGIN
    */
             html{overflow: scroll;}
             body { font-family: Arial, Helvetica, sans-serif}
             strong{font-size: 18px;}
             canvas { z-index: 8; }
             input[type='range'] {}
             input[type='radio'] {margin-left:0;}
             input[type='checkbox'] {margin-right:7px; margin-left: 0px; padding-left:0px;}
             .group{padding-bottom: 40px;}
             .settings * {z-index: 11; }
             .settings{z-index: 10; margin-left: 30px; display: none; width: 14em; height: 90%; border: solid 1px silver; padding: 2px; overflow-y: scroll; background-color: white }
             .indented{margin-left: 20px; margin-top: 15px; padding-bottom: 0px;} 
             .shownObjectsList{overflow: auto; max-width: 150px; max-height: 150px;}
             .showSettingsButton{display: block; z-index: 12; position: absolute }
             .hideSettingsButton{display: none; z-index: 12; position: absolute; opacity: 0.5}
             .resetButton{margin-top: 20px;}
             button{margin-left: 0;}
             img{cursor: pointer;}
             .suboption{padding-top: 30px;}
             .transparency{display: none;}
             .labelsCheckbox{margin-top: 10px;}
    
    
             input[type=range] {
               -webkit-appearance: none;
               padding:0; 
               width:90%; 
               margin-left: auto;
               margin-right: auto;
               margin-top: 20px;
               display: block;	
             }
             input[type=range]:focus {
               outline: none;
             }
             input[type=range]::-webkit-slider-runnable-track {
               height: 4px;
               cursor: pointer;
               animate: 0.2s;
               box-shadow: 0px 0px 0px #000000;
               background: #E3E3E3;
               border-radius: 0px;
               border: 0px solid #000000;
             }
             input[type=range]::-webkit-slider-thumb {
               box-shadow: 1px 1px 2px #B8B8B8;
               border: 1px solid #ABABAB;
               height: 13px;
               width: 25px;
               border-radius: 20px;
               background: #E0E0E0;
               cursor: pointer;
               -webkit-appearance: none;
               margin-top: -5px;
             }
             input[type=range]:focus::-webkit-slider-runnable-track {
               background: #E3E3E3;
             }
             input[type=range]::-moz-range-track {
               height: 4px;
               cursor: pointer;
               animate: 0.2s;
               box-shadow: 0px 0px 0px #000000;
               background: #E3E3E3;
               border-radius: 0px;
               border: 0px solid #000000;
             }
             input[type=range]::-moz-range-thumb {
               box-shadow: 1px 1px 2px #B8B8B8;
               border: 1px solid #ABABAB;
               height: 13px;
               width: 25px;
               border-radius: 20px;
               background: #E0E0E0;
               cursor: pointer;
             }
             input[type=range]::-ms-track {
               height: 4px;
               cursor: pointer;
               animate: 0.2s;
               background: transparent;
               border-color: transparent;
               color: transparent;
             }
             input[type=range]::-ms-fill-lower {
               background: #E3E3E3;
               border: 0px solid #000000;
               border-radius: 0px;
               box-shadow: 0px 0px 0px #000000;
             }
             input[type=range]::-ms-fill-upper {
               background: #E3E3E3;
               border: 0px solid #000000;
               border-radius: 0px;
               box-shadow: 0px 0px 0px #000000;
             }
             input[type=range]::-ms-thumb {
               box-shadow: 1px 1px 2px #B8B8B8;
               border: 1px solid #ABABAB;
               height: 13px;
               width: 25px;
               border-radius: 20px;
               background: #E0E0E0;
               cursor: pointer;
             }
             input[type=range]:focus::-ms-fill-lower {
               background: #E3E3E3;
             }
             input[type=range]:focus::-ms-fill-upper {
               background: #E3E3E3;
             }
    /*
    // COMMON_CODE_BLOCK_END
    */
    		</style>
       </head>
    
    <body>
    
    		<div id='settings_9' class='settings'>
    			<div class=group id='explode_9'>
    				<strong>Explode</strong>
    				<input id='explodeRange_9' type='range' min=0 max=6 step=0.01 value=0>
    				<div class=indented><input id='explodeCheckbox_9' type='checkbox'>Automatic explosion</div>
    				<div class=suboption>Exploding speed</div>
    				<input id='explodingSpeedRange_9' type='range' min=0 max=0.5 step=0.001 value=0.05>
    			</div>
    
    			
    			<div class=group id='transparency_9' class='transparency'>
    				<strong>Transparency</strong>
    				<input id='transparencyRange_9' type='range' min=0 max=1 step=0.01 value=0>
    			</div>
    			
    			<div class=group id='rotation_9'>
    				<strong>Rotation</strong>
    				<div class=indented>
    					<div><input type='checkbox' id='changeRotationX_9'> x-axis</div>
    					<div><input type='checkbox' id='changeRotationY_9'> y-axis</div>
    					<div><input type='checkbox' id='changeRotationZ_9'> z-axis</div>
    					<button id='resetButton_9' class='resetButton' >Reset</button>
    				</div>
    
    				<div class=suboption>Rotation speed</div>
    				<input id='rotationSpeedRange_9' type='range' min=0 max=5 step=0.01 value=2>
    
    			</div>
    
    
    			<div class=group id='display_9'>
    				<strong>Display</strong>
    				<div class=indented>
    					<div id='shownObjectsList_9' class='shownObjectsList'></div>
    					<div class='labelsCheckbox'><input type='checkbox' id='labelsCheckboxInput_9' checked>Labels</div>
    				</div>
    			</div>
    
    
    			<div class=group id='svg_9'>
    				<strong>SVG</strong>
    				<div class=indented>
    					<form>
    						<input type="radio" name='screenshotMode' value='download' id='download_9' checked> Download<br>
    						<input type="radio" name='screenshotMode' value='tab' id='tab_9' > New tab<br>
    					</form>
    					<button id='takeScreenshot_9'>Screenshot</button>
    				</div>
    			</div>
    
    		</div>	<!-- end of settings -->
    		<img id='hideSettingsButton_9' style="display: none" class='hideSettingsButton' src='/kernelspecs/polymake/close.svg' width=20px">
    		<img id='showSettingsButton_9' class='showSettingsButton' src='/kernelspecs/polymake/menu.svg' width=20px">
    <div id="model98861580906"></div>
    
    <script>
    requirejs.config({
      paths: {
        three: '/kernelspecs/polymake/three',
        Detector: '/kernelspecs/polymake/Detector',
        SVGRenderer: '/kernelspecs/polymake/SVGRenderer',
        CanvasRenderer: '/kernelspecs/polymake/CanvasRenderer',
        Projector: '/kernelspecs/polymake/Projector',
        TrackballControls: '/kernelspecs/polymake/TrackballControls'
      },
      shim: {
        'three':
        {
          exports: 'THREE'
        },
        'Detector':
        {
          deps: [ 'three' ],
          exports: 'Detector'
        },
        'SVGRenderer':
        {
          deps: [ 'three' ],
          exports: 'THREE.SVGRenderer'
        },
        'CanvasRenderer':
        {
          deps: [ 'three' ],
          exports: 'THREE.CanvasRenderer'
        },
        'Projector':
        {
          deps: [ 'three' ],
          exports: 'THREE.Projector'
        },
        'TrackballControls':
        {
          deps: [ 'three' ],
          exports: 'THREE.TrackballControls'
        }
      }
    });
    require(['three'],function(THREE){
        window.THREE = THREE;
      require(['Detector','SVGRenderer','CanvasRenderer','Projector','TrackballControls'],function(Detector,SVGRenderer,CanvasRenderer,Projector,TrackballControls){
          THREE.SVGRenderer = SVGRenderer;
          THREE.CanvasRenderer = CanvasRenderer;
          THREE.Projector = Projector;
          THREE.TrackballControls = TrackballControls;
    
    // COMMON_CODE_BLOCK_BEGIN
    	var foldable = false;
       var container = document.getElementById( 'model98861580906' );
       var renderer = Detector.webgl? new THREE.WebGLRenderer({antialias: true}): new THREE.CanvasRenderer({antialias: true});
    	var svgRenderer = new THREE.SVGRenderer({antialias: true});
                var box = document.getElementsByClassName( 'output_subarea' )[0];
             var notebook = document.getElementById( 'notebook_panel' );
    
       var width = box.clientWidth - 25;
       var height = notebook.clientHeight * 0.8;
       renderer.setSize(width, height);
       svgRenderer.setSize(width, height);
       renderer.setClearColor(0xFFFFFF, 1);
       svgRenderer.setClearColor(0xFFFFFF, 1);
    
       container.appendChild(renderer.domElement);
    
       var scene = new THREE.Scene();
       var camera = new THREE.PerspectiveCamera(75, width/height, 0.1, 1000);
    
       var renderid;
    
       camera.position.set(0, 0, 5);
       camera.lookAt(0, 0, 0);
       camera.up.set(0, 1, 0);
    
       // class to allow move points together with labels and spheres
       var PMPoint = function (x,y,z) {
          this.vector = new THREE.Vector3(x,y,z);
          this.sprite = null;
          this.sphere = null;
       }
       PMPoint.prototype.makelabel = function(label) {
          this.sprite = textSprite( label );
          this.sprite.position.copy(this.vector);
       }
       PMPoint.prototype.makesphere = function(radius,material) {
          this.sphere = new THREE.Mesh(new THREE.SphereGeometry(radius), material);
          this.sphere.position.copy(this.vector);
       }
    
       PMPoint.prototype.setX = function(x) {
          this.vector.setX(x);
          if (this.sprite) {
             this.sprite.position.setX(x);
          }
          if (this.sphere) {
             this.sphere.position.setX(x);
          }
       };
       PMPoint.prototype.setY = function(y) {
          this.vector.setY(y);
          if (this.sprite) {
             this.sprite.position.setY(y);
          }
          if (this.sphere) {
             this.sphere.position.setY(y);
          }
       };
       PMPoint.prototype.setZ = function(z) {
          this.vector.setZ(z);
          if (this.sprite) {
             this.sprite.position.setZ(z);
          }
          if (this.sphere) {
             this.sphere.position.setZ(z);
          }
       };
       PMPoint.prototype.set = function(x,y,z) {
          this.vector.set(x,y,z);
          if (this.sprite) {
             this.sprite.position.set(x,y,z);
          }
          if (this.sphere) {
             this.sphere.position.set(x,y,z);
          }
       };
       PMPoint.prototype.add = function(o) {
          if (this.sprite) {
             o.add(this.sprite);
          }
          if (this.sphere) {
             o.add(this.sphere);
          }
       };
    
    
       var controls = new THREE.TrackballControls(camera, container);
    	controls.zoomSpeed = 0.2;
    	controls.rotateSpeed = 4;
    
       var all_objects = [];
       var centroids = [];
       // select the target node
       var target = document.querySelector('#model98861580906');
    
       // create an observer instance
       var observer = new MutationObserver(function(mutations) {
          mutations.forEach(function(mutation) {
             if (mutation.removedNodes && mutation.removedNodes.length > 0) {
                cancelAnimationFrame(renderId);
                observer.disconnect();
                console.log("cancelled frame "+renderId);
             }
          });
       });
    
       // configuration of the observer:
       var config = { childList: true, characterData: true }
    
       // pass in the target node, as well as the observer options
       while (target) {
          if (target.className=="output") {
             observer.observe(target, config);
             break;
          }
          target = target.parentNode;
       }
    
    // COMMON_CODE_BLOCK_END
    
       var objectnames = ["unnamed__1","unnamed__2","unnamed__3","unnamed__4","unnamed__5","unnamed__6","unnamed__7","unnamed__8","unnamed__9","unnamed__10","unnamed__11","unnamed__12","unnamed__13","unnamed__14","unnamed__15","unnamed__16","unnamed__17","unnamed__18","unnamed__19","unnamed__20","unnamed__21","unnamed__22","unnamed__23","unnamed__24","unnamed__25","unnamed__26","unnamed__27","unnamed__28","unnamed__29","unnamed__30","unnamed__31","unnamed__32","unnamed__33","unnamed__34","unnamed__35","unnamed__36","unnamed__37","unnamed__38","unnamed__39","unnamed__40","unnamed__41","unnamed__42","unnamed__43","unnamed__44","unnamed__45","unnamed__46","unnamed__47"];
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0.333333, 0.333333, 0.333333));
       allpoints.push(new PMPoint(0.166667, 0.166667, 0.5));
       allpoints.push(new PMPoint(0.166667, 0.5, 0.166667));
       allpoints.push(new PMPoint(0.5, 0.166667, 0.166667));
       allpoints.push(new PMPoint(0, 0.333333, 0.333333));
       allpoints.push(new PMPoint(0.333333, 0, 0.333333));
       allpoints.push(new PMPoint(0.333333, 0.333333, 0));
       allpoints.push(new PMPoint(0.166667, 0.166667, 0.166667));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
       allpoints[3].makesphere(0.02,points_material);
       allpoints[4].makesphere(0.02,points_material);
       allpoints[5].makesphere(0.02,points_material);
       allpoints[6].makesphere(0.02,points_material);
       allpoints[7].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
       faces.vertices.push(allpoints[3].vector);
       faces.vertices.push(allpoints[4].vector);
       faces.vertices.push(allpoints[5].vector);
       faces.vertices.push(allpoints[6].vector);
       faces.vertices.push(allpoints[7].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x77EC9E, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(4, 1, 0, undefined, undefined, 0));
       faces.faces.push(new THREE.Face3(4, 0, 2, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(5, 1, 4, undefined, undefined, 0));
       faces.faces.push(new THREE.Face3(5, 4, 7, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(4, 2, 6, undefined, undefined, 0));
       faces.faces.push(new THREE.Face3(4, 6, 7, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(3, 5, 7, undefined, undefined, 0));
       faces.faces.push(new THREE.Face3(3, 7, 6, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(0, 1, 5, undefined, undefined, 0));
       faces.faces.push(new THREE.Face3(0, 5, 3, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(2, 0, 3, undefined, undefined, 0));
       faces.faces.push(new THREE.Face3(2, 3, 6, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[4].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[4].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[5].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[4].vector);
       line.vertices.push(allpoints[7].vector);
       line.vertices.push(allpoints[5].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[4].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[6].vector);
       line.vertices.push(allpoints[7].vector);
       line.vertices.push(allpoints[4].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[5].vector);
       line.vertices.push(allpoints[7].vector);
       line.vertices.push(allpoints[6].vector);
       line.vertices.push(allpoints[3].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[5].vector);
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[6].vector);
       line.vertices.push(allpoints[2].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0.333333, 0.333333, 0.333333));
       allpoints.push(new PMPoint(0.166667, 0.166667, 0.5));
       allpoints.push(new PMPoint(0.166667, 0.5, 0.166667));
       allpoints.push(new PMPoint(0, 0.333333, 0.333333));
       allpoints.push(new PMPoint(0, 0.5, 0.5));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
       allpoints[3].makesphere(0.02,points_material);
       allpoints[4].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
       faces.vertices.push(allpoints[3].vector);
       faces.vertices.push(allpoints[4].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x77EC9E, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(4, 3, 1, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(2, 3, 4, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(0, 2, 4, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(4, 1, 0, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(1, 3, 2, undefined, undefined, 0));
       faces.faces.push(new THREE.Face3(1, 2, 0, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[4].vector);
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[4].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[4].vector);
       line.vertices.push(allpoints[2].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[4].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[4].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[4].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0.166667, 0.166667, 0.5));
       allpoints.push(new PMPoint(0, 0.333333, 0.333333));
       allpoints.push(new PMPoint(0.333333, 0, 0.333333));
       allpoints.push(new PMPoint(0.166667, 0.166667, 0.166667));
       allpoints.push(new PMPoint(0, 0, 0.5));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
       allpoints[3].makesphere(0.02,points_material);
       allpoints[4].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
       faces.vertices.push(allpoints[3].vector);
       faces.vertices.push(allpoints[4].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x77EC9E, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(4, 1, 3, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(0, 1, 4, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(2, 0, 4, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(4, 3, 2, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(3, 1, 0, undefined, undefined, 0));
       faces.faces.push(new THREE.Face3(3, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[4].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[4].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[4].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[4].vector);
       line.vertices.push(allpoints[2].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[4].vector);
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[4].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[3].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0.333333, 0.333333, 0.333333));
       allpoints.push(new PMPoint(0.166667, 0.166667, 0.5));
       allpoints.push(new PMPoint(0.5, 0.166667, 0.166667));
       allpoints.push(new PMPoint(0.333333, 0, 0.333333));
       allpoints.push(new PMPoint(0.5, 0, 0.5));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
       allpoints[3].makesphere(0.02,points_material);
       allpoints[4].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
       faces.vertices.push(allpoints[3].vector);
       faces.vertices.push(allpoints[4].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x77EC9E, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(4, 1, 3, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(0, 1, 4, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(2, 0, 4, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(4, 3, 2, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(3, 1, 0, undefined, undefined, 0));
       faces.faces.push(new THREE.Face3(3, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[4].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[4].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[4].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[4].vector);
       line.vertices.push(allpoints[2].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[4].vector);
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[4].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[3].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0.333333, 0.333333, 0.333333));
       allpoints.push(new PMPoint(0.166667, 0.5, 0.166667));
       allpoints.push(new PMPoint(0.5, 0.166667, 0.166667));
       allpoints.push(new PMPoint(0.333333, 0.333333, 0));
       allpoints.push(new PMPoint(0.5, 0.5, 0));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
       allpoints[3].makesphere(0.02,points_material);
       allpoints[4].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
       faces.vertices.push(allpoints[3].vector);
       faces.vertices.push(allpoints[4].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x77EC9E, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 4, 3, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(1, 0, 4, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(2, 4, 0, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(3, 4, 2, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(1, 3, 2, undefined, undefined, 0));
       faces.faces.push(new THREE.Face3(1, 2, 0, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[4].vector);
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[4].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[4].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[4].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[3].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0.166667, 0.5, 0.166667));
       allpoints.push(new PMPoint(0, 0.333333, 0.333333));
       allpoints.push(new PMPoint(0.333333, 0.333333, 0));
       allpoints.push(new PMPoint(0.166667, 0.166667, 0.166667));
       allpoints.push(new PMPoint(0, 0.5, 0));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
       allpoints[3].makesphere(0.02,points_material);
       allpoints[4].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
       faces.vertices.push(allpoints[3].vector);
       faces.vertices.push(allpoints[4].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x77EC9E, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 4, 3, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(1, 0, 4, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(2, 4, 0, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(3, 4, 2, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(1, 3, 2, undefined, undefined, 0));
       faces.faces.push(new THREE.Face3(1, 2, 0, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[4].vector);
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[4].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[4].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[4].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[3].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0.5, 0.166667, 0.166667));
       allpoints.push(new PMPoint(0.333333, 0, 0.333333));
       allpoints.push(new PMPoint(0.333333, 0.333333, 0));
       allpoints.push(new PMPoint(0.166667, 0.166667, 0.166667));
       allpoints.push(new PMPoint(0.5, 0, 0));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
       allpoints[3].makesphere(0.02,points_material);
       allpoints[4].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
       faces.vertices.push(allpoints[3].vector);
       faces.vertices.push(allpoints[4].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x77EC9E, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(3, 4, 1, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(3, 2, 4, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(0, 4, 2, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(1, 4, 0, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(3, 1, 0, undefined, undefined, 0));
       faces.faces.push(new THREE.Face3(3, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[4].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[3].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[4].vector);
       line.vertices.push(allpoints[3].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[4].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[4].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[3].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0.166667, 0.166667, 0.5));
       allpoints.push(new PMPoint(0, 0.333333, 0.333333));
       allpoints.push(new PMPoint(0, 0.5, 0.5));
       allpoints.push(new PMPoint(0, 0.2, 0.6));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
       allpoints[3].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
       faces.vertices.push(allpoints[3].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x77EC9E, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 2, 0, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(3, 2, 1, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(0, 2, 3, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(1, 0, 3, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[3].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0.333333, 0.333333, 0.333333));
       allpoints.push(new PMPoint(0.166667, 0.166667, 0.5));
       allpoints.push(new PMPoint(0, 0.5, 0.5));
       allpoints.push(new PMPoint(0.2, 0.2, 0.6));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
       allpoints[3].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
       faces.vertices.push(allpoints[3].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x77EC9E, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 3, 1, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(2, 3, 0, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(1, 3, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0.333333, 0.333333, 0.333333));
       allpoints.push(new PMPoint(0.166667, 0.5, 0.166667));
       allpoints.push(new PMPoint(0, 0.5, 0.5));
       allpoints.push(new PMPoint(0.2, 0.6, 0.2));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
       allpoints[3].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
       faces.vertices.push(allpoints[3].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x77EC9E, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(3, 0, 1, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(2, 0, 3, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(3, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[3].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[2].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[3].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0.166667, 0.5, 0.166667));
       allpoints.push(new PMPoint(0, 0.333333, 0.333333));
       allpoints.push(new PMPoint(0, 0.5, 0.5));
       allpoints.push(new PMPoint(0, 0.6, 0.2));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
       allpoints[3].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
       faces.vertices.push(allpoints[3].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x77EC9E, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(3, 2, 0, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(1, 2, 3, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(3, 0, 1, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(0, 2, 1, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[3].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[3].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0.166667, 0.166667, 0.5));
       allpoints.push(new PMPoint(0, 0.333333, 0.333333));
       allpoints.push(new PMPoint(0, 0, 0.5));
       allpoints.push(new PMPoint(0, 0.2, 0.6));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
       allpoints[3].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
       faces.vertices.push(allpoints[3].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x77EC9E, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 3, 0, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(2, 3, 1, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(0, 3, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0.166667, 0.166667, 0.5));
       allpoints.push(new PMPoint(0.333333, 0, 0.333333));
       allpoints.push(new PMPoint(0, 0, 0.5));
       allpoints.push(new PMPoint(0.2, 0, 0.6));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
       allpoints[3].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
       faces.vertices.push(allpoints[3].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x77EC9E, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(3, 1, 0, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(2, 1, 3, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(3, 0, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[3].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[2].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[3].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0, 0.333333, 0.333333));
       allpoints.push(new PMPoint(0.166667, 0.166667, 0.166667));
       allpoints.push(new PMPoint(0, 0, 0.5));
       allpoints.push(new PMPoint(0, 0.2, 0.2));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
       allpoints[3].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
       faces.vertices.push(allpoints[3].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x77EC9E, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(3, 0, 1, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(2, 0, 3, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(3, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[3].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[2].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[3].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0.333333, 0, 0.333333));
       allpoints.push(new PMPoint(0.166667, 0.166667, 0.166667));
       allpoints.push(new PMPoint(0, 0, 0.5));
       allpoints.push(new PMPoint(0.2, 0, 0.2));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
       allpoints[3].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
       faces.vertices.push(allpoints[3].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x77EC9E, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 3, 1, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(2, 3, 0, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(1, 3, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0.333333, 0.333333, 0.333333));
       allpoints.push(new PMPoint(0.166667, 0.166667, 0.5));
       allpoints.push(new PMPoint(0.5, 0, 0.5));
       allpoints.push(new PMPoint(0.2, 0.2, 0.6));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
       allpoints[3].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
       faces.vertices.push(allpoints[3].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x77EC9E, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(2, 0, 3, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(3, 0, 1, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(2, 3, 1, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[2].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[3].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0.166667, 0.166667, 0.5));
       allpoints.push(new PMPoint(0.333333, 0, 0.333333));
       allpoints.push(new PMPoint(0.5, 0, 0.5));
       allpoints.push(new PMPoint(0.2, 0, 0.6));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
       allpoints[3].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
       faces.vertices.push(allpoints[3].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x77EC9E, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 2, 3, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(0, 2, 1, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(3, 2, 0, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(1, 3, 0, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[3].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0.333333, 0.333333, 0.333333));
       allpoints.push(new PMPoint(0.5, 0.166667, 0.166667));
       allpoints.push(new PMPoint(0.5, 0, 0.5));
       allpoints.push(new PMPoint(0.6, 0.2, 0.2));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
       allpoints[3].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
       faces.vertices.push(allpoints[3].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x77EC9E, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 3, 2, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(0, 3, 1, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(2, 3, 0, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(1, 2, 0, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0.5, 0.166667, 0.166667));
       allpoints.push(new PMPoint(0.333333, 0, 0.333333));
       allpoints.push(new PMPoint(0.5, 0, 0.5));
       allpoints.push(new PMPoint(0.6, 0, 0.2));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
       allpoints[3].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
       faces.vertices.push(allpoints[3].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x77EC9E, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(3, 0, 2, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(1, 0, 3, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(3, 2, 1, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(2, 0, 1, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[3].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[3].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0.333333, 0.333333, 0.333333));
       allpoints.push(new PMPoint(0.166667, 0.5, 0.166667));
       allpoints.push(new PMPoint(0.5, 0.5, 0));
       allpoints.push(new PMPoint(0.2, 0.6, 0.2));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
       allpoints[3].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
       faces.vertices.push(allpoints[3].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x77EC9E, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 2, 3, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(1, 2, 0, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(3, 2, 1, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(0, 3, 1, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[3].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0.333333, 0.333333, 0.333333));
       allpoints.push(new PMPoint(0.5, 0.166667, 0.166667));
       allpoints.push(new PMPoint(0.5, 0.5, 0));
       allpoints.push(new PMPoint(0.6, 0.2, 0.2));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
       allpoints[3].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
       faces.vertices.push(allpoints[3].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x77EC9E, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(2, 3, 1, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(0, 3, 2, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(1, 3, 0, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(2, 1, 0, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0.166667, 0.5, 0.166667));
       allpoints.push(new PMPoint(0.333333, 0.333333, 0));
       allpoints.push(new PMPoint(0.5, 0.5, 0));
       allpoints.push(new PMPoint(0.2, 0.6, 0));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
       allpoints[3].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
       faces.vertices.push(allpoints[3].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x77EC9E, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(2, 1, 3, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(2, 3, 0, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(3, 1, 0, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[2].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[3].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0.5, 0.166667, 0.166667));
       allpoints.push(new PMPoint(0.333333, 0.333333, 0));
       allpoints.push(new PMPoint(0.5, 0.5, 0));
       allpoints.push(new PMPoint(0.6, 0.2, 0));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
       allpoints[3].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
       faces.vertices.push(allpoints[3].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x77EC9E, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(3, 2, 0, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(1, 2, 3, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(3, 0, 1, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(0, 2, 1, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[3].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[3].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0.166667, 0.5, 0.166667));
       allpoints.push(new PMPoint(0, 0.333333, 0.333333));
       allpoints.push(new PMPoint(0, 0.5, 0));
       allpoints.push(new PMPoint(0, 0.6, 0.2));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
       allpoints[3].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
       faces.vertices.push(allpoints[3].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x77EC9E, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(2, 3, 0, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(1, 3, 2, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(0, 3, 1, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(2, 0, 1, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0, 0.333333, 0.333333));
       allpoints.push(new PMPoint(0.166667, 0.166667, 0.166667));
       allpoints.push(new PMPoint(0, 0.5, 0));
       allpoints.push(new PMPoint(0, 0.2, 0.2));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
       allpoints[3].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
       faces.vertices.push(allpoints[3].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x77EC9E, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(2, 0, 1, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(3, 0, 2, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(2, 1, 3, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(1, 0, 3, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[3].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[2].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0.166667, 0.5, 0.166667));
       allpoints.push(new PMPoint(0.333333, 0.333333, 0));
       allpoints.push(new PMPoint(0, 0.5, 0));
       allpoints.push(new PMPoint(0.2, 0.6, 0));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
       allpoints[3].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
       faces.vertices.push(allpoints[3].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x77EC9E, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 3, 0, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(2, 3, 1, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(0, 3, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0.333333, 0.333333, 0));
       allpoints.push(new PMPoint(0.166667, 0.166667, 0.166667));
       allpoints.push(new PMPoint(0, 0.5, 0));
       allpoints.push(new PMPoint(0.2, 0.2, 0));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
       allpoints[3].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
       faces.vertices.push(allpoints[3].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x77EC9E, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(3, 0, 1, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(2, 0, 3, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(3, 1, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[3].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[2].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[3].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0.333333, 0, 0.333333));
       allpoints.push(new PMPoint(0.166667, 0.166667, 0.166667));
       allpoints.push(new PMPoint(0.5, 0, 0));
       allpoints.push(new PMPoint(0.2, 0, 0.2));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
       allpoints[3].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
       faces.vertices.push(allpoints[3].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x77EC9E, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(2, 0, 3, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(2, 3, 1, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(3, 0, 1, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[2].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[3].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0.5, 0.166667, 0.166667));
       allpoints.push(new PMPoint(0.333333, 0, 0.333333));
       allpoints.push(new PMPoint(0.5, 0, 0));
       allpoints.push(new PMPoint(0.6, 0, 0.2));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
       allpoints[3].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
       faces.vertices.push(allpoints[3].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x77EC9E, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 3, 2, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(1, 3, 0, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(2, 3, 1, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(0, 2, 1, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0.5, 0.166667, 0.166667));
       allpoints.push(new PMPoint(0.333333, 0.333333, 0));
       allpoints.push(new PMPoint(0.5, 0, 0));
       allpoints.push(new PMPoint(0.6, 0.2, 0));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
       allpoints[3].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
       faces.vertices.push(allpoints[3].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x77EC9E, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(3, 0, 2, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(1, 0, 3, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(3, 2, 1, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(2, 0, 1, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[3].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[3].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0.333333, 0.333333, 0));
       allpoints.push(new PMPoint(0.166667, 0.166667, 0.166667));
       allpoints.push(new PMPoint(0.5, 0, 0));
       allpoints.push(new PMPoint(0.2, 0.2, 0));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
       allpoints[3].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
       faces.vertices.push(allpoints[3].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x77EC9E, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 2, 3, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(1, 2, 0, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(0, 3, 1, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(3, 2, 1, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[3].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0.166667, 0.166667, 0.5));
       allpoints.push(new PMPoint(0, 0.5, 0.5));
       allpoints.push(new PMPoint(0, 0.2, 0.6));
       allpoints.push(new PMPoint(0.2, 0.2, 0.6));
       allpoints.push(new PMPoint(0, 0.25, 0.75));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
       allpoints[3].makesphere(0.02,points_material);
       allpoints[4].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
       faces.vertices.push(allpoints[3].vector);
       faces.vertices.push(allpoints[4].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x77EC9E, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(2, 1, 0, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(2, 4, 1, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(3, 1, 4, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(0, 1, 3, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(2, 0, 3, undefined, undefined, 0));
       faces.faces.push(new THREE.Face3(2, 3, 4, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[4].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[4].vector);
       line.vertices.push(allpoints[3].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[4].vector);
       line.vertices.push(allpoints[2].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0.166667, 0.5, 0.166667));
       allpoints.push(new PMPoint(0, 0.5, 0.5));
       allpoints.push(new PMPoint(0.2, 0.6, 0.2));
       allpoints.push(new PMPoint(0, 0.6, 0.2));
       allpoints.push(new PMPoint(0, 0.75, 0.25));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
       allpoints[3].makesphere(0.02,points_material);
       allpoints[4].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
       faces.vertices.push(allpoints[3].vector);
       faces.vertices.push(allpoints[4].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x77EC9E, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 3, 0, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(4, 3, 1, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(2, 4, 1, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(0, 3, 4, undefined, undefined, 0));
       faces.faces.push(new THREE.Face3(0, 4, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[4].vector);
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[4].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[4].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[4].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0.166667, 0.166667, 0.5));
       allpoints.push(new PMPoint(0, 0, 0.5));
       allpoints.push(new PMPoint(0, 0.2, 0.6));
       allpoints.push(new PMPoint(0.2, 0, 0.6));
       allpoints.push(new PMPoint(0, 0, 0.75));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
       allpoints[3].makesphere(0.02,points_material);
       allpoints[4].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
       faces.vertices.push(allpoints[3].vector);
       faces.vertices.push(allpoints[4].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x77EC9E, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 2, 0, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(4, 2, 1, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(3, 4, 1, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(1, 0, 3, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(0, 2, 4, undefined, undefined, 0));
       faces.faces.push(new THREE.Face3(0, 4, 3, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[4].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[4].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[4].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[3].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[4].vector);
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0.166667, 0.166667, 0.166667));
       allpoints.push(new PMPoint(0, 0, 0.5));
       allpoints.push(new PMPoint(0, 0.2, 0.2));
       allpoints.push(new PMPoint(0.2, 0, 0.2));
       allpoints.push(new PMPoint(0, 0, 0.25));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
       allpoints[3].makesphere(0.02,points_material);
       allpoints[4].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
       faces.vertices.push(allpoints[3].vector);
       faces.vertices.push(allpoints[4].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x77EC9E, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 2, 4, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(0, 2, 1, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(3, 0, 1, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(1, 4, 3, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(4, 2, 0, undefined, undefined, 0));
       faces.faces.push(new THREE.Face3(4, 0, 3, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[4].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[3].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[4].vector);
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[4].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[4].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0.166667, 0.166667, 0.5));
       allpoints.push(new PMPoint(0.5, 0, 0.5));
       allpoints.push(new PMPoint(0.2, 0.2, 0.6));
       allpoints.push(new PMPoint(0.2, 0, 0.6));
       allpoints.push(new PMPoint(0.25, 0, 0.75));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
       allpoints[3].makesphere(0.02,points_material);
       allpoints[4].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
       faces.vertices.push(allpoints[3].vector);
       faces.vertices.push(allpoints[4].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x77EC9E, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 3, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(0, 2, 1, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(4, 1, 2, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(3, 1, 4, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(0, 3, 4, undefined, undefined, 0));
       faces.faces.push(new THREE.Face3(0, 4, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[4].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[4].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[4].vector);
       line.vertices.push(allpoints[3].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[4].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0.5, 0.166667, 0.166667));
       allpoints.push(new PMPoint(0.5, 0, 0.5));
       allpoints.push(new PMPoint(0.6, 0.2, 0.2));
       allpoints.push(new PMPoint(0.6, 0, 0.2));
       allpoints.push(new PMPoint(0.75, 0, 0.25));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
       allpoints[3].makesphere(0.02,points_material);
       allpoints[4].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
       faces.vertices.push(allpoints[3].vector);
       faces.vertices.push(allpoints[4].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x77EC9E, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 3, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(2, 0, 1, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(4, 2, 1, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(1, 3, 4, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(3, 0, 2, undefined, undefined, 0));
       faces.faces.push(new THREE.Face3(3, 2, 4, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[4].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[4].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[4].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[4].vector);
       line.vertices.push(allpoints[3].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0.166667, 0.5, 0.166667));
       allpoints.push(new PMPoint(0.5, 0.5, 0));
       allpoints.push(new PMPoint(0.2, 0.6, 0.2));
       allpoints.push(new PMPoint(0.2, 0.6, 0));
       allpoints.push(new PMPoint(0.25, 0.75, 0));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
       allpoints[3].makesphere(0.02,points_material);
       allpoints[4].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
       faces.vertices.push(allpoints[3].vector);
       faces.vertices.push(allpoints[4].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x77EC9E, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 3, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(2, 0, 1, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(4, 2, 1, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(1, 3, 4, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(3, 0, 2, undefined, undefined, 0));
       faces.faces.push(new THREE.Face3(3, 2, 4, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[4].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[4].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[4].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[4].vector);
       line.vertices.push(allpoints[3].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0.5, 0.166667, 0.166667));
       allpoints.push(new PMPoint(0.5, 0.5, 0));
       allpoints.push(new PMPoint(0.6, 0.2, 0.2));
       allpoints.push(new PMPoint(0.6, 0.2, 0));
       allpoints.push(new PMPoint(0.75, 0.25, 0));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
       allpoints[3].makesphere(0.02,points_material);
       allpoints[4].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
       faces.vertices.push(allpoints[3].vector);
       faces.vertices.push(allpoints[4].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x77EC9E, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 3, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(0, 2, 1, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(4, 1, 2, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(3, 1, 4, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(0, 3, 4, undefined, undefined, 0));
       faces.faces.push(new THREE.Face3(0, 4, 2, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[4].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[4].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[4].vector);
       line.vertices.push(allpoints[3].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[4].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0.166667, 0.5, 0.166667));
       allpoints.push(new PMPoint(0, 0.5, 0));
       allpoints.push(new PMPoint(0, 0.6, 0.2));
       allpoints.push(new PMPoint(0.2, 0.6, 0));
       allpoints.push(new PMPoint(0, 0.75, 0));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
       allpoints[3].makesphere(0.02,points_material);
       allpoints[4].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
       faces.vertices.push(allpoints[3].vector);
       faces.vertices.push(allpoints[4].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x77EC9E, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(2, 1, 0, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(2, 4, 1, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(3, 1, 4, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(0, 1, 3, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(2, 0, 3, undefined, undefined, 0));
       faces.faces.push(new THREE.Face3(2, 3, 4, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[4].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[4].vector);
       line.vertices.push(allpoints[3].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[4].vector);
       line.vertices.push(allpoints[2].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0.166667, 0.166667, 0.166667));
       allpoints.push(new PMPoint(0, 0.5, 0));
       allpoints.push(new PMPoint(0, 0.2, 0.2));
       allpoints.push(new PMPoint(0.2, 0.2, 0));
       allpoints.push(new PMPoint(0, 0.25, 0));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
       allpoints[3].makesphere(0.02,points_material);
       allpoints[4].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
       faces.vertices.push(allpoints[3].vector);
       faces.vertices.push(allpoints[4].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x77EC9E, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 2, 0, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(4, 2, 1, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(3, 4, 1, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(1, 0, 3, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(0, 2, 4, undefined, undefined, 0));
       faces.faces.push(new THREE.Face3(0, 4, 3, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[4].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[4].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[4].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[3].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[4].vector);
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0.166667, 0.166667, 0.166667));
       allpoints.push(new PMPoint(0.5, 0, 0));
       allpoints.push(new PMPoint(0.2, 0, 0.2));
       allpoints.push(new PMPoint(0.2, 0.2, 0));
       allpoints.push(new PMPoint(0.25, 0, 0));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
       allpoints[3].makesphere(0.02,points_material);
       allpoints[4].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
       faces.vertices.push(allpoints[3].vector);
       faces.vertices.push(allpoints[4].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x77EC9E, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(3, 0, 1, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(4, 3, 1, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(1, 2, 4, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(2, 0, 3, undefined, undefined, 0));
       faces.faces.push(new THREE.Face3(2, 3, 4, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[3].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[4].vector);
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[4].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[4].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[4].vector);
       line.vertices.push(allpoints[2].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0.5, 0.166667, 0.166667));
       allpoints.push(new PMPoint(0.5, 0, 0));
       allpoints.push(new PMPoint(0.6, 0, 0.2));
       allpoints.push(new PMPoint(0.6, 0.2, 0));
       allpoints.push(new PMPoint(0.75, 0, 0));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
       allpoints[3].makesphere(0.02,points_material);
       allpoints[4].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
       faces.vertices.push(allpoints[3].vector);
       faces.vertices.push(allpoints[4].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x77EC9E, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(0, 1, 2, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(0, 3, 1, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(4, 1, 3, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(2, 1, 4, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(0, 2, 4, undefined, undefined, 0));
       faces.faces.push(new THREE.Face3(0, 4, 3, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[4].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[4].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[4].vector);
       line.vertices.push(allpoints[2].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[4].vector);
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0.166667, 0.166667, 0.5));
       allpoints.push(new PMPoint(0, 0.2, 0.6));
       allpoints.push(new PMPoint(0.2, 0.2, 0.6));
       allpoints.push(new PMPoint(0.2, 0, 0.6));
       allpoints.push(new PMPoint(0, 0.25, 0.75));
       allpoints.push(new PMPoint(0, 0, 0.75));
       allpoints.push(new PMPoint(0.25, 0, 0.75));
       allpoints.push(new PMPoint(0, 0, 1));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
       allpoints[3].makesphere(0.02,points_material);
       allpoints[4].makesphere(0.02,points_material);
       allpoints[5].makesphere(0.02,points_material);
       allpoints[6].makesphere(0.02,points_material);
       allpoints[7].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
       faces.vertices.push(allpoints[3].vector);
       faces.vertices.push(allpoints[4].vector);
       faces.vertices.push(allpoints[5].vector);
       faces.vertices.push(allpoints[6].vector);
       faces.vertices.push(allpoints[7].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x77EC9E, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(1, 4, 2, undefined, undefined, 0));
       faces.faces.push(new THREE.Face3(1, 2, 0, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(7, 4, 1, undefined, undefined, 0));
       faces.faces.push(new THREE.Face3(7, 1, 5, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(1, 0, 3, undefined, undefined, 0));
       faces.faces.push(new THREE.Face3(1, 3, 5, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(6, 7, 5, undefined, undefined, 0));
       faces.faces.push(new THREE.Face3(6, 5, 3, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(2, 4, 7, undefined, undefined, 0));
       faces.faces.push(new THREE.Face3(2, 7, 6, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(0, 2, 6, undefined, undefined, 0));
       faces.faces.push(new THREE.Face3(0, 6, 3, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[4].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[7].vector);
       line.vertices.push(allpoints[4].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[5].vector);
       line.vertices.push(allpoints[7].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[5].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[6].vector);
       line.vertices.push(allpoints[7].vector);
       line.vertices.push(allpoints[5].vector);
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[6].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[4].vector);
       line.vertices.push(allpoints[7].vector);
       line.vertices.push(allpoints[6].vector);
       line.vertices.push(allpoints[2].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[6].vector);
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0.166667, 0.5, 0.166667));
       allpoints.push(new PMPoint(0.2, 0.6, 0.2));
       allpoints.push(new PMPoint(0, 0.6, 0.2));
       allpoints.push(new PMPoint(0.2, 0.6, 0));
       allpoints.push(new PMPoint(0, 0.75, 0.25));
       allpoints.push(new PMPoint(0.25, 0.75, 0));
       allpoints.push(new PMPoint(0, 0.75, 0));
       allpoints.push(new PMPoint(0, 1, 0));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
       allpoints[3].makesphere(0.02,points_material);
       allpoints[4].makesphere(0.02,points_material);
       allpoints[5].makesphere(0.02,points_material);
       allpoints[6].makesphere(0.02,points_material);
       allpoints[7].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
       faces.vertices.push(allpoints[3].vector);
       faces.vertices.push(allpoints[4].vector);
       faces.vertices.push(allpoints[5].vector);
       faces.vertices.push(allpoints[6].vector);
       faces.vertices.push(allpoints[7].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x77EC9E, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(4, 2, 0, undefined, undefined, 0));
       faces.faces.push(new THREE.Face3(4, 0, 1, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(6, 2, 4, undefined, undefined, 0));
       faces.faces.push(new THREE.Face3(6, 4, 7, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(0, 2, 6, undefined, undefined, 0));
       faces.faces.push(new THREE.Face3(0, 6, 3, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(3, 6, 7, undefined, undefined, 0));
       faces.faces.push(new THREE.Face3(3, 7, 5, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(4, 1, 5, undefined, undefined, 0));
       faces.faces.push(new THREE.Face3(4, 5, 7, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(1, 0, 3, undefined, undefined, 0));
       faces.faces.push(new THREE.Face3(1, 3, 5, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[4].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[4].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[6].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[4].vector);
       line.vertices.push(allpoints[7].vector);
       line.vertices.push(allpoints[6].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[6].vector);
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[6].vector);
       line.vertices.push(allpoints[7].vector);
       line.vertices.push(allpoints[5].vector);
       line.vertices.push(allpoints[3].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[4].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[5].vector);
       line.vertices.push(allpoints[7].vector);
       line.vertices.push(allpoints[4].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[5].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0.166667, 0.166667, 0.166667));
       allpoints.push(new PMPoint(0, 0.2, 0.2));
       allpoints.push(new PMPoint(0.2, 0, 0.2));
       allpoints.push(new PMPoint(0.2, 0.2, 0));
       allpoints.push(new PMPoint(0, 0, 0.25));
       allpoints.push(new PMPoint(0, 0.25, 0));
       allpoints.push(new PMPoint(0.25, 0, 0));
       allpoints.push(new PMPoint(0, 0, 0));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
       allpoints[3].makesphere(0.02,points_material);
       allpoints[4].makesphere(0.02,points_material);
       allpoints[5].makesphere(0.02,points_material);
       allpoints[6].makesphere(0.02,points_material);
       allpoints[7].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
       faces.vertices.push(allpoints[3].vector);
       faces.vertices.push(allpoints[4].vector);
       faces.vertices.push(allpoints[5].vector);
       faces.vertices.push(allpoints[6].vector);
       faces.vertices.push(allpoints[7].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x77EC9E, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(5, 1, 0, undefined, undefined, 0));
       faces.faces.push(new THREE.Face3(5, 0, 3, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(4, 1, 5, undefined, undefined, 0));
       faces.faces.push(new THREE.Face3(4, 5, 7, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(0, 1, 4, undefined, undefined, 0));
       faces.faces.push(new THREE.Face3(0, 4, 2, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(2, 4, 7, undefined, undefined, 0));
       faces.faces.push(new THREE.Face3(2, 7, 6, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(5, 3, 6, undefined, undefined, 0));
       faces.faces.push(new THREE.Face3(5, 6, 7, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(3, 0, 2, undefined, undefined, 0));
       faces.faces.push(new THREE.Face3(3, 2, 6, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[5].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[5].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[4].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[5].vector);
       line.vertices.push(allpoints[7].vector);
       line.vertices.push(allpoints[4].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[4].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[4].vector);
       line.vertices.push(allpoints[7].vector);
       line.vertices.push(allpoints[6].vector);
       line.vertices.push(allpoints[2].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[5].vector);
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[6].vector);
       line.vertices.push(allpoints[7].vector);
       line.vertices.push(allpoints[5].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[6].vector);
       line.vertices.push(allpoints[3].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
       var obj = new THREE.Object3D();
       var allpoints = [];
       allpoints.push(new PMPoint(0.5, 0.166667, 0.166667));
       allpoints.push(new PMPoint(0.6, 0.2, 0.2));
       allpoints.push(new PMPoint(0.6, 0, 0.2));
       allpoints.push(new PMPoint(0.6, 0.2, 0));
       allpoints.push(new PMPoint(0.75, 0, 0.25));
       allpoints.push(new PMPoint(0.75, 0.25, 0));
       allpoints.push(new PMPoint(0.75, 0, 0));
       allpoints.push(new PMPoint(1, 0, 0));
    
       <!-- Vertex style -->
       var points_material = new THREE.MeshBasicMaterial ( {color: 0xFF0000, } );
    
       points_material.side = THREE.DoubleSide;
       points_material.transparent = true;
    
       <!-- POINTS -->
       allpoints[0].makesphere(0.02,points_material);
       allpoints[1].makesphere(0.02,points_material);
       allpoints[2].makesphere(0.02,points_material);
       allpoints[3].makesphere(0.02,points_material);
       allpoints[4].makesphere(0.02,points_material);
       allpoints[5].makesphere(0.02,points_material);
       allpoints[6].makesphere(0.02,points_material);
       allpoints[7].makesphere(0.02,points_material);
    
       for (index = 0; index < allpoints.length; ++index) {
          allpoints[index].add(obj);
       }
       var faces = new THREE.Geometry();
    
       <!-- VERTICES -->
       faces.vertices.push(allpoints[0].vector);
       faces.vertices.push(allpoints[1].vector);
       faces.vertices.push(allpoints[2].vector);
       faces.vertices.push(allpoints[3].vector);
       faces.vertices.push(allpoints[4].vector);
       faces.vertices.push(allpoints[5].vector);
       faces.vertices.push(allpoints[6].vector);
       faces.vertices.push(allpoints[7].vector);
    
       centroids.push(computeCentroid(faces));
    
       <!-- Facet style -->
       var faces_material = new THREE.MeshBasicMaterial ( {color: 0x77EC9E, transparent: true, opacity: 1, side: THREE.DoubleSide , depthWrite: true, depthTest: true, } );
    
       faces_material.side = THREE.DoubleSide;
       faces_material.transparent = true;
    
       <!-- FACETS --> 
       faces.faces.push(new THREE.Face3(3, 0, 1, undefined, undefined, 0));
       faces.faces.push(new THREE.Face3(3, 1, 5, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(2, 0, 3, undefined, undefined, 0));
       faces.faces.push(new THREE.Face3(2, 3, 6, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(1, 0, 2, undefined, undefined, 0));
       faces.faces.push(new THREE.Face3(1, 2, 4, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(4, 2, 6, undefined, undefined, 0));
       faces.faces.push(new THREE.Face3(4, 6, 7, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(3, 5, 7, undefined, undefined, 0));
       faces.faces.push(new THREE.Face3(3, 7, 6, undefined, undefined, 0));
    
       faces.faces.push(new THREE.Face3(5, 1, 4, undefined, undefined, 0));
       faces.faces.push(new THREE.Face3(5, 4, 7, undefined, undefined, 0));
    
    
       faces.computeFaceNormals();
       faces.computeVertexNormals();
    
       var object = new THREE.Mesh(faces, faces_material);
       obj.add(object);
    
       <!-- Edge style -->
       var line_material = new THREE.LineBasicMaterial ( {color: 0x000000, linewidth: 1.5, } );
    
       line_material.side = THREE.DoubleSide;
       line_material.transparent = true;
    
       <!-- EDGES --> 
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[5].vector);
       line.vertices.push(allpoints[3].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[6].vector);
       line.vertices.push(allpoints[2].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[0].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[4].vector);
       line.vertices.push(allpoints[1].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[4].vector);
       line.vertices.push(allpoints[2].vector);
       line.vertices.push(allpoints[6].vector);
       line.vertices.push(allpoints[7].vector);
       line.vertices.push(allpoints[4].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[3].vector);
       line.vertices.push(allpoints[5].vector);
       line.vertices.push(allpoints[7].vector);
       line.vertices.push(allpoints[6].vector);
       line.vertices.push(allpoints[3].vector);
       obj.add(new THREE.Line(line, line_material));
    
       var line = new THREE.Geometry();
       line.vertices.push(allpoints[5].vector);
       line.vertices.push(allpoints[1].vector);
       line.vertices.push(allpoints[4].vector);
       line.vertices.push(allpoints[7].vector);
       line.vertices.push(allpoints[5].vector);
       obj.add(new THREE.Line(line, line_material));
    
       scene.add(obj);
       all_objects.push(obj);
    
    // COMMON_CODE_BLOCK_BEGIN
    var xRotationEnabled = false;
    var yRotationEnabled = false;
    var zRotationEnabled = false;
    var rotationSpeedFactor = 1;
    var settingsShown = false;
    var labelsShown = true;
    var intervals = [];
    var timeouts = [];
    var explodingSpeed = 0.05;
    var explodeScale = 0;
    var XMLS = new XMLSerializer();
    var svgElement;
    var renderId;
    
    	var render = function () {
    
    		renderId = requestAnimationFrame(render);
    
    //		comment in for automatic explosion
    //		explode(updateFactor());
    
    		var phi = 0.02 * rotationSpeedFactor;
    
    		if (xRotationEnabled){
    			scene.rotation.x += phi;
    		}
    		if(yRotationEnabled){
    			scene.rotation.y += phi;
    		}
    		if(zRotationEnabled){
    			scene.rotation.z += phi;
    		}
    
    		controls.update();
    		renderer.render(scene, camera);
    	};
    
    	render();
    
    	function computeCentroid(geom) {
    		centroid = new THREE.Vector3();
    		geom.vertices.forEach(function(v) {
    			centroid.add(v);			
    		});
    		centroid.divideScalar(geom.vertices.length);
    		return centroid;
    	}
    
    	function changeTransparency(event){
    		var opacity = 1-Number(event.currentTarget.value);
    		for (var i=0; i<all_objects.length; i++){
    			for (var j=0; j<all_objects[i].children.length; j++){
    				if (all_objects[i].children[j].material.type == "MultiMaterial") {
    					for (var k=0; k<all_objects[i].children[j].material.materials.length; k++){
    						all_objects[i].children[j].material.materials[k].opacity = opacity;
    						all_objects[i].children[j].material.materials[k].depthWrite = opacity < 0.5 ? false : true;
    						all_objects[i].children[j].material.materials[k].depthTest = opacity < 0.5 ? false : true;
    					}
    				} else if (all_objects[i].children[j].material.transparent && 
    							  all_objects[i].children[j].material.type == "MeshBasicMaterial" &&
    							  all_objects[i].children[j].geometry.type == "Geometry"){
    					all_objects[i].children[j].material.opacity = opacity;
    					all_objects[i].children[j].material.depthWrite = opacity < 0.5 ? false : true;
    					all_objects[i].children[j].material.depthTest = opacity < 0.5 ? false : true;
    				}
    			}
    		}
    	}
    
    	function changeRotationX(event){
    		xRotationEnabled = event.currentTarget.checked;
    	}	
    
    	function changeRotationY(event){
    		yRotationEnabled = event.currentTarget.checked;
    	}	
    
    	function changeRotationZ(event){
    		zRotationEnabled = event.currentTarget.checked;
    	}	
    
    
    	function changeRotationSpeedFactor(event){
    		rotationSpeedFactor = Number(event.currentTarget.value);
    	}
    
    	function resetScene(){
    		scene.rotation.set(0,0,0);
    		camera.position.set(0,0,5);
    		camera.up.set(0,1,0);
    	}
    
    	function showSettings(event){
    		event.currentTarget.style.display = 'none';
    		document.getElementById('settings_9').style.position = 'absolute';
    		document.getElementById('settings_9').style.display = 'block';
    		document.getElementById('showSettingsButton_9').style.display = 'none';
    		document.getElementById('hideSettingsButton_9').style.display = 'block';
    		settingsShown = true;
    	}
    
    	function hideSettings(event){
    		event.currentTarget.style.display = 'none';
    		document.getElementById('settings_9').style.display = 'none';
    		document.getElementById('hideSettingsButton_9').style.display = 'none';
    		document.getElementById('showSettingsButton_9').style.display = 'block';
    		settingsShown = false;
    	}
    
    
    
    	var pos = 150* Math.PI;
    
    	function updateFactor() {
    		pos++;
    		return Math.sin(.01*pos)+1;
    	}
    
    	function makelabel(message, x, y, z, params) {
    		var spritey = textSprite( message, params );
    		spritey.position.set(x, y, z);
    		obj.add(spritey);
    	}
    
    	function textSprite(message, parameters)
    	{
    		if ( parameters === undefined ) parameters = {};
    
    		var fontface = "Helvetica";
    
    		var fontsize = parameters.hasOwnProperty("fontsize") ? 
    			parameters["fontsize"] : 18;
    		fontsize = fontsize*10;
    
    		var canvas = document.createElement('canvas');
    		var size = 1024;
    		canvas.width = size;
    		canvas.height = size;
    		var context = canvas.getContext('2d');
    		context.font = fontsize + "px " + fontface;
    
    		// text color
    		context.fillStyle = "rgba(0, 0, 0, 1.0)";
    
    		context.fillText(message, size/2, size/2);
    
    		// canvas contents will be used for a texture
    		var texture = new THREE.Texture(canvas);
    		texture.needsUpdate = true;
    
    		var spriteMaterial = new THREE.SpriteMaterial(
    			{map: texture, useScreenCoordinates: false});
    		var sprite = new THREE.Sprite(spriteMaterial);
    		return sprite;
    	}
    
    	function takeSvgScreenshot(){
    		if (labelsShown){
    			hideLabels();
    		}
    		svgRenderer.render(scene,camera);
    		svgElement = XMLS.serializeToString(svgRenderer.domElement);
    		
    		if (labelsShown){
    			displayLabels();
    		}
    
    		if (document.getElementById('tab_9').checked){
    			//show in new tab
    			var myWindow = window.open("","");
    			myWindow.document.body.innerHTML = svgElement;
    		} else{
    			// download svg file 
    			download("screenshot.svg", svgElement);
    		}
    	}
    		
    
    	function showOrHideObject(event){
    		var nr = Number(event.currentTarget.name);
    		all_objects[nr].visible = event.currentTarget.checked;
    	}
    
    
    	function displayOrHideOptions(){
    		for (var i=0; i<all_objects.length; i++){
    			for (var j=0; j<all_objects[i].children.length; j++){
    				if (all_objects[i].children[j].material.type == "MultiMaterial") {
    					for (var k=0; k<all_objects[i].children[j].material.materials.length; k++){
    						if (all_objects[i].children[j].material.materials[k].transparent) {
    							document.getElementById('transparency_9').style.display = 'block';
    							document.getElementById('transparencyRange_9').value = 1 - 
    							    all_objects[i].children[j].material.materials[k].opacity;
    							return;
    						}
    					}
    				} else if (all_objects[i].children[j].material.transparent && 
    							  all_objects[i].children[j].material.type == "MeshBasicMaterial" &&
    							  all_objects[i].children[j].geometry.type == "Geometry"){
    					document.getElementById('transparency_9').style.display = 'block';
    					return;
    				}
    			}
    		}
    	}
    
    	displayOrHideOptions()
    
    
    
    
    // ---------------------- EXPLOSION ------------------------------------------------
    // ---------------------------------------------------------------------------------
    
    	function explode(factor) {
    		var obj, c;
    		var c0 = centroids[0];
    		for (var i = 0; i<centroids.length; ++i) {
    			c = centroids[i];
    			obj = all_objects[all_objects.length - centroids.length + i];
    			obj.position.set(c.x*factor, c.y*factor, c.z*factor);
    		}	
    	}
    
    	function triggerExplode(event){
    		explodeScale = Number(event.currentTarget.value);
    		explode(explodeScale);
    	}
    
    	function setExplodingSpeed(event){
    		explodingSpeed = Number(event.currentTarget.value);
    	}
    
    	function triggerAutomaticExplode(event){
    		if (event.currentTarget.checked){
    			startExploding();
    		} else {
    			clearIntervals();
    		}	
    	}
    
    	function startExploding(){
    		intervals.push(setInterval(explodingInterval, 25));
    	}
    
    
    	function explodingInterval(){
    		explodeScale += explodingSpeed;
    		if (explodeScale <= 6){ 
    			explode(explodeScale);
    		}
    		else{
    			explode(6);
    			explodeScale = 6;
    			clearIntervals();
    			timeouts.push(setTimeout(startUnexploding, 3000));
    		}
    		document.getElementById('explodeRange_9').value = explodeScale;
    	}
    
    
    	function startUnexploding(){
    		intervals.push(setInterval(unexplodingInterval, 25));
    	}
    
    	function unexplodingInterval(){
    		explodeScale -= explodingSpeed;
    		if (explodeScale >= 0){	
    			explode(explodeScale);
    		}
    		else {
    			explode(0);
    			explodeScale = 0;
    			clearIntervals();
    			timeouts.push(setTimeout(startExploding, 3000));
    		}
    		document.getElementById('explodeRange_9').value = explodeScale;
    	}
    
    	function clearIntervals(){
    		intervals.forEach(function(interval){
    			clearInterval(interval);
    		});
    		intervals = [];
    		timeouts.forEach(function(timeout){
    			clearTimeout(timeout);
    		});
    		timeouts = [];
    	}
    
    			
    
    	// append checkboxes for displaying or hiding objects
    	var shownObjectsList = document.getElementById('shownObjectsList_9');
    	for (var i=0; i<all_objects.length; i++){
    		var objNode = document.createElement('span');
    		objNode.innerHTML = objectnames[i] + '<br>';
    		var checkbox = document.createElement('input');
    		checkbox.type = 'checkbox';
    		checkbox.checked = true;
    		checkbox.name = String(i);
    		checkbox.onchange = showOrHideObject;
    		shownObjectsList.appendChild(checkbox);
    		shownObjectsList.appendChild(objNode);
    	}
    
    	function displayLabels(){
    		for (var i=0; i<all_objects.length; i++){
    			for (var j=0; j<all_objects[i].children.length; j++){
    				var child = all_objects[i].children[j];
    				if (child.type == 'Sprite'){
    					child.visible = true;
    				}
    			}
    		}
    	}
    
    	function hideLabels(){
    		for (var i=0; i<all_objects.length; i++){
    			for (var j=0; j<all_objects[i].children.length; j++){
    				var child = all_objects[i].children[j];
    				if (child.type == 'Sprite'){
    					child.visible = false;
    				}
    			}
    		}
    	}
    
    	function displayOrHideLabels(event){
    		if (event.currentTarget.checked){
    			displayLabels();
    			labelsShown = true;
    		} else {
    			hideLabels();
    			labelsShown = false;
    		}
    	}
    
    	function download(filename, text) {
    	  var element = document.createElement('a');
    	  element.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(text));
    	  element.setAttribute('download', filename);
    
    	  element.style.display = 'none';
    	  document.body.appendChild(element);
    
    	  element.click();
    
    	  document.body.removeChild(element);
    	}
    
    var tempobj;
    tempobj = document.getElementById('explodeRange_9');
    if (tempobj) {
       tempobj.oninput = triggerExplode;
       document.getElementById('explodeCheckbox_9').onchange = triggerAutomaticExplode;
       document.getElementById('explodingSpeedRange_9').oninput = setExplodingSpeed;
    }
    tempobj = document.getElementById('foldRange_9');
    if (tempobj) {
       tempobj.oninput = fold;
    }
    document.getElementById('transparencyRange_9').oninput = changeTransparency;
    document.getElementById('changeRotationX_9').onchange = changeRotationX;
    document.getElementById('changeRotationY_9').onchange = changeRotationY;
    document.getElementById('changeRotationZ_9').onchange = changeRotationZ;
    document.getElementById('resetButton_9').onclick = resetScene;
    document.getElementById('rotationSpeedRange_9').oninput = changeRotationSpeedFactor;
    document.getElementById('labelsCheckboxInput_9').onchange = displayOrHideLabels;
    document.getElementById('takeScreenshot_9').onclick = takeSvgScreenshot;
    document.getElementById('showSettingsButton_9').onclick = showSettings;
    document.getElementById('hideSettingsButton_9').onclick = hideSettings;
    
    	
    
    // ------------------ SHORTCUTS --------------------------------------------
    // -------------------------------------------------------------------------
    
    /**
     * http://www.openjs.com/scripts/events/keyboard_shortcuts/
     * Version : 2.01.B
     * By Binny V A
     * License : BSD
     */
    shortcut = {
    	'all_shortcuts':{},//All the shortcuts are stored in this array
    	'add': function(shortcut_combination,callback,opt) {
    		//Provide a set of default options
    		var default_options = {
    			'type':'keydown',
    			'propagate':false,
    			'disable_in_input':false,
    			'target':document,
    			'keycode':false
    		}
    		if(!opt) opt = default_options;
    		else {
    			for(var dfo in default_options) {
    				if(typeof opt[dfo] == 'undefined') opt[dfo] = default_options[dfo];
    			}
    		}
    
    		var ele = opt.target;
    		if(typeof opt.target == 'string') ele = document.getElementById(opt.target);
    		var ths = this;
    		shortcut_combination = shortcut_combination.toLowerCase();
    
    		//The function to be called at keypress
    		var func = function(e) {
    			e = e || window.event;
    			
    			if(opt['disable_in_input']) { //Don't enable shortcut keys in Input, Textarea fields
    				var element;
    				if(e.target) element=e.target;
    				else if(e.srcElement) element=e.srcElement;
    				if(element.nodeType==3) element=element.parentNode;
    
    				if(element.tagName == 'INPUT' || element.tagName == 'TEXTAREA') return;
    			}
    	
    			//Find Which key is pressed
    			if (e.keyCode) code = e.keyCode;
    			else if (e.which) code = e.which;
    			var character = String.fromCharCode(code).toLowerCase();
    			
    			if(code == 188) character=","; //If the user presses , when the type is onkeydown
    			if(code == 190) character="."; //If the user presses , when the type is onkeydown
    
    			var keys = shortcut_combination.split("+");
    			//Key Pressed - counts the number of valid keypresses - if it is same as the number of keys, the shortcut function is invoked
    			var kp = 0;
    			
    			//Work around for stupid Shift key bug created by using lowercase - as a result the shift+num combination was broken
    			var shift_nums = {
    				"`":"~",
    				"1":"!",
    				"2":"@",
    				"3":"#",
    				"4":"$",
    				"5":"%",
    				"6":"^",
    				"7":"&",
    				"8":"*",
    				"9":"(",
    				"0":")",
    				"-":"_",
    				"=":"+",
    				";":":",
    				"'":"\"",
    				",":"<",
    				".":">",
    				"/":"?",
    				"\\":"|"
    			}
    			//Special Keys - and their codes
    			var special_keys = {
    				'esc':27,
    				'escape':27,
    				'tab':9,
    				'space':32,
    				'return':13,
    				'enter':13,
    				'backspace':8,
    	
    				'scrolllock':145,
    				'scroll_lock':145,
    				'scroll':145,
    				'capslock':20,
    				'caps_lock':20,
    				'caps':20,
    				'numlock':144,
    				'num_lock':144,
    				'num':144,
    				
    				'pause':19,
    				'break':19,
    				
    				'insert':45,
    				'home':36,
    				'delete':46,
    				'end':35,
    				
    				'pageup':33,
    				'page_up':33,
    				'pu':33,
    	
    				'pagedown':34,
    				'page_down':34,
    				'pd':34,
    	
    				'left':37,
    				'up':38,
    				'right':39,
    				'down':40,
    	
    				'f1':112,
    				'f2':113,
    				'f3':114,
    				'f4':115,
    				'f5':116,
    				'f6':117,
    				'f7':118,
    				'f8':119,
    				'f9':120,
    				'f10':121,
    				'f11':122,
    				'f12':123
    			}
    	
    			var modifiers = { 
    				shift: { wanted:false, pressed:false},
    				ctrl : { wanted:false, pressed:false},
    				alt  : { wanted:false, pressed:false},
    				meta : { wanted:false, pressed:false}	//Meta is Mac specific
    			};
                            
    			if(e.ctrlKey)	modifiers.ctrl.pressed = true;
    			if(e.shiftKey)	modifiers.shift.pressed = true;
    			if(e.altKey)	modifiers.alt.pressed = true;
    			if(e.metaKey)   modifiers.meta.pressed = true;
                            
    			for(var i=0; k=keys[i],i<keys.length; i++) {
    				//Modifiers
    				if(k == 'ctrl' || k == 'control') {
    					kp++;
    					modifiers.ctrl.wanted = true;
    
    				} else if(k == 'shift') {
    					kp++;
    					modifiers.shift.wanted = true;
    
    				} else if(k == 'alt') {
    					kp++;
    					modifiers.alt.wanted = true;
    				} else if(k == 'meta') {
    					kp++;
    					modifiers.meta.wanted = true;
    				} else if(k.length > 1) { //If it is a special key
    					if(special_keys[k] == code) kp++;
    					
    				} else if(opt['keycode']) {
    					if(opt['keycode'] == code) kp++;
    
    				} else { //The special keys did not match
    					if(character == k) kp++;
    					else {
    						if(shift_nums[character] && e.shiftKey) { //Stupid Shift key bug created by using lowercase
    							character = shift_nums[character]; 
    							if(character == k) kp++;
    						}
    					}
    				}
    			}
    			
    			if(kp == keys.length && 
    						modifiers.ctrl.pressed == modifiers.ctrl.wanted &&
    						modifiers.shift.pressed == modifiers.shift.wanted &&
    						modifiers.alt.pressed == modifiers.alt.wanted &&
    						modifiers.meta.pressed == modifiers.meta.wanted) {
    				callback(e);
    	
    				if(!opt['propagate']) { //Stop the event
    					//e.cancelBubble is supported by IE - this will kill the bubbling process.
    					e.cancelBubble = true;
    					e.returnValue = false;
    	
    					//e.stopPropagation works in Firefox.
    					if (e.stopPropagation) {
    						e.stopPropagation();
    						e.preventDefault();
    					}
    					return false;
    				}
    			}
    		}
    		this.all_shortcuts[shortcut_combination] = {
    			'callback':func, 
    			'target':ele, 
    			'event': opt['type']
    		};
    		//Attach the function with the event
    		if(ele.addEventListener) ele.addEventListener(opt['type'], func, false);
    		else if(ele.attachEvent) ele.attachEvent('on'+opt['type'], func);
    		else ele['on'+opt['type']] = func;
    	},
    
    	//Remove the shortcut - just specify the shortcut and I will remove the binding
    	'remove':function(shortcut_combination) {
    		shortcut_combination = shortcut_combination.toLowerCase();
    		var binding = this.all_shortcuts[shortcut_combination];
    		delete(this.all_shortcuts[shortcut_combination])
    		if(!binding) return;
    		var type = binding['event'];
    		var ele = binding['target'];
    		var callback = binding['callback'];
    
    		if(ele.detachEvent) ele.detachEvent('on'+type, callback);
    		else if(ele.removeEventListener) ele.removeEventListener(type, callback, false);
    		else ele['on'+type] = false;
    	}
    }
    
    shortcut.add("Alt+Left",function() {
    	var event = new Event('click');
    	if (settingsShown){
    		document.getElementById('hideSettingsButton_9').dispatchEvent(event);
    	} else{
    		document.getElementById('showSettingsButton_9').dispatchEvent(event);
    	}
    });
    
    if (foldable) moveToBaryCenter();
    
    
    });});
    // COMMON_CODE_BLOCK_END
    </script>
    
    </body>
    </html>











