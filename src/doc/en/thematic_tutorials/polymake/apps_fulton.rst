.. -*- coding: utf-8 -*-
.. escape-backslashes
.. default-role:: math


Toric polymake tutorial
=======================

This tutorial will go over the basics of polymake and then focus on the
``application "fulton"`` for toric varieties.


Quick start
-----------

Below you see a small sample session. First switch to the application
with the following command.


.. link

.. CODE-BLOCK:: perl

    polymake> application "fulton";

Start by creating a cone.


.. link

.. CODE-BLOCK:: perl

    polymake> $c = new Cone(INPUT_RAYS=>[[-2,1],[1,1]]);
    polymake> print $c->HILBERT_BASIS;

You can ask for the binomials generating the associated toric ideal in
two ways: The first gives a matrix of the binomial exponents, the second
gives you the actual binomials.


.. link

.. CODE-BLOCK:: perl

    polymake> $toric = $c->TORIC_IDEAL;
    polymake> print $toric->BINOMIAL_GENERATORS, "\n";
    polymake> print join("\n", @{$toric->GENERATORS});

Asking for properties of the toric variety is done in the same manner as
for polytopes.


.. link

.. CODE-BLOCK:: perl

    polymake> $tv = new NormalToricVariety($c);
    polymake> print "Is smooth? ", $tv->SMOOTH, "\n";
    polymake> print "Is affine? ", $tv->AFFINE, "\n";
    polymake> print "Is orbifold? ", $tv->ORBIFOLD, "\n";
    polymake> print "Is complete? ", $tv->COMPLETE, "\n";
    polymake> $tv->properties();

Affine toric varieties
----------------------

Affine toric varieties arise from cones. To dualize a (pointed) cone
just construct a new cone switching facets and rays.


.. link

.. CODE-BLOCK:: perl

    polymake> $sigma = new Cone(INPUT_RAYS=>[[1,0,0],[0,1,0],[1,0,1],[0,1,1]]);
    polymake> $sigmad = polarize($sigma);
    polymake> print $sigmad->HILBERT_BASIS, "\n";
    polymake> print $sigmad->TORIC_IDEAL->BINOMIAL_GENERATORS, "\n";
    polymake> print $sigmad->TORIC_IDEAL->GENERATORS, "\n";

The exponent vectors of the binomials generate the lattice of relations
of the Hilbert basis of the dual cone. In particular we have


.. link

.. CODE-BLOCK:: perl

    polymake> $hb = $sigmad->HILBERT_BASIS;
    polymake> $binomials = $sigmad->TORIC_IDEAL->BINOMIAL_GENERATORS;
    polymake> print $binomials * $hb; 

Cyclic quotient singularities
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Two-dimensional pointed cones in two-dimensional space can always be
generated by two rays in the standard form ``[[1,0],[-q,n]]`` with
``0<q<n`` and ``q`` and ``n`` coprime.


.. link

.. CODE-BLOCK:: perl

    polymake> $N7Q3 = new CyclicQuotient(N=>7, Q=>3);
    polymake> print primitive($N7Q3->RAYS);

CQS are deeply connected with the associated continued fractions.


.. link

.. CODE-BLOCK:: perl

    polymake> $cf = new Vector<Rational>($N7Q3->CONTINUED_FRACTION);
    polymake> print $cf, "\n";
    polymake> print $cf->[0] -1/( $cf->[1] -1/ $cf->[2]), "\n";

.. link

.. CODE-BLOCK:: perl

    polymake> $dcf = new Vector<Rational>($N7Q3->DUAL_CONTINUED_FRACTION);
    polymake> print $dcf, "\n";
    polymake> print $dcf->[0] -1/ $dcf->[1], "\n";

If we start with the Hilbert basis of the dual cone, sorted by first
coordinate:


.. link

.. CODE-BLOCK:: perl

    polymake> print $N7Q3->WEIGHT_CONE->HILBERT_BASIS, "\n";
    polymake> $sorted = new Matrix(sort(@{$N7Q3->WEIGHT_CONE->HILBERT_BASIS}));
    polymake> print $sorted;

Then the dual continued fraction expansion of ``n/(n-q)`` gives us
relations among these elements:


.. link

.. CODE-BLOCK:: perl

    polymake> print $sorted->[0] + $sorted->[2] == $dcf->[0] * $sorted->[1],"\n";
    polymake> print $sorted->[1] + $sorted->[3] == $dcf->[1] * $sorted->[2],"\n";

Q: Derive and prove the general relation formula.


Projective varieties
~~~~~~~~~~~~~~~~~~~~

Projective toric varieties arise from polytopes. Normal projective toric
varieties arise from fans. To construct a projective toric variety,
simply take the normal fan of a polytope and give it to the
``NormalToricVariety`` constructor.


.. link

.. CODE-BLOCK:: perl

    polymake> $PP2 = new NormalToricVariety(normal_fan(simplex(2)));
    polymake> print $PP2->RAYS;
    polymake> print $PP2->MAXIMAL_CONES;

.. link

.. CODE-BLOCK:: perl

    polymake> $PP2->VISUAL;

The Hasse diagram looks as follows:


.. link

.. CODE-BLOCK:: perl

    polymake> $PP2->HASSE_DIAGRAM->VISUAL;

Now consider the following two cones:


.. link

.. CODE-BLOCK:: perl

    polymake> $c1 = new Cone(simplex(2));
    polymake> print $c1->HILBERT_BASIS, "\n";
    polymake> $c2 = new Cone(simplex(2,2));
    polymake> print $c2->HILBERT_BASIS, "\n";

Lets look at the associated toric ideals:


.. link

.. CODE-BLOCK:: perl

    polymake> print "C1: ", join("\n", @{$c1->TORIC_IDEAL->GENERATORS}),"\n";
    polymake> print "C2: ", join("\n", @{$c2->TORIC_IDEAL->GENERATORS}),"\n";

The first ideal is actually ``0``. Both ideals are homogeneous and
hence, they define projective varieties.

Q: What are these projective varieties?


A non-projective toric variety
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Not every fan is the normal fan of a polytope. Here we give an example.


.. link

.. CODE-BLOCK:: perl

    polymake> $f = new PolyhedralFan(INPUT_RAYS=>
    polymake> [[1,0,0],[0,1,0],[-1,-1,-1],
    polymake> [0,0,1],[2,1,1],[1,2,1],[1,1,2]],
    polymake> INPUT_CONES=>[[0,1,2],[0,2,3],
    polymake> [1,2,3],[4,5,6],[0,1,4],[1,3,5],
    polymake> [0,3,6],[1,4,5],[3,5,6],[0,4,6]]
    polymake> );
    polymake> $tv = new NormalToricVariety($f);
    polymake> print "Projective? ", $tv->PROJECTIVE, "\n";
    polymake> print "Smooth? ", $tv->SMOOTH, "\n";
    polymake> print "Complete? ", $tv->COMPLETE, "\n";

.. link

.. CODE-BLOCK:: perl

    polymake> $tv->VISUAL;

Hirzebruch surfaces
^^^^^^^^^^^^^^^^^^^

Hirzebruch surfaces come from two-dimensional complete fans with exactly
four rays. Smoothness makes it possible to bring these fans into a
standard form such that we arrive at a one-parameter family.


.. link

.. CODE-BLOCK:: perl

    polymake> $h1 = hirzebruch_surface(1);
    polymake> print $h1->RAYS;

.. link

.. CODE-BLOCK:: perl

    polymake> $h1->VISUAL;

.. link

.. CODE-BLOCK:: perl

    polymake> $h2 = hirzebruch_surface(2);
    polymake> print $h2->RAYS;

.. link

.. CODE-BLOCK:: perl

    polymake> $h2->VISUAL;

Q: Construct the/an associated polytope.

Q: Prove the standard form for complete smooth fans in two dimensions
with exactly four rays.


polymake has a method to reconstruct a polytope from a regular fan /
projective toric variety.


.. link

.. CODE-BLOCK:: perl

    polymake> $A = generating_polyhedron_facets($h2);
    polymake> print $A;

This polytope has the given fan as a normal fan.


.. link

.. CODE-BLOCK:: perl

    polymake> $P = new Polytope(INEQUALITIES=>$A);
    polymake> $FF = normal_fan($P);
    polymake> print $FF->RAYS;
    polymake> print $FF->MAXIMAL_CONES;

The polytope we just constructed looks like:


.. link

.. CODE-BLOCK:: perl

    polymake> $P->VISUAL;

The polytope is not unique. Any polytope with the same facet vectors and
combinatorics will have the same normal fan.

Its normal fan is exactly the fan we started with.


.. link

.. CODE-BLOCK:: perl

    polymake> $FF->VISUAL;

Simple, not smooth
^^^^^^^^^^^^^^^^^^


.. link

.. CODE-BLOCK:: perl

    polymake> $p = new Polytope(POINTS=>[
    polymake> [1, 0, 0, 0],
    polymake> [1, 1, 1, 0],
    polymake> [1, 1, 0, 1],
    polymake> [1, 0, 1, 1]]);
    polymake> print "Simple? ", $p->SIMPLE, "\n";
    polymake> print "Smooth? ", $p->SMOOTH, "\n";

Non-normal toric varieties
~~~~~~~~~~~~~~~~~~~~~~~~~~

polymake only handles normal toric varieties. Nevertheless we can use it
to get at the toric ideal of a non-normal toric variety by giving the
semigroup generators directly as a mock Hilbert basis. For example for
the Neil parabola use:


.. link

.. CODE-BLOCK:: perl

    polymake> $c = new Cone(HILBERT_BASIS_GENERATORS=>[[[2],[3]],[[]]]);
    polymake> print $c->TORIC_IDEAL->BINOMIAL_GENERATORS;
    polymake> print $c->TORIC_IDEAL->GENERATORS;

If we build a new cone from this semigroup, we see that it was not
saturated. The semigroup generated by 2 and 3 does not come from a cone.


.. link

.. CODE-BLOCK:: perl

    polymake> $cc = new Cone(INPUT_RAYS=>$c->HILBERT_BASIS_GENERATORS->[0]);
    polymake> print $cc->RAYS, "\n";
    polymake> print $cc->HILBERT_BASIS, "\n";

Q: What are necessary conditions for a semigroup to come from a cone?


Smooth vs normal
^^^^^^^^^^^^^^^^

It is an open question by Oda whether smoothness and normality of
polytopes are equivalent.


.. link

.. CODE-BLOCK:: perl

    polymake> print $p->VERTICES, "\n";
    polymake> print "Normal? ", $p->NORMAL, "\n";
    polymake> print "Smooth? ", $p->SMOOTH, "\n";

.. link

.. CODE-BLOCK:: perl

    polymake> help "NORMAL";
    polymake> help "SMOOTH";

.. link

.. CODE-BLOCK:: perl

    polymake> print $p->HILBERT_BASIS;

Dealing with torus invariant divisors
-------------------------------------

The application ``fulton`` allows one to compute several properties of
divisors and even divisor classes. First build a divisor from its
representation as a sum of primitive divisors.


.. link

.. CODE-BLOCK:: perl

    polymake> $tv = hirzebruch_surface(4);
    polymake> $d = $tv->DIVISOR(COEFFICIENTS=>[1,1,1,1]);

Then treat them like any polymake object.


.. link

.. CODE-BLOCK:: perl

    polymake> print "Effective? ", $d->EFFECTIVE, "\n";
    polymake> print "Ample? ", $d->AMPLE, "\n";
    polymake> print "Basepoint free? ", $d->BASEPOINT_FREE, "\n";
    polymake> print "Nef? ", $d->NEF, "\n";
    polymake> print "Cartier? ", $d->CARTIER, "\n";

The following code produces the vertices of the polytope of global
sections.


.. link

.. CODE-BLOCK:: perl

    polymake> $pd = $d->SECTION_POLYTOPE;
    polymake> print $pd->VERTICES;

Furthermore one can deal with rational divisor classes, rather than
divisors, using the class group exact sequence. Its projection matrix
can be produced as follows.


.. link

.. CODE-BLOCK:: perl

    polymake> print $tv->RATIONAL_DIVISOR_CLASS_GROUP->PROJECTION;

Then one can access the nef cone, effective cone and Mori cone of the
toric variety:


.. link

.. CODE-BLOCK:: perl

    polymake> print "Nef cone:\n", $tv->NEF_CONE->RAYS,"\n";
    polymake> print "Effective cone:\n", $tv->EFFECTIVE_CONE->RAYS,"\n";
    polymake> print "Mori cone:\n", $tv->MORI_CONE->RAYS,"\n";

Accessing Singular
------------------

`Singular <https://www.singular.uni-kl.de/>`__ is a computer algebra
system developed in Kaiserslautern. It can be accessed from polymake on
different levels. For ideals there are low-level c++ methods providing
basic funtionality to compute Groebner bases, radicals, etc. At top
level for users there are perl methods giving the opportunity to send
command strings to Singular if something has not been accessed on c++
level yet. This allows fast proof of concept implementations.


.. link

.. CODE-BLOCK:: perl

    polymake> application "fulton";
    polymake> $c = new Cone(INPUT_RAYS=>[[-1,1],[0,1],[1,1]]);
    polymake> $tv = new NormalToricVariety($c);
    polymake> $toric = $c->TORIC_IDEAL;

.. link

.. CODE-BLOCK:: perl

    polymake> singular_eval("listvar();");

.. link

.. CODE-BLOCK:: perl

    polymake> $radical = $toric->RADICAL;
    polymake> print join("\n", @{$radical->GENERATORS});

.. link

.. CODE-BLOCK:: perl

    polymake> singular_eval("listvar();");

.. link

.. CODE-BLOCK:: perl

    polymake> $ideal = $tv->WEIGHT_CONE->TORIC_IDEAL;
    polymake> print $ideal;

It is possible to execute arbitrary Singular commands from polymake
using the ``singular_eval`` command. First build your command as a
string.


.. link

.. CODE-BLOCK:: perl

    polymake> $cmd = "ring r = 0,(x_0,x_1,x_2),dp;";
    polymake> print $cmd;

Then hand this string to ``singular_eval``.


.. link

.. CODE-BLOCK:: perl

    polymake> singular_eval($cmd);
    polymake> singular_eval("r;");

One can also retrieve variables from Singular to polymake using the
``singular_get_var`` command in the following manner.


.. link

.. CODE-BLOCK:: perl

    polymake> singular_eval("int n = nvars(r);");
    polymake> $n = singular_get_var("n");
    polymake> print $n,"\n";

It is possible to retrieve the following datatypes from Singular:
``int``, ``intmat``, ``intvec`` and ``poly``.


.. link

.. CODE-BLOCK:: perl

    polymake> singular_eval("poly p = x_2^2-x_0*x_1");
    polymake> $p = singular_get_var("p");
    polymake> print $p,"\n";

To load a Singular library, you can use the ``load_singular_library``
command with the library name. Afterwards all library methods are
accessible, as in the following example.


.. link

.. CODE-BLOCK:: perl

    polymake> load_singular_library("deform.lib");
    polymake> singular_eval("ideal i = x_0*x_1, x_2;");
    polymake> singular_eval("def L = versal(i);");
    polymake> singular_eval("L;");

