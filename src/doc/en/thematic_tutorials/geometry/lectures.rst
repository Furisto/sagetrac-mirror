.. -*- coding: utf-8 -*-

.. linkall

.. _polytutorial:

==================================================
An introduction to polyhedral computations in Sage
==================================================

.. MODULEAUTHOR:: sarah-marie belcastro <smbelcas@toroidalsnark.net>, Jean-Philippe Labbé <labbe@math.fu-berlin.de>

This tutorial aims to showcase some of the possibilities of Sage concerning
polyhedral geometry and combinatorics.

The classic litterature on the topic includes:

 - *Convex Polytopes*, Branko Grünbaum, [Gru1967]_
 - *An Introduction to Convex Polytopes*, Arne Brøndsted, [Bro1983]_
 - *Lectures on Polytopes*, Günter M. Ziegler, [Zie2007]_

.. contents:: Lectures Menu
    :depth: 2

Lecture 0: Basic definitions and constructions
==============================================

A real :math:`(k\times d)`-matrix :math:`A` and a real vector :math:`b`
in :math:`\mathbb{R}^d` define a (convex) **polyhedron** :math:`P` as the set of solutions 
of the system of linear inequalities:

.. MATH::
    A\cdot x + b \geq 0.

Each row of :math:`A` defines a closed half-space of :math:`\mathbb{R}^d`.
Hence a polyhedron is the intersection of finitely many closed half-spaces in
:math:`\mathbb{R}^d`. The matrix :math:`A` may contain equal rows, which may lead to a
set of *equalities* satisfied by the polyhedron. If there are no redundant rows 
in the above definition, this definition is refered to as the 
:math:`\mathbf{H}` **-representation** of a polyhedron.

The maximal affine subspace :math:`L` contained in a polyhedron is the
**lineality** space. Fixing a point :math:`o` of the lineality space to act 
as the *origin*, one can write every point :math:`p` inside a polyhedron as a combination

.. MATH::
    p = \ell +\sum_{i=1}^{n}\lambda_iv_i+\sum_{i=1}^{m}\mu_ir_i,

where :math:`\ell\in L` (using :math:`o` as the origin), :math:`\sum_{i=1}^n\lambda_i=1`, 
:math:`\mu_i\geq0`, and :math:`r_i\neq0` for all :math:`0\leq i\leq m` and the 
set of :math:`r_i` 's are positively independant (the origin is not in their positive span). 
There are many equivalent ways write the above, so one asks :math:`n` and :math:`m` 
to be minimal with that property.

The points :math:`v_i` 's are called the *vertices* of :math:`P` and the points
:math:`r_i` 's are called the *rays* of :math:`P`.
This way to represent a polyhedron is refered to as the
:math:`\mathbf{V}` **-representation** of a polyhedron. The second sum represents the *convex
hull* of the vertices :math:`v_i` 's and the second sum represents a *pointed
polyhedral cone* generated by finitely many rays.

When the lineality space and the rays are reduced to a point (i.e. no rays and
no lines) the object is often refered to as a **polytope**.

.. note :: As mentioned in the documentation of the constructor when typing :code:`Polyhedron?`, 

    *You may either define it with vertex/ray/line or
    inequalities/equations data, but not both. Redundant data will
    automatically be removed (unless "minimize=False"), and the
    complementary representation will be computed.*

    You can find here is the documentation for the constructor function of :ref:`sage.geometry.polyhedron.constructor`.

:math:`V`-representation
------------------------

First, let's define a polyhedron object as the convex hull of a set of points
and some rays.

::

    sage: P1 = Polyhedron(vertices = [[1, 0], [0, 1]], rays = [[1, 1]])
    sage: P1
    A 2-dimensional polyhedron in ZZ^2 defined as the convex hull of 2 vertices and 1 ray

.. end of output

The string representation already gives a lot of information:

 - the dimension of the polyhedron (the smallest affine space containing it)
 - the dimension of the space in which it is defined
 - the base ring (:math:`\mathbb{Z}^2`) over which the polyhedron lives (this specifies the parent class, see :ref:`sage.geometry.polyhedron.parent`)
 - the number of vertices
 - the number of rays

Of course, you want to know what this object looks like:

::

    sage: P1.plot()
    Launched png viewer for Graphics object consisting of 5 graphics primitives

.. end of output

We can also add a lineality space.

::

    sage: P2 = Polyhedron(vertices = [[1/2, 0, 0], [0, 1/2, 0]],
    ....:                 rays = [[1, 1, 0]],
    ....:                 lines = [[0, 0, 1]])
    sage: P2
    A 3-dimensional polyhedron in QQ^3 defined as the convex hull of 2 vertices, 1 ray, 1 line
    sage: P2.plot()
    Launched jmol viewer for Graphics3d Object

.. end of output

Notice that the base ring change because of the value :math:`\frac{1}{2}`.
Indeed, Sage finds an appropriate ring to define the object.

::

    sage: P1.parent()
    Polyhedra in ZZ^2
    sage: P2.parent()
    Polyhedra in QQ^3

.. end of output

The chosen ring depends on the input format.

::

    sage: P3 = Polyhedron(vertices = [[0.5, 0], [0, 0.5]])
    sage: P3
    A 1-dimensional polyhedron in RDF^2 defined as the convex hull of 2 vertices
    sage: P3.parent()
    Polyhedra in RDF^2

.. end of output

.. WARNING::

    The base ring :code:`RDF` should be used with care. As it is not an exact
    ring certain computations may break, for example when dealing with
    non-simplicial polyhedron.


The following example demonstrates the limitations of :code:`RDF`.

::

    sage: P = polytopes.dodecahedron()
    sage: P
    A 3-dimensional polyhedron in (Number Field in sqrt5 with defining
    polynomial x^2 - 5)^3 defined as the convex hull of 20 vertices
    sage: P_RDF = Polyhedron(vertices = [n(v.vector(),digits=6) for v in
    P.vertices()], base_ring=RDF)
    sage: P_RDF
    A 3-dimensional polyhedron in RDF^3 defined as the convex hull of 17
    vertices

.. end of output

It is also possible to define polyhedron over algebraic numbers.

::

    sage: sqrt_2 = AA(2)^(1/2)
    sage: cbrt_2 = AA(2)^(1/3)
    sage: timeit('Polyhedron(vertices = [[sqrt_2, 0], [0, cbrt_2]])')  # random
    5 loops, best of 3: 43.2 ms per loop
    sage: P4 = Polyhedron(vertices = [[sqrt_2, 0], [0, cbrt_2]]); P4
    A 1-dimensional polyhedron in AA^2 defined as the convex hull of 2 vertices

.. end of output

There is another way to create a polyhedron over algebraic numbers:

::

    sage: K.<a> = NumberField(x^2 - 2, embedding=AA(2)**(1/2))
    sage: L.<b> = NumberField(x^3 - 2, embedding=AA(2)**(1/3))
    sage: timeit('Polyhedron(vertices = [[a, 0], [0, b]])')  # random
    5 loops, best of 3: 39.9 ms per loop
    sage: P5 = Polyhedron(vertices = [[a, 0], [0, b]]); P5
    A 1-dimensional polyhedron in AA^2 defined as the convex hull of 2 vertices

.. end of output

If the base ring is known it may be a good option to use the proper :code:`composite_field`:

::

    sage: J = K.composite_fields(L)[0]
    sage: timeit('Polyhedron(vertices = [[J(a), 0], [0, J(b)]])')  # random
    25 loops, best of 3: 9.8 ms per loop
    sage: P5_comp = Polyhedron(vertices = [[J(a), 0], [0, J(b)]]); P5_comp
    A 1-dimensional polyhedron in (Number Field in ab with defining polynomial x^6 - 6*x^4 - 4*x^3 + 12*x^2 - 24*x - 4)^2 defined as the convex hull of 2 vertices

.. end of output

Since the :code:`Symbolic Ring` is not exact, it is not possible to define a
polyhedron over it:

::

    sage: sqrt_2s = sqrt(2)
    sage: cbrt_2s = 2^(1/3)
    sage: Polyhedron(vertices = [[sqrt_2s, 0], [0, cbrt_2s]])
    Traceback (most recent call last):
    ...
    ValueError: no appropriate backend for computations with Symbolic Ring

.. end of output

Similarly, it is not possible to create polyhedron objects over :code:`floats`
or over :code:`RR` (no matter how many bits of precision).

::

    sage: F45 = RealField(45)
    sage: F100 = RealField(100)
    sage: f = 1.1
    sage: Polyhedron(vertices=[[F45(f)]])
    Traceback (most recent call last):
    ...
    ValueError: no appropriate backend for computations with Real Field with 45
    bits of precision
    sage: Polyhedron(vertices=[[F100(f)]])
    Traceback (most recent call last):
    ...
    ValueError: no appropriate backend for computations with Real Field with
    100 bits of precision
    
    sage: FLOATS EXAMPLE

.. end of output

There is one exception, when the number of bits of precision is 53, then the
base ring is converted to :code:`RDF`:

::

    sage: F53 = RealField(53)
    sage: Polyhedron(vertices=[[F53(f)]])
    A 0-dimensional polyhedron in RDF^1 defined as the convex hull of 1 vertex
    sage: type(Polyhedron(vertices=[[F53(f)]]))
    <class 'sage.geometry.polyhedron.backend_cdd.Polyhedra_RDF_cdd_with_category.element_class'>

.. end of output

This behavior can be seen as wrong, but it allows the following to be
acceptable by Sage:

::

    sage: Polyhedron([(1.0, 2.3), (3.5, 2.0)])
    A 1-dimensional polyhedron in RDF^2 defined as the convex hull of 2 vertices

.. end of output

without having specified the base ring :code:`RDF` by the user.


`H`-representation
------------------

If a polyhedron object was constructed via a :math:`V`-representation, Sage can provide 
the :math:`H`-representation of the object. 

::

    sage: for h in P1.Hrepresentation():
    ....:     print h
    An inequality (1, 1) x - 1 >= 0
    An inequality (1, -1) x + 1 >= 0
    An inequality (-1, 1) x + 1 >= 0

.. end of output

Each line gives a row of the matrix :math:`A` and an entry of the vector :math:`b`.
The variable :math:`x` is a vector in the ambient space where :code:`P1` is
defined. The :math:`H`-representation may contain equations:

::

    sage: P3.Hrepresentation()
    (An equation (1.0, 1.0) x - 0.5 == 0,
     An inequality (-2.0, 0.0) x + 1.0 >= 0,
     An inequality (1.0, 0.0) x + 0.0 >= 0)

.. end of output

The construction of a polyhedron object via its :math:`H`-representation,
requires a precise format. Each inequality :math:`(a_{i1}, \dots, a_{id})\cdot
x + b_i \geq 0` must be written as :code:`[b_i,a_i1, ..., a_id]`. 

::

    sage: P3_H = Polyhedron(ieqs = [[1.0, -2, 0], [0, 1, 0]], eqns = [[-0.5, 1, 1]])
    sage: P3 == P3_H
    True
    sage: P3_H.Vrepresentation()
    (A vertex at (0.0, 0.5), A vertex at (0.5, 0.0))

.. end of output

It is worth using the parameter :code:`eqns` to shorten the construction of the
object. In the following example, the first four rows are the negative of the
second group of four rows.

::

    sage: H = [[0, 0, 0, 0, 0, 0, 0, 0, 1],
    ....:  [0, 0, 0, 0, 0, 0, 1, 0, 0],
    ....:  [-2, 1, 1, 1, 1, 1, 0, 0, 0],
    ....:  [0, 0, 0, 0, 0, 0, 0, 1, 0],
    ....:  [0, 0, 0, 0, 0, 0, 0, 0, -1],
    ....:  [0, 0, 0, 0, 0, 0, -1, 0, 0],
    ....:  [2, -1, -1, -1, -1, -1, 0, 0, 0],
    ....:  [0, 0, 0, 0, 0, 0, 0, -1, 0],
    ....:  [2, -1, -1, -1, -1, 0, 0, 0, 0],
    ....:  [0, 0, 0, 0, 1, 0, 0, 0, 0],
    ....:  [0, 0, 0, 1, 0, 0, 0, 0, 0],
    ....:  [0, 0, 1, 0, 0, 0, 0, 0, 0],
    ....:  [-1, 1, 1, 1, 1, 0, 0, 0, 0],
    ....:  [1, 0, 0, -1, 0, 0, 0, 0, 0],
    ....:  [0, 1, 0, 0, 0, 0, 0, 0, 0],
    ....:  [1, 0, 0, 0, -1, 0, 0, 0, 0],
    ....:  [1, 0, -1, 0, 0, 0, 0, 0, 0],
    ....:  [1, -1, 0, 0, 0, 0, 0, 0, 0]]
    sage: timeit('Polyhedron(ieqs = H)')  # random
    125 loops, best of 3: 5.99 ms per loop
    sage: timeit('Polyhedron(ieqs = H[8:], eqns = H[:4])')  # random
    125 loops, best of 3: 4.78 ms per loop
    sage: Polyhedron(ieqs = H) == Polyhedron(ieqs = H[8:], eqns = H[:4])
    True

.. end of output

Of course, this is a toy example, but it is generally worth to preprocess 
the data before defining the polyhedron if possible.


Lecture 1: Representation objects
===================================

Many objects are related to the :math:`H`- and :math:`V`-representations. Sage 
has classes implemented for them.

`H`-representation
------------------

You can store the :math:`H`-representation in a variable and use the
inequalities and equalities as objects. 

::

    sage: P3_QQ = Polyhedron(vertices = [[0.5, 0], [0, 0.5]], base_ring=QQ)
    sage: HRep = P3_QQ.Hrepresentation()
    sage: H1 = HRep[0]; H1
    An equation (2, 2) x - 1 == 0
    sage: H2 = HRep[1]; H2
    An inequality (0, -2) x + 1 >= 0
    sage: H1.<tab>
    sage: H1.A()
    (2, 2)
    sage: H1.b()
    -1
    sage: H1.is_equation()
    True
    sage: H1.is_inequality()
    False
    sage: H1.contains(vector([0,0]))
    False
    sage: H2.contains(vector([0,0]))
    True
    sage: H1.is_incident(H2)
    True

.. end of output


`V`-representation
------------------

Similarly, you can access to vertices, rays and lines of the polyhedron.

::

    sage: VRep = P2.Vrepresentation(); VRep
    (A line in the direction (0, 0, 1),
     A vertex at (0, 1/2, 0),
     A vertex at (1/2, 0, 0),
     A ray in the direction (1, 1, 0))
    sage: L = VRep[0]; L
    A line in the direction (0, 0, 1)
    sage: V = VRep[1]; V
    A vertex at (0, 1/2, 0)
    sage: R = VRep[3]; R
    A ray in the direction (1, 1, 0)
    sage: L.is_line()
    True
    sage: L.is_incident(V)
    True
    sage: R.is_incident(L)
    False
    sage: L.vector()
    (0, 0, 1)
    sage: V.vector()
    (0, 1/2, 0)

.. end of output

Lecture 2: Backends for polyhedral computations
===============================================

To deal with polyhedron objects, Sage currently has four backends available.
These backends offer various functionalities and have their own specific strengths and limitations.

 - :ref:`sage.geometry.polyhedron.backend_cdd`

   - `The cdd and cddplus homepage <https://www.inf.ethz.ch/personal/fukudak/cdd_home/>`_

 - :ref:`sage.geometry.polyhedron.backend_ppl`

   - `The Parma Polyhedra Library homepage <http://bugseng.com/products/ppl/>`_

 - :ref:`sage.geometry.polyhedron.backend_field`

   - This is a :code:`python` backend that provides an implementation of
     polyhedron over irrational coordinates.
 
 - :ref:`sage.geometry.polyhedron.backend_normaliz`, (requires the optional package :code:`pynormaliz`)

   - `Normaliz Homepage <https://www.normaliz.uni-osnabrueck.de/>`_


The default backend is :code:`ppl`. Whenever one needs **speed** it is good to try out 
the different backends. The backend :code:`field` is **not** specifically designed
for dealing with extremal computations.

The :code:`cdd` backend
-----------------------

In order to use a specific backend, we specify the :code:`backend` parameter.

::

    sage: P1_cdd = Polyhedron(vertices = [[1, 0], [0, 1]], rays = [[1, 1]], backend='cdd')
    sage: P1_cdd
    A 2-dimensional polyhedron in QQ^2 defined as the convex hull of 2 vertices and 1 ray

.. end of output

A priori, it seems that nothing changed, but ...

::

    sage: P1_cdd.parent()
    Polyhedra in QQ^2

.. end of output

The polyhedron :code:`P1_cdd` is now considered as a rational polyhedron by the
backend :code:`cdd`. We can also check the backend and the parent using
:code:`type`:

::

    sage: type(P1_cdd)
    <class 'sage.geometry.polyhedron.backend_cdd.Polyhedra_QQ_cdd_with_category.element_class'>
    sage: type(P1)
    <class 'sage.geometry.polyhedron.backend_ppl.Polyhedra_ZZ_ppl_with_category.element_class'>

.. end of output

We *clearly* (!) see

  - the backend used (ex: :code:`backend_cdd`)
  - followed by a dot ''.''
  - the parent (ex: :code:`Polyhedra_QQ`) followed again by the backend,

and you can safely ignore the rest for the purpose of this tutorial.

The :code:`cdd` backend accepts also entries in :code:`RDF`:

::

    sage: P3_cdd = Polyhedron(vertices = [[0.5, 0], [0, 0.5]], backend='cdd')
    sage: P3_cdd
    A 1-dimensional polyhedron in RDF^2 defined as the convex hull of 2 vertices

.. end of output

but not algebraic or symbolic values:

::

    sage: P4_cdd = Polyhedron(vertices = [[sqrt_2, 0], [0, cbrt_2]], backend='cdd')
    Traceback (most recent call last):
    ...
    ValueError: No such backend (=cdd) implemented for given basering (=Algebraic Real Field).

    sage: P5_cdd = Polyhedron(vertices = [[sqrt_2s, 0], [0, cbrt_2s]], backend='cdd')
    Traceback (most recent call last):
    ...
    ValueError: No such backend (=cdd) implemented for given basering (=Symbolic Ring).

.. end of output

It is possible to get the :code:`cdd` format of any polyhedron object defined
over :math:`\mathbb{Z}`, :math:`\mathbb{Q}`, or :code:`RDF`:

::

    sage: print P1.cdd_Vrepresentation()
    V-representation
    begin
     3 3 rational
     0 1 1
     1 0 1
     1 1 0
    end
    sage: print P3.cdd_Hrepresentation()
    H-representation
    begin
     3 3 real
     1.5 -1.0 1.0
     -1.5 1.0 1.5
     1.0 1.0 -1.0
    end

.. end of output

You can also write this data to a file using the method :code:`.write_cdd_Hrepresentation(filename)`
or :code:`.write_cdd_Vrepresentation(filename)`, where :code:`filename` is a
string containing a path to a file to be written.


The :code:`ppl` backend
-----------------------

The :code:`ppl` is the default backend for polyhedron objects.

::

    sage: type(P1)
    <class 'sage.geometry.polyhedron.backend_ppl.Polyhedra_ZZ_ppl_with_category.element_class'>
    sage: type(P2)
    <class 'sage.geometry.polyhedron.backend_ppl.Polyhedra_QQ_ppl_with_category.element_class'>
    sage: type(P3)  # has entries like 0.5
    <class 'sage.geometry.polyhedron.backend_cdd.Polyhedra_RDF_cdd_with_category.element_class'>

.. end of output

As you see, it does not accepts values in :code:`RDF` and the polyhedron constructor 
used the :code:`cdd` backend.


The :code:`field` backend
-------------------------

As it turns out, the rational numbers do not suffice to represent all combinatorial 
types of polytopes. For example, Perles constructed a `8`-dimensional polytope with
`12` vertices which does not have a realization with rational coordinates.
Furthermore, if one wants a realization to have
specific geometric property, such as symmetry, one also sometimes need
irrational coordinates.

The backend :code:`field` provides the necessary tools to deal with such
examples.

::

    sage: D = polytopes.dodecahedron()
    sage: D
    A 3-dimensional polyhedron in (Number Field in sqrt5 with defining polynomial x^2 - 5)^3 defined as the convex hull of 20 vertices
    sage: type(D)
    <class 'sage.geometry.polyhedron.backend_field.Polyhedra_field_with_category.element_class'>

.. end of output

Any time that the coordinates should be in an extension of the rational, the
backend :code:`field` is called.

::

    sage: P4.parent()
    Polyhedra in AA^2
    sage: P5.parent()
    Polyhedra in AA^2
    sage: type(P4)
    <class 'sage.geometry.polyhedron.backend_field.Polyhedra_field_with_category.element_class'>
    sage: type(P5)
    <class 'sage.geometry.polyhedron.backend_field.Polyhedra_field_with_category.element_class'>

.. end of output

The :code:`normaliz` backend
----------------------------

The fourth backend is :code:`normaliz` and is an optional Sage package.

::

    sage: P1_normaliz = Polyhedron(vertices = [[1, 0], [0, 1]], rays = [[1, 1]], backend='normaliz')  # optional - pynormaliz
    sage: type(P1_normaliz)                                                                           # optional - pynormaliz
    <class 'sage.geometry.polyhedron.backend_normaliz.Polyhedra_ZZ_normaliz_with_category.element_class'>
    sage: P2_normaliz = Polyhedron(vertices = [[1/2, 0, 0], [0, 1/2, 0]],                             # optional - pynormaliz
    ....:                 rays = [[1, 1, 0]],
    ....:                 lines = [[0, 0, 1]], backend='normaliz')
    sage: type(P2_normaliz)                                                                           # optional - pynormaliz
    <class 'sage.geometry.polyhedron.backend_normaliz.Polyhedra_QQ_normaliz_with_category.element_class'>

.. end of output

This backend does not work with :code:`RDF`, or algebraic numbers or the :code:`Symbolic Ring`:

::

    sage: P3_normaliz = Polyhedron(vertices = [[0.5, 0], [0, 0.5]], backend='normaliz')             # optional - pynormaliz
    Traceback (most recent call last):
    ...
    ValueError: No such backend (=normaliz) implemented for given basering (=Real Double Field).

    sage: P4_normaliz = Polyhedron(vertices = [[sqrt_2, 0], [0, cbrt_2]], backend='normaliz')       # optional - pynormaliz
    Traceback (most recent call last):
    ... 
    ValueError: No such backend (=normaliz) implemented for given basering (=Algebraic Real Field).

    sage: P5_normaliz = Polyhedron(vertices = [[sqrt_2s, 0], [0, cbrt_2s]], backend='normaliz')     # optional - pynormaliz
    Traceback (most recent call last):
    ...
    ValueError: No such backend (=normaliz) implemented for given basering (=Symbolic Ring).

.. end of output

The backend :code:`normaliz` provides other methods such as 
:code:`integral_hull`, which also works on unbounded polyhedron.

::

    sage: P6 = Polyhedron(vertices = [[0, 0], [3/2, 0], [3/2, 3/2], [0, 3]], backend='normaliz')  # optional - pynormaliz
    sage: IH = P6.integral_hull(); IH                                                             # optional - pynormaliz
    A 2-dimensional polyhedron in QQ^2 defined as the convex hull of 4 vertices
    sage: P6.plot(color='blue')+IH.plot(color='red')                                              # optional - pynormaliz
    Launched png viewer for Graphics object consisting of 12 graphics primitives
    sage: P1_normaliz.integral_hull()                                                             # optional - pynormaliz
    A 2-dimensional polyhedron in ZZ^2 defined as the convex hull of 2 vertices and 1 ray

.. end of output

Lecture 3: A library of polytopes
==================================

There are a lot of polytopes that are readily available in the library, see
:ref:`sage.geometry.polyhedron.library`. Have a look at them to see if your
polytope is already defined!

::

    sage: A = polytopes.buckyball(); A  # long time up to 20sec
    A 3-dimensional polyhedron in (Number Field in sqrt5 with defining polynomial x^2 - 5)^3 defined as the convex hull of 60 vertices
    sage: B = polytopes.cross_polytope(4); B
    A 4-dimensional polyhedron in ZZ^4 defined as the convex hull of 8 vertices
    sage: C = polytopes.cyclic_polytope(3,10); C
    A 3-dimensional polyhedron in QQ^3 defined as the convex hull of 10 vertices
    sage: E = polytopes.snub_cube(); E
    A 3-dimensional polyhedron in RDF^3 defined as the convex hull of 24 vertices
    sage: polytopes.<tab>  # to view all the possible polytopes

.. end of output


Lecture 4: To every polyhedron, the proper parent class
=======================================================

In order to **know all the methods that a polyhedron object has** one has to look into its :code:`base class`:

 - :ref:`sage.geometry.polyhedron.base` : This is the generic class for Polyhedron related objects.
 - :ref:`sage.geometry.polyhedron.base_ZZ`
 - :ref:`sage.geometry.polyhedron.base_QQ`
 - :ref:`sage.geometry.polyhedron.base_RDF`

Don't be surprised if the classes look empty! The classes mainly contain private
methods that implement some comparison methods: to verify equality and inequality 
of numbers in the base ring and other internal functionalities.



Lecture 5: Getting new polyhedra from old ones
===============================================

It is possible to apply various constructions once one has a polyhedron object.
Here is a - not necessarily complete - list of operations.

Minkowski sums
--------------

It is possible to do Minkowski sums of polyhedron, using two syntaxes.

::

    sage: P1.Minkowski_sum(P3)
    A 2-dimensional polyhedron in RDF^2 defined as the convex hull of 2 vertices and 1 ray

    sage: P1 + P3
    A 2-dimensional polyhedron in RDF^2 defined as the convex hull of 2 vertices and 1 ray

.. end of output

Minkowski differences
---------------------

After adding, one would like to substract:

::

    sage: Cube = polytopes.cube()
    sage: Square = Polyhedron(vertices = [[1, -1, -1], [1, -1, 1], [1, 1, -1], [1, 1, 1]])
    
    sage: Cube.Minkowski_difference(Square)
    A 1-dimensional polyhedron in ZZ^3 defined as the convex hull of 2 vertices
    sage: Square.Minkowski_difference(Cube)
    A 0-dimensional polyhedron in ZZ^3 defined as the convex hull of 1 vertex

    sage: Cube - Square
    A 1-dimensional polyhedron in ZZ^3 defined as the convex hull of 2 vertices
    sage: Square - Cube
    A 0-dimensional polyhedron in ZZ^3 defined as the convex hull of 1 vertex
    
.. end of output

Product
-------

It is also possible to multiply polyhedron:

::

    sage: P1.product(P3)
    A 3-dimensional polyhedron in RDF^4 defined as the convex hull of 4 vertices and 1 ray

    sage: P1 * P3
    A 3-dimensional polyhedron in RDF^4 defined as the convex hull of 4 vertices and 1 ray

.. end of output

Intersection
------------

Of course, it is possible to intersect two polyhedron objects:

::

    sage: P1.intersection(P7)
    A 2-dimensional polyhedron in ZZ^2 defined as the convex hull of 4 vertices

    sage: P1_and_P7 = P1 & P7; P1_and_P7
    A 2-dimensional polyhedron in ZZ^2 defined as the convex hull of 4 vertices

.. end of output

Union
---------

It is also possible to take the *set theoretic* union of two polyhedron
objects. It does the union of vertices, rays and lines to form the convex hull
of the two objects.

::

    sage: R1 = Polyhedron(rays = [[-1]])
    sage: R2 = Polyhedron(rays = [[1]])
    sage: R1.convex_hull(R2)
    A 1-dimensional polyhedron in ZZ^1 defined as the convex hull of 1 vertex and 1 line

    sage: P1_union_P7 = P1.convex_hull(P7)
    sage: P1_union_P7
    A 2-dimensional polyhedron in ZZ^2 defined as the convex hull of 2 vertices
    and 2 rays
    sage: P1_union_P7.vertices()
    (A vertex at (3, 0), A vertex at (1, 0))
    sage: P1_union_P7.rays()
    (A ray in the direction (-1, 1), A ray in the direction (1, 1))

.. end of output

Taking a face
-------------

It is possible to obtain each face of a polyhedron.

::

    sage: for f in P1.faces(1):
    ....:     print f.ambient_Vrepresentation()
    (A vertex at (0, 1), A ray in the direction (1, 1))
    (A vertex at (0, 1), A vertex at (1, 0))
    (A vertex at (1, 0), A ray in the direction (1, 1))

.. end of output

Faces remember the polyhedron it comes from and can also become a polyhedron
object on its own.

::

    sage: f = P1.faces(1)[0]
    sage: f.polyhedron() is P1
    True

    sage: f.as_polyhedron()
    A 1-dimensional polyhedron in ZZ^2 defined as the convex hull of 1 vertex and 1 ray

.. end of output

Barycentric subdivision
-----------------------

What is the barycentric subdivision of the simplex?

::

    sage: S = polytopes.simplex(3); S
    A 3-dimensional polyhedron in ZZ^4 defined as the convex hull of 4 vertices
    sage: BS = S.barycentric_subdivision(); BS
    A 3-dimensional polyhedron in QQ^4 defined as the convex hull of 14 vertices

.. end of output

Hint: it is the polar dual of a polytope in the library.

Bipyramid
---------

The bipyramid is similar to the suspension in topology. It increases the
dimension of the polytope by 1.

::

    sage: Cube.bipyramid()
    A 4-dimensional polyhedron in ZZ^4 defined as the convex hull of 10
    vertices

.. end of output

Dilation
--------

It is possible to dilate a polyhedron by an arbitrary scalar.

::

    sage: D_P1 = P1.dilation(AA(sqrt(2))); D_P1.vertices()
    (A vertex at (0, 1.414213562373095?), A vertex at (1.414213562373095?, 0))

    sage: P8 = Polyhedron(vertices = [[0, 0], [1, 0], [0, 1]])
    sage: 2*P8
    A 2-dimensional polyhedron in ZZ^2 defined as the convex hull of 3 vertices
    sage: P8.dilation(2) == 2*P8
    True

.. end of output

Face-truncation
---------------

It is possible to truncate a specific face of a polyhedron. One can also change
the angle of the truncation and how deep the cut is done. 

::

    sage: my_face = P1.faces(0)[0]  # This is a vertex-face
    sage: Trunc1_P1 = P1.face_truncation(P1.faces(0)[0])
    sage: Trunc1_P1.plot()
    Launched png viewer for Graphics object consisting of 6 graphics primitives
    sage: Trunc_P2 = P1.face_truncation(P1.faces(0)[0],linear_coefficients=(1, 1/2), cut_frac=3/4)
    sage: Trunc_P2.plot()
    Launched png viewer for Graphics object consisting of 6 graphics primitives

.. end of output

Lattice polytope
----------------

This method returns an encompassing lattice polytope.

::

    sage: LP = P3_QQ.lattice_polytope(envelope=True)  # envelope=True for rational polytopes
    sage: LP.vertices()
    M(0, 0),
    M(0, 1),
    M(1, 0)
    in 2-d lattice M

.. end of output

Polar
-----

The polar polytope is only defined for compact, or bounded, polyhedron.

::

    sage: P3.polar()
    A 2-dimensional polyhedron in RDF^2 defined as the convex hull of 2 vertices and 1 line

    sage: P2.polar()
    Traceback (most recent call last):
    ...
    AssertionError: Not a polytope.

.. end of output

Prism
-----

The prism construction is the same as taking the Minkowski sum of the
polyhedorn with a segment (a 1-dimensional polytope) in an orthogonal space.

::

    sage: P1.prism()
    A 3-dimensional polyhedron in ZZ^3 defined as the convex hull of 4 vertices and 1 ray

.. end of output

Pyramid
-------

Similar, the pyramid is a join of a vertex with the polyhedron.

::

    sage: (P1_and_P7).pyramid()
    A 3-dimensional polyhedron in ZZ^3 defined as the convex hull of 5 vertices

.. end of output

Translation
-----------

One can translate a polyhedron by a vector.

::

    sage: (P1_and_P7).vertices()
    (A vertex at (2, 3),
     A vertex at (3, 2),
     A vertex at (2, 1),
     A vertex at (1, 2))
    sage: P1P7_translate = (P1_and_P7).translation([-1, 0])
    sage: P1P7_translate.vertices()
    (A vertex at (0, 2),
     A vertex at (1, 1),
     A vertex at (1, 3),
     A vertex at (2, 2))
    
    sage: P1_and_P7.find_translation(P17_translate)
    (-1, 0)
    sage: P1_and_P7.find_translation(P2)
    Traceback (most recent call last):
    ...
    ValueError: polyhedron is not a translation of self

.. end of output

Lecture 6: Obtain related combinatorial and geometric objects
==============================================================

Once one constructed the polyhedron object, one would like to know some
combinatorial and geometric information about this object.


Enumerative properties
----------------------

Dimensions
~~~~~~~~~~~~

The ambient dimension is the dimension of the space in which the object is
defined:

::

    sage: P1 = Polyhedron(vertices = [[1, 0], [0, 1]], rays = [[1, 1]])
    sage: P1.ambient_dim()
    2

.. end of output

Whereas the dimension of the object is the dimension of the smallest affine
subspace containing it.

::

    sage: Polyhedron(rays = [[1, 1]])
    A 1-dimensional polyhedron in ZZ^2 defined as the convex hull of 1 vertex
    and 1 ray
    sage: Polyhedron(rays = [[1, 1]]).dim()
    1
    sage: Polyhedron(rays = [[1, 1]]).dimension()
    1

.. end of output

:math:`f`-vector
~~~~~~~~~~~~~~~~~

The :math:`f`-vector contains the number of faces of the object ordered by
increasing dimension:

The cube has 8 vertices, 12 edges and 6 polygons:

::

    sage: Cube.f_vector()
    (1, 8, 12, 6, 1)

.. end of output

One can also ask the :math:`f`-vector of unbounded polyhedron. :code:`P1` has 2
vertices and 3 edges.

::

    sage: P1.f_vector()
    (1, 2, 3, 1)

.. end of output

Number of representation objects
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The number of objects used in each representations is stored in 
several methods:

::

    sage: P1.n_Hrepresentation()  # The number of elements in the H-representation
    3
    sage: P1.n_Vrepresentation()  # The number of elements in the V-representation
    3

    sage: P1.n_equations()
    0
    sage: P1.n_inequalities()
    3
    sage: P1.n_lines()
    0
    sage: P1.n_rays()
    1

    sage: P1.n_vertices()
    2
    sage: P1.n_facets()
    3

.. end of output

Geometric objects and properties
--------------------------------

Center and Representative point
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The :code:`center` returns the average of the vertices while the
:code:`representative_point` returns a point in the interior as far as it is
possible; if the polyhedron is not full dimensional a point in the relative
interior is returned.

::

    sage: P1.center()
    (1/2, 1/2)
    sage: P1.representative_point()
    (3/2, 3/2)

    sage: P6.representative_point()  # optional - normaliz
    (3/4, 9/8)

.. end of output

Containment
~~~~~~~~~~~

Testing if a polyhedron contains a point is done as follows.

::

    sage: P1_and_P7.interior_contains([2,2])
    True
    sage: P1_and_P7.interior_contains([2,1])
    False
    sage: P1_and_P7.contains([2,1])
    True

.. end of output

Face and Normal fans
~~~~~~~~~~~~~~~~~~~~

The *face fan* and the *normal fan* are two structures encoding geometrical
data of the polyhedron.

::

    sage: FaceFan(Cube)
    Rational polyhedral fan in 3-d lattice M
    sage: NormalFan(P1_and_P7)
    Rational polyhedral fan in 2-d lattice N

.. end of output

Gale transform
~~~~~~~~~~~~~~

The Gale transform -- also called *Gale dual* -- is useful to study polytopes
with few vertices. It allows to visualize polytopes and linear relations
between the vertices in a relatively small dimensional space.

::

    sage: CP = polytopes.cyclic_polytope(5,8)  # A 5-dim. polytope with 8 vertices
    sage: CP.gale_transform()
    [(1, 0), (0, 1), (-21, -6), (70, 15), (-105, -20), (84, 15), (-35, -6), (6, 1)]

.. end of ouput

Hyperplane arrangement
~~~~~~~~~~~~~~~~~~~~~~

You can obtain the hyperplane arrangement given by the
:math:`H`-representation as an hyperplane arrangement object.

::

    sage: CP.hyperplane_arrangement()
    Arrangement of 30 hyperplanes of dimension 5 and rank 5

.. end of output

Integral points
~~~~~~~~~~~~~~~

You can count integer points as follows. The package :code:`latte_int` is
a useful addition in this kind of computations. You can install it by typing

.. CODE::

    sage -i latte_int

.. end of output

in a console.

::
    
    sage: Square.integral_points()
    ((1, -1, -1),
     (1, -1, 0),
     (1, -1, 1),
     (1, 0, -1),
     (1, 0, 0),
     (1, 0, 1),
     (1, 1, -1),
     (1, 1, 0),
     (1, 1, 1))
    sage: Square.integral_points_count()  # optional - latte_int
    9

.. end of output

Radius and radius square
~~~~~~~~~~~~~~~~~~~~~~~~

The radius is the distance from the vertices to the center. All rays and lines
are ignored.

::

    sage: P1.radius()
    sqrt(1/2)
    sage: P1.radius_square()
    1/2

    sage: P6.radius()  # optional - normaliz
    3/8*sqrt(29)
    sage: P6.radius_square()  # optional - normaliz
    261/64

.. end of output

Corresponding linear program
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

If you would like to use some linear programming on your polyhedron object, use
the :code:`to_linear_program` method to obtain the corresponding linear program object.

::

    sage: P1.to_linear_program()
    Mixed Integer Program  ( maximization, 2 variables, 3 constraints )
    sage: P2.to_linear_program()
    Mixed Integer Program  ( maximization, 3 variables, 3 constraints )
    sage: P3.to_linear_program()
    Mixed Integer Program  ( maximization, 2 variables, 3 constraints )
    sage: P4.to_linear_program()
    Mixed Integer Program  ( maximization, 2 variables, 3 constraints )
    sage: P6.to_linear_program()  # optional - normaliz
    Mixed Integer Program  ( maximization, 2 variables, 4 constraints )
    sage: CP.to_linear_program()
    Mixed Integer Program  ( maximization, 5 variables, 30 constraints )

.. end of output

Triangulation
~~~~~~~~~~~~~

You can triangulate a bounded polyhedron.

::

    sage: T = CP.triangulate()
    sage: for t in T:
    ....:     print t
    (0, 1, 2, 3, 4, 5)
    (0, 1, 2, 3, 5, 6)
    (0, 1, 2, 3, 6, 7)
    (0, 1, 2, 3, 7, 8)
    (0, 1, 3, 4, 5, 6)
    (0, 1, 3, 4, 6, 7)
    (0, 1, 3, 4, 7, 8)
    (0, 1, 4, 5, 6, 7)
    (0, 1, 4, 5, 7, 8)
    (0, 1, 5, 6, 7, 8)
    (1, 2, 3, 4, 5, 6)
    (1, 2, 3, 4, 6, 7)
    (1, 2, 3, 4, 7, 8)
    (1, 2, 4, 5, 6, 7)
    (1, 2, 4, 5, 7, 8)
    (1, 2, 5, 6, 7, 8)
    (2, 3, 4, 5, 6, 7)
    (2, 3, 4, 5, 7, 8)
    (2, 3, 5, 6, 7, 8)
    (3, 4, 5, 6, 7, 8)
    sage: type(T)
    <class 'sage.geometry.triangulation.element.PointConfiguration_with_category.element_class'>

.. end of output

.. note:: 

    If one is interested in studying the triangulations of a polytope, it is
    worth considering the class :ref:`sage.geometry.triangulation.point_configuration`.

Volume
~~~~~~

The volume can be computed for full-dimensional bounded polyhedron. Setting
:code:`engine='lrs'` makes it possible to compute volumes of faces without
reducing the dimension of the ambient space.

::

    sage: P3.volume()
    0.0
    sage: CP.volume()
    1216512
    sage: Square.volume()
    0
    sage: Square.volume(engine='lrs')
    4.0
    sage: Cube.volume()
    8
    sage: Cube.volume(engine='lrs')
    8.0

.. end of output

Combinatorial objects
----------------------------

Face lattice
~~~~~~~~~~~~~

One of the most important object related to a polyhedron is its *face lattice*
that records faces ordered by inclusion.

::

    sage: FL = S.face_lattice()
    sage: BL = posets.BooleanLattice(4)
    sage: FL.is_isomorphic(BL)
    True

.. end of output

.. note ::

    If one is interested in checking the combinatorial isomorphism of two
    polyhedron objects, one should look at the `Combinatorial Isomorphism`_. 

Facet and Vertex adjacency matrices
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

In order to know when two facets intersect or two vertices are contained in a
common face, one can looks at adjacency matrices.

::

    sage: Cube.facet_adjacency_matrix()
    [0 1 1 1 0 1]
    [1 0 1 1 1 0]
    [1 1 0 0 1 1]
    [1 1 0 0 1 1]
    [0 1 1 1 0 1]
    [1 0 1 1 1 0]

    sage: Cube.vertex_adjacency_matrix()
    [0 1 1 0 1 0 0 0]
    [1 0 0 1 0 1 0 0]
    [1 0 0 1 0 0 1 0]
    [0 1 1 0 0 0 0 1]
    [1 0 0 0 0 1 1 0]
    [0 1 0 0 1 0 0 1]
    [0 0 1 0 1 0 0 1]
    [0 0 0 1 0 1 1 0]

.. end of output

Graph or 1-skeleton
~~~~~~~~~~~~~~~~~~~~

The graph of a polyhedron consists of its vertices and edges.
For unbounded polyhedron, only the bounded edges are used.
There are two ways to get it.

::

    sage: K4 = graphs.CompleteGraph(4)
    sage: S.graph().is_isomorphic(K4)
    True
    sage: S.vertex_graph().is_isomorphic(K4)
    True

    sage: P1.graph()
    Graph on 2 vertices

.. end of output


Incidence matrix
~~~~~~~~~~~~~~~~~

The entries of the incidence matrix of a polyhedron object are indexed as

 - Rows :math:`\leftrightarrow` Vertices
 - Columns :math:`\leftrightarrow` Facets

There is a 1 when the corresponding vertex belongs to the corresponding facet
and a 0 otherwise.

::

    sage: Cube.incidence_matrix()
    [0 0 0 1 1 1]
    [1 0 0 1 0 1]
    [0 1 0 1 1 0]
    [1 1 0 1 0 0]
    [0 0 1 0 1 1]
    [1 0 1 0 0 1]
    [0 1 1 0 1 0]
    [1 1 1 0 0 0]

.. end of output

Vertex directed graph
~~~~~~~~~~~~~~~~~~~~~~

Given a linear functional, sometimes also called an *objective function*, one
can give a direction to the edges in the graph of the polyhedron from the
smallest to the biggest value given by the functional (the default setup).

When two vertices have the same value, then two oriented edges are placed
between them. Checkout how :code:`G1` and :code:`G2` look like with the
:code:`plot` method.

::

    sage: G1 = Cube.vertex_digraph(vector([1,1,1]))
    sage: G1.sinks()
    [A vertex at (1, 1, 1)]
    sage: G2 = Cube.vertex_digraph(vector([1,1,0]))
    sage: G2.sinks()
    []
    sage: G2.sources()
    []

.. end of output






Bibliography
=============

.. [Bro1983] Brondsted, A., An Introduction to Convex Polytopes, volume 90
             of Graduate Texts in Mathematics. Springer-Verlag, New York, 1983. ISBN
             978-1-4612-7023-2

.. [Gru1967] Grünbaum, B., Convex polytopes, volume 221 of Graduate Texts in
             Mathematics. Springer-Verlag, New York, 2003. ISBN
             978-1-4613-0019-9

.. [Zie2007] Ziegler, G. M., Lectures on polytopes, volume 152 of Graduate
             Texts in Mathematics. Springer-Verlag, New York, 2007. 
             ISBN 978-0-387-94365-7








Other stuff
============

Surely you want to compute the polar dual:

::

    sage: P1dual = P1.polar()
    sage: P1dual
    A 2-dimensional polyhedron in QQ^2 defined as the convex hull of 4 vertices

.. end of output

Check it out\-\-\-we started with an integer\-lattice polytope and dualized
to a rational\-lattice polytope.  Let's look at that.

 


::

    sage: P1dual.plot()
    Graphics object consisting of 6 graphics primitives


.. end of output

::

    sage: P1.plot() + P1dual.plot()
    Graphics object consisting of 12 graphics primitives


.. end of output

Oh, yeah, unless the polytope is unit\-sphere\-sized, the dual will be a
very different size.  Let's rescale.


::

    sage: ((1/4)*P1).plot() + (4*P1dual).plot()
    Graphics object consisting of 12 graphics primitives

.. end of output

If you think that looks a little bit shady, you're correct.  Here is an
example that makes the issue a bit clearer.


::

    sage: P2 = Polyhedron(vertices = [[-5,0], [-1,1], [-2,0], [1,0], [-2,-1], [-3,-1], [-5,-1]])
    sage: P2
    A 2-dimensional polyhedron in ZZ^2 defined as the convex hull of 5 vertices
    sage: P2dual = P2.polar(); P2dual
    A 2-dimensional polyhedron in QQ^2 defined as the convex hull of 5 vertices
    sage: P2.plot() + P2dual.plot()
    Graphics object consisting of 14 graphics primitives

.. end of output

That is clearly not computing what we think of as the polar dual.  But look
at this...


::

    sage: P2.plot() + (-1*P2dual).plot()
    Graphics object consisting of 14 graphics primitives

.. end of output

Here is what's going on. 

If a polytope ``P`` is in `\ZZ`, then...

(1) ...the dual is inverted in some way, which is vertically for polygons.

(2) ...the dual is taken of P itself.

(3) ...if the origin is not in P, then an error is returned.

However, if a polytope is  *not*  in `\ZZ`, for example if it's in `\QQ` or
``RDF``, then...

(1') ...the dual is not inverted.

(2') ...the dual is taken of P\-translated\-so\-barycenter\-is\-at\-origin.

Keep all of this in mind as you take polar duals.



Queries to polytopes
====================

Once you've constructed some polytope, you can ask Sage questions about it.


::

    sage: P1.contains([1,0])
    True

.. end of output

::

    sage: P1.interior_contains([3,0])
    False

.. end of output

::

    sage: P3.contains([1,0,0])
    False

.. end of output

Face information can be useful.  


::

    sage: int34.f_vector()
    (1, 8, 12, 6, 1)

.. end of output

Well, geometric information might be  *more*  helpful...
Here we are told which of the vertices form each 2\-face:


::

    sage: int34.faces(2)
    (<1,3,4>, <0,1,3,5>, <0,1,2,4,6>, <2,3,4,5,7>, <2,6,7>, <0,5,6,7>)

.. end of output

Yeah, that isn't so useful as it is.  Let's figure out the vertex and
hyperplane representations of the first face in the list.


::

    sage: first2faceofint34 = P3.faces(2)[0]
    sage: first2faceofint34.ambient_Hrepresentation(); first2faceofint34.vertices()
    (An inequality (1, 0, 0) x + 0 >= 0,)
    (A vertex at (0, 0, 0), A vertex at (0, 0, 1/2), A vertex at (0, 1/2, 0))

.. end of output

If you want more... :ref:`sage.geometry.polyhedron.base` is the first place you want to go.

