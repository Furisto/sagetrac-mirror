.. -*- coding: utf-8 -*-

.. linkall

.. _polytutorial:

==================================================
An introduction to polyhedral computations in Sage
==================================================

.. MODULEAUTHOR:: sarah-marie belcastro <smbelcas@toroidalsnark.net>, Jean-Philippe Labbé <labbe@math.fu-berlin.de>

If you already know some convex geometry  *à la*  Grünbaum or
Brøndsted, then you may have itched to get your hands dirty with some
polytope calculations.  

.. contents:: Lectures Menu
    :depth: 2

Lecture 0: Basic definitions and constructions
==============================================

A real :math:`(k\times d)`-matrix :math:`A` and a real vector :math:`b`
in :math:`\mathbb{R}^d` define a (convex) **polyhedron** :math:`P` as the set of solutions 
of the system of linear inequalities:

.. MATH::
    A\cdot x + b \geq 0.

Each row of :math:`A` defines a closed half-space of :math:`\mathbb{R}^d`.
Hence a polyhedron is the intersection of finitely many closed half-spaces in
:math:`\mathbb{R}^d`. The matrix :math:`A` may contain equal rows, which may lead to a
set of *equalities* satisfied by the polyhedron. If there are no redundant rows 
in the above definition, this definition is refered to as the 
:math:`\mathbf{H}` **-representation** of a polyhedron.

The maximal affine subspace :math:`L` contained in a polyhedron is the
**lineality** space. Fixing a point :math:`o` of the lineality space to act 
as the *origin*, one can write every point :math:`p` inside a polyhedron as a combination

.. MATH::
    p = \ell +\sum_{i=1}^{n}\lambda_iv_i+\sum_{i=1}^{m}\mu_ir_i,

where :math:`\ell\in L` (using :math:`o` as the origin), :math:`\sum_{i=1}^n\lambda_i=1`, 
:math:`\mu_i\geq0`, and :math:`r_i\neq0` for all :math:`0\leq i\leq m` and the 
set of :math:`r_i` 's are positively independant (the origin is not in their positive span). 
There are many equivalent ways write the above, so one asks :math:`n` and :math:`m` 
to be minimal with that property.

The points :math:`v_i` 's are called the *vertices* of :math:`P` and the points
:math:`r_i` 's are called the *rays* of :math:`P`.
This way to represent a polyhedron is refered to as the
:math:`\mathbf{V}` **-representation** of a polyhedron. The second sum represents the *convex
hull* of the vertices :math:`v_i` 's and the second sum represents a *pointed
polyhedral cone* generated by finitely many rays.

When the lineality space and the rays are reduced to a point (i.e. no rays and
no lines) the object is often refered to as a **polytope**.

.. note :: As mentioned in the documentation of the constructor when typing :code:`Polyhedron?`, 

    *You may either define it with vertex/ray/line or
    inequalities/equations data, but not both. Redundant data will
    automatically be removed (unless "minimize=False"), and the
    complementary representation will be computed.*

    You can find here is the documentation for the constructor function of :ref:`sage.geometry.polyhedron.constructor`.

:math:`V`-representation
------------------------

First, let's define a polyhedron object as the convex hull of a set of points
and some rays.

::

    sage: P1 = Polyhedron(vertices = [[1, 0], [0, 1]], rays = [[1, 1]])
    sage: P1
    A 2-dimensional polyhedron in ZZ^2 defined as the convex hull of 2 vertices and 1 ray

.. end of output

The string representation already gives a lot of information:

 - the dimension of the polyhedron (the smallest affine space containing it)
 - the dimension of the space in which it is defined
 - the base ring (:math:`\mathbb{Z}^2`) over which the polyhedron lives (this specifies the parent class, see :ref:`sage.geometry.polyhedron.parent`)
 - the number of vertices
 - the number of rays

Of course, you want to know what this object looks like:

::

    sage: P1.plot()
    Launched png viewer for Graphics object consisting of 5 graphics primitives

.. end of output

We can also add a lineality space.

::

    sage: P2 = Polyhedron(vertices = [[1/2, 0, 0], [0, 1/2, 0]],
    ....:                 rays = [[1, 1, 0]],
    ....:                 lines = [[0, 0, 1]])
    sage: P2
    A 3-dimensional polyhedron in QQ^3 defined as the convex hull of 2 vertices, 1 ray, 1 line
    sage: P2.plot()
    Launched jmol viewer for Graphics3d Object

.. end of output

Notice that the base ring change because of the value :math:`\frac{1}{2}`.
Indeed, Sage finds an appropriate ring to define the object.

::

    sage: P1.parent()
    Polyhedra in ZZ^2
    sage: P2.parent()
    Polyhedra in QQ^3

.. end of output

The chosen ring depends on the input format.

::

    sage: P3 = Polyhedron(vertices = [[0.5, 0], [0, 0.5]])
    sage: P3
    A 1-dimensional polyhedron in RDF^2 defined as the convex hull of 2 vertices
    sage: P3.parent()
    Polyhedra in RDF^2

.. end of output

.. WARNING::

    The base ring :code:`RDF` should be used with care. As it is not an exact
    ring certain computations may break, for example when dealing with
    non-simplicial polyhedron.


The following example demonstrates the limitations of :code:`RDF`.

::

    sage: P = polytopes.dodecahedron()
    sage: P
    A 3-dimensional polyhedron in (Number Field in sqrt5 with defining
    polynomial x^2 - 5)^3 defined as the convex hull of 20 vertices
    sage: P_RDF = Polyhedron(vertices = [n(v.vector(),digits=6) for v in
    P.vertices()], base_ring=RDF)
    sage: P_RDF
    A 3-dimensional polyhedron in RDF^3 defined as the convex hull of 17
    vertices

.. end of output

It is also possible to define polyhedron over algebraic numbers.

::

    sage: sqrt_2 = AA(2)^(1/2)
    sage: cbrt_2 = AA(2)^(1/3)
    sage: timeit('Polyhedron(vertices = [[sqrt_2, 0], [0, cbrt_2]])')
    5 loops, best of 3: 43.2 ms per loop

    sage: sqrt_2s = sqrt(2)
    sage: cbrt_2s = 2^(1/3)
    sage: timeit('Polyhedron(vertices = [[sqrt_2s, 0], [0, cbrt_2s]])')
    5 loops, best of 3: 198 ms per loop

    sage: P4 = Polyhedron(vertices = [[sqrt_2, 0], [0, cbrt_2]]); P4
    A 1-dimensional polyhedron in AA^2 defined as the convex hull of 2 vertices
    sage: P5 = Polyhedron(vertices = [[sqrt_2s, 0], [0, cbrt_2s]]); P5
    A 1-dimensional polyhedron in (Symbolic Ring)^2 defined as the convex hull
    of 2 vertices

.. end of output

.. WARNING::

    As the above :code:`timeit` shows, it is considerably slower thus
    strongly discouraged to use the :code:`Symbolic Ring`.

The **better option** is to use a :code:`NumberField`:

::

    sage: J = NumberField(x^2 - 2,'s')
    sage: s = J.gens()[0]
    sage: timeit('Polyhedron(vertices = [[s, 0], [0, s]])')
    125 loops, best of 3: 5.18 ms per loop

.. end of output

`H`-representation
------------------

If a polyhedron object was constructed via a :math:`V`-representation, Sage can provide 
the :math:`H`-representation of the object. 

::

    sage: for h in P1.Hrepresentation():
    ....:     print h
    An inequality (1, 1) x - 1 >= 0
    An inequality (1, -1) x + 1 >= 0
    An inequality (-1, 1) x + 1 >= 0

.. end of output

Each line gives a row of the matrix :math:`A` and an entry of the vector :math:`b`.
The variable :math:`x` is a vector in the ambient space where :code:`P1` is
defined. The :math:`H`-representation may contain equations:

::

    sage: P3.Hrepresentation()
    (An equation (1.0, 1.0) x - 0.5 == 0,
     An inequality (-2.0, 0.0) x + 1.0 >= 0,
     An inequality (1.0, 0.0) x + 0.0 >= 0)

.. end of output

The construction of a polyhedron object via its :math:`H`-representation,
requires a precise format. Each inequality :math:`(a_{i1}, \dots, a_{id})\cdot
x + b_i \geq 0` must be written as :code:`[b_i,a_i1, ..., a_id]`. 

::

    sage: P3_H = Polyhedron(ieqs = [[1.0, -2, 0], [0, 1, 0]], eqns = [[-0.5, 1, 1]])
    sage: P3 == P3_H
    True
    sage: P3_H.Vrepresentation()
    (A vertex at (0.0, 0.5), A vertex at (0.5, 0.0))

.. end of output

It is worth using the parameter :code:`eqns` to shorten the construction of the
object. In the following example, the first four rows are the negative of the
second group of four rows.

::

    sage: H = [[0, 0, 0, 0, 0, 0, 0, 0, 1],
    ....:  [0, 0, 0, 0, 0, 0, 1, 0, 0],
    ....:  [-2, 1, 1, 1, 1, 1, 0, 0, 0],
    ....:  [0, 0, 0, 0, 0, 0, 0, 1, 0],
    ....:  [0, 0, 0, 0, 0, 0, 0, 0, -1],
    ....:  [0, 0, 0, 0, 0, 0, -1, 0, 0],
    ....:  [2, -1, -1, -1, -1, -1, 0, 0, 0],
    ....:  [0, 0, 0, 0, 0, 0, 0, -1, 0],
    ....:  [2, -1, -1, -1, -1, 0, 0, 0, 0],
    ....:  [0, 0, 0, 0, 1, 0, 0, 0, 0],
    ....:  [0, 0, 0, 1, 0, 0, 0, 0, 0],
    ....:  [0, 0, 1, 0, 0, 0, 0, 0, 0],
    ....:  [-1, 1, 1, 1, 1, 0, 0, 0, 0],
    ....:  [1, 0, 0, -1, 0, 0, 0, 0, 0],
    ....:  [0, 1, 0, 0, 0, 0, 0, 0, 0],
    ....:  [1, 0, 0, 0, -1, 0, 0, 0, 0],
    ....:  [1, 0, -1, 0, 0, 0, 0, 0, 0],
    ....:  [1, -1, 0, 0, 0, 0, 0, 0, 0]]
    sage: timeit('Polyhedron(ieqs = H)')
    125 loops, best of 3: 5.99 ms per loop
    sage: timeit('Polyhedron(ieqs = H[8:], eqns = H[:4])')
    125 loops, best of 3: 4.78 ms per loop
    sage: Polyhedron(ieqs = H) == Polyhedron(ieqs = H[8:], eqns = H[:4])
    True

.. end of output

Of course, this is a toy example, but it is generally worth to preprocess 
the data before defining the polyhedron if possible.


Lecture 1: Representation objects
===================================

Many objects are related to the :math:`H`- and :math:`V`-representations. Sage 
has classes implemented for them.

`H`-representation
------------------

You can store the :math:`H`-representation in a variable and use the
inequalities and equalities as objects. 

::

    sage: P3_QQ = Polyhedron(vertices = [[0.5, 0], [0, 0.5]], base_ring=QQ)
    sage: HRep = P3_QQ.Hrepresentation()
    sage: H1 = HRep[0]; H1
    An equation (2, 2) x - 1 == 0
    sage: H2 = HRep[1]; H2
    An inequality (0, -2) x + 1 >= 0
    sage: H1.<tab>
    sage: H1.A()
    (2, 2)
    sage: H1.b()
    -1
    sage: H1.is_equation()
    True
    sage: H1.is_inequality()
    False
    sage: H1.contains(vector([0,0]))
    False
    sage: H2.contains(vector([0,0]))
    True
    sage: H1.is_incident(H2)
    True

.. end of output


`V`-representation
------------------

Similarly, you can access to vertices, rays and lines of the polyhedron.

::

    sage: VRep = P2.Vrepresentation(); VRep
    (A line in the direction (0, 0, 1),
     A vertex at (0, 1/2, 0),
     A vertex at (1/2, 0, 0),
     A ray in the direction (1, 1, 0))
    sage: L = VRep[0]; L
    A line in the direction (0, 0, 1)
    sage: V = VRep[1]; V
    A vertex at (0, 1/2, 0)
    sage: R = VRep[3]; R
    A ray in the direction (1, 1, 0)
    sage: L.is_line()
    True
    sage: L.is_incident(V)
    True
    sage: R.is_incident(L)
    False
    sage: L.vector()
    (0, 0, 1)
    sage: V.vector()
    (0, 1/2, 0)

.. end of output

Lecture 2: Backends for polyhedral computations
===============================================

To deal with polyhedron objects, Sage currently has four backends available.
These backends offer various functionalities and have their own specific strengths and limitations.

 - :ref:`sage.geometry.polyhedron.backend_cdd`

   - `The cdd and cddplus homepage <https://www.inf.ethz.ch/personal/fukudak/cdd_home/>`_

 - :ref:`sage.geometry.polyhedron.backend_ppl`

   - `The Parma Polyhedra Library homepage <http://bugseng.com/products/ppl/>`_

 - :ref:`sage.geometry.polyhedron.backend_field`

   - This is a :code:`python` backend that provides an implementation of
     polyhedron over irrational coordinates.
 
 - :ref:`sage.geometry.polyhedron.backend_normaliz`, (requires the optional package :code:`pynormaliz`)

   - `Normaliz Homepage <https://www.normaliz.uni-osnabrueck.de/>`_


The default backend is :code:`ppl`. Whenever one needs **speed** it is good to try out 
the different backends. The backend :code:`field` is **not** specifically designed
for dealing with extremal computations.

The :code:`cdd` backend
-----------------------

In order to use a specific backend, we specify the :code:`backend` parameter.

::

    sage: P1_cdd = Polyhedron(vertices = [[1, 0], [0, 1]], rays = [[1, 1]], backend='cdd')
    sage: P1_cdd
    A 2-dimensional polyhedron in QQ^2 defined as the convex hull of 2 vertices and 1 ray

.. end of output

A priori, it seems that nothing changed, but ...

::

    sage: P1_cdd.parent()
    Polyhedra in QQ^2

.. end of output

The polyhedron :code:`P1_cdd` is now considered as a rational polyhedron by the
backend :code:`cdd`. We can also check the backend and the parent using
:code:`type`:

::

    sage: type(P1_cdd)
    <class 'sage.geometry.polyhedron.backend_cdd.Polyhedra_QQ_cdd_with_category.element_class'>
    sage: type(P1)
    <class 'sage.geometry.polyhedron.backend_ppl.Polyhedra_ZZ_ppl_with_category.element_class'>

.. end of output

We *clearly* (!) see

  - the backend used (ex: :code:`backend_cdd`)
  - followed by a dot ''.''
  - the parent (ex: :code:`Polyhedra_QQ`) followed again by the backend,

and you can safely ignore the rest for the purpose of this tutorial.

The :code:`cdd` backend accepts also entries in :code:`RDF`:

::

    sage: P3_cdd = Polyhedron(vertices = [[0.5, 0], [0, 0.5]], backend='cdd')
    sage: P3_cdd
    A 1-dimensional polyhedron in RDF^2 defined as the convex hull of 2 vertices

.. end of output

but not algebraic or symbolic values:

::

    sage: P4_cdd = Polyhedron(vertices = [[sqrt_2, 0], [0, cbrt_2]], backend='cdd')
    Traceback (most recent call last):
    ...
    ValueError: No such backend (=cdd) implemented for given basering (=Algebraic Real Field).

    sage: P5_cdd = Polyhedron(vertices = [[sqrt_2s, 0], [0, cbrt_2s]], backend='cdd')
    Traceback (most recent call last):
    ...
    ValueError: No such backend (=cdd) implemented for given basering (=Symbolic Ring).

.. end of output

The :code:`ppl` backend
-----------------------

The :code:`ppl` is the default backend for polyhedron objects.

::

    sage: type(P1)
    <class 'sage.geometry.polyhedron.backend_ppl.Polyhedra_ZZ_ppl_with_category.element_class'>
    sage: type(P2)
    <class 'sage.geometry.polyhedron.backend_ppl.Polyhedra_QQ_ppl_with_category.element_class'>
    sage: type(P3)  # has entries like 0.5
    <class 'sage.geometry.polyhedron.backend_cdd.Polyhedra_RDF_cdd_with_category.element_class'>

.. end of output

As you see, it does not accepts values in :code:`RDF` and the polyhedron constructor 
used the :code:`cdd` backend.


The :code:`field` backend
-------------------------

As it turns out, the rational numbers do not suffice to represent all combinatorial 
types of polytopes. For example, Perles constructed a `8`-dimensional polytope with
`12` vertices which does not have a realization with rational coordinates.
Furthermore, if one wants a realization to have
specific geometric property, such as symmetry, one also sometimes need
irrational coordinates.

The backend :code:`field` provides the necessary tools to deal with such
examples.

::

    sage: D = polytopes.dodecahedron()
    sage: D
    A 3-dimensional polyhedron in (Number Field in sqrt5 with defining polynomial x^2 - 5)^3 defined as the convex hull of 20 vertices
    sage: type(D)
    <class 'sage.geometry.polyhedron.backend_field.Polyhedra_field_with_category.element_class'>

.. end of output

Any time that the coordinates should be in an extension of the rational, the
backend :code:`field` is called.

::

    sage: P4.parent()
    Polyhedra in AA^2
    sage: P5.parent()
    Polyhedra in (Symbolic Ring)^2
    sage: type(P4)
    <class 'sage.geometry.polyhedron.backend_field.Polyhedra_field_with_category.element_class'>
    sage: type(P5)
    <class 'sage.geometry.polyhedron.backend_field.Polyhedra_field_with_category.element_class'>

.. end of output

The :code:`normaliz` backend
----------------------------

The fourth backend is :code:`normaliz` and is an optional Sage package.

::

    sage: P1_normaliz = Polyhedron(vertices = [[1, 0], [0, 1]], rays = [[1, 1]], backend='normaliz')  # optional - pynormaliz
    sage: type(P1_normaliz)                                                                           # optional - pynormaliz
    <class 'sage.geometry.polyhedron.backend_normaliz.Polyhedra_ZZ_normaliz_with_category.element_class'>
    sage: P2_normaliz = Polyhedron(vertices = [[1/2, 0, 0], [0, 1/2, 0]],                             # optional - pynormaliz
    ....:                 rays = [[1, 1, 0]],
    ....:                 lines = [[0, 0, 1]], backend='normaliz')
    sage: type(P2_normaliz)                                                                           # optional - pynormaliz
    <class 'sage.geometry.polyhedron.backend_normaliz.Polyhedra_QQ_normaliz_with_category.element_class'>

.. end of output

This backend does not work with :code:`RDF`, or algebraic numbers or the :code:`Symbolic Ring`:

::

    sage: P3_normaliz = Polyhedron(vertices = [[0.5, 0], [0, 0.5]], backend='normaliz')             # optional - pynormaliz
    Traceback (most recent call last):
    ...
    ValueError: No such backend (=normaliz) implemented for given basering (=Real Double Field).

    sage: P4_normaliz = Polyhedron(vertices = [[sqrt_2, 0], [0, cbrt_2]], backend='normaliz')       # optional - pynormaliz
    Traceback (most recent call last):
    ... 
    ValueError: No such backend (=normaliz) implemented for given basering (=Algebraic Real Field).

    sage: P5_normaliz = Polyhedron(vertices = [[sqrt_2s, 0], [0, cbrt_2s]], backend='normaliz')     # optional - pynormaliz
    Traceback (most recent call last):
    ...
    ValueError: No such backend (=normaliz) implemented for given basering (=Symbolic Ring).

.. end of output

The backend :code:`normaliz` provides other methods such as :code:`integral_hull`:

::

    sage: P6 = Polyhedron(vertices = [[0, 0], [3/2, 0], [3/2, 3/2], [0, 3]], backend='normaliz')  # optional - pynormaliz
    sage: IH = P6.integral_hull(); IH                                                             # optional - pynormaliz
    A 2-dimensional polyhedron in QQ^2 defined as the convex hull of 4 vertices
    sage: P6.plot(color='blue')+IH.plot(color='red')                                              # optional - pynormaliz
    Launched png viewer for Graphics object consisting of 12 graphics primitives

.. end of output

Lecture 3: A library of polytopes
==================================

There are a lot of polytopes that are readily available in the library, see
:ref:`sage.geometry.polyhedron.library`. Have a look at them to see if your
polytope is already defined!

::

    sage: A = polytopes.buckyball(); A  # long time up to 20sec
    A 3-dimensional polyhedron in (Number Field in sqrt5 with defining polynomial x^2 - 5)^3 defined as the convex hull of 60 vertices
    sage: B = polytopes.cross_polytope(4); B
    A 4-dimensional polyhedron in ZZ^4 defined as the convex hull of 8 vertices
    sage: C = polytopes.cyclic_polytope(3,10); C
    A 3-dimensional polyhedron in QQ^3 defined as the convex hull of 10 vertices
    sage: E = polytopes.snub_cube(); E
    A 3-dimensional polyhedron in RDF^3 defined as the convex hull of 24 vertices
    sage: polytopes.<tab>  # to view all the possible polytopes

.. end of output


Lecture 4: To every polyhedron, the proper parent class
=======================================================

In other to **know all the methods that a polyhedron object has** one has to look into its :code:`base class`:

 - :ref:`sage.geometry.polyhedron.base` : This is the generic class for Polyhedron related objects.
 - :ref:`sage.geometry.polyhedron.base_ZZ`
 - :ref:`sage.geometry.polyhedron.base_QQ`
 - :ref:`sage.geometry.polyhedron.base_RDF`

Don't be surprised if the classes look empty! The classes mainly contain private
methods that implement some comparison methods: to verify equality and inequality 
of numbers in the base ring and other internal functionalities.



Lecture 5: Getting new polyhedra from old ones
===============================================

It is possible to apply various constructions once one has a polyhedron object.
Here is a - not necessarily complete - list of operations.

Minkowski sums
--------------

It is possible to do Minkowski sums of polyhedron, using two syntaxes.

::

    sage: P1 + P3
    A 2-dimensional polyhedron in RDF^2 defined as the convex hull of 2 vertices and 1 ray

    sage: P1.Minkowski_sum(P3)
    A 2-dimensional polyhedron in RDF^2 defined as the convex hull of 2 vertices and 1 ray

.. end of output

Minkowski differences
---------------------

After adding, one would like to substract:

::

    sage: Cube = polytopes.cube()
    sage: Square = Polyhedron(vertices = [[1, -1, -1], [1, -1, 1], [1, 1, -1], [1, 1, 1]])
    
    sage: Cube - Square
    A 1-dimensional polyhedron in ZZ^3 defined as the convex hull of 2 vertices
    sage: Square - Cube
    A 0-dimensional polyhedron in ZZ^3 defined as the convex hull of 1 vertex
    
    sage: Cube.Minkowski_difference(Square)
    A 1-dimensional polyhedron in ZZ^3 defined as the convex hull of 2 vertices
    sage: Square.Minkowski_difference(Cube)
    A 0-dimensional polyhedron in ZZ^3 defined as the convex hull of 1 vertex

.. end of output

Product
-------

It is also possible to multiply polyhedron:

::

    sage: P1 * P3
    A 3-dimensional polyhedron in RDF^4 defined as the convex hull of 4 vertices and 1 ray
    sage: P1.product(P3)
    A 3-dimensional polyhedron in RDF^4 defined as the convex hull of 4 vertices and 1 ray

.. end of output

Intersection
------------

Of course, it is possible to intersect two polyhedron objects:

::

    sage: P1.intersection(P7)
    A 2-dimensional polyhedron in ZZ^2 defined as the convex hull of 4 vertices
    sage: P1 & P7
    A 2-dimensional polyhedron in ZZ^2 defined as the convex hull of 4 vertices

.. end of output

Taking a face
-------------

It is possible to obtain each face of a polyhedron.

::

    sage: for f in P1.faces(1):
    ....:     print f.ambient_Vrepresentation()
    (A vertex at (0, 1), A ray in the direction (1, 1))
    (A vertex at (0, 1), A vertex at (1, 0))
    (A vertex at (1, 0), A ray in the direction (1, 1))

.. end of output

Faces remember the polyhedron it comes from and can also become a polyhedron
object on its own.

::

    sage: f = P1.faces(1)[0]
    sage: f.polyhedron() is P1
    True

    sage: f.as_polyhedron()
    A 1-dimensional polyhedron in ZZ^2 defined as the convex hull of 1 vertex and 1 ray

.. end of output

Barycentric subdivision
-----------------------

What is the barycentric subdivision of the simplex?

::

    sage: S = polytopes.simplex(3); S
    A 3-dimensional polyhedron in ZZ^4 defined as the convex hull of 4 vertices
    sage: BS = S.barycentric_subdivision(); BS
    A 3-dimensional polyhedron in QQ^4 defined as the convex hull of 14 vertices

.. end of output

Hint: it is the polar dual of a polytope in the library.

Bipyramid
---------

The bipyramid is similar to the suspension in topology. It increases the
dimension of the polytope by 1.

::

    sage: Cube.bipyramid()
    A 4-dimensional polyhedron in ZZ^4 defined as the convex hull of 10
    vertices

.. end of output

Dilation
--------

It is possible to dilate a polyhedron by an arbitrary scalar.

::

    sage: D_P1 = P1.dilation(AA(sqrt(2))); D_P1.vertices()
    (A vertex at (0, 1.414213562373095?), A vertex at (1.414213562373095?, 0))

    sage: P8 = Polyhedron(vertices = [[0, 0], [1, 0], [0, 1]])
    sage: 2*P8
    A 2-dimensional polyhedron in ZZ^2 defined as the convex hull of 3 vertices
    sage: P8.dilation(2) == 2*P8
    True

.. end of output

Face-truncation
---------------

It is possible to truncate a specific face of a polyhedron. One can also change
the angle of the truncation and how deep the cut is done. 

::

    sage: my_face = P1.faces(0)[0]  # This is a vertex-face
    sage: Trunc1_P1 = P1.face_truncation(P1.faces(0)[0])
    sage: Trunc1_P1.plot()
    Launched png viewer for Graphics object consisting of 6 graphics primitives
    sage: Trunc_P2 = P1.face_truncation(P1.faces(0)[0],linear_coefficients=(1, 1/2), cut_frac=3/4)
    sage: Trunc_P2.plot()
    Launched png viewer for Graphics object consisting of 6 graphics primitives

.. end of output

Lattice polytope
----------------

This method returns an encompassing lattice polytope.

::

    sage: LP = P3_QQ.lattice_polytope(envelope=True)  # envelope=True for rational polytopes
    sage: LP.vertices()
    M(0, 0),
    M(0, 1),
    M(1, 0)
    in 2-d lattice M

.. end of output

Polar
-----

The polar polytope is only defined for compact, or bounded, polyhedron.

::

    sage: P3.polar()
    A 2-dimensional polyhedron in RDF^2 defined as the convex hull of 2 vertices and 1 line

    sage: P2.polar()
    Traceback (most recent call last):
    ...
    AssertionError: Not a polytope.

.. end of output

Prism
-----

The prism construction is the same as taking the Minkowski sum of the
polyhedorn with a segment (a 1-dimensional polytope) in an orthogonal space.

::

    sage: P1.prism()
    A 3-dimensional polyhedron in ZZ^3 defined as the convex hull of 4 vertices and 1 ray

.. end of output

Pyramid
-------

Similar, the pyramid is a join of a vertex with the polyhedron.

::

    sage: (P1 & P7).pyramid()
    A 3-dimensional polyhedron in ZZ^3 defined as the convex hull of 5 vertices

.. end of output

Translation
-----------

One can translate a polyhedron by a vector.

::

    sage: (P1 & P7).vertices()
    (A vertex at (2, 3),
     A vertex at (3, 2),
     A vertex at (2, 1),
     A vertex at (1, 2))
    sage: (P1 & P7).translation([-1, 0]).vertices()
    (A vertex at (0, 2),
     A vertex at (1, 1),
     A vertex at (1, 3),
     A vertex at (2, 2))

.. end of output

Lecture 6: Obtain related combinatorial and geometric objects
==============================================================

Once one constructed the polyhedron object, one would like to know some
combinatorial and geometric information about this object.


Enumerative properties
----------------------

Ambient dimension
~~~~~~~~~~~~~~~~~

Dimension
~~~~~~~~~

:math:`f`-vector
~~~~~~~~~~~~~~~~~




Geometric objects and properties
--------------------------------

Combinatorial objects
----------------------------

Visualizations
----------------


Normal and Face fans
--------------------

Other stuff
============

Surely you want to compute the polar dual:

::

    sage: P1dual = P1.polar()
    sage: P1dual
    A 2-dimensional polyhedron in QQ^2 defined as the convex hull of 4 vertices

.. end of output

Check it out\-\-\-we started with an integer\-lattice polytope and dualized
to a rational\-lattice polytope.  Let's look at that.

 


::

    sage: P1dual.plot()
    Graphics object consisting of 6 graphics primitives


.. end of output

::

    sage: P1.plot() + P1dual.plot()
    Graphics object consisting of 12 graphics primitives


.. end of output

Oh, yeah, unless the polytope is unit\-sphere\-sized, the dual will be a
very different size.  Let's rescale.


::

    sage: ((1/4)*P1).plot() + (4*P1dual).plot()
    Graphics object consisting of 12 graphics primitives

.. end of output

If you think that looks a little bit shady, you're correct.  Here is an
example that makes the issue a bit clearer.


::

    sage: P2 = Polyhedron(vertices = [[-5,0], [-1,1], [-2,0], [1,0], [-2,-1], [-3,-1], [-5,-1]])
    sage: P2
    A 2-dimensional polyhedron in ZZ^2 defined as the convex hull of 5 vertices
    sage: P2dual = P2.polar(); P2dual
    A 2-dimensional polyhedron in QQ^2 defined as the convex hull of 5 vertices
    sage: P2.plot() + P2dual.plot()
    Graphics object consisting of 14 graphics primitives

.. end of output

That is clearly not computing what we think of as the polar dual.  But look
at this...


::

    sage: P2.plot() + (-1*P2dual).plot()
    Graphics object consisting of 14 graphics primitives

.. end of output

Here is what's going on. 

If a polytope ``P`` is in `\ZZ`, then...

(1) ...the dual is inverted in some way, which is vertically for polygons.

(2) ...the dual is taken of P itself.

(3) ...if the origin is not in P, then an error is returned.

However, if a polytope is  *not*  in `\ZZ`, for example if it's in `\QQ` or
``RDF``, then...

(1') ...the dual is not inverted.

(2') ...the dual is taken of P\-translated\-so\-barycenter\-is\-at\-origin.

Keep all of this in mind as you take polar duals.

 

Polytope Constructions
======================

Minkowski sums!  Now with two syntaxes!


::

    sage: P1+P2
    A 2-dimensional polyhedron in ZZ^2 defined as the convex hull of 8 vertices

.. end of output

::

    sage: P1.Minkowski_sum(P2)
    A 2-dimensional polyhedron in ZZ^2 defined as the convex hull of 8 vertices

.. end of output

Okay, fine.  We should have some 3\-dimensional examples, at least.
(Note that in order to display polytopes effectively you'll need
visualization software such as Javaview and Jmol installed.)


::

    sage: P3 = Polyhedron(vertices=[(0,0,0), (0,0,1/2), (0,1/2,0), (1/2,0,0), (3/4,1/5,3/2)]); P3
    A 3-dimensional polyhedron in QQ^3 defined as the convex hull of 5 vertices
    sage: P4 = Polyhedron(vertices=[(-1,1,0),(1,1,0),(-1,0,1), (1,0,1),(0,-1,1),(0,1,1)]); P4
    A 3-dimensional polyhedron in ZZ^3 defined as the convex hull of 6 vertices
    sage: P3.plot() + P4.plot()
    Graphics3d Object

.. end of output

::

    sage: (P3+P4).plot()
    Graphics3d Object

.. end of output

We can also find the intersection of two polytopes... and this too has two
syntaxes!


::

    sage: int12 = P1.intersection(P2*.5); int12.plot()
    Graphics object consisting of 7 graphics primitives

.. end of output

::

    sage: int34 = P3 & P4; int34.plot()
    Graphics3d Object

.. end of output

Should one wish to translate, one can.


::

    sage: transP2 = P2.translation([2,1])
    sage: P2.plot() + transP2.plot()
    Graphics object consisting of 14 graphics primitives

.. end of output

Then of course we can take prisms, pyramids, and bipyramids of polytopes...


::

    sage: P2.prism().plot()
    Graphics3d Object

.. end of output

::

    sage: P1.pyramid().plot()
    Graphics3d Object

.. end of output

::

    sage: P2dual.bipyramid().plot()
    Graphics3d Object

.. end of output

Okay, fine.  Yes, Sage has some kinds of polytopes built in.
If you type ``polytopes.`` and then press ``TAB`` after the period, you'll get a
list of pre\-built polytopes.


::

    sage: P5 = polytopes.hypercube(5)
    sage: P6 = polytopes.cross_polytope(3)
    sage: P7 = polytopes.simplex(7)


.. end of output

Let's look at a 4\-dimensional polytope.


::

    sage: P8 = polytopes.hypercube(4)
    sage: P8.plot()
    Graphics3d Object

.. end of output

We can see it from a different perspective:


::

    sage: P8.schlegel_projection([2,5,11,17]).plot()
    Graphics3d Object

.. end of output

Queries to polytopes
====================

Once you've constructed some polytope, you can ask Sage questions about it.


::

    sage: P1.contains([1,0])
    True

.. end of output

::

    sage: P1.interior_contains([3,0])
    False

.. end of output

::

    sage: P3.contains([1,0,0])
    False

.. end of output

Face information can be useful.  


::

    sage: int34.f_vector()
    (1, 8, 12, 6, 1)

.. end of output

Well, geometric information might be  *more*  helpful...
Here we are told which of the vertices form each 2\-face:


::

    sage: int34.faces(2)
    (<1,3,4>, <0,1,3,5>, <0,1,2,4,6>, <2,3,4,5,7>, <2,6,7>, <0,5,6,7>)

.. end of output

Yeah, that isn't so useful as it is.  Let's figure out the vertex and
hyperplane representations of the first face in the list.


::

    sage: first2faceofint34 = P3.faces(2)[0]
    sage: first2faceofint34.ambient_Hrepresentation(); first2faceofint34.vertices()
    (An inequality (1, 0, 0) x + 0 >= 0,)
    (A vertex at (0, 0, 0), A vertex at (0, 0, 1/2), A vertex at (0, 1/2, 0))

.. end of output

If you want more... :ref:`sage.geometry.polyhedron.base` is the first place you want to go.

