.. -*- coding: utf-8 -*-

.. linkall

.. _polytutorial:

An introduction to polyhedral computations in Sage
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. MODULEAUTHOR:: sarah-marie belcastro <smbelcas@toroidalsnark.net>, Jean-Philippe Labbé <labbe@math.fu-berlin.de>

If you already know some convex geometry  *à la*  Grünbaum or
Brøndsted, then you may have itched to get your hands dirty with some
polytope calculations.  

Basics
""""""

A real :math:`(k\times d)`-matrix :math:`A` and a real vector :math:`\vec{b}`
in :math:`R^d` define a (convex) **polyhedron** :math:`P` as the set of solutions 
of the system of linear inequalities:

.. MATH::
    A\cdot\vec{x} + \vec{b} \geq 0.

Each row of :math:`A` defines a closed half-space of :math:`R^d`.
Hence a polyhedron is the intersection of finitely many closed half-spaces in
:math:`R^d`. The matrix :math:`A` may contain equal rows, which may lead to a
set of *equalities* satisfied by the polyhedron. If there are no redundant rows 
in the above definition, this definition is refered to as the 
:math:`\mathbf{H}` **-representation** of a polyhedron.

The maximal affine subspace :math:`L` contained in a polyhedron is the
**lineality** space. Fixing a point :math:`o` of the lineality space to act 
as the *origin*, one can write every point :math:`p` inside a polyhedron as a combination

.. MATH::
    p = \ell +\sum_{i=1}^{n}\lambda_iv_i+\sum_{i=1}^{m}\mu_ir_i,

where :math:`\ell\in L` (using :math:`o` as the origin), :math:`\sum_{i=1}^n\lambda_i=1`, 
:math:`\mu_i\geq0`, and :math:`r_i\neq0` for all :math:`0\leq i\leq m` and the 
set of :math:`r_i`'s are positively independant (the origin is not in their positive span). 
There are many equivalent ways write the above, so one asks :math:`n` and :math:`m` 
to be minimal with that property.

The points :math:`v_i`'s are called the *vertices* of :math:`P` and the points
:math:`r_i`'s are called the *rays* of :math:`P`.
This way to represent a polyhedron is refered to as the
:math:`\mathbf{V}` **-representation** of a polyhedron. The second sum represents the *convex
hull* of the vertices :math:`v_i`'s and the second sum represents a *pointed
polyhedral cone* generated by finitely many rays.

:math:`V`-representation
~~~~~~~~~~~~~~~~~~~~~~~~

First, let's define a polyhedron object as the convex hull of a set of points
and some rays.

::

    sage: P1 = Polyhedron(vertices = [[1, 0], [0, 1]], rays = [[1, 1]])
    sage: P1
    A 2-dimensional polyhedron in ZZ^2 defined as the convex hull of 2 vertices and 1 ray

.. end of output

The string representation already gives a lot of information:

 - the dimension of the polyhedron (the smallest affine space containing it)
 - the dimension of the space in which it is defined
 - the base ring (:math:`\mathbb{Z}^2`) over which the polyhedron lives
 - the number of vertices
 - the number of rays

Of course, you want to know what this object looks like:

::

    sage: P1.plot()
    Launched png viewer for Graphics object consisting of 5 graphics primitives

.. end of output

We can also add a lineality space.

::

    sage: P2 = Polyhedron(vertices = [[1/2, 0, 0], [0, 1/2, 0]],
    ....:                 rays = [[1, 1, 0]],
    ....:                 lines = [[0, 0, 1]])
    sage: P2
    A 3-dimensional polyhedron in QQ^3 defined as the convex hull of 2 vertices, 1 ray, 1 line

.. end of output

Notice that the base ring change because of the value :math:`\frac{1}{2}`.
Indeed, Sage finds an appropriate ring to define the object.

::

    sage: P1.parent()
    Polyhedra in ZZ^2
    sage: P2.parent()
    Polyhedra in QQ^3

.. end of output

The chosen ring depends on the input format.

::

    sage: P3 = Polyhedron(vertices = [[0.5, 0], [0, 0.5]])
    sage: P3
    A 1-dimensional polyhedron in RDF^2 defined as the convex hull of 2 vertices
    sage: P3.parent()
    Polyhedra in RDF^2

.. end of output

.. WARNING::

    The base ring :code:`RDF` should be used with care. As it is not an exact
    ring certain computations may break, for example when dealing with
    non-simplicial polyhedron.


The following example demonstrates the limitations of :code:`RDF`.

::

    sage: P = polytopes.dodecahedron()
    sage: P
    A 3-dimensional polyhedron in (Number Field in sqrt5 with defining
    polynomial x^2 - 5)^3 defined as the convex hull of 20 vertices
    sage: P_RDF = Polyhedron(vertices = [n(v.vector(),digits=6) for v in
    P.vertices()], base_ring=RDF)
    sage: P_RDF
    A 3-dimensional polyhedron in RDF^3 defined as the convex hull of 17
    vertices

.. end of output

It is also possible to define polyhedron over algebraic numbers.

::

    sage: sqrt_2 = AA(2)^(1/2)
    sage: cbrt_2 = AA(2)^(1/3)
    sage: timeit('Polyhedron(vertices = [[sqrt_2, 0], [0, cbrt_2]])')
    5 loops, best of 3: 43.2 ms per loop

    sage: sqrt_2s = sqrt(2)
    sage: cbrt_2s = 2^(1/3)
    sage: timeit('Polyhedron(vertices = [[sqrt_2s, 0], [0, cbrt_2s]])')
    5 loops, best of 3: 198 ms per loop

    sage: P4 = Polyhedron(vertices = [[sqrt_2, 0], [0, cbrt_2]]); P4
    A 1-dimensional polyhedron in AA^2 defined as the convex hull of 2 vertices
    sage: P5 = Polyhedron(vertices = [[sqrt_2s, 0], [0, cbrt_2s]]); P5
    A 1-dimensional polyhedron in (Symbolic Ring)^2 defined as the convex hull
    of 2 vertices

.. end of output

.. WARNING::

    As the above :code:`timeit` shows, it is considerably slower thus
    strongly discouraged to use the :code:`Symbolic Ring`.

The **better option** is to use a :code:`NumberField`:

::

    sage: J = NumberField(x^2 - 2,'s')
    sage: s = J.gens()[0]
    sage: timeit('Polyhedron(vertices = [[s, 0], [0, s]])')
    125 loops, best of 3: 5.18 ms per loop

.. end of output



H-representation
~~~~~~~~~~~~~~~~

Given a :math:`V`-representation Sage can provide the :math:`H`-representation of the object. 

::

    sage: for q in P1.Hrepresentation():
    ....:    print(q)
    An inequality (-4, 1) x + 12 >= 0
    An inequality (1, 7) x + 26 >= 0
    An inequality (1, 0) x + 5 >= 0
    An inequality (2, -9) x + 28 >= 0

.. end of output

The inequalities ``(-4, 1) x + 12 >= 0`` should be read as :math:`(-4, 1)\cdot\vec{x} + 12 \geq 0`.

So... if you want to define a polytope via inequalities, you have to
translate each inequality into a vector.  For example,
:math:`(-4, 1)\cdot\vec{x} + 12 \geq 0` becomes (12, \-4, 1).


::

    sage: altP1 = Polyhedron(ieqs=[(12, -4, 1), (26, 1, 7),(5,1,0), (28, 2, -9)])
    sage: altP1.plot()
    Graphics object consisting of 6 graphics primitives

.. end of output

Other information you might want to pull out of Sage about a polytope is the
vertex list, which can be done in two ways:


::

    sage: for q in P1.Vrepresentation():
    ....:    print(q)
    A vertex at (-5, -3)
    A vertex at (-5, 2)
    A vertex at (4, 4)
    A vertex at (2, -4)

.. end of output

::

    sage: P1.vertices()
    (A vertex at (-5, -3), A vertex at (-5, 2), A vertex at (4, 4), A vertex at (2, -4))

.. end of output

Polar duals
"""""""""""

Surely you want to compute the polar dual:


::

    sage: P1dual = P1.polar()
    sage: P1dual
    A 2-dimensional polyhedron in QQ^2 defined as the convex hull of 4 vertices

.. end of output

Check it out\-\-\-we started with an integer\-lattice polytope and dualized
to a rational\-lattice polytope.  Let's look at that.

 


::

    sage: P1dual.plot()
    Graphics object consisting of 6 graphics primitives


.. end of output

::

    sage: P1.plot() + P1dual.plot()
    Graphics object consisting of 12 graphics primitives


.. end of output

Oh, yeah, unless the polytope is unit\-sphere\-sized, the dual will be a
very different size.  Let's rescale.


::

    sage: ((1/4)*P1).plot() + (4*P1dual).plot()
    Graphics object consisting of 12 graphics primitives

.. end of output

If you think that looks a little bit shady, you're correct.  Here is an
example that makes the issue a bit clearer.


::

    sage: P2 = Polyhedron(vertices = [[-5,0], [-1,1], [-2,0], [1,0], [-2,-1], [-3,-1], [-5,-1]])
    sage: P2
    A 2-dimensional polyhedron in ZZ^2 defined as the convex hull of 5 vertices
    sage: P2dual = P2.polar(); P2dual
    A 2-dimensional polyhedron in QQ^2 defined as the convex hull of 5 vertices
    sage: P2.plot() + P2dual.plot()
    Graphics object consisting of 14 graphics primitives

.. end of output

That is clearly not computing what we think of as the polar dual.  But look
at this...


::

    sage: P2.plot() + (-1*P2dual).plot()
    Graphics object consisting of 14 graphics primitives

.. end of output

Here is what's going on. 

If a polytope ``P`` is in `\ZZ`, then...

(1) ...the dual is inverted in some way, which is vertically for polygons.

(2) ...the dual is taken of P itself.

(3) ...if the origin is not in P, then an error is returned.

However, if a polytope is  *not*  in `\ZZ`, for example if it's in `\QQ` or
``RDF``, then...

(1') ...the dual is not inverted.

(2') ...the dual is taken of P\-translated\-so\-barycenter\-is\-at\-origin.

Keep all of this in mind as you take polar duals.

 

Polytope Constructions
""""""""""""""""""""""

Minkowski sums!  Now with two syntaxes!


::

    sage: P1+P2
    A 2-dimensional polyhedron in ZZ^2 defined as the convex hull of 8 vertices

.. end of output

::

    sage: P1.Minkowski_sum(P2)
    A 2-dimensional polyhedron in ZZ^2 defined as the convex hull of 8 vertices

.. end of output

Okay, fine.  We should have some 3\-dimensional examples, at least.
(Note that in order to display polytopes effectively you'll need
visualization software such as Javaview and Jmol installed.)


::

    sage: P3 = Polyhedron(vertices=[(0,0,0), (0,0,1/2), (0,1/2,0), (1/2,0,0), (3/4,1/5,3/2)]); P3
    A 3-dimensional polyhedron in QQ^3 defined as the convex hull of 5 vertices
    sage: P4 = Polyhedron(vertices=[(-1,1,0),(1,1,0),(-1,0,1), (1,0,1),(0,-1,1),(0,1,1)]); P4
    A 3-dimensional polyhedron in ZZ^3 defined as the convex hull of 6 vertices
    sage: P3.plot() + P4.plot()
    Graphics3d Object

.. end of output

::

    sage: (P3+P4).plot()
    Graphics3d Object

.. end of output

We can also find the intersection of two polytopes... and this too has two
syntaxes!


::

    sage: int12 = P1.intersection(P2*.5); int12.plot()
    Graphics object consisting of 7 graphics primitives

.. end of output

::

    sage: int34 = P3 & P4; int34.plot()
    Graphics3d Object

.. end of output

Should one wish to translate, one can.


::

    sage: transP2 = P2.translation([2,1])
    sage: P2.plot() + transP2.plot()
    Graphics object consisting of 14 graphics primitives

.. end of output

Then of course we can take prisms, pyramids, and bipyramids of polytopes...


::

    sage: P2.prism().plot()
    Graphics3d Object

.. end of output

::

    sage: P1.pyramid().plot()
    Graphics3d Object

.. end of output

::

    sage: P2dual.bipyramid().plot()
    Graphics3d Object

.. end of output

Okay, fine.  Yes, Sage has some kinds of polytopes built in.
If you type ``polytopes.`` and then press ``TAB`` after the period, you'll get a
list of pre\-built polytopes.


::

    sage: P5 = polytopes.hypercube(5)
    sage: P6 = polytopes.cross_polytope(3)
    sage: P7 = polytopes.simplex(7)


.. end of output

Let's look at a 4\-dimensional polytope.


::

    sage: P8 = polytopes.hypercube(4)
    sage: P8.plot()
    Graphics3d Object

.. end of output

We can see it from a different perspective:


::

    sage: P8.schlegel_projection([2,5,11,17]).plot()
    Graphics3d Object

.. end of output

Queries to polytopes
""""""""""""""""""""

Once you've constructed some polytope, you can ask Sage questions about it.


::

    sage: P1.contains([1,0])
    True

.. end of output

::

    sage: P1.interior_contains([3,0])
    False

.. end of output

::

    sage: P3.contains([1,0,0])
    False

.. end of output

Face information can be useful.  


::

    sage: int34.f_vector()
    (1, 8, 12, 6, 1)

.. end of output

Well, geometric information might be  *more*  helpful...
Here we are told which of the vertices form each 2\-face:


::

    sage: int34.faces(2)
    (<1,3,4>, <0,1,3,5>, <0,1,2,4,6>, <2,3,4,5,7>, <2,6,7>, <0,5,6,7>)

.. end of output

Yeah, that isn't so useful as it is.  Let's figure out the vertex and
hyperplane representations of the first face in the list.


::

    sage: first2faceofint34 = P3.faces(2)[0]
    sage: first2faceofint34.ambient_Hrepresentation(); first2faceofint34.vertices()
    (An inequality (1, 0, 0) x + 0 >= 0,)
    (A vertex at (0, 0, 0), A vertex at (0, 0, 1/2), A vertex at (0, 1/2, 0))

.. end of output

If you want more... :ref:`sage.geometry.polyhedron.base` is the first place you want to go.
