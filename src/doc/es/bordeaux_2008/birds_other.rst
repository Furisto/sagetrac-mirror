
La Matríz de Frobenius Sobre Curvas Hiperelípticas
==================================================

Sage posee una implementación altamente optimizada de el algoritmo
Harvey-Kedlaya para computar la matríz de Frobenius asocida a una curva
sobre un campo finito. Esta es una implementación de David Harvey, la cual
tiene licencia GPL y depende únicamente de NTL y ``zn_poly`` (una biblioteca en C para
aritmética rápida en :math:`(\ZZ/n\ZZ)[x]`).

Importamos la función ``hypellfrob`` y la invocamos sobre un polinomio en :math:`\ZZ`.

::

    sage: from sage.schemes.hyperelliptic_curves.hypellfrob import hypellfrob
    sage: R.<x> = PolynomialRing(ZZ)
    sage: f = x^5 + 2*x^2 + x + 1; p = 101
    sage: M = hypellfrob(p, 1, f); M
    [ 0 + O(101)  0 + O(101) 93 + O(101) 62 + O(101)]
    [ 0 + O(101)  0 + O(101) 55 + O(101) 19 + O(101)]
    [ 0 + O(101)  0 + O(101) 65 + O(101) 42 + O(101)]
    [ 0 + O(101)  0 + O(101) 89 + O(101) 29 + O(101)]

Efectuamos el mismo cálculo pero en :math:`\ZZ/101^4\ZZ`,
el cual da la suficiente precisión para reconocer el polinomio característico
de Frobenius exacto en :math:`\ZZ[x]` como un elemento de el
anillo de endomorfismo. Este cómputo es, a pesar de todo, muy rápido, tomando unicamente una
fracción de segundo.

.. link

::

    sage: M = hypellfrob(p, 4, f)   # alrededor de 0.25 seconds
    sage: M[0,0]
    91844754 + O(101^4)

El polinomio característico de Frobenius es :math:`x^4 + 7x^3 +
167x^2 + 707x + 10201`, el cual determina la función :math:`\zeta` de
la curva :math:`y^2= f(x)`.

.. link

::

    sage: M.charpoly()
    (1 + O(101^4))*x^4 + (7 + O(101^3))*x^3 + (167 + O(101^3))*x^2 
       + (707 + O(101^3))*x + (10201 + O(101^4))

.. note::
   
   Ejercicio: Escriba la función zeta explicitamente, cuente puntos sobre
   algunos cámpos finitos y asegurese que todo concuerde.


Símbolos Modulares
==================

Los símbolos modulares juegan un papel importante en los algorítmos para computos con
formas modulares, valores especiales de :math:`L`-funciones, curvas elípticas,
y variedades modulares abelianas. Sage tiene la implementación más general
de símbolos modulares disponible, grácias al trabajo de su servidor
Jordi Quer (de Barcelona) y Craig Citro (un estudiante de Hida).
Por otra parte, los cómputos con símbolos modulares es hasta ahora mi
parte más favorita de la matemática computacional. Todavía hay bastante
trabajo de afinamiento y optimización por hacer para símbolos modulares en
Sage, a fin de que séa en todas las categorías la implementación más rápida del mundo,
ya que mi implementación de Magma aún sigue siendo mejor en algunos casos importantes.

.. note::

   Hablaré mucho más sobre símbolos modulares en mi clase de el
   Viernes, que será sobre formas modulares y objetos relacionados.

Creamos el espacio :math:`M` de símbolos modulares de peso :math:`4`
para un cierto subgrupo de congruencia :math:`\Gamma_H(13)`
de nivel :math:`13`. Luego calculamos una base para este espacio,
expresada en terminos de símbolos de Manin. Finalmente, calculamos el operador Hecke
 :math:`T_2` actuando sobre :math:`M`, encontramos su
polinomio caracteristico y lo factorizamos. También, calculamos la
dimensión del sub-espacio cuspidal.

::

    sage: M = ModularSymbols(GammaH(13,[3]), weight=4)
    sage: M
    Modular Symbols space of dimension 14 for Congruence Subgroup 
    Gamma_H(13) with H generated by [3] of weight 4 with sign 0 
    and over Rational Field
    sage: M.basis()
    ([X^2,(0,1)], [X^2,(0,7)], [X^2,(2,5)], [X^2,(2,8)], [X^2,(2,9)], 
     [X^2,(2,10)], [X^2,(2,11)], [X^2,(2,12)], [X^2,(4,0)], [X^2,(4,3)], 
     [X^2,(4,6)], [X^2,(4,8)], [X^2,(4,12)], [X^2,(7,1)])
    sage: factor(charpoly(M.T(2)))
    (x - 7) * (x + 7) * (x - 9)^2 * (x + 5)^2 
            * (x^2 - x - 4)^2 * (x^2 + 9)^2
    sage: dimension(M.cuspidal_subspace())
    10

Biblioteca de Simbolos Modulares de Cremona
--------------------------------------------
Sage incluye la desquiciadamente rápida y especializada implementación de símbolos modulares para
peso 2 y caracter trivial de John Cremona. Presentamos a continuación el cálculo
de un espacio de símbolos modulares de nivel 20014, el cual tiene dimensión
:math:`5005`, junto con un operador de Hecke sobre este espacio.
Todo el cómputo de abajo toma sólo unos segundos; un cómputo similar
toma unos cuantos minutos usando el código genérico para simbolos modulares de Sage.
Además, Cremona ha hecho cómputos a niveles por encima de
200,000 utilizando su biblioteca, por lo que se sabe que el código se adapta bién
a problemas grandes. El nuevo código para símbolos modulares en Sage es mucho
más general, pero no se adapta casi tan bién (todavía).

::

    sage: M = CremonaModularSymbols(20014)      # pocos segundos
    sage: M
    Cremona Modular Symbols space of dimension 5005 for 
    Gamma_0(20014) of weight 2 with sign 0
    sage: t = M.hecke_matrix(3)                 # pocos segundos

Enumerando Cámpos de Numeros Totalmente Reales
==============================================

Como parte de su proyecto de enumerar las curvas de Shimura, John Voight ha
contribuido código a Sage para enumerar cámpos de numeros totalmente reales.
El algorítmo no es extremadamente complicado, pero involucra algunos
"bucles internos" que tienen que codificarse para que corran muy rápido.
Usando Cython, Voight pudo implementar con exactitud una variante de la
iteración de Newton que necesitaba para su problema.

La función ``enumerate_totallyreal_fields_prim(n, B, ...)``
enumera, sin usar una primitiva (!) de base de datos (sin subcampo própio),
cámpos totalmente reales de grado :math:`n>1` con discriminante :math:`d
\leq B`.

Calculémos los cámpos cuadráticos totalmente reales de discriminante
:math:`\leq 50`. El cálculo de abajo, el cual es cási instantáneo,
está hecho en tiempo reál y no se extrajo de alguna tabla.

::

    sage: enumerate_totallyreal_fields_prim(2,50)
    [[5, x^2 - x - 1], [8, x^2 - 2], [12, x^2 - 3], [13, x^2 - x - 3], 
     [17, x^2 - x - 4], [21, x^2 - x - 5], [24, x^2 - 6], [28, x^2 - 7],  
     [29, x^2 - x - 7], [33, x^2 - x - 8], [37, x^2 - x - 9], 
     [40, x^2 - 10], [41, x^2 - x - 10], [44, x^2 - 11]]

Calculémos todos los cámpos quínticos totalmente reales de discriminante
:math:`\leq 10^5`.  De nuevo, esto está hecho en tiempo reál - ¡No proviene de una tabla!

::

    sage: enumerate_totallyreal_fields_prim(5,10^5)
    [[14641, x^5 - x^4 - 4*x^3 + 3*x^2 + 3*x - 1], 
     [24217, x^5 - 5*x^3 - x^2 + 3*x + 1],
     [36497, x^5 - 2*x^4 - 3*x^3 + 5*x^2 + x - 1], 
     [38569, x^5 - 5*x^3 + 4*x - 1],
     [65657, x^5 - x^4 - 5*x^3 + 2*x^2 + 5*x + 1],   
     [70601, x^5 - x^4 - 5*x^3 + 2*x^2 + 3*x - 1],
     [81509, x^5 - x^4 - 5*x^3 + 3*x^2 + 5*x - 2], 
     [81589, x^5 - 6*x^3 + 8*x - 1],
     [89417, x^5 - 6*x^3 - x^2 + 8*x + 3]]


Números de Bernoulli
====================

Mathematica y Pari
-------------------

De la página web de mathematica:

    "Hoy rompímos el record de Bernoulli: Desde el Motor Analítico
    hasta Mathematica Abril 29, 2008 Oleksandr Pavlyk, Kernel Technology
    Hace una semana, tomé nuestra más reciente versión en desarrollo de Mathematica,
    y tecleé ``BernoulliB[10^7]``, y luego esperé. Ayer--5
    días, 23 horas, 51 minutos y 37 segundos después--¡obtuve el
    resultado!"


Tom Boothby hizo el mismo cómputo en Sage, que utiliza el comando
``bernfrac`` de Pari el cual usa la evaluación de :math:`\zeta` y el
factorial a una alta precisión, y le tomó 2 días y 12 horas.

La Función ``bernmm`` de David Harvey
---------------------------------

Luego David Harvey surgió con un algorítmo enteramente nuevo que
paraleliza bién. Da los siguientes cronometrajes para computar
:math:`B_{10^7}` en su máquina (le toma 59 minutos, 57 segundos a mi
ordenador de 16 procesadores Opteron de 1.8ghz):

``PARI: 75 h, Mathematica: 142 h``

``bernmm (1 core) = 11.1 h, bernmm (10 cores) = 1.3 h``

    "Corriendo a razón de 10 procesadores durante 5.5 dias, yo, [David Harvey] calculé [el
    número de Bernoulli] :math:`B_k` para :math:`k = 10^8`, el cual yo
    creo que és un nuevo record. Esencialmente, es el algorítmo multimodular
    que sugerí anteriormente en esta discusión, pero descubrí
    algunos trucos para optimizar el cómputo de :math:`B_k \text{mod} p`."


Asi que ahora Sage es el más rápido en el mundo para números de Bernoulli
grandes. Los cronometrajes a continuación fueron tomados en un ordenador
de 16 procesadores Opteron de 1.8ghz.

::

    sage: w = bernoulli(100000, num_threads=16)     # 1.87 segundos
    sage: w = bernoulli(100000, algorithm='pari')   # 28 segundos


Aritmética Polinomial 
=====================

FLINT: Aritmética Polinomial Univariada
---------------------------------------

Sage usa Flint, una biblioteca para aritmética escrita en C y con
licencia GPL de Bill Hart y David Harvey en :math:`\ZZ[x]`.
Su principal reivindicación a la fama es el ser
la más rápida del mundo para multiplicación de polinomios, por ejemplo, en la
siguiente medición es 3 veces más rápida que NTL y el doble de rápida que
Magma. Tras bambalinas contiene un poco de código de transformada discreta de Fourier
cuidadosamente afinado (del cual no sé casi nada).

::

    sage: Rflint = PolynomialRing(ZZ, 'x')
    sage: f = Rflint([ZZ.random_element(2^64) for _ in [1..32]])
    sage: g = Rflint([ZZ.random_element(2^64) for _ in [1..32]])
    sage: timeit('f*g')               # resultado aleatorio
    625 loops, best of 3: 105 microseconds per loop
    sage: Rntl = PolynomialRing(ZZ, 'x', implementation='NTL')
    sage: f = Rntl([ZZ.random_element(2^64) for _ in [1..32]])
    sage: g = Rntl([ZZ.random_element(2^64) for _ in [1..32]])
    sage: timeit('f*g')               # resultado aleatorio
    625 loops, best of 3: 310 microseconds per loop
    sage: ff = magma(f); gg = magma(g)  #opcional - magma
    sage: s = 'time v := [%s * %s for _ in [1..10^5]];'%(ff.name(), gg.name()) #opcional - magma
    sage: magma.eval(s)     #opcional - magma
    'Time: 17.120'
    sage: (17.120/10^5)*10^(6)    # convierta a microsegundos
    171.200000000000

Singular: Aritmética Polinomial Multivarida
--------------------------------------------

La aritmética polinomial multivarida utiliza, en muchos casos, Singular en
modo de biblioteca (grácias a Martin Albrecht), la cual es muy rápida. Por ejemplo,
abajo, efectuamos la prueba de Fateman sobre el campo finito de órden 32003.

::

    sage: P.<x,y,z> = GF(32003)[]
    sage: p = (x+y+z+1)^20
    sage: q = p+1
    sage: timeit('p*q')   # resultado aleatorio
    5 loops, best of 3: 384 ms per loop
    sage: pp = magma(p); qq = magma(q) #opcional - magma
    sage: s = 'time w := %s*%s;'%(pp.name(),qq.name()) #opcional - magma
    sage: magma.eval(s) #opcional - magma
    'Time: 1.480'

Note que la multiplicación le lleva a Magma alrededor de 4 tantos.

