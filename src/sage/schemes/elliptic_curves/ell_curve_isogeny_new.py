from sage.categories import homset

from sage.categories.morphism import Morphism
from sage.rings.polynomial.polynomial_element import is_Polynomial

def kernel_polynomial_from_points(kernel_gens, check):
    E = kernel_gens[0].codomain()
    K = E.base_field()
    if check and not K.is_finite():
        for P in kernel_gens:
            if not P.has_finite_order():
                raise ValueError, "The points in the kernel must be of finite order."
    
    # Compute the group generated by the "kernel_gens"
    # Useless compatations are done here : we only need the abscissae of the points.
    # Morever, there is maybe a better algo to do that.
    kernel_list = set([E(0)])
    for P in kernel_gens:
        points_to_add = set()
        for j in range(P.order()):
            for Q in kernel_list:
                points_to_add.add(j*P+Q)
        kernel_list = kernel_list.union(points_to_add)
    kernel_list.remove(E(0))
    
    # Compute the kernel polynomial
    R = PolynomialRing(K,'x')
    x = R.gen()
    polyn = R(1)
    for P in kernel_list:
        polyn *= x - P.xy()[0]
    return polyn
        
class EllipticIsogeny(Morphism):
    r"""
    Construct an elliptic curve isogeny.
    
    This class implements cyclic, separable isogenies of
    elliptic curves.
    
    Characteristic 2 is not supported.
    
    INPUT:
    
    - ``E``         - an elliptic curve, the domain of the isogeny to initialize.

    - ``kernel``    - (default: ``None``) the kernel of the isogeny.
                      It could be either a point in ``E``, a list 
                      of points in ``E``, a monic kernel polynomial or a couple 
                      of polynomials.
                      
                      If point or sequence of points are passed, then the kernel
                      will be the group generated by this (list of) point(s).
                      
                      The kernel polynomial factors as `ab^2` where 
                      `a | (x^3 + b_2 x^2 + b_4 x + b_6)` vanishes on the 
                      abscissae of the `2`-torsion part of the kernel, and `b`
                      vanishes on all the other abscissae with multiplicity exactly one.
                      There is several ways to specify this polynomial:
                      * kernel is a polynomial and degree is not given, assumes
                      `ab` is given;
                      * ``(kernel=h, degree=n)`` is given with h a polynomial and
                      n an integer, if  the degree of `h` is `n-1` assumes `h=ab^2`,
                      else assumes `h=ab`;
                      * kernel is couple of polynomials, assumes `(a,b)` is given.
                      If initializing from a domain/codomain, this must be None.

    - ``codomain``  - (default:``None``) an elliptic curve.  
                      If ``kernel``
                      is ``None``, then this must be the codomain of a cyclic,
                      separable, normalized isogeny, furthermore, ``degree``
                      must be the degree of the isogeny from ``E`` to
                      ``codomain`` (not yet implemented). If ``kernel`` is not 
                      ``None``, then this must be isomorphic to the codomain of 
                      the cyclic normalized separable isogeny defined by ``kernel``,
                      in this case, the isogeny is post composed with an 
                      isomorphism so that this parameter is the codomain.

    - ``degree``    - (default: ``None``) an integer: the degree of the isogeny.
                      If ``kernel`` is ``None``, then this is the degree of the
                      isogeny from ``E`` to ``codomain``.
                      If ``kernel`` is not ``None``, then this is used to determine
                      whether or not to skip a gcd of the kernel polynomial with the
                      two torsion polynomial of ``E``.
    - ``urst``      - (default: ``None``) a 4-uple.
                      If not ``None``, the isogen is post composed by the isomorphism
                      given by `(u, r, s, t)`.
    - ``check`` - (default: ``True``) checks if the input is valid to define an isogeny
    
    EXAMPLES::
    
        sage: F = GF(19)
        sage: R.<x> = PolynomialRing(F)
        sage: E=EllipticCurve(F,[1,2,3,4,5])
        
    Define `\phi` with kernel polynomial::
    
        sage: phi = EllipticIsogeny(E,x+9); phi
        Isogenie of degree 3:
          From: Elliptic Curve defined by y^2 + x*y + 3*y = x^3 + 2*x^2 + 4*x + 5 over Finite Field of size 19
          To:   Elliptic Curve defined by y^2 = x^3 + 7*x^2 + 6*x + 18 over Finite Field of size 19
          Defn: (x,y) |--> ((x^2 + 9*x - 2)/(x + 9), (x^2*y - x*y + 7*y)/(x^2 - x + 5))
        sage: phi2 = EllipticIsogeny(E,x+9, urst = (2,3,5,7)); phi2
        Isogenie of degree 3:
          From: Elliptic Curve defined by y^2 + x*y + 3*y = x^3 + 2*x^2 + 4*x + 5 over Finite Field of size 19
          To:   Elliptic Curve defined by y^2 + 5*x*y + 16*y = x^3 + 12*x^2 + 11*x + 11 over Finite Field of size 19
          Defn: (x,y) |--> ((4*x^2 + x)/(x + 9), (x^3 + 8*x^2*y + 6*x^2 - 8*x*y - 4*x - y - 2)/(x^2 - x + 5))
    
    Define `\phi` with points of the kernel::       
          


    ALGORITHM:
    
    See [DeF], section 8.2 for complete presentation and justification of the following
    formulae.
    
    Let `\phi : E \to E'` be an isogeny of degree `\ell` between two elliptic curves
    and `h` be the kernel polynomial of `\phi`, i.e. 
    
    .. math::
        h(x) = \prod_{Q\in \ker \phi \setminus\{\mathcal O\}} (x-x(Q)).
    
    We will note `s_i` the `i`-th  power sum of the roots of `h`.
    
    The simpliest case occurs when the equation of `E` is of the form `y^2=f(x)`, with 
    `f(x) = x^3 + a_2 x^2 + a_4 x + a_6`. In this case, one can easily compute the
    fractions defining the isogeny:
    
    .. math::
    
        \phi(x,y) = \left( \frac{g(x)}{h(x)}, y \left(\frac{g(x)}{h(x)}\right)'\right),
    
    where
    
    .. math::
        
        \frac{g(x)}{h(x)} = \ell x - s_1 - f'(x) \frac{h'(x)}{h(x)} - 2 f(x) \left(\frac{h'(x)}{h(x)} \right)'.
    
    Moreover, the equation of `E'` is given by:
    
    .. math::
        E':\quad y^2 = x^3 + a_2 x^2 +(a_4-5t)x + a_6 - a_2t - 7w,
        
    where:
    
    .. math::
    
        t = 3s_2 + 2 a_2 s_1 + (\ell-1)a4,\quad  w = 5 s_3 + 4 a_2 s_2 + 3 a_4 s_1 +2 (\ell-1) a_6.
        
    When the equation of `E` is of the form `y^2+ a_1 x y + a_3 y = x^3 + a_2 x^2 + a_4 x + a_6`
    with `a_1 \neq 0` or `a_3 \neq 0`, the class internally proceed to the following 
    change of variables:
    
    .. math::
    
        y \mapsto y - \frac{a_1}2 x - \frac{a_3}2,
        
    hence, we have an isomorphism to a new curve `E''` whose equation is of the 
    above form. Note that abscissae are not modified, so the kernel polynomial is
    the same.
    
    REFERENCES:
    
    - [DeF] De Feo, "Fast algorithms for towers of finite fields and isogenies".
    """
    def __init__(self, E, kernel = None, codomain = None, degree = None, urst = None, check = True):
        R = PolynomialRing(E.base_ring().fraction_field(), 'x')
        x = R.gen()
        f = x**3 + E.a2()*x**2 + E.a4()*x + E.a6()

        if isinstance(kernel,(tuple,list)) and is_Polynomial(kernel[0]) :
            a, b = kernel
            self.h = R(a)*R(b)**2
        elif is_Polynomial(kernel):
            if degree == None:
                a = R(kernel).gcd(f)
                b, _ = R(kernel).quo_rem(a)
                self.h = a*b**2
            else:
                if degree == kernel.degree()+1:
                    self.h = R(kernel)
                else:
                    a = R(kernel).gcd(f)
                    b, _ = R(kernel).quo_rem(a)
                    self.h = a*b**2
        elif isinstance(kernel,(list,tuple)) and kernel[0] in E:
            self.h = kernel_polynomial_from_points(kernel, check)
        elif kernel in E:
            self.h = kernel_polynomial_from_points([kernel], check)
        else:
            raise ValueError, "The parameter kernel must be a polynomial, a nonempty list of points of E or a point of E."
            
        self.__init_via_kernel_polynomial(E, codomain, urst)
        
    def __init_via_kernel_polynomial(self, E, codomain, urst):
        " Assume that the kernel polynomial of the isogeny is in self.h"
        a1, a2, a3, a4, a6 = E.ainvs()
        self._pre_urst = (1, 0, 0, 0)
        self.__domain_reduced=E
        if a1 != 0 or a3 != 0:
            if E.base_ring().characteristic() == 2:
                raise NotImplementedError, "The characteristic 2 is not supported"
            self._pre_urst = (1, 0, a1/2, a3/2)
            a1, a3 = E.base_field()(0), E.base_field()(0)
            a2, a4, a6 = E.b2()/4, E.b4()/2, E.b6()/4
            self.__domain_reduced = EllipticCurve((a1,a2,a3,a4,a6))
        n = self.h.degree()
        coeffs_list = self.h.list()
        
        c1, c2, c3 = 0, 0, 0
        if 1 <= n:
            c1 = coeffs_list[n-1]
        if 2 <= n:
            c2 = coeffs_list[n-2]
        if 3 <= n:
            c3 = coeffs_list[n-3]
        
        s1 = -c1
        s2 = c1**2 - 2*c2
        s3 = -c1**3 + 3*c1*c2 - 3*c3
        
        t = 3*s2 + 2*a2*s1 + n*a4
        w = 5*s3 + 4*a2*s2 + 3*a4*s1 +2*n*a6
        
        a4 = a4 - 5*t
        a6 = a6 - 4*a2*t - 7*w
        E2 = None
        if codomain is not None:
            E2 = EllipticCurve((a1, a2, a3, a4, a6))
            urst = isomorphisms(E2, codomain, JustOne = True)
            if urst is None:
                raise ValueError, "Codomain parameter must be isomorphic to computed codomain isogeny"
            self.urst = urst
            E2 = codomain
        elif urst is not None:
            u, r, s, t = urst
            if u == 0:
                raise ValueError, "In (u, r, s, t), u can not be null."
                
            self.urst  = urst
            a6 += r*(a4 + r*(a2 + r)) - t*(a3 + r*a1 + t)
            a4 += -s*a3 + 2*r*a2 - (t + r*s)*a1 + 3*r*r - 2*s*t
            a3 += r*a1 +t+t
            a2 += -s*a1 + 3*r - s*s
            a1 += 2*s
            E2 = EllipticCurve((a1/u,a2/u**2,a3/u**3,a4/u**4,a6/u**6))
        else:
            E2 = EllipticCurve((a1, a2, a3, a4, a6))
            self.urst  = (1, 0, 0, 0)
        # Multiply urst by the unit of the base_field in order to coerce urst properly
        unit = E2.base_ring().fraction_field()(1)
        self.urst = u, r, s, t = tuple( i*unit for i in self.urst)
        self.urst_inv = (1/u, -r/(u**2), -s/u, (r*s - t)/(u**3))
        parent = homset.Hom(E,E2)
        Morphism.__init__(self, parent)

        
      
    def _call_(self, P):
        E, E2 = self.domain(), self.codomain()
        
        P = E(P)
        if P.is_zero() or self.h(P.xy()[0]) == 0 :
            return E2(0)

        x, y = P.xy()            
        _,_,s,t = self._pre_urst
        y += s*x + t
        x_map, y_map = self.__internal_maps()
        xn, yn = x_map(x), y*y_map(x)
        u,r,s,t= self.urst_inv
        return E2( (u**2*xn + r, u**3*yn + s*u**2*xn + t) )
    
#    @cached_method        
    def __internal_maps(self):
        n = self.h.degree()
        x = self.h.parent().gen()
        s1 = -self.h.list()[n-1] if self.h.degree()> 0 else 0
        E = self.__domain_reduced
        f = x**3 + E.a2()*x**2 + E.a4()*x + E.a6()
        fp = f.derivative()
        hp_o_h = self.h.derivative() / self.h

        x_map = (n+1)*x - s1 - fp*hp_o_h - 2*f*(hp_o_h.derivative())
        y_map = x_map.derivative()

        return x_map, y_map
        
#    @cached_method
    def rational_maps(self):
        R = PolynomialRing(self.domain().base_ring().fraction_field(), 2, 'xy').fraction_field()
        x, y = R.gens()
        u, r, s, t = self.urst
        x_map, y_map = self.__internal_maps()
        phi_x, phi_y = R(u**2*x_map + r), R(u**3*y*y_map + s*u**2*x_map + t)

        _,_,s,t = self._pre_urst
        return phi_x(y=y-s*x-t), phi_y(y=y-s*x-t)
        
    def degree(self):
        return self.h.degree() + 1
        
    def is_normalized(self):
        return self.u == 1
    
    def _repr_defn(self):
        return '(x,y) |--> ' + str(self.rational_maps())
    
    def _repr_(self):
        D = self.domain()
        if D is None:
            return "Defunct map"
        s = "Isogenie of degree %d:"%self.degree()
        s += "\n  From: %s"%D
        s += "\n  To:   %s"%self.codomain()
        s += "\n  Defn: %s"%('\n        '.join(self._repr_defn().split('\n')))
        return s
def isomorphisms(E,F,JustOne=False):
    r"""
    Returns one or all isomorphisms between two elliptic curves.

    INPUT:

    - ``E``, ``F`` (EllipticCurve) -- Two elliptic curves.

    - ``JustOne`` (bool) If True, returns one isomorphism, or None if
      the curves are not isomorphic.  If False, returns a (possibly
      empty) list of isomorphisms.

    OUTPUT:

    Either None, or a 4-tuple `(u,r,s,t)` representing an isomorphism,
    or a list of these.

    .. note::

       This function is not intended for users, who should use the
       interface provided by ``ell_generic``.

    EXAMPLES::

        sage: from sage.schemes.elliptic_curves.weierstrass_morphism import *
        sage: isomorphisms(EllipticCurve_from_j(0),EllipticCurve('27a3'))
        [(-1, 0, 0, -1), (1, 0, 0, 0)]
        sage: isomorphisms(EllipticCurve_from_j(0),EllipticCurve('27a3'),JustOne=True)
        (1, 0, 0, 0)
        sage: isomorphisms(EllipticCurve_from_j(0),EllipticCurve('27a1'))
        []
        sage: isomorphisms(EllipticCurve_from_j(0),EllipticCurve('27a1'),JustOne=True)
    """
#    from ell_generic import EllipticCurve_generic
#    if not isinstance(E, EllipticCurve_generic) or not isinstance(F, EllipticCurve_generic):
#        raise ValueError, "arguments are not elliptic curves"
    K = E.base_ring()
#   if not K == F.base_ring(): return []
    j=E.j_invariant()
    if  j != F.j_invariant():
        if JustOne: return None
        return []

    from sage.rings.all import PolynomialRing
    x=PolynomialRing(K,'x').gen()

    a1E, a2E, a3E, a4E, a6E = E.ainvs()
    a1F, a2F, a3F, a4F, a6F = F.ainvs()

    char=K.characteristic()

    if char==2:
        if j==0:
            ulist=(x**3-(a3E/a3F)).roots(multiplicities=False)
            ans=[]
            for u in ulist:
                slist=(x**4+a3E*x+(a2F**2+a4F)*u**4+a2E**2+a4E).roots(multiplicities=False)
                for s in slist:
                    r=s**2+a2E+a2F*u**2
                    tlist= (x**2 + a3E*x + r**3 + a2E*r**2 + a4E*r + a6E + a6F*u**6).roots(multiplicities=False)
                    for t in tlist:
                        if JustOne: return (u,r,s,t)
                        ans.append((u,r,s,t))
            if JustOne: return None
            ans.sort()
            return ans
        else:
            ans=[]
            u=a1E/a1F
            r=(a3E+a3F*u**3)/a1E
            slist=[s[0] for s in (x**2+a1E*x+(r+a2E+a2F*u**2)).roots()]
            for s in slist:
                t = (a4E+a4F*u**4 + s*a3E + r*s*a1E + r**2)
                if JustOne: return (u,r,s,t)
                ans.append((u,r,s,t))
            if JustOne: return None
            ans.sort()
            return ans

    b2E, b4E, b6E, b8E      = E.b_invariants()
    b2F, b4F, b6F, b8F      = F.b_invariants()

    if char==3:
        if j==0:
            ulist=(x**4-(b4E/b4F)).roots(multiplicities=False)
            ans=[]
            for u in ulist:
                s=a1E-a1F*u
                t=a3E-a3F*u**3
                rlist=(x**3-b4E*x+(b6E-b6F*u**6)).roots(multiplicities=False)
                for r in rlist:
                    if JustOne: return (u,r,s,t+r*a1E)
                    ans.append((u,r,s,t+r*a1E))
            if JustOne: return None
            ans.sort()
            return ans
        else:
            ulist=(x**2-(b2E/b2F)).roots(multiplicities=False)
            ans=[]
            for u in ulist:
                r = (b4F*u**4 -b4E)/b2E
                s = (a1E-a1F*u)
                t = (a3E-a3F*u**3 + a1E*r)
                if JustOne: return (u,r,s,t)
                ans.append((u,r,s,t))
            if JustOne: return None
            ans.sort()
            return ans

# now char!=2,3:
    c4E,c6E = E.c_invariants()
    c4F,c6F = F.c_invariants()

    if j==0:
        m,um = 6,c6E/c6F
    elif j==1728:
        m,um=4,c4E/c4F
    else:
        m,um=2,(c6E*c4F)/(c6F*c4E)
    ulist=(x**m-um).roots(multiplicities=False)
    ans=[]
    for u in ulist:
        s = (a1F*u - a1E)/2
        r = (a2F*u**2 + a1E*s + s**2 - a2E)/3
        t = (a3F*u**3 - a1E*r - a3E)/2
        if JustOne: return (u,r,s,t)
        ans.append((u,r,s,t))
    if JustOne: return None
    ans.sort()
    return ans

