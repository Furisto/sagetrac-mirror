r"""
*******************
Classes of Lattices
*******************

Lattices for tori are defined byy equipping the standard lattice in `\ZZ^n` with a group action.

We allow trivial group actions.


All lattices inherit from :class:`Lattice_generic`, and there are currently
two types of lattices: ambient lattices (:class:`Lattice_ambient`) and sublattices of ambient
lattices (:class:`SubLattice`).

One can define a lattice in 5 different ways:

- Giving a group and matrix actions for each generator.

- Giving a group and an integer.

- Giving a list of matrices or finite matrix group.

- Giving a list corresponding to the isomorphism type of a finite abelian group.

- Giving an ambient lattice and a list of vectors spanning an invariant submodule.


Lattice_ambient(group, actions)
===============================

You can define a lattice by giving a group and matrix actions for each generator::

    sage: G = PermutationGroup([(1,2), (3,4,5)])
    sage: G.gens()
    [(3,4,5), (1,2)]
    sage: act1 = matrix(3, [0,1,0,0,0,1,1,0,0])
    sage: act2 = matrix(3, [1,0,0,0,1,0,0,0,1])
    sage: act = [act1, act2]

We created the group `G` as `C_2 \times C_3`, and the action where `C_2` acts trivially.
One has to be careful when defining the action to match sage's order of the generators::

    sage: L = Lattice_ambient(G,act); L
    Ambient free module of rank 3 over the principal ideal domain Integer Ring

    sage: L._action_matrices
    [
    [0 1 0]  [1 0 0]
    [0 0 1]  [0 1 0]
    [1 0 0], [0 0 1]
    ]

Lattice_ambient(group, n)
=========================

If you provide a group and an integer `n`, you get the lattice of rank `n` with
trivial action of the group::

    sage: L = Lattice_ambient(SymmetricGroup(3), 2); L
    Ambient free module of rank 2 over the principal ideal domain Integer Ring
    sage: L._action_matrices
    [
    [1 0]  [1 0]
    [0 1], [0 1]
    ]

Lattice_ambient(List_of_matrices) or Lattice_ambient(Matrix_Group)
==================================================================

If you provide a list of matrices, Sage will construct the lattice with rank
equal to the the size of the matrices, and the group will be understood to be
the subgroup of `GL_n(\ZZ)` generated by the provided matrices.
This subgroup should be finite::

    sage: m1 = matrix(3, [0,0,1,-1,-1,-1,1,0,0])
    sage: m2 = matrix(3, [-1,0,0,0,-1,0,0,0,-1])
    sage: m3 = matrix(3, [0,1,0,1,0,0,-1,-1,-1])
    sage: L = Lattice_ambient([m1, m2, m3]); L
    Ambient free module of rank 3 over the principal ideal domain Integer Ring

    sage: L._action_matrices
    [
    [ 0  0  1]  [-1  0  0]  [ 0  1  0]
    [-1 -1 -1]  [ 0 -1  0]  [ 1  0  0]
    [ 1  0  0], [ 0  0 -1], [-1 -1 -1]
    ]

::

    sage: m1 = matrix(3, [0,0,1,-1,-1,-1,1,0,0])
    sage: m2 = matrix(3, [-1,0,0,0,-1,0,0,0,-1])
    sage: m3 = matrix(3, [0,1,0,1,0,0,-1,-1,-1])
    sage: G = MatrixGroup([m1,m2,m3]);G
    Matrix group over Integer Ring with 3 generators (
    [ 0  0  1]  [-1  0  0]  [ 0  1  0]
    [-1 -1 -1]  [ 0 -1  0]  [ 1  0  0]
    [ 1  0  0], [ 0  0 -1], [-1 -1 -1]
    )
    sage: L = Lattice_ambient(G); L
    Ambient free module of rank 3 over the principal ideal domain Integer Ring



Lattice(list_of_integers,action)
================================

Providing a list of integers corresponding to a finite abelian group, and action
matrices (or integer for the trivial action)::

    sage: L = Lattice_ambient([2,2,2,2]); L
    Ambient free module of rank 1 over the principal ideal domain Integer Ring
    sage: L._group
    Permutation Group with generators [(7,8), (5,6), (3,4), (1,2)]



SubLattice(lattice, generators)
===============================

In order to create a sublattice, give a lattice and a list of vectors in the lattice::

    sage: L = Lattice_ambient(DihedralGroup(6), 3)
    sage: x, y, z = L.basis()
    sage: SubLattice(L, [x, y + 2z])
    Free module of degree 3 and rank 2 over Integer Ring
    Echelon basis matrix:
    [1 0 0]
    [0 1 2]

The algorithm checks if the sublattice is stable under the group action::

    sage: L = Lattice_ambient(SymmetricGroup(2), [matrix([[0,1], [1,0]])])
    sage: SubLattice(L, [L.basis()[0]])
    Traceback (most recent call last):
    ...
    ValueError: The basis is not stable under the action of the group


Attributes of a lattice
=======================

- ``lattice._group`` -- the group acting on the lattice

- ``lattice._generators`` -- the generators of that group

- ``lattice._rank`` -- the rank of the lattice

- ``lattice._action_matrices`` -- the matrices through which the group acts

- ``lattice._action._morphism`` -- the map (as a group homomorphism in GAP) from
    the group to ``GL(rank,ZZ)``

- ``lattice._GAPMap`` -- returns the Sage :class:`sage.categories.map.Map` element
    representing Lattice.action_morphism

- ``lattice._action`` -- the Sage action of the group on the lattice

- ``lattice._parent_lattice`` -- the parent lattice; this attribute only exists for
    the SubLattice class


Methods of a lattice
====================

- :meth:`Lattice_generic.group` -- the group acting on the lattice

- :meth:`Lattice_generic._act` -- the action of the group on the lattice

- :meth:`Lattice_generic.subgroup_lattice` -- restricts the action of  
    the group to a subgroup.

- :meth:`Lattice_generic.rational_characters` -- the sublattice of 
    elements fixed by the group.

- :meth:`Lattice_generic.quotient_ambient_sublattice` -- the quotient lattice
    of an ambient lattice by some sublattice

- :meth:`Lattice_generic.quotient_lattice` -- the quotient lattice
    of a lattice by some sublattice

- :meth:`Lattice_generic.isomorphic_ambient_lattice` -- gives an isomorphic 
    ambient lattice, returns the same lattice if it is already ambient.

-- :meth:`Lattice_generic.GAPMatrixgroup` -- the matrix group corresponding to 
    the action, as a GAP group.

- :meth:`Lattice_generic.colattice` -- the lattice where the action of the group
    is composed with the inverse transpose automorphism.

- :meth:`Lattice_generic.Tate_Cohomology` -- computes the Tate cohomology of the lattice

- :meth:`Lattice_generic.induced_lattice` -- the induction of the lattice to a bigger group

- :meth:`Lattice_generic.zero_sum_sublattice` -- the sublattice of zero sum vectors,
    can also give an ambient lattice isomorphic to this zero sum sublattice. 






EXAMPLES::

    sage: G = PermutationGroup([(1,2), (3,4,5)])
    sage: G.gens()
    [(3,4,5), (1,2)]
    sage: act1 = matrix(3, [0,1,0,0,0,1,1,0,0])
    sage: act2 = matrix(3, [1,0,0,0,1,0,0,0,1])
    sage: act = [act1,act2]
    sage: L1 = Lattice_ambient(G, act)

``L1`` is the group `C_2 \times C_3` acting on `\ZZ^3` via the identity for the first component and
an order 3 permutation for the second component.

::

    sage: L2 = Lattice_ambient(SymmetricGroup(3), 4)

``L2`` is the symmetric group `S_3` acting trivially on `\ZZ^4`.

::

    sage: m1 = matrix(3, [0,0,1,-1,-1,-1,1,0,0])
    sage: m2 = matrix(3, [-1,0,0,0,-1,0,0,0,-1])
    sage: m3 = matrix(3, [0,1,0,1,0,0,-1,-1,-1])
    sage: L3 = Lattice_ambient([m1, m2, m3])

``L3`` is the lattice with action of the group generated by the matrices ``m1``, ``m2``, ``m3``,
which is also the group of GAP ID (3,3,3,3)







##################################################
#
#   CLASS FOR TORI
#
##################################################


Tori are now only implemented as character lattices with an action of 
the Galois group (at least as large as the galois group of a splitting field).
For now this Galois group will just be an abstract group, 
either a permutation group or a finite matrix group in ``GL(n,ZZ)``.



 To define a torus we use AlgebraicTorus(character_lattice)


EXAMPLES::

    sage: L = Lattice_ambient(PermutationGroup([()]), 1)
    sage: AlgebraicTorus(L)
    Algebraic Torus of rank 1 defined by the following lattice :
    Ambient free module of rank 1 over the principal ideal domain Integer Ring
    and an action by the galois group of the form :
    Permutation Group with generators [()]
    
This is the split torus ``\mathbb{G_m}``, with action of the trivial Galois group.::


    sage: LL = Lattice_ambient(SymmetricGroup(3), 1)
    sage: AlgebraicTorus(LL)
    Algebraic Torus of rank 1 defined by the following lattice :
    Ambient free module of rank 1 over the principal ideal domain Integer Ring
    and an action by the galois group of the form :
    Symmetric group of order 3! as a permutation group
 

This is still ``\mathbb{G}_m``, with trivial action of a galois group isomorphic to S3. Note that 
this Galois group is not necessarily the one of a minimal splitting extension.::

    sage: act1 = matrix(3, [0,1,0,0,0,1,1,0,0])
    sage: act2 = matrix(3, [0,1,0,1,0,0,0,0,1])
    sage: LLL = Lattice_ambient(SymmetricGroup(3), [act1,act2])
    sage: AlgebraicTorus(LLL)
    Algebraic Torus of rank 3 defined by the following lattice :
    Ambient free module of rank 3 over the principal ideal domain Integer Ring
    and an action by the galois group of the form :
    Symmetric group of order 3! as a permutation group
    sage: T3=_


This is a non-split anisotropic torus with galois group of splitting field isomorphic to ``S_3``.::

    sage: SL = SubLattice(L, [2*L.basis()[0]])
    sage: AlgebraicTorus(SL)
    Algebraic Torus of rank 1 defined by the following lattice :
    Free module of degree 1 and rank 1 over Integer Ring
    Echelon basis matrix:
    [2]
    and an action by the galois group of the form :
    Permutation Group with generators [()]

This torus is obtained from the sublattice of the first lattice L. The torus obtained is isomorphic.





Attributes of a Torus
=====================

- ``torus._lattice`` -- the character lattice of the torus

- ``torus._base_field`` -- optional, the field over which the torus is defined.

- ``torus._splitting_field`` -- optional, a field over which the torus splits



Methods of a Torus
==================

- :meth:`AlgebraicTorus.rank` -- the rank of the torus.

- :meth:`AlgebraicTorus.galois_group` -- the galois group (as abstract group)
    of a splitting field of the torus.

- :meth:`AlgebraicTorus.character_lattice` -- the character lattice of the torus

- :meth:`AlgebraicTorus.cocharacter_lattice` -- the cocharacter lattice of the torus

- :meth:`AlgebraicTorus.is_rational` -- tests if a point is rational

- :meth:`AlgebraicTorus.Tate_Cohomology` -- the isomorphism
    type of Tate Cohomology groups of the Torus

- :meth:`AlgebraicTorus.restriction_of_scalars` -- returns the torus obtained by 
    estriction of scalars

- :meth:`AlgebraicTorus.norm_one_restriction_of_scalars` -- the torus of norm 1
elements in the restriction of scalars


"""

###########################################################################
#       Copyright (C) 2018 Thomas Rüd <tompa.rud@gmail.com>
#
#  Distributed under the terms of the GNU General Public License (GPL)
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# (at your option) any later version.
#                  http://www.gnu.org/licenses/
###########################################################################


from __future__ import print_function, absolute_import



from sage.schemes.generic.scheme import Scheme
from sage.categories.morphism import SetMorphism
from sage.matrix.action import MatrixMulAction
from sage.categories.action import PrecomposedAction
from six import integer_types
from sage.rings.integer_ring import ZZ
from sage.groups.perm_gps.permgroup import PermutationGroup
from sage.groups.perm_gps.permgroup_element import SymmetricGroupElement
from sage.categories.map import Map
from sage.modules.free_module import FreeModule_ambient_pid 
from sage.modules.free_module import FreeModule_generic
from sage.modules.free_module import FreeModule_submodule_pid
import sage.groups.libgap_group
import sage.matrix.matrix0
from sage.categories.homset import Hom
from sage.groups.matrix_gps.catalog import GL
from sage.libs.gap.element import GapElement
import sage.groups.libgap_wrapper 
import sage.groups.libgap_group
import sage.libs.gap.util
from sage.libs.gap.libgap import libgap
from sage.interfaces.gap import gap
from sage.matrix.constructor import matrix
from sage.groups.matrix_gps.group_element import MatrixGroupElement_gap
from sage.combinat.permutation import Permutation
from sage.matrix.matrix_space import MatrixSpace
from sage.groups.matrix_gps.finitely_generated import MatrixGroup
from sage.groups.perm_gps.permgroup import load_hap
from sage.matrix.special import block_matrix
from sage.matrix.matrix_integer_dense import Matrix_integer_dense
from sage.groups.matrix_gps.finitely_generated import FinitelyGeneratedMatrixGroup_gap




def extended_xgcd(lst,result=[1]):
    """
    Takes a list of integers, and gives a 2-tuple giving their gcd, and
    a list of Bezout coefficients

    INPUT:

    - ``lst`` -- the list of integers we want the gdc and Bezout coefficients.
    - ``result`` -- only used for recursion

    EXAMPLES::

        sage: extended_xgcd([6,20,15])
        (1, [21, -7, 1])
        sage: extended_xgcd([12,20,28,30])
        (2, [-14, 7, 0, 1])
    """

    if len(lst)==0:
        raise ValueError("Missing numbers to take the gcd")
    elif len(lst)==1:
        return (lst[0],result)
    else:
        a,b,c=xgcd(lst[0],lst[1])
        r=[b*i for i in result]
        return extended_xgcd([a]+[lst[i] for i in range(2,len(lst))],r+[c])


def remove_duplicates(lst):
    """
    Takes a list and returns a copy without duplicate elements.


    INPUT: 

    - ``lst`` -- the list we want to get the sublist of.


    EXAMPLES::
       
        sage: lst=[1,2,4,5,6,2,3,45,3,4,5,1]
        sage: remove_duplicates(lst)
        [1, 2, 4, 5, 6, 3, 45]

    ::

        sage: lst2=["hat","cat","bat","bat","cat","cat","cat"]
        sage: remove_duplicates(lst2)
        ['hat', 'cat', 'bat']
    """
    result=[]
    for i in lst:
        if not i in result:
            result.append(i)
    return result

def coset_matrix_group(g,subgroup,left_or_right="Left"):
    """
    Takes an element ``g`` of a matrix group ``G``, a subgroup ``H`` 
    and gives the list of elements corresponding to ``gH``

    INPUT:

    - ``g`` -- an element of the bigger group 

    - ``H`` -- the subgroup we want the coset of

    - ``left_or_right`` -- "Left" is the default option and returns the 
    left coset. Otherwise input "Right" for the right coset.

    EXAMPLES::

        sage: m1 = matrix(3, [0,0,1,-1,-1,-1,1,0,0])
        sage: m2 = matrix(3, [-1,0,0,0,-1,0,0,0,-1])
        sage: m3 = matrix(3, [0,1,0,1,0,0,-1,-1,-1])
        sage: G = MatrixGroup([m1,m2,m3])
        sage: H = MatrixGroup([m1])
        sage: coset_matrix_group(G.gens()[0],H)
        [
        [ 0  0  1]  [1 0 0]
        [-1 -1 -1]  [0 1 0]
        [ 1  0  0], [0 0 1]
        ]

    """
    if subgroup.order() is +Infinity: 
        raise ValueError("The matrix group has to be finite")

    elif left_or_right=="Left":
        return [g.matrix()*h.matrix() for h in subgroup]
    elif left_or_right=="Right":
        return [h.matrix()*g.matrix() for h in subgroup]
    else:
        raise ValueError("Failed to specity Left or Right in the third argument") 

def list_cosets_matrix_group(group,subgroup,left_or_right="Left"):
    """ 
    Returns the list of cosets of a subgroup of a matrix group.

    INPUT: 

    - ``group`` -- the matrix group we want to decompose into cosets

    - ``subgroup`` -- the subgroup we take cosets of

    - ``left_or_right`` -- "Left" if we want left cosets, "Right" for the 
        right cosets. Default value is "Left"
    

    EXAMPLES::

        sage: m1 = matrix(3, [0,0,1,-1,-1,-1,1,0,0])
        sage: m2 = matrix(3, [-1,0,0,0,-1,0,0,0,-1])
        sage: m3 = matrix(3, [0,1,0,1,0,0,-1,-1,-1])
        sage: G = MatrixGroup([m1,m2,m3])
        sage: H = MatrixGroup([m1])
        sage: list_cosets_matrix_group(G,H)
        [[
        [1 0 0]  [ 0  0  1]
        [0 1 0]  [-1 -1 -1]
        [0 0 1], [ 1  0  0]
        ],
         [
        [-1  0  0]  [ 0  0 -1]
        [ 0 -1  0]  [ 1  1  1]
        [ 0  0 -1], [-1  0  0]
        ],
         [
        [ 0 -1  0]  [ 1  1  1]
        [-1  0  0]  [ 0  0 -1]
        [ 1  1  1], [ 0 -1  0]
        ],
         [
        [ 0  1  0]  [-1 -1 -1]
        [ 1  0  0]  [ 0  0  1]
        [-1 -1 -1], [ 0  1  0]
        ]]

    ::

        sage: H2 = MatrixGroup([m1,m2])
        sage: list_cosets_matrix_group(G,H2)
        [[
        [1 0 0]  [-1  0  0]  [ 0  0  1]  [ 0  0 -1]
        [0 1 0]  [ 0 -1  0]  [-1 -1 -1]  [ 1  1  1]
        [0 0 1], [ 0  0 -1], [ 1  0  0], [-1  0  0]
        ],
         [
        [ 0 -1  0]  [ 0  1  0]  [ 1  1  1]  [-1 -1 -1]
        [-1  0  0]  [ 1  0  0]  [ 0  0 -1]  [ 0  0  1]
        [ 1  1  1], [-1 -1 -1], [ 0 -1  0], [ 0  1  0]
        ]]


    """

    incl_elements=[]
    result=[]
    coset_builder=[]
    for g in group:
        if not g.matrix() in incl_elements:
            for h in subgroup: 
                if left_or_right=="Left":
                    coset_builder.append(g.matrix()*h.matrix())
                elif left_or_right=="Right":
                    coset_builder.append(h.matrix()*g.matrix())
                else:
                    raise ValueError("the only possible options for the third argument are Left, Right, or it should be left blank")
            incl_elements+=coset_builder
            result.append(coset_builder)
            coset_builder=[]
    return result



###############################################################################
#
# Base class for all group schemes
#
###############################################################################


def is_GroupScheme(X):
    """
    Returns True if X inherits from GroupScheme

    INPUT:

    - ``X`` -- an object we want to test.

    EXAMPLES::

        sage: X1=GroupScheme()
        sage: X2 = Scheme()
        sage: is_GroupScheme(X1)
        True
        sage: is_GroupScheme(X2)
        False

    ::

        sage: L = Lattice_ambient(PermutationGroup([()]), 1)
        sage: is_GroupScheme(L)
        False
        sage: T = AlgebraicTorus(L)
        sage: is_GroupScheme(T)
        True

    """
    return isinstance(X,GroupScheme)



class GroupScheme(Scheme):
    """Group_scheme"""
    def __init__(self, X=None):
        r"""
        Creates a group scheme from a scheme.
        
        INPUT:

        -``X`` -- Can be None for ``\mathrm{Spec}(\ZZ)``, or a scheme, 
            scheme morphism or a commutative ring.

        NOTE::

            Currently, this class is just a particular scheme, with 
            no explicit extra structure. 

        EXAMPLES::

            sage: GroupScheme()
            <__main__.GroupScheme_with_category object at 0x7f1499aa4148>

        """
        Scheme.__init__(self,X)
        








class GAPMap_toGLn(Map):
    r"""
    Sage Map class for a group homomorphism to ``GL(n,\ZZ)`` in GAP

    """

    def __init__(self, group,rank, hom):
        """
        Contruct a map

        INPUT:

        - ``group`` -- The domain of the homomorphism

        - ``rank`` -- The rank of the target matrix group

        - ``hom`` -- The group homomorphism as a GAP object


        EXAMPLES::


            sage: L1._action
            Left action by Full MatrixSpace of 3 by 3 dense matrices over Integer Ring on Ambient free module of rank 3 over the principal ideal domain Integer Ring
            with precomposition on left by Composite map:
              From: Permutation Group with generators [(3,4,5), (1,2)]
              To:   Full MatrixSpace of 3 by 3 dense matrices over Integer Ring
              Defn:   Generic map:
                      From: Permutation Group with generators [(3,4,5), (1,2)]
                      To:   General Linear Group of degree 3 over Integer Ring
                    then
                      Coercion morphism:
                      From: General Linear Group of degree 3 over Integer Ring
                      To:   Full MatrixSpace of 3 by 3 dense matrices over Integer Ring


        """

        Map.__init__(self,Hom(group,GL(rank,ZZ)))
        self._morphism=hom
        self._domain=group
        self._codomain=GL(rank,ZZ)
    def _call_(self,element):
        if element is tuple:
            Elt = Permutation(element)
        else:
            Elt=element
        return matrix((gap.Image(self._morphism,Elt)).sage())
        




###############################################################################
#
# Base class for all lattices
#
###############################################################################




class Lattice_generic(FreeModule_generic):
    """
    Generic classes for all lattices
    """



    def __init__(self, galois, action=1, check = True):
        """
        Constructs  a generic lattice.

        INPUT:

        - ``galois`` -- the permutation group acting on the lattice (often the galois group of 
        an algebraic group hence the name). It can be a list of matrices or matrix group, 
        or even a list of integers corresponding to the isomorphism type of a finite abelian
        group.

        - ``action`` -- action of the group on the lattice. Can be an integer for the 
        trivial action on the standard lattice of dimension that number, or a set of 
        matrices, one for each generator, or left blank if we declare the group with matrices.

        - ``check`` -- boolean, by default True, in which case we check that the action is 
        compatible with the group structure.


        EXAMPLES::

            sage: Lattice_ambient(SymmetricGroup(3), 5)
            Ambient free module of rank 5 over the principal ideal domain Integer Ring
            sage: L=_
            sage: a,b,c,d,e = L.basis()
                
        ::

            sage: SubLattice(L, [a,b,c+d+e])
            Free module of degree 5 and rank 3 over Integer Ring
            Echelon basis matrix:
            [1 0 0 0 0]
            [0 1 0 0 0]
            [0 0 1 1 1]

        ::

            sage: act1 = matrix(3, [0,1,0,0,0,1,1,0,0])
            sage: act2 = matrix.identity(3)
            sage: G = PermutationGroup([(1,2), (3,4,5)])
            sage: Lattice_ambient(G, [act1,act2])
            Ambient free module of rank 3 over the principal ideal domain Integer Ring

        ::

            sage: m1 = matrix(3, [0,0,1,-1,-1,-1,1,0,0])
            sage: m2 = matrix(3, [-1,0,0,0,-1,0,0,0,-1])
            sage: m3 = matrix(3, [0,1,0,1,0,0,-1,-1,-1])
            sage: Lattice_ambient([m1,m2,m3])
            Ambient free module of rank 3 over the principal ideal domain Integer Ring        
        
        ::

            sage: H = MatrixGroup([m1,m2,m3])
            sage: Lattice_ambient(H)
            Ambient free module of rank 3 over the principal ideal domain Integer Ring

        """

        if type(galois)==list and type(galois[0]) is Integer:
            counter=1
            perms=[]
            for i in galois: 
                perms.append([j for j in range(counter,counter+i)])
                counter+=i
                group = PermutationGroup([tuple(k) for k in perms])
                self.__init__(group,action,check)
        elif type(galois)==list and type(galois[0]) is Matrix_integer_dense:
            gp = MatrixGroup(galois)
            self.__init__(gp)
            #self._group = MatrixGroup(galois)
            #self._generators=galois
            #self._rank = galois[0].nrows()
            #self._action_matrices=galois
            #FreeModule_generic.__init__(self,ZZ,self._rank,self._rank)
            #A=libgap(galois)
            #G=gap.GroupByGenerators(A)
            #self._action_morphism=gap.GroupHomomorphismByImages(G,G,A,A)
        elif isinstance(galois,FinitelyGeneratedMatrixGroup_gap):
            gapgroup=gap.Group([i.gap() for i in galois.gens()])
            iso = gap.IsomorphismPermGroup(gapgroup)
            permg=gap.Image(iso)
            genperm=gap.GeneratorsOfGroup(permg)
            goodgp = PermutationGroup(genperm)
            mats=gap.PreImage(iso,goodgp.gens())
            act=[matrix(i) for i in mats.sage()]
            self.__init__(goodgp,act)
        else:
            self._group=galois
            self._generators=galois.gens()
            if action  in ZZ: 
                FreeModule_generic.__init__(self,ZZ,action,action)
                self._rank=action
                self._action_matrices=[matrix.identity(action) for i in range(len(self._generators))]
            elif not len(action):
                raise ValueError('The module is missing the action of the Galois group.')
            else:
                self._action_matrices=action    
                for x in action: 
                    if not x.nrows()==x.ncols():
                        raise ValueError('The matrices for the action need to be squares.')
                    elif not x.nrows()==action[0].nrows(): 
                        raise ValueError('The matrices fot the action need to have same dimension.')
                    elif not x in GL(action[0].nrows(),ZZ):
                     raise ValueError('The matrices need to be invertible in ZZ.')
                    else:
                        self._rank=action[0].nrows()
                        FreeModule_generic.__init__(self,ZZ,self._rank,self._rank)
                if not len(self._generators)==len(action):
                    raise ValueError('The number of action matrices needs to match the number of generators of the Galois group.')
            G=gap(self._group) 
            GenG=gap(self._generators)
            Mats=gap(self._action_matrices)
            if self._rank==1: 
                gl=gap.Group([ [ [ -1 ] ] ])
            else:
                gl=gap.GL(self._rank,ZZ)
            self._action_morphism=gap.GroupHomomorphismByImages(G,gl,GenG,Mats)
            if check and gap.IsBool(self._action_morphism):
                raise ValueError('The action is not well defined') 

        self._GAPMap=GAPMap_toGLn(self._group,self._rank,self._action_morphism)
        MZ = MatrixSpace(ZZ,self._rank)
        A=MZ.get_action(self)
        self._action=PrecomposedAction(A,self._GAPMap,None)
    def _act(self,g,e):
        """
        Computes the action of the group_element on a lattice element::
        
        INPUT:

        - ``g`` -- an element of the group acting on the lattice.

        - ``e`` -- an element of the lattice we wish to compute the action for.

        EXAMPLES::
            
            sage: G = PermutationGroup([(1,2), (3,4,5)])
            sage: act1 = matrix(3, [0,1,0,0,0,1,1,0,0])
            sage: act2 = matrix.identity(3)
            sage: L1 = Lattice_ambient(G, [act1,act2])
            sage: L1._act(L1.group()[1], L1.basis()[0])
            (0, 0, 1)

        ::

            sage: L2 = Lattice_ambient(PermutationGroup([(2,3), (1,6,3), (7,6,4,5)]), 1)
            sage: L2._act(L2.group()[1], L2.basis()[0])
            (1, 0, 0, 0)
        """
        return  self._action.act(g,e)






    ##### METHODS FOR LATTICES WITH GROUP ACTIONS######
    def group(self):
        """
        Returns the group associated with the lattice.


        EXAMPLES::

            sage: L1 = Lattice_ambient(SymmetricGroup(3), 5)
            sage: L1.group()
            Symmetric group of order 3! as a permutation group

        ::

            sage: L2 = Lattice_ambient(PermutationGroup([(2,3), (1,6,3), (7,6,4,5)]), 1)
            sage: L2.group()
            Permutation Group with generators [(4,5,7,6), (2,3), (1,6,3)]

        ::

            sage: L3 = Lattice_ambient([-matrix.identity(3)])
            sage: L3.group()
            Matrix group over Integer Ring with 1 generators (
            [-1  0  0]
            [ 0 -1  0]
            [ 0  0 -1]
            )
        """
        return self._group


    def subgroup_lattice(self,subgp):
        """
        Changes the group acting on the lattice to a subgroup.


        INPUT:

        - ``subgp`` -- the subgroup we wish to restrict the lattice to


        EXAMPLES::

            sage: G = SymmetricGroup(4)
            sage: H = DihedralGroup(4)
            sage: L = Lattice_ambient(G, 5)
            sage: L.subgroup_lattice(H)
            Ambient free module of rank 5 over the principal ideal domain Integer Ring
            sage: _._group
            Dihedral group of order 8 as a permutation group


        """
        return subgroup_lattice(self,subgp)

    def parent_lattice(self):
        return self.parent_lattice()


    def rational_characters(self):
        """
        Computes the rational charactesr over the base field, in other words the sublattice of elements fixed by the group.
        
        EXAMPLES::

            sage: G = PermutationGroup([(1,2),(3,4),(5,6),(7,8)])
            sage: L = Lattice_ambient(PermutationGroup([()]), 1)
            sage: IL = L.induced_lattice(G)
            sage: ROS = L.norm_one_restriction_of_scalars(G)
            
        ::

            sage: IL.rational_characters()
            Free module of degree 16 and rank 1 over Integer Ring
            Echelon basis matrix:
            [1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1]
            sage: ROS.rational_characters()
            Free module of degree 15 and rank 0 over Integer Ring
            Echelon basis matrix:
            []
            sage: L.rational_characters()
            Free module of degree 1 and rank 1 over Integer Ring
            Echelon basis matrix:
            [1]
        """

        kers=[kernel(m-matrix.identity(self._rank)) for m in self._action_matrices]
        res=self
        for i in kers: 
            res=res.intersection(i)
        return res

    def isomorphic_ambient_lattice(self):
        """
        Returns an isomorphic ambient lattice.


            NOTE::

                For ambient lattices it just returns the lattice itself, this method is motsly useful for sublattices.

            EXAMPLES::
                
                sage: G = PermutationGroup([(1,2), (3,4,5)])
                sage: act1 = matrix(3, [0,1,0,0,0,1,1,0,0])
                sage: act2 = matrix.identity(3)
                sage: L1 = Lattice_ambient(G, [act1,act2])
                
            ::

                sage: x, y, z = L1.basis()
                sage: SL = SubLattice(L1, [x-y, y-z])
                sage: L1.isomorphic_ambient_lattice() is L1
                True
                sage: X = SL.isomorphic_ambient_lattice(); X
                Ambient free module of rank 2 over the principal ideal domain Integer Ring
                sage: X._action_matrices
                [
                [ 0 -1]  [1 0]
                [ 1 -1], [0 1]
                ]

            ::

                sage: L = Lattice_ambient(SymmetricGroup(2), [matrix([[0,1], [1,0]])])
                sage: x, y = L.basis()
                sage: SL = SubLattice(L, [x+y])
                sage: X = SL.isomorphic_ambient_lattice(); X
                Ambient free module of rank 1 over the principal ideal domain Integer Ring
                sage: X.basis()
                [
                (1)
                ]
                sage: X._action_matrices
                [[1]]
        """
        return self.isomorphic_ambient_lattice()

    def GAPMatrixGroup(self):
        """
        The image of the action of the group inside 
        ``GL(rank,ZZ)`` as a GAP group::
        

        EXAMPLES::
            sage: G = PermutationGroup([(1,2), (3,4,5)])
            sage: act1 = matrix(3, [0,1,0,0,0,1,1,0,0])
            sage: act2 = matrix.identity(3)
            sage: L1 = Lattice_ambient(G, [act1,act2])
            sage: L1.GAPMatrixGroup()
            Group([ [ [ 0, 1, 0 ], [ 0, 0, 1 ], [ 1, 0, 0 ] ],
              [ [ 1, 0, 0 ], [ 0, 1, 0 ], [ 0, 0, 1 ] ] ])

        ::

            sage: L2 = Lattice_ambient(PermutationGroup([(2,3), (1,6,3), (7,6,4,5)]), 1)
            sage: L2.GAPMatrixGroup()
            Group([ [ [ 1, 0, 0, 0 ], [ 0, 1, 0, 0 ], [ 0, 0, 1, 0 ], [ 0, 0, 0, 1 ] ],
              [ [ 1, 0, 0, 0 ], [ 0, 1, 0, 0 ], [ 0, 0, 1, 0 ], [ 0, 0, 0, 1 ] ] ])
        
        ::

            sage: m1 = matrix(3, [0,0,1,-1,-1,-1,1,0,0])
            sage: m2 = matrix(3, [-1,0,0,0,-1,0,0,0,-1])
            sage: m3 = matrix(3, [0,1,0,1,0,0,-1,-1,-1])
            sage: L3 = Lattice_ambient([m1,m2,m3])
            sage: L3.GAPMatrixGroup()
            Group([ [ [ 0, 0, 1 ], [ -1, -1, -1 ], [ 1, 0, 0 ] ],
              [ [ -1, 0, 0 ], [ 0, -1, 0 ], [ 0, 0, -1 ] ],
              [ [ 0, 1, 0 ], [ 1, 0, 0 ], [ -1, -1, -1 ] ] ])
        """
        f=self._GAPMap
        return gap.Image(f._morphism)


    def colattice(self):
        """
        Outputs the lattice with action of the same group, but its action is 
        composed with the inverse transpose automorphism of ``GL(n,ZZ)``


        EXAMPLES::

            sage: L = Lattice_ambient(CyclicPermutationGroup(6), [matrix([[0,1], [-1,-1]])])
            sage: L._action_matrices
            [
            [ 0  1]
            [-1 -1]
            ]
            sage: L.colattice()._action_matrices
            [
            [-1  1]
            [-1  0]
            ]
        """
        newacts = [ i.inverse().transpose() for i in self._action_matrices]
        return Lattice_ambient(self._group,newacts)
    

    def Tate_Cohomology(self,n):
        """
        Returns the isomorphism type of the `n`-th Tate cohomology group.

        INPUT:

        - ``n`` -- the index of the cohomology group to compute.


        EXAMPLES::

            sage: G = PermutationGroup([(1,2), (3,4,5)])
            sage: act1 = matrix(3, [0,1,0,0,0,1,1,0,0])
            sage: act2 = matrix.identity(3)
            sage: L1 = Lattice_ambient(G, [act1, act2])
            sage: for i in range(-5, 6): 
            ....:     print("H^"+str(i)+" : ") , L1.Tate_Cohomology(i)
            H^-5 :  []
            H^-4 :  [2]
            H^-3 :  []
            H^-2 :  [2]
            H^-1 :  []
            H^0 :  [2]
            H^1 :  []
            H^2 :  [2]
            H^3 :  []
            H^4 :  [2]
            H^5 :  []

        ::


            sage: L2 = Lattice_ambient(SymmetricGroup(3), 4)
            sage: for i in range(-5, 6) : 
            ....:     print("H^"+str(i)+" : ") , L2.Tate_Cohomology(i)
            H^-5 :  []
            H^-4 :  [6, 6, 6, 6]
            H^-3 :  []
            H^-2 :  [2, 2, 2, 2]
            H^-1 :  []
            H^0 :  [6, 6, 6, 6]
            H^1 :  []
            H^2 :  [2, 2, 2, 2]
            H^3 :  []
            H^4 :  [6, 6, 6, 6]
            H^5 :  []


        ::

            sage: m1 = matrix(3, [0,0,1,-1,-1,-1,1,0,0])
            sage: m2 = matrix(3, [-1,0,0,0,-1,0,0,0,-1])
            sage: m3 = matrix(3, [0,1,0,1,0,0,-1,-1,-1])
            sage: L3 = Lattice_ambient([m1,m2,m3])
            sage: for i in range(-5, 6) : 
            ....:     print("H^"+str(i)+" : ") , L3.Tate_Cohomology(i)  
            H^-5 :  [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]
            H^-4 :  [2, 2, 2, 2, 2, 2, 2, 2]
            H^-3 :  [2, 2, 2, 2, 2, 2]
            H^-2 :  [2, 2, 2]
            H^-1 :  [2]
            H^0 :  []
            H^1 :  [2]
            H^2 :  [2]
            H^3 :  [2, 2, 2]
            H^4 :  [2, 2, 2, 2]
            H^5 :  [2, 2, 2, 2, 2, 2, 2]
        """
        return self.Tate_Cohomology(n)

    def induced_lattice(self,group,build = True):
        """
        The ambient lattice obtained by inducing the representation of
        the group to a bigger group.

        INPUT:

        - ``group`` -- a group containing the group for this lattice.

        - ``build`` -- boolean (default True).  If False, just returns the matrices
           that define the action on the induced lattice but doesn't build the lattice.

        NOTE::

            This is not yet implemented when a lattice is declared with a matrix group since
            Sage doesn't handle cosets for matrix groups.

        EXAMPLES::

            sage: G = PermutationGroup([(1,2), (3,4,5)])
            sage: act1 = matrix(3, [0,1,0,0,0,1,1,0,0])
            sage: act2 = matrix(3, [1,0,0,0,1,0,0,0,1])
            sage: L1 = Lattice_ambient(G, [act1, act2])
            sage: L1.induced_lattice(SymmetricGroup(5))
            Ambient free module of rank 60 over the principal ideal domain Integer Ring

            sage: L2 = Lattice_ambient(SymmetricGroup(3), 4)
            sage: L2.induced_lattice(SymmetricGroup(4), False)
            [
            [0 0 0 0|0 0 0 0|0 0 0 0|1 0 0 0]  [1 0 0 0|0 0 0 0|0 0 0 0|0 0 0 0]
            [0 0 0 0|0 0 0 0|0 0 0 0|0 1 0 0]  [0 1 0 0|0 0 0 0|0 0 0 0|0 0 0 0]
            [0 0 0 0|0 0 0 0|0 0 0 0|0 0 1 0]  [0 0 1 0|0 0 0 0|0 0 0 0|0 0 0 0]
            [0 0 0 0|0 0 0 0|0 0 0 0|0 0 0 1]  [0 0 0 1|0 0 0 0|0 0 0 0|0 0 0 0]
            [-------+-------+-------+-------]  [-------+-------+-------+-------]
            [1 0 0 0|0 0 0 0|0 0 0 0|0 0 0 0]  [0 0 0 0|1 0 0 0|0 0 0 0|0 0 0 0]
            [0 1 0 0|0 0 0 0|0 0 0 0|0 0 0 0]  [0 0 0 0|0 1 0 0|0 0 0 0|0 0 0 0]
            [0 0 1 0|0 0 0 0|0 0 0 0|0 0 0 0]  [0 0 0 0|0 0 1 0|0 0 0 0|0 0 0 0]
            [0 0 0 1|0 0 0 0|0 0 0 0|0 0 0 0]  [0 0 0 0|0 0 0 1|0 0 0 0|0 0 0 0]
            [-------+-------+-------+-------]  [-------+-------+-------+-------]
            [0 0 0 0|1 0 0 0|0 0 0 0|0 0 0 0]  [0 0 0 0|0 0 0 0|0 0 0 0|1 0 0 0]
            [0 0 0 0|0 1 0 0|0 0 0 0|0 0 0 0]  [0 0 0 0|0 0 0 0|0 0 0 0|0 1 0 0]
            [0 0 0 0|0 0 1 0|0 0 0 0|0 0 0 0]  [0 0 0 0|0 0 0 0|0 0 0 0|0 0 1 0]
            [0 0 0 0|0 0 0 1|0 0 0 0|0 0 0 0]  [0 0 0 0|0 0 0 0|0 0 0 0|0 0 0 1]
            [-------+-------+-------+-------]  [-------+-------+-------+-------]
            [0 0 0 0|0 0 0 0|1 0 0 0|0 0 0 0]  [0 0 0 0|0 0 0 0|1 0 0 0|0 0 0 0]
            [0 0 0 0|0 0 0 0|0 1 0 0|0 0 0 0]  [0 0 0 0|0 0 0 0|0 1 0 0|0 0 0 0]
            [0 0 0 0|0 0 0 0|0 0 1 0|0 0 0 0]  [0 0 0 0|0 0 0 0|0 0 1 0|0 0 0 0]
            [0 0 0 0|0 0 0 0|0 0 0 1|0 0 0 0], [0 0 0 0|0 0 0 0|0 0 0 1|0 0 0 0]
            ]
        """
        return self.induced_lattice(group, build)

    def zero_sum_sublattice(self,ambient=False):
        r"""
        Returns the sublattice of elements with coordinates summing up to zero.
      
        INPUT:

        - ``ambient`` -- Boolean, if ambient is True the algorithm will give
        an ambient lattice isomorphic to the zero sum sublattice. If False or
        left blank, it will give the sublattice of zero sum vectors.
        (default option is True)


        NOTE::

            The zero sum sublattice is not necessarily stable under the group
            action, as the last example will illustrate.



        EXAMPLES::
            
            sage: G = PermutationGroup([(1,2), (3,4,5)])
            sage: act1 = matrix(3, [0,1,0,0,0,1,1,0,0])
            sage: act2 = matrix(3, [1,0,0,0,1,0,0,0,1])
            sage: L1 = Lattice_ambient(G, [act1, act2])
            sage: L2 = Lattice_ambient(SymmetricGroup(3), 4)
            
        ::

            sage: L1.zero_sum_sublattice()
            Free module of degree 3 and rank 2 over Integer Ring
            Echelon basis matrix:
            [ 1  0 -1]
            [ 0  1 -1]
            sage: L2.zero_sum_sublattice()
            Free module of degree 4 and rank 3 over Integer Ring
            Echelon basis matrix:
            [ 1  0  0 -1]
            [ 0  1  0 -1]
            [ 0  0  1 -1]


        We can make them directly ambient lattices::


            sage: L1.zero_sum_sublattice(True)
            Ambient free module of rank 2 over the principal ideal domain Integer Ring
            sage: _._action_matrices
            [
            [ 0  1]  [1 0]
            [-1 -1], [0 1]
            ]
            sage: L2.zero_sum_sublattice(True)
            Ambient free module of rank 3 over the principal ideal domain Integer Ring
            sage: _._action_matrices
            [
            [1 0 0]  [1 0 0]
            [0 1 0]  [0 1 0]
            [0 0 1], [0 0 1]
            ]


        Now we decide not to transform it into an ambient lattice, but to create the sublattice of
        zero sum vectors.::


            sage: L = Lattice_ambient(SymmetricGroup(3), 5)
            sage: L.zero_sum_sublattice()
            Free module of degree 5 and rank 4 over Integer Ring
            Echelon basis matrix:
            [ 1  0  0  0 -1]
            [ 0  1  0  0 -1]
            [ 0  0  1  0 -1]
            [ 0  0  0  1 -1]
            sage: L.zero_sum_sublattice().zero_sum_sublattice()
            Free module of degree 5 and rank 4 over Integer Ring
            Echelon basis matrix:
            [ 1  0  0  0 -1]
            [ 0  1  0  0 -1]
            [ 0  0  1  0 -1]
            [ 0  0  0  1 -1]
            sage: L.zero_sum_sublattice(True).zero_sum_sublattice(True)
            Ambient free module of rank 3 over the principal ideal domain Integer Ring

        Here we see that the zero sum sublattice of the zero sum sublattice is itself, 
        which is not the case when we return an ambient ambient lattice.::

            sage: L = Lattice_ambient(SymmetricGroup(3), 5)
            sage: SL = SubLattice(L, [L.basis()[2]+3*L.basis()[4], 5*L.basis()[0]+L.basis()[1], L.basis()[1]+6*L.basi
            ....: s()[3]])
            sage: SL
            Free module of degree 5 and rank 4 over Integer Ring
            Echelon basis matrix:
            [ 1  0  0  0 -1]
            [ 0  1  0  0 -1]
            [ 0  0  1  0 -1]
            [ 0  0  0  1 -1]
            sage: SL.zero_sum_sublattice()
            Free module of degree 5 and rank 2 over Integer Ring
            Echelon basis matrix:
            [  5   3  -5  12 -15]
            [  0   4  -7  24 -21]
        

        Here is an example of lattice whose zero sum submodule over ``\ZZ``
        is not stable under the group action::

            sage: G = SymmetricGroup(2)
            sage: m = matrix(2, [-1,0,0,1])
            sage: L = Lattice_ambient(G, [m])
            sage: L.zero_sum_sublattice()
            ...
            ValueError: The basis is not stable under the action of the group




        """
        return self.zero_sum_sublattice(ambient)
    

    def norm_one_restriction_of_scalars(self,group,ambient = True):
        """
        Combines the induction and zero sum methods to return the character 
        lattice corresponding to a norm 1 restriction of scalars of a Torus.

        INPUT:

        - ``group`` -- the group used for the induction, when restricting scalars.

        - ``ambient`` -- boolean, will construct an isomorphic ambient lattice if true,
        otherwise it will give the sublattice of the restriction of scalars.

        NOTE::

            Note that this method involves taking a zero sum submodule, which needs not be 
            stable under the action of the group.
       
        EXAMPLES::

            sage: G = PermutationGroup([(1,2), (3,4,5)])
            sage: act1 = matrix(3, [0,1,0,0,0,1,1,0,0])
            sage: act2 = matrix(3, [1,0,0,0,1,0,0,0,1])
            sage: L1 = Lattice_ambient(G, [act1, act2])
            sage: L1.norm_one_restriction_of_scalars(SymmetricGroup(5))
            Free module of degree 3 and rank 2 over Integer Ring
            Echelon basis matrix:
            [ 1  0 -1]
            [ 0  1 -1]
            
        ::

            sage: L2 = Lattice_ambient(SymmetricGroup(3), 4)
            sage: L2.norm_one_restriction_of_scalars(SymmetricGroup(4))
            Free module of degree 4 and rank 3 over Integer Ring
            Echelon basis matrix:
            [ 1  0  0 -1]
            [ 0  1  0 -1]
            [ 0  0  1 -1]

        We can check the actions on each norm one restriction

            sage: L1.norm_one_restriction_of_scalars(SymmetricGroup(5))
            Free module of degree 3 and rank 2 over Integer Ring
            Echelon basis matrix:
            [ 1  0 -1]
            [ 0  1 -1]
            sage: L2.norm_one_restriction_of_scalars(SymmetricGroup(4))
            Free module of degree 4 and rank 3 over Integer Ring
            Echelon basis matrix:
            [ 1  0  0 -1]
            [ 0  1  0 -1]
            [ 0  0  1 -1]
        """

        return self.norm_one_restriction_of_scalars(self,group,ambient)

    def quotient_ambient_sublattice(self,sublattice,check=True):
        """
        Computes the quotient of an ambient lattice by a saturated proper sublattice.

        INPUT:

        - ``sublattice`` -- sublattice by which we want to quotient

        - ``check`` -- boolean, true if one wants to check that the 
            sublattice is saturated and proper

        EXAMPLES::

            sage: L = Lattice_ambient(PermutationGroup([()]), 2)
            sage: LL = Lattice_ambient(SymmetricGroup(3), 5)
            sage: IL = L.induced_lattice(G)
            sage: ROS = IL.zero_sum_sublattice()
            sage: SL = SubLattice(LL,[LL.basis()[0],LL.basis()[1]+LL.basis()[2],LL.basis()[4]])
            
            ::

            sage: LL.quotient_ambient_sublattice(SL)
            Ambient free module of rank 2 over the principal ideal domain Integer Ring
            sage: _._action_matrices
            [
            [1 0]
            [0 1]
            ]

            ::

            sage: IL.quotient_ambient_sublattice(ROS)
            Ambient free module of rank 1 over the principal ideal domain Integer Ring
            sage: _._action_matrices
            [[1]]

        """

        M=matrix(sublattice.basis()).transpose()

        SM=M.smith_form()
        #M is a matrix taking vectors in the basis of the sublattice and giving their vector in the ambient lattice.


        if check and ((not SM[0][M.ncols()-1,M.ncols()-1]==1) or sublattice.rank()==self.rank()):
            raise ValueError("The sublattice is not saturated or not proper"    ) 
        

        P=SM[1]

        # P is a matrix such that there is a matrix with PMQ diagonal with 1's on the diagonal

        Pi=P.inverse()
        # if r is the rank of the sublattice,
        # The columns of Pi are vectors of  a basis of the ambient lattice where the first r are a basis of the sublattice, and the rest 
        # are a basis of the complement (it is the complement as a Z-module, but need not be stable under the action of the group)

        index = range(sublattice.rank(),self.rank())
        v=Pi[range(self.rank()),index]

 
        A = [(P*i*v)[index] for i in self._action_matrices]
        # This computes the action on the vectors of the complement of the sublattice
        return Lattice_ambient(self.group(),A)

 

    def quotient_lattice(self,sublattice,check=True):


        """
        Returns an ambient lattice isomorphic to the quotient of two lattices.
        Slightly slower than quotient_ambient_lattice for ambient lattices



        INPUT:

            - ``sublattice`` -- sublattice by which we want to quotient

            - ``check`` -- boolean, true if one wants to check that the 
                sublattice is saturated and proper


        EXAMPLES::

            sage: m=matrix([[0,0,0,0,0,1],[0,0,0,0,1,0],[0,0,0,1,0,0],[0,0,1,0,0,0],[0,1,0,0,
            ....: ....: 0,0],[1,0,0,0,0,0]])
            sage: L=Lattice_ambient([2],[m]);L._action_matrices
            [
            [0 0 0 0 0 1]
            [0 0 0 0 1 0]
            [0 0 0 1 0 0]
            [0 0 1 0 0 0]
            [0 1 0 0 0 0]
            [1 0 0 0 0 0]
            ]
            sage: B=L.basis()
            sage: SL=SubLattice(L,[B[1],B[2],B[3],B[4]])
            sage: SSL=SubLattice(SL,[B[2],B[3]])
            sage: SSSL1=SubLattice(SSL,[B[2]+B[3]])
            sage: SSSL2=SubLattice(SSL,[B[2]-B[3]])

        ::

            sage: Q1 = L.quotient_lattice(SL); Q1; Q1._action_matrices
            Ambient free module of rank 2 over the principal ideal domain Integer Ring
            [
            [0 1]
            [1 0]
            ]
            sage: Q2 = L.quotient_lattice(SSSL1); Q2; Q2._action_matrices
            Ambient free module of rank 5 over the principal ideal domain Integer Ring
            [
            [ 0  0  0  1  0]
            [ 0  0  0  0 -1]
            [ 0  0 -1  0  0]
            [ 1  0  0  0  0]
            [ 0 -1  0  0  0]
            ]
            sage: Q3=  SL.quotient_lattice(SSL); Q3; Q3._action_matrices
            Ambient free module of rank 2 over the principal ideal domain Integer Ring
            [
            [0 1]
            [1 0]
            ]
            sage: Q4 = SL.quotient_lattice(SSSL1); Q4; Q4._action_matrices
            Ambient free module of rank 3 over the principal ideal domain Integer Ring
            [
            [ 0  0 -1]
            [ 0 -1  0]
            [-1  0  0]
            ]
            sage: Q5 = SL.quotient_lattice(SSSL2); Q5; Q5._action_matrices
            Ambient free module of rank 3 over the principal ideal domain Integer Ring
            [
            [ 0  0 -1]
            [ 0  1  0]
            [-1  0  0]
            ]
            sage: Q6 = SSL.quotient_lattice(SSSL1); Q6; Q6._action_matrices
            Ambient free module of rank 1 over the principal ideal domain Integer Ring
            [[-1]]
            sage: Q7 = SSL.quotient_lattice(SSSL2); Q7; Q7._action_matrices
            Ambient free module of rank 1 over the principal ideal domain Integer Ring
            [[1]]
            

        """
        oldBasis=self.basis()
        act_builder=[]
        for g in self._group.gens():
            mat_builder=[]
            for i in oldBasis:
                mat_builder.append(self.coordinate_vector(self._act(g,i)))
            act_builder.append(matrix(mat_builder))



        M=matrix([self.coordinate_vector(i) for i in sublattice.basis()]).transpose()

        SM=M.smith_form()

        if check and ((not SM[0][M.ncols()-1,M.ncols()-1]==1) or sublattice.rank()==self.rank()):
            raise ValueError("The sublattice is not saturated or not proper"    ) 
        
      
        P=SM[1]

        Pi=P.inverse()

        index = range(sublattice.rank(),self.rank())

        v=Pi[range(self.rank()),index]

        A = [(P*i*v)[index] for i in act_builder]

        # This computes the action on the vectors of the complement of the sublattice
        return Lattice_ambient(self.group(),A)


class Lattice_ambient(FreeModule_ambient_pid,Lattice_generic):
    """
    Class for ambient lattices.
    """

    def __init__(self, galois, action=1, check = True):
        r"""
        Constructs an ambient lattice.

        INPUT:

        - ``galois`` -- the group acting on the lattice, either permutation
            group or finite sugroup of ``GL(n,\ZZ)`` for some n. It can be a list
            of integers for a finite abelian group of that type.
        
        - ``action`` -- the list of matrices by which the generators of the group
            act, or an integer for the trivial action on the ambient free 
            ``\ZZ`` module of that rank.
        
        - ``check`` -- boolean, defaults to True in which case we test if the action
            is well defined.


        EXAMPLES ::
 
            sage: Lattice_ambient(G, [act1,act2])
            Ambient free module of rank 3 over the principal ideal domain Integer Ring
            
        ::

            sage: act1 = matrix(3, [0,1,0,0,0,1,1,0,0])
            sage: act2 = matrix.identity(3)
            sage: G = PermutationGroup([(1,2), (3,4,5)])
            sage: Lattice_ambient(G, [act1,act2])
            Ambient free module of rank 3 over the principal ideal domain Integer Ring
        
        ::

            sage: m1 = matrix(3, [0,0,1,-1,-1,-1,1,0,0])
            sage: m2 = matrix(3, [-1,0,0,0,-1,0,0,0,-1])
            sage: m3 = matrix(3, [0,1,0,1,0,0,-1,-1,-1])
            sage: Lattice_ambient([m1,m2,m3])
            Ambient free module of rank 3 over the principal ideal domain Integer Ring



        """
        Lattice_generic.__init__(self,galois,action,check)
        FreeModule_ambient_pid.__init__(self,ZZ,self._rank)

    def subgroup_lattice(self, subgp):
        """
        Restrict the group acting on the lattice to a subgroup


        INPUT:

        - ``subgp`` -- the subgroup we want to restrict the lattice to


        EXAMPLES::



            sage: G = SymmetricGroup(3)
            sage: H = CyclicPermutationGroup(3)
            sage: m1 = matrix(3, [0,1,0,0,0,1,1,0,0])
            sage: m2 = matrix(3, [0,1,0,1,0,0,0,0,1])
            sage: L = Lattice_ambient(G, [m1,m2])
            sage: L1 = Lattice_ambient(G, [m1,m2])

        ::

            sage: L2 = L1.subgroup_lattice(H); L2
            Ambient free module of rank 3 over the principal ideal domain Integer Ring
            sage: L2._group
            Cyclic group of order 3 as a permutation group
            sage: L2._action_matrices
            [
            [0 1 0]
            [0 0 1]
            [1 0 0]
            ]


        Now we induce the lattice back to ``S_3`` and check we get different cohomologies::


            sage: L3 = L2.induced_lattice(G)
            sage: L3._action_matrices
            [
            [0 1 0|0 0 0]  [0 0 0|0 0 1]
            [0 0 1|0 0 0]  [0 0 0|1 0 0]
            [1 0 0|0 0 0]  [0 0 0|0 1 0]
            [-----+-----]  [-----+-----]
            [0 0 0|0 0 1]  [0 1 0|0 0 0]
            [0 0 0|1 0 0]  [0 0 1|0 0 0]
            [0 0 0|0 1 0], [1 0 0|0 0 0]
            ]
            sage: for i in range(-5, 6): 
            ....:     print("H^"+str(i)+" : ") , L1.Tate_Cohomology(i)
            ....:     
            H^-5 :  []
            H^-4 :  [2]
            H^-3 :  []
            H^-2 :  [2]
            H^-1 :  []
            H^0 :  [2]
            H^1 :  []
            H^2 :  [2]
            H^3 :  []
            H^4 :  [2]
            H^5 :  []
            sage: for i in range(-5, 6): 
            ....:     print("H^"+str(i)+" : ") , L3.Tate_Cohomology(i)
            ....:     
            H^-5 :  []
            H^-4 :  []
            H^-3 :  []
            H^-2 :  []
            H^-1 :  []
            H^0 :  []
            H^1 :  []
            H^2 :  []
            H^3 :  []
            H^4 :  []
            H^5 :  []


        """

        mor=self._action_morphism
        I=[gap.Image(mor,i).sage() for i in H.gens()]
        a=[matrix(i) for i in I]
        return Lattice_ambient(subgp,a)




    def isomorphic_ambient_lattice(self):
        """
        Gives an isomorphic ambient lattice, in this case it returns itself.



        EXAMPLES::

            sage: L = Lattice_ambient(PermutationGroup([()]), 1)
            sage: L.isomorphic_ambient_lattice()
            Ambient free module of rank 1 over the principal ideal domain Integer Ring
            sage: _ is L
            True
        """
        return self




    def parent_lattice(self):
        return self



    def Tate_Cohomology(self,n):
        """
        Computes the Tate cohomology of an ambient character lattice.

        INPUT:

        -``n`` -- integer corresponding to the cohomology group to compute.
        

        NOTE::

            More examples are done in Lattice_generic documentation, 
            and in the AlgebraicTorus one.


        EXAMPLES::


            sage: G = CyclicPermutationGroup(58)
            sage: mat = matrix(2, [0,1,1,0])
            sage: L = Lattice_ambient(G, [mat])
            sage: for i in range(-5, 6): 
            ....:     print("H^"+str(i)+" : ") , L.Tate_Cohomology(i)
            H^-5 :  []
            H^-4 :  [29]
            H^-3 :  []
            H^-2 :  [29]
            H^-1 :  []
            H^0 :  [29]
            H^1 :  []
            H^2 :  [29]
            H^3 :  []
            H^4 :  [29]
            H^5 :  []
        """
        MG=self.GAPMatrixGroup()

        if type(self._group[0]) is PermutationGroupElement:
            G=libgap(self._group)  
        elif type(self._group[0]) is SymmetricGroupElement:
            G=gap.Group([gap(i) for i in self._generators])
        else:
            G=gap.Group(self._action_matrices)
        #This is a slight adaptation of the code from Hoshi and Yamasaki done on GAP
        if n==0:
            M = matrix.zero(self._rank)
            if type(self._group[0]) is PermutationGroupElement or type(self._group[0]) is SymmetricGroupElement:
                Lst=[libgap(i) for i in self._group]
            else:
                Lst=[i.gap() for i in self._group]
            for i in Lst:
                M += matrix(gap.Image(self._action_morphism,i).sage())
            #M = matrix((libgap.Sum(MG)).sage())
            S=M.smith_form(False,True)
            R = S.rank()
            RR=[S[i][i] for i in range(R)]
            return [i for i in RR if i>1]
        elif n==-1:
            m=gap([])
            for i in gap.GeneratorsOfGroup(MG): 
                m=gap.Concatenation(m,i-gap.Identity(MG))
            ms = matrix(m.sage())
            s=ms.smith_form(False,True)
            r=s.rank()
            rr=gap([s[i][i] for i in range(r)])
            return [i for i in rr if i>1]
        else:
            load_hap()
            if self._rank==1: 
                gl=gap.Group([ [ [ -1 ] ] ])
            else:
                gl=gap.GL(self._rank,ZZ)
            mor=gap.GroupHomomorphismByImages(G,gl,gap(self._group.gens()),gap([m.transpose().inverse() for m in self._action_matrices]))
            if n>0:
                #This computes the standard resolution of G in HAP
                R = gap.ResolutionFiniteGroup(G,n+1)
                #Then applies the map to the action to the resolution
                TR = gap.HomToIntegralModule(R,mor)
                #Might have a problem because gap does only right actions ?
                return (gap.Cohomology(TR,n)).sage()
            else:
                R = gap.ResolutionFiniteGroup(G,-n)
                TR = gap.TensorWithIntegralModule(R,mor)
                return (gap.Homology(TR,-n-1)).sage()







    def induced_lattice(self,group,build = True):
        """
        Given a bigger group than the original acting on the lattice, 
        contructs the induced module on that larger group.


        INPUT:

        - ``group`` -- the bigger group to which we want to induce the lattice

        - ``build`` -- boolean, True if we want to return the induced lattice, 
            otherwise the method just returns the set of matrices defining the 
            induced action. 

        NOTE::

            If a matrix group is entered, it will find an isomorphic permutation group
            to do the induction, so one has to be careful that the isomorphic group 
            will contain the permutation group of the lattice. If the lattice is declared
            with matrices, or a matrix group, then inputing a bigger matrix group here
            should work.

        EXAMPLES::

        
            sage: G = CyclicPermutationGroup(3)
            sage: mat = matrix(3, [0,1,0,0,0,1,1,0,0])
            sage: L = Lattice_ambient(G, [mat])
            sage: L.induced_lattice(SymmetricGroup(3))
            Ambient free module of rank 6 over the principal ideal domain Integer Ring
            sage: L.induced_lattice(SymmetricGroup(3),False)
            [
            [0 1 0|0 0 0]  [0 0 0|0 0 1]
            [0 0 1|0 0 0]  [0 0 0|1 0 0]
            [1 0 0|0 0 0]  [0 0 0|0 1 0]
            [-----+-----]  [-----+-----]
            [0 0 0|0 0 1]  [0 1 0|0 0 0]
            [0 0 0|1 0 0]  [0 0 1|0 0 0]
            [0 0 0|0 1 0], [1 0 0|0 0 0]
            ]

        ::

            sage: m1 = matrix(3, [0,0,1,-1,-1,-1,1,0,0])
            sage: m2 = matrix(3, [-1,0,0,0,-1,0,0,0,-1])
            sage: m3 = matrix(3, [0,1,0,1,0,0,-1,-1,-1])
            sage: G = MatrixGroup([m1,m2,m3])
            sage: H = MatrixGroup([m1,m2])
            sage: L = Lattice_ambient(H)
            sage: L.induced_lattice(G)
            Ambient free module of rank 6 over the principal ideal domain Integer Ring
            sage: _._action_matrices
            [
            [ 0  0  0|-1  0  0]  [ 0  0  0| 0  0 -1]  [ 0  0  0| 0  0  1]
            [ 0  0  0| 0 -1  0]  [ 0  0  0| 1  1  1]  [ 0  0  0|-1 -1 -1]
            [ 0  0  0| 0  0 -1]  [ 0  0  0|-1  0  0]  [ 0  0  0| 1  0  0]
            [--------+--------]  [--------+--------]  [--------+--------]
            [-1  0  0| 0  0  0]  [ 0  0 -1| 0  0  0]  [ 0  0  1| 0  0  0]
            [ 0 -1  0| 0  0  0]  [ 1  1  1| 0  0  0]  [-1 -1 -1| 0  0  0]
            [ 0  0 -1| 0  0  0], [-1  0  0| 0  0  0], [ 1  0  0| 0  0  0]
            ]
        """

        if isinstance(group,FinitelyGeneratedMatrixGroup_gap):
            gapgroup=gap.Group([i.gap() for i in group.gens()])
            iso = gap.IsomorphismPermGroup(gapgroup)
            permg=gap.Image(iso)
            genperm=gap.GeneratorsOfGroup(permg)
            return self.induced_lattice(PermutationGroup(genperm),build)
        else:
            LCos=group.cosets(self._group,'left')
        LCosReps=[i[0] for i in LCos]
        LCosnum=len(LCos)
         #get_coset_index will take an element g of G and return the index of the coset it belongs to
        def get_coset_index(g):
            for i in range(LCosnum):
                if g in LCos[i]:
                    return i
            raise ValueError('Found an element which does not belong to any coset')

        #decomp takes an element g of the big group G, and returns a pair
        def decomp(g):
            i=get_coset_index(g)
            return [i, (LCosReps[i].inverse())*g]
        r"""
        decomp2(element,index) will do the main computation for the group action on the 
        induced lattice (we deal with finite groups so induced is the same as coinduced)
        ``\ZZ[G]\otimes_{\ZZ[H]} L ``

         To do so, we look at the multiplication g*gi where gi is a representative of the
         ith left coset
        """


        def decomp2(g,i):
            return decomp(g*LCosReps[i])


        #Now we create block matrices corresponding to actions of each generator of G, it 
        #is the composition of a block unimodular matrix for permutation of blocks
        #and the block diagonal matrix applying the correct element of H to each block

        def make_matrix(g):
            Lst=[]
            Bigmatlist = []
            for i in range(LCosnum): 
                Lst.append(decomp2(g,i))
            Matlist=[matrix.zero(self._rank) for j in range(LCosnum)]
            Matlist=[ matrix((gap.Image(self._action_morphism,gap(j[1]))).sage())   for j in Lst]
            for i in range(LCosnum):
                Bigmatlist+=[Matlist[j] if Lst[j][0]==i else matrix.zero(self._rank)   for j in range(LCosnum)]
            return block_matrix(LCosnum,LCosnum,Bigmatlist)








        GGen=self._generators
        gens_induced_act = [make_matrix(g) for g in group.gens()]
        if build:
            return Lattice_ambient(group,gens_induced_act)   
        else:
            return gens_induced_act



    def zero_sum_sublattice(self,ambient=False):
        """
        Gives the lattice consisting of vectors with zero sum of coordinates.



        INPUT:

        - ``ambient`` -- boolean, if True it will give an ambient lattice isomorphic to 
            the sublattice of vectors with zero sum of coordinates. If False or left blank
            the method returns the sublattice of zero sum vectors.

        
        NOTE::
            More examples are done in the Lattice_generic and SubLattice classes.

        EXAMPLES::

            sage: L = Lattice_ambient(DihedralGroup(4), 4)
            sage: L.zero_sum_sublattice()
            Free module of degree 4 and rank 3 over Integer Ring
            Echelon basis matrix:
            [ 1  0  0 -1]
            [ 0  1  0 -1]
            [ 0  0  1 -1]

        ::

            sage: L.zero_sum_sublattice(True)
            Ambient free module of rank 3 over the principal ideal domain Integer Ring 
        """
        if ambient:
            A=self
            acts=self._action_matrices
            newacts=[A[[i for i in range(A.ncols()-1)], [i for i in range(A.ncols()-1)]]-A[[i for i in range(A.ncols()-1)], [A.ncols()-1]]*matrix(1, [1 for i in range(A.ncols()-1)]) for A in acts]
            return Lattice_ambient(self._group,newacts)
        else:
            oldBasis=self.basis()
            newBasis = [ oldBasis[i]-oldBasis[len(oldBasis)-1]     for i in range(len(oldBasis)-1)  ]
            return SubLattice(self,newBasis)
        r"""
        This does the following, for each nxn matrix defining the action of the induced representation, 
        it extracts two blocks
        (        |   )
        (    A   | B )     A which is of size n-1 x n-1
        (        |   ) and B which is of size n-1 x 1 
        (------------)
        (    C   | D )

        Then it computes the action for the norm 1 restriction of scalars, which is
        A - B * (1,1,...,1)


        Indeed, since the norm 1 restriction lattice will be the sublattice 
        of elements summing up to 1, so we only consider the first n-1 basis elements, 
        doing the matrix computation, the element l=(l_1,...l_(n-1)) is sent to 
        A *l + B * (-sum_i l_i), which is the transformation A-B*(1,...,1)
        """

    def norm_one_restriction_of_scalars(self,group,ambient = True):
        """
        Compute the lattice corresponding to norm one restriction of scalars
        of a torus.

        INPUT:

        -``group`` -- group for the induction, corresponding to the restriction 
            of scalars.

        - ``ambient`` -- boolean, if True it gives an ambient lattice isomorphic to 
            the desired one, if False it gives the sublattice.
            (default option is True)

        
        NOTE::
            More examples are computed in the AlgeraicTorus class and Lattice_generic.


        EXAMPLES::

            sage: L = Lattice_ambient(DihedralGroup(4), 4)
            sage: ROS = L.norm_one_restriction_of_scalars(SymmetricGroup(4));ROS
            Ambient free module of rank 11 over the principal ideal domain Integer Ring
            sage: ROS._action_matrices
            [
            [ 1  0  0  0  0  0  0  0  0  0  0]  [0 0 0 0 1 0 0 0 0 0 0]
            [ 0  1  0  0  0  0  0  0  0  0  0]  [0 0 0 0 0 1 0 0 0 0 0]
            [ 0  0  1  0  0  0  0  0  0  0  0]  [0 0 0 0 0 0 1 0 0 0 0]
            [ 0  0  0  1  0  0  0  0  0  0  0]  [0 0 0 0 0 0 0 1 0 0 0]
            [ 0  0  0  0  0  0  0  0  1  0  0]  [1 0 0 0 0 0 0 0 0 0 0]
            [ 0  0  0  0  0  0  0  0  0  1  0]  [0 1 0 0 0 0 0 0 0 0 0]
            [ 0  0  0  0  0  0  0  0  0  0  1]  [0 0 1 0 0 0 0 0 0 0 0]
            [-1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1]  [0 0 0 1 0 0 0 0 0 0 0]
            [ 0  0  0  0  1  0  0  0  0  0  0]  [0 0 0 0 0 0 0 0 1 0 0]
            [ 0  0  0  0  0  1  0  0  0  0  0]  [0 0 0 0 0 0 0 0 0 1 0]
            [ 0  0  0  0  0  0  1  0  0  0  0], [0 0 0 0 0 0 0 0 0 0 1]
            ]
            sage: for i in range(-5, 6): 
            ....:     print("H^"+str(i)+" : ") , L.Tate_Cohomology(i)
            ....:     
            H^-5 :  [2, 2, 2, 2, 2, 2, 2, 2]
            H^-4 :  [2, 2, 2, 2, 2, 2, 2, 2, 4, 4, 4, 4]
            H^-3 :  [2, 2, 2, 2]
            H^-2 :  [2, 2, 2, 2, 2, 2, 2, 2]
            H^-1 :  []
            H^0 :  [8, 8, 8, 8]
            H^1 :  []
            H^2 :  [2, 2, 2, 2, 2, 2, 2, 2]
            H^3 :  [2, 2, 2, 2]
            H^4 :  [2, 2, 2, 2, 2, 2, 2, 2, 4, 4, 4, 4]
            H^5 :  [2, 2, 2, 2, 2, 2, 2, 2]
            sage: for i in range(-5, 6) : 
            ....:     print("H^"+str(i)+" : ") , ROS.Tate_Cohomology(i)
            H^-5 :  [2, 2, 2, 2, 2, 2, 2]
            H^-4 :  [2, 2, 2, 2, 2, 2, 2, 4, 4, 4]
            H^-3 :  [2, 2, 6]
            H^-2 :  [2, 2, 2, 2, 2, 2, 2]
            H^-1 :  [3]
            H^0 :  [8, 8, 8]
            H^1 :  [3]
            H^2 :  [2, 2, 2, 2, 2, 2, 2]
            H^3 :  [2, 2, 2]
            H^4 :  [2, 2, 2, 2, 2, 2, 2, 4, 4, 4]
            H^5 :  [2, 2, 2, 2, 2, 2, 6]
        """
        return self.induced_lattice(group).zero_sum_sublattice(ambient)


 


class SubLattice(Lattice_generic,FreeModule_submodule_pid):
    """ Class for sublattices of ambient lattices (or sublattices themselves)."""




    def __init__(self, lattice,basis,check = True):
        """
        Construct an element of the class SubLattice.



        INPUT:

        - ``lattice`` -- the lattice (ambient or not) in which our lattice embeds

        - ``basis`` -- a set of generators of the sublattice

        - ``check`` -- boolean, if True we check that the sublattice is stable under
            the group action.



        """


        Lattice_generic.__init__(self,lattice._group,lattice._action_matrices)
        FreeModule_submodule_pid.__init__(self,lattice.parent_lattice(),basis)
        

        self._parent_lattice=lattice.parent_lattice()
        if check:
            for i in lattice._group.gens():
                for j in basis:
                    if not lattice._act(i,j) in self:
                        raise ValueError("The basis is not stable under the action of the group")

    def parent_lattice(self):
        """
        Returns the ambient lattice containing the sublattice ``self``.
        

        EXAMPLES::


        sage: L = Lattice_ambient(DihedralGroup(4), 4).zero_sum_sublattice()
        sage: L.parent_lattice()
        Ambient free module of rank 4 over the principal ideal domain Integer Ring

        """


        return self._parent_lattice


    def subgroup_lattice(self,subgp):
        """
        Restrict the group acting on the sublattice to a subgroup


        INPUT:

        - ``subgp`` -- the subgroup we want to restrict the lattice to


        EXAMPLES::


            sage: G = SymmetricGroup(3)
            sage: H = CyclicPermutationGroup(2)
            sage: m1 = matrix(3, [0,1,0,0,0,1,1,0,0])
            sage: m2 = matrix(3, [0,1,0,1,0,0,0,0,1])
            sage: L = Lattice_ambient(G, [m1,m2])
            sage: a,b,c = L.basis()
            sage: SL = SubLattice(L, [a,b])

        ::


            sage: SL = SubLattice(L, [a+b+c])
            sage: SL2 = SL.subgroup_lattice(H);SL2
            Free module of degree 3 and rank 1 over Integer Ring
            Echelon basis matrix:
            [1 1 1]
            sage: SL2._group
            Cyclic group of order 2 as a permutation group
            sage: SL2._action_matrices
            [
            [0 1 0]
            [1 0 0]
            [0 0 1]

        This time we can see that inducing this lattice back to ``G`` we
        get a lattice isomorphic to ``L``



            sage: SL3 = SL2.induced_lattice(G)
            sage: SL3._action_matrices
            [
            [0|0|1]  [1|0|0]
            [-+-+-]  [-+-+-]
            [1|0|0]  [0|0|1]
            [-+-+-]  [-+-+-]
            [0|1|0], [0|1|0]
            ]

        """
        return SubLattice(self.parent_lattice().subgroup_lattice(subgp),self.basis())



    def isomorphic_ambient_lattice(self):
        """
        Gives an isomorphic ambient lattice.

        EXAMPLES:: 

            sage: L = Lattice_ambient(DihedralGroup(4), 4)
            sage: SL1 = L.zero_sum_sublattice()
            sage: L = Lattice_ambient(DihedralGroup(4), 4)
            sage: SL1 = L.zero_sum_sublattice();SL1
            Free module of degree 4 and rank 3 over Integer Ring
            Echelon basis matrix:
            [ 1  0  0 -1]
            [ 0  1  0 -1]
            [ 0  0  1 -1]
            sage: SL1.isomorphic_ambient_lattice()
            Ambient free module of rank 3 over the principal ideal domain Integer Ring 
        """
        oldBasis=self.basis()
        act_builder=[]
        for g in self._group.gens():
            mat_builder=[]
            for i in oldBasis:
                mat_builder.append(self.coordinate_vector(self._act(g,i)))
            act_builder.append(matrix(mat_builder))
        return Lattice_ambient(self._group,act_builder)

    def Tate_Cohomology(self,n):
        """
        Computes the isomorphism type of the Tate cohomology groups of the sublattice.


        INPUT:

        - ``n`` -- integer corresponding to the cohomology group we compute.

        EXAMPLES::

            sage: L = Lattice_ambient(DihedralGroup(4), 4)
            sage: SL = L.zero_sum_sublattice()
            sage: for i in range(-5, 6): 
            ....:     print("H^"+str(i)+" : ") , SL1.Tate_Cohomology(i)
            ....:     
            H^-5 :  [2, 2, 2, 2, 2, 2]
            H^-4 :  [2, 2, 2, 2, 2, 2, 4, 4, 4]
            H^-3 :  [2, 2, 2]
            H^-2 :  [2, 2, 2, 2, 2, 2]
            H^-1 :  []
            H^0 :  [8, 8, 8]
            H^1 :  []
            H^2 :  [2, 2, 2, 2, 2, 2]
            H^3 :  [2, 2, 2]
            H^4 :  [2, 2, 2, 2, 2, 2, 4, 4, 4]
            H^5 :  [2, 2, 2, 2, 2, 2]

        ::

            sage: G = DihedralGroup(4)
            sage: m1 = matrix(2, [0,1,1,0])
            sage: m2= -matrix.identity(2)
            sage: L = Lattice_ambient(G, [m1,m2])
            sage: for i in range(-5, 6): 
            ....:     print("H^"+str(i)+" : ") , L.Tate_Cohomology(i)
            H^-5 :  [2, 2, 2]
            H^-4 :  [2, 2]
            H^-3 :  [2, 2]
            H^-2 :  [2]
            H^-1 :  [2]
            H^0 :  []
            H^1 :  [2]
            H^2 :  [2]
            H^3 :  [2, 2]
            H^4 :  [2, 2]
            H^5 :  [2, 2, 2]
            sage: SL1 = L.zero_sum_sublattice()
            sage: a,b = L.basis()
            sage: SL2 = SubLattice(L, [a+b])
            sage: for i in range(-5, 6): 
            ....:     print("H^"+str(i)+" : ") , SL1.Tate_Cohomology(i)
            H^-5 :  [2, 2, 2]
            H^-4 :  [2, 2]
            H^-3 :  [2, 2]
            H^-2 :  [2]
            H^-1 :  [2]
            H^0 :  []
            H^1 :  [2]
            H^2 :  [2]
            H^3 :  [2, 2]
            H^4 :  [2, 2]
            H^5 :  [2, 2, 2]
            sage: for i in range(-5, 6) : 
            ....:     print("H^"+str(i)+" : ") , SL2.Tate_Cohomology(i)
            H^-5 :  [2, 2, 2]
            H^-4 :  [2, 2]
            H^-3 :  [2, 2]
            H^-2 :  [4]
            H^-1 :  [2]
            H^0 :  []
            H^1 :  [2]
            H^2 :  [4]
            H^3 :  [2, 2]
            H^4 :  [2, 2]
            H^5 :  [2, 2, 2]
        """
        return self.isomorphic_ambient_lattice().Tate_Cohomology(n)

    def induced_lattice(self,group):
        """
        Compute an ambient lattice isomorphic to the induction of this lattice
        to a larger group.



        INPUT:

        - ``group`` -- the larger group to induce the lattice to.

        EXAMPLE::


            sage: G = DihedralGroup(4)
            sage: m1 = matrix(2, [0,1,1,0])
            sage: m2 = -matrix.identity(2)
            sage: L = Lattice_ambient(G, [m1,m2])
            sage: SL1 = L.zero_sum_sublattice()
            sage: a,b = L.basis()
            sage: SL2 = SubLattice(L, [a+b])

        ::

            sage: SL1.induced_lattice(SymmetricGroup(4))
            Ambient free module of rank 3 over the principal ideal domain Integer Ring
            sage: _._action_matrices
            [
            [-1| 0| 0]  [ 0|-1| 0]
            [--+--+--]  [--+--+--]
            [ 0| 0| 1]  [-1| 0| 0]
            [--+--+--]  [--+--+--]
            [ 0|-1| 0], [ 0| 0| 1]
            ]
            sage: SL2.induced_lattice(SymmetricGroup(4))
            Ambient free module of rank 3 over the principal ideal domain Integer Ring
            sage: _._action_matrices
            [
            [ 1| 0| 0]  [ 0|-1| 0]
            [--+--+--]  [--+--+--]
            [ 0| 0|-1]  [-1| 0| 0]
            [--+--+--]  [--+--+--]
            [ 0| 1| 0], [ 0| 0|-1]
            ]
        """
        return self.isomorphic_ambient_lattice().induced_lattice(group)

    def norm_one_restriction_of_scalars(self,group,ambient = True):
        """
        Compute the ambient lattice.


        INPUT:

        - ``group`` -- the bigger group corresponding to the induction for
        the restriction of scalars.

        - ``ambient`` -- boolean, if True it will return an ambient lattice,
        otherwise it will return the sublattice of the restriction of scalars.
        (default option is True)



        EXAMPLES::

            sage: G = DihedralGroup(4)
            sage: L = Lattice_ambient(G, 3)
            sage: SL = L.zero_sum_sublattice()
            sage: SL.norm_one_restriction_of_scalars(SymmetricGroup(4))
            Ambient free module of rank 5 over the principal ideal domain Integer Ring
            sage: _._action_matrices
            [
            [ 1  0  0  0  0]  [0 0 1 0 0]
            [ 0  1  0  0  0]  [0 0 0 1 0]
            [ 0  0  0  0  1]  [1 0 0 0 0]
            [-1 -1 -1 -1 -1]  [0 1 0 0 0]
            [ 0  0  1  0  0], [0 0 0 0 1]
            ]
            sage: SL.norm_one_restriction_of_scalars(SymmetricGroup(4),False)
            Free module of degree 6 and rank 5 over Integer Ring
            Echelon basis matrix:
            [ 1  0  0  0  0 -1]
            [ 0  1  0  0  0 -1]
            [ 0  0  1  0  0 -1]
            [ 0  0  0  1  0 -1]
            [ 0  0  0  0  1 -1]
            sage: _._action_matrices
            [
            [1 0|0 0|0 0]  [0 0|1 0|0 0]
            [0 1|0 0|0 0]  [0 0|0 1|0 0]
            [---+---+---]  [---+---+---]
            [0 0|0 0|1 0]  [1 0|0 0|0 0]
            [0 0|0 0|0 1]  [0 1|0 0|0 0]
            [---+---+---]  [---+---+---]
            [0 0|1 0|0 0]  [0 0|0 0|1 0]
            [0 0|0 1|0 0], [0 0|0 0|0 1]
            ]


        """
        return self.isomorphic_ambient_lattice().norm_one_restriction_of_scalars(group,ambient)
    



    def zero_sum_sublattice(self,ambient=False):
        """
        Creates the sublattice of the vectors with zero sum of coordinates
        in the ambient module.

        INPUT:

        - ``ambient`` -- boolean, if True the method returns an ambient lattice
            isomorphic to the zero sum sublattice.

        NOTE:: 

            Again, not all zero sum lattices are stable under the action of the group,
            this method can fail in those cases.

        EXAMPLES::
        


            sage: G1 = SymmetricGroup(3)
            sage: L1 = Lattice_ambient(G, 5)
            sage: a,b,c,d,e = L1.basis()
            sage: SL1 = SubLattice(L1, [a+2*b+d,d-5*e,3*c]); SL1
            Free module of degree 5 and rank 3 over Integer Ring
            Echelon basis matrix:
            [ 1  2  0  0  5]
            [ 0  0  3  0  0]
            [ 0  0  0  1 -5]
            sage: SL1.zero_sum_sublattice()
            Free module of degree 5 and rank 2 over Integer Ring
            Echelon basis matrix:
            [  1   2   0   2  -5]
            [  0   0  12   3 -15]
            sage: SL1.zero_sum_sublattice(True)
            Ambient free module of rank 2 over the principal ideal domain Integer Ring



        Next is another example of sublattice where the zero sum submodule
        is not stable under the group action::

            sage: G2 = CyclicPermutationGroup(2)
            sage: m = matrix([[0,1,0,0,0], [1,0,0,0,0], [0,0,1,0,0], [0,0,0,-1,0], [0,0,0,0,-1]])
            sage: L2 = Lattice_ambient(G, [m])
            sage: a,b,c,d,e = L2.basis()
            sage: SL2 = SubLattice(L2, [a,b,d]); SL2
            Free module of degree 5 and rank 3 over Integer Ring
            Echelon basis matrix:
            [1 0 0 0 0]
            [0 1 0 0 0]
            [0 0 0 1 0]
            sage: SL2.zero_sum_sublattice()
            ...
            ValueError: The basis is not stable under the action of the group

        """
        oldBasis=self.basis()
        newBasis=[]
        diagonal=0
        for i in self._parent_lattice.basis():
            diagonal+=i
        totals=[i.inner_product(diagonal) for i in oldBasis]
        gcd,coefs=extended_xgcd(totals)
        if gcd==0: 
            return self
        dist_elt=0
        for i in range(len(oldBasis)):
            dist_elt+=coefs[i]*oldBasis[i]
        for i in range(len(oldBasis)):
            newBasis.append(oldBasis[i]-(totals[i]/gcd)*dist_elt)
        while 0 in newBasis:
            newBasis.remove(0)
        result = SubLattice(self._parent_lattice,newBasis)
        return result if not ambient else result.isomorphic_ambient_lattice()




		
		
class AlgebraicTorus(GroupScheme):
    """
    Creates an algebraic torus through its equivalence of categories with the action of a Galois Group on an integral lattice.

    


    """

    def __init__(self, lattice,base_field=None,splitting_field=None):
        """
        Constructs an object of the albegraic torus class.

        INPUT:

        - ``lattice`` -- the character lattice with galois action
         defining the torus.
        


        EXAMPLES::

            sage: L = Lattice_ambient(DihedralGroup(4), 4)
            sage: AlgebraicTorus(L)
            Algebraic Torus of rank 4 defined by the following lattice :
            Ambient free module of rank 4 over the principal ideal domain Integer Ring
            and an action by the galois group of the form :
            Dihedral group of order 8 as a permutation group


        """
        GroupScheme.__init__(self)
        if lattice is None:
        	raise ValueError('You have to specify a lattice.')
        else:
            self._lattice = lattice
            self._base_field=base_field
            self._splitting_field=splitting_field


    def _repr_(self):
        """
        The printing representation of an algebraic torus. 


        EXAMPLES:: 


            sage: AlgebraicTorus(Lattice_ambient(CyclicPermutationGroup(3), 2))
            Algebraic Torus of rank 2 defined by the following lattice :
            Ambient free module of rank 2 over the principal ideal domain Integer Ring
            and an action by the galois group of the form :
            Cyclic group of order 3 as a permutation group

        ::

            sage: L = Lattice_ambient(CyclicPermutationGroup(3), 2).norm_one_restriction_of_scalars(SymmetricGroup(3
            ....: ),False)
            sage: AlgebraicTorus(L)
            Algebraic Torus of rank 4 defined by the following lattice :
            Free module of degree 4 and rank 3 over Integer Ring
            Echelon basis matrix:
            [ 1  0  0 -1]
            [ 0  1  0 -1]
            [ 0  0  1 -1]
            and an action by the galois group of the form :
            Symmetric group of order 3! as a permutation group

        """
        return "Algebraic Torus of rank %s defined by the following lattice :\n"%(self.rank())+self._lattice._repr_()+"\nand an action by the galois group of the form :\n"+self._lattice._group._repr_() 

    def rank(self):
        """
        The rank of the torus.

        EXAMPLES::

        
            sage: L = Lattice_ambient(PermutationGroup([()]), 1)
            sage: T1 = AlgebraicTorus(L)
            sage: LL = Lattice_ambient(SymmetricGroup(3), 1)
            sage: T2 = AlgebraicTorus(LL)
            sage: act1 = matrix(3, [0,1,0,0,0,1,1,0,0])
            sage: act2 = matrix(3, [0,1,0,1,0,0,0,0,1])
            sage: LLL = Lattice_ambient(SymmetricGroup(3), [act1,act2])
            sage: T3 = AlgebraicTorus(LLL)

        ::

            sage: T1.rank()
            1
            sage: T2.rank()
            1
            sage: T3.rank()
            3
        """
        return self._lattice._rank

    def galois_group(self):
        """
        The abstract Galois group of a splitting field of the torus.


        NOTE:: 

            It doesn't have to be a minimal splitting field, therefore we 
            allow trivial Galois action. 

        EXAMPLES::

            sage: L = Lattice_ambient(PermutationGroup([()]), 1)
            sage: T1 = AlgebraicTorus(L)
            sage: LL = Lattice_ambient(SymmetricGroup(3), 1)
            sage: T2 = AlgebraicTorus(LL)
            sage: act1 = matrix(3, [0,1,0,0,0,1,1,0,0])
            sage: act2 = matrix(3, [0,1,0,1,0,0,0,0,1])
            sage: LLL = Lattice_ambient(SymmetricGroup(3), [act1,act2])
            sage: T3 = AlgebraicTorus(LLL)

        ::
            
            sage: T1.galois_group()
            Permutation Group with generators [()]
            sage: T2.galois_group()
            Symmetric group of order 3! as a permutation group
            sage: T3.galois_group()
            Symmetric group of order 3! as a permutation group
        """
        return self._lattice._group


    def is_rational(self,ruple,subgp=None):
        """
        Detects if a point is rational over the base field. 

        INPUT:

        - ``ruple`` -- a point of the torus given as an r-tuple of points over the 
        splitting field, where r is the rank of the torus. 

        - ``subgp`` -- optional, subgroup of the galois group corresponding to an
        intermediate extension. If specified, the algorithm will test the rationality 
        over the intermediate extension.


        EXAMPLES::

            sage: K.<w> = QuadraticField(5); G = K.galois_group()
            sage: Lat = Lattice_ambient(PermutationGroup([()]),1)
            sage: Lati = Lat.induced_lattice(G)
            
        ::

            sage: T=AlgebraicTorus(Lati, QQ, K)
            sage: T.is_rational([w,w])
            'The given point is not rational'
            sage: T.is_rational([1,1])
            'The given point is rational'
            sage: T.is_rational([1,w])
            'The given point is not rational'





        """
        if subgp==None: 
            elt = matrix(self.rank(), ruple)
            res=elt
            galgen=self.galois_group().gens()
            for g in range(len(galgen)) : 
                res=self.cocharacter_lattice()._action_matrices[g] * matrix(self.rank(), [galgen[g](x) for x in ruple])
                if not res==elt :
                    return "The given point is not rational"
            return "The given point is rational"

        else:
            elt = matrix(self.rank(), ruple)
            res=elt
            hgen=subgp.gens()
            colat= self.cocharacter_lattice().subgroup_lattice(subgp)
            for g in range(len(hgen)) : 
                res=colat._action_matrices[g] * matrix(self.rank(), [hgen[g](x) for x in ruple])
                if not res==elt :
                    return "The given point is not rational over this intermediate extension"
            return "The given point is rational over this intermediate extension"            

    def character_lattice(self):
        """
        The character lattice of the torus.


        EXAMPLES::

            sage: L = Lattice_ambient(PermutationGroup([()]), 1)
            sage: T1 = AlgebraicTorus(L)
            sage: LL = Lattice_ambient(SymmetricGroup(3), 1)
            sage: T2 = AlgebraicTorus(LL)
            sage: act1 = matrix(3, [0,1,0,0,0,1,1,0,0])
            sage: act2 = matrix(3, [0,1,0,1,0,0,0,0,1])
            sage: LLL = Lattice_ambient(SymmetricGroup(3), [act1,act2])
            sage: T3 = AlgebraicTorus(LLL)

        ::
            
            sage: T1.character_lattice()
            Ambient free module of rank 1 over the principal ideal domain Integer Ring
            sage: T2.character_lattice()
            Ambient free module of rank 1 over the principal ideal domain Integer Ring
            sage: T3.character_lattice()
            Ambient free module of rank 3 over the principal ideal domain Integer Ring
        """
        return self._lattice

    def cocharacter_lattice(self):
        """"
        The cocharacter lattice of the torus.


        EXAMPLES::

            sage: L = Lattice_ambient(PermutationGroup([()]), 1)
            sage: T1 = AlgebraicTorus(L)
            sage: LL = Lattice_ambient(SymmetricGroup(3), 1)
            sage: T2 = AlgebraicTorus(LL)
            sage: act1 = matrix(3, [0,1,0,0,0,1,1,0,0])
            sage: act2 = matrix(3, [0,1,0,1,0,0,0,0,1])
            sage: LLL = Lattice_ambient(SymmetricGroup(3), [act1,act2])
            sage: T3 = AlgebraicTorus(LLL)

        ::
            
            sage: T3.character_lattice()._action_matrices
            [
            [0 1 0]  [0 1 0]
            [0 0 1]  [1 0 0]
            [1 0 0], [0 0 1]
            ]
            sage: T3.cocharacter_lattice()._action_matrices
            [
            [0 1 0]  [0 1 0]
            [0 0 1]  [1 0 0]
            [1 0 0], [0 0 1]
            ]

        The matrices are all orthogonal so we get the same lattice. The action will be 
        different in the next example.
        ::



            sage: Lattice_ambient(PermutationGroup([(1,2,3,4,5,6)]), [matrix(2, [0,1,-1,-1])])
            Ambient free module of rank 2 over the principal ideal domain Integer Ring
            sage: T = AlgebraicTorus(_)
            sage: T.character_lattice()._action_matrices
            [
            [ 0  1]
            [-1 -1]
            ]
            sage: T.cocharacter_lattice()._action_matrices
            [
            [-1  1]
            [-1  0]
            ]
        """
        return self._lattice.colattice()


    def Tate_Cohomology(self,n):
        """
        Gives the isomorphism type of the nth cohomology group using Tate-Nakayama duality.

        INPUT:

        - ``n`` -- the integer corresponding to the cohomology group we wish to compute. 
        

        NOTE::

            This currently only works for tori over local p-adic fields. For global fields, 
            Tate-Nakayama gives the cohomology of the class group, not the torus itself.                      

        EXAMPLES::

            sage: L = Lattice_ambient(PermutationGroup([()]), 1)
            sage: T1 = AlgebraicTorus(L)
            sage: LL = Lattice_ambient(SymmetricGroup(3), 1)
            sage: T2 = AlgebraicTorus(LL)
            sage: act1 = matrix(3, [0,1,0,0,0,1,1,0,0])
            sage: act2 = matrix(3, [0,1,0,1,0,0,0,0,1])
            sage: LLL = Lattice_ambient(SymmetricGroup(3), [act1,act2])
            sage: T3 = AlgebraicTorus(LLL)

        ::

            sage: for i in range(-5, 6): 
            ....:     print("H^"+str(i)+" : ") , T1.Tate_Cohomology(i)
            H^-5 :  []
            H^-4 :  []
            H^-3 :  []
            H^-2 :  []
            H^-1 :  []
            H^0 :  []
            H^1 :  []
            H^2 :  []
            H^3 :  []
            H^4 :  []




        The Galois group is trivial and has obviously trivial cohomology
        ::

            sage: for i in range(-5, 6): 
            ....:     print("H^"+str(i)+" : ") , T2.Tate_Cohomology(i)            
            H^-5 :  []
            H^-4 :  [2]
            H^-3 :  []
            H^-2 :  [6]
            H^-1 :  []
            H^0 :  [2]
            H^1 :  []
            H^2 :  [6]
            H^3 :  []
            H^4 :  [2]

        We can recognize from class field theory that H^2, which is the Brauer group of
        our extension is isomorphic to the cyclic group Cn where n is the order of the 
        Galois group. Here the group is S3, which has order 6 so we get C6.

        Another way to see it is seeing this H^2 as H^0 of its character lattice. Since the group
        acts trivially, the fixed elements are the whole lattice, and the trace map is multiplication
        by the order of the group, which is 6, so we get C6^(rank of T1)


        Also, H^0 can be seen as the abelianization of the Galois group, which here has order
        2 (it is the group of signatures)
        ::

            sage: for i in range(-5, 6): 
            ....:     print("H^"+str(i)+" : ") , T3.Tate_Cohomology(i)           
            H^-5 :  []
            H^-4 :  [2]
            H^-3 :  []
            H^-2 :  [2]
            H^-1 :  []
            H^0 :  [2]
            H^1 :  []
            H^2 :  [2]
            H^3 :  []
            H^4 :  [2]
           
        In this example, we can see the 2-periodicity of the cohomology groups, consequence
        of the group being cyclic.
        """

        return self._lattice.Tate_Cohomology(2-n)

        #gives the torus representing the Restriction of scalars. 
        #Right now, for a torus defined over K, splitting over L, 
        #to compute the restriction of scalars to k inside K, 
        #the user has to enter the galois group of the extension L/k
        #In the future, when we will have a better notion for Galois group
        #perhaps we can deal with fields directly.


    def restriction_of_scalars(self,group):
        """
        The torus obtained through restriction of scalars.

        INPUT:

        - ``group`` -- the bigger group corresponding the the galois group
        of the splitting field over the subfield one wishes to restrict scalars.


        NOTE::

            The user has to input the (larger) galois group for this extension. 
            More concretely, if the torus is defined over K, splits over L, and 
            is defined by the action of Gal(L/K) on its character lattice, then
            if one want the restriction of scalars to a smaller field k,
            one has to enter Gal(L/k) as argument of this method. 

        EXAMPLES::

            sage: L = Lattice_ambient(PermutationGroup([()]), 1)
            sage: T1 = AlgebraicTorus(L)
            sage: LL = Lattice_ambient(SymmetricGroup(3), 1)
            sage: T2 = AlgebraicTorus(LL)
            sage: act1 = matrix(3, [0,1,0,0,0,1,1,0,0])
            sage: act2 = matrix(3, [0,1,0,1,0,0,0,0,1])
            sage: LLL = Lattice_ambient(SymmetricGroup(3), [act1, act2])
            sage: T3 = AlgebraicTorus(LLL)

        ::

            sage: T1.restriction_of_scalars(PermutationGroup([(1,2), (3,4), (5,6), (7,8)]))
            Algebraic Torus of rank 16 defined by the following lattice :
            Ambient free module of rank 16 over the principal ideal domain Integer Ring
            and an action by the galois group of the form :
            Permutation Group with generators [(7,8), (5,6), (3,4), (1,2)]

        ::

            sage: T2.restriction_of_scalars(SymmetricGroup(4))
            Algebraic Torus of rank 4 defined by the following lattice :
            Ambient free module of rank 4 over the principal ideal domain Integer Ring
            and an action by the galois group of the form :
            Symmetric group of order 4! as a permutation group
            sage: _.character_lattice()._action_matrices
            [
            [0|0|0|1]  [1|0|0|0]
            [-+-+-+-]  [-+-+-+-]
            [1|0|0|0]  [0|1|0|0]
            [-+-+-+-]  [-+-+-+-]
            [0|1|0|0]  [0|0|0|1]
            [-+-+-+-]  [-+-+-+-]
            [0|0|1|0], [0|0|1|0]
            ]
        
        ::  
        
            sage: T3.restriction_of_scalars(SymmetricGroup(4))
            Algebraic Torus of rank 12 defined by the following lattice :
            Ambient free module of rank 12 over the principal ideal domain Integer Ring
            and an action by the galois group of the form :
            Symmetric group of order 4! as a permutation group
            sage: _.character_lattice()._action_matrices
            [
            [0 0 0|0 0 0|0 0 0|1 0 0]  [0 1 0|0 0 0|0 0 0|0 0 0]
            [0 0 0|0 0 0|0 0 0|0 1 0]  [1 0 0|0 0 0|0 0 0|0 0 0]
            [0 0 0|0 0 0|0 0 0|0 0 1]  [0 0 1|0 0 0|0 0 0|0 0 0]
            [-----+-----+-----+-----]  [-----+-----+-----+-----]
            [0 1 0|0 0 0|0 0 0|0 0 0]  [0 0 0|0 1 0|0 0 0|0 0 0]
            [0 0 1|0 0 0|0 0 0|0 0 0]  [0 0 0|1 0 0|0 0 0|0 0 0]
            [1 0 0|0 0 0|0 0 0|0 0 0]  [0 0 0|0 0 1|0 0 0|0 0 0]
            [-----+-----+-----+-----]  [-----+-----+-----+-----]
            [0 0 0|0 1 0|0 0 0|0 0 0]  [0 0 0|0 0 0|0 0 0|1 0 0]
            [0 0 0|0 0 1|0 0 0|0 0 0]  [0 0 0|0 0 0|0 0 0|0 1 0]
            [0 0 0|1 0 0|0 0 0|0 0 0]  [0 0 0|0 0 0|0 0 0|0 0 1]
            [-----+-----+-----+-----]  [-----+-----+-----+-----]
            [0 0 0|0 0 0|0 1 0|0 0 0]  [0 0 0|0 0 0|1 0 0|0 0 0]
            [0 0 0|0 0 0|0 0 1|0 0 0]  [0 0 0|0 0 0|0 1 0|0 0 0]
            [0 0 0|0 0 0|1 0 0|0 0 0], [0 0 0|0 0 0|0 0 1|0 0 0]
            ]


        """
        return AlgebraicTorus(self._lattice.induced_lattice(group))

    def norm_one_restriction(self,group):
        """
        Torus of norm one elements in the restriction of scalars.
        

        INPUT:

        - ``group`` -- the abstract Galois group of the restriction of 
        scalars.



        EXAMPLES::

            sage: L = Lattice_ambient(PermutationGroup([()]), 1)
            sage: T1 = AlgebraicTorus(L)
            sage: LL = Lattice_ambient(SymmetricGroup(3), 1)
            sage: T2 = AlgebraicTorus(LL)
            sage: act1 = matrix(3, [0,1,0,0,0,1,1,0,0])
            sage: act2 = matrix(3, [0,1,0,1,0,0,0,0,1])
            sage: LLL = Lattice_ambient(SymmetricGroup(3), [act1,act2])
            sage: T3 = AlgebraicTorus(LLL)

        ::

            sage: T1.norm_one_restriction(PermutationGroup([(1,2), (3,4), (5,6), (7,8)]))
            Algebraic Torus of rank 15 defined by the following lattice :
            Ambient free module of rank 15 over the principal ideal domain Integer Ring
            and an action by the galois group of the form :
            Permutation Group with generators [(7,8), (5,6), (3,4), (1,2)]
            sage: _.character_lattice()._action_matrices[0]
            [ 0  1  0  0  0  0  0  0  0  0  0  0  0  0  0]
            [ 1  0  0  0  0  0  0  0  0  0  0  0  0  0  0]
            [ 0  0  0  1  0  0  0  0  0  0  0  0  0  0  0]
            [ 0  0  1  0  0  0  0  0  0  0  0  0  0  0  0]
            [ 0  0  0  0  0  1  0  0  0  0  0  0  0  0  0]
            [ 0  0  0  0  1  0  0  0  0  0  0  0  0  0  0]
            [ 0  0  0  0  0  0  0  1  0  0  0  0  0  0  0]
            [ 0  0  0  0  0  0  1  0  0  0  0  0  0  0  0]
            [ 0  0  0  0  0  0  0  0  0  1  0  0  0  0  0]
            [ 0  0  0  0  0  0  0  0  1  0  0  0  0  0  0]
            [ 0  0  0  0  0  0  0  0  0  0  0  1  0  0  0]
            [ 0  0  0  0  0  0  0  0  0  0  1  0  0  0  0]
            [ 0  0  0  0  0  0  0  0  0  0  0  0  0  1  0]
            [ 0  0  0  0  0  0  0  0  0  0  0  0  1  0  0]
            [-1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1]
            sage: T2.norm_one_restriction(SymmetricGroup(4))
            Algebraic Torus of rank 3 defined by the following lattice :
            Ambient free module of rank 3 over the principal ideal domain Integer Ring
            and an action by the galois group of the form :
            Symmetric group of order 4! as a permutation group
            sage: _.character_lattice()._action_matrices
            [
            [-1 -1 -1]  [ 1  0  0]
            [ 1  0  0]  [ 0  1  0]
            [ 0  1  0], [-1 -1 -1]
            ]
            sage: T3.norm_one_restriction(SymmetricGroup(4))
            Algebraic Torus of rank 11 defined by the following lattice :
            Ambient free module of rank 11 over the principal ideal domain Integer Ring
            and an action by the galois group of the form :
            Symmetric group of order 4! as a permutation group
            sage: _.character_lattice()._action_matrices
            [
            [ 0  0  0  0  0  0  0  0  0  1  0]  [ 0  1  0  0  0  0  0  0  0  0  0]
            [ 0  0  0  0  0  0  0  0  0  0  1]  [ 1  0  0  0  0  0  0  0  0  0  0]
            [-1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1]  [ 0  0  1  0  0  0  0  0  0  0  0]
            [ 0  1  0  0  0  0  0  0  0  0  0]  [ 0  0  0  0  1  0  0  0  0  0  0]
            [ 0  0  1  0  0  0  0  0  0  0  0]  [ 0  0  0  1  0  0  0  0  0  0  0]
            [ 1  0  0  0  0  0  0  0  0  0  0]  [ 0  0  0  0  0  1  0  0  0  0  0]
            [ 0  0  0  0  1  0  0  0  0  0  0]  [ 0  0  0  0  0  0  0  0  0  1  0]
            [ 0  0  0  0  0  1  0  0  0  0  0]  [ 0  0  0  0  0  0  0  0  0  0  1]
            [ 0  0  0  1  0  0  0  0  0  0  0]  [-1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1]
            [ 0  0  0  0  0  0  0  1  0  0  0]  [ 0  0  0  0  0  0  1  0  0  0  0]
            [ 0  0  0  0  0  0  0  0  1  0  0], [ 0  0  0  0  0  0  0  1  0  0  0]
            ]

        We now compute the cohomologies of all those tori.
        For the two latter examples, we check that we get different cohomologies with the
        same group, and the norm one restriction of the split torus has nontrivial cohomology.::

            sage: ROS = T1.norm_one_restriction(PermutationGroup([(1,2), (3,4), (5,6), (7,8)]))
            sage: for i in range(-4, 6) :
            ....:     print("H^"+str(i)+" : ") , ROS.Tate_Cohomology(i)
            H^-4 :  [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]
            H^-3 :  [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]
            H^-2 :  [2, 2, 2, 2, 2, 2]
            H^-1 :  [2, 2, 2, 2]
            H^0 :  []
            H^1 :  [16]
            H^2 :  []
            H^3 :  [16]
            H^4 :  [2, 2, 2, 2, 2, 2]
            H^5 :  [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]

        This torus ROS is the example of Ono where he applies his formula for the Tamagawa
        number of a Torus. See his paper 'On the Tamagawa Number of Algebraic Tori'.
        ::

            sage: ROS2 = T2.norm_one_restriction(SymmetricGroup(4))
            sage: for i in range(-4, 6) : 
            ....:     print("H^"+str(i)+" : ") , T2.Tate_Cohomology(i)
            H^-4 :  [2]
            H^-3 :  []
            H^-2 :  [6]
            H^-1 :  []
            H^0 :  [2]
            H^1 :  []
            H^2 :  [6]
            H^3 :  []
            H^4 :  [2]
            H^5 :  []

            sage: ROS3 = T3.norm_one_restriction(SymmetricGroup(4))
            sage: for i in range(-4, 6) : 
            ....:     print("H^"+str(i)+" : ") , ROS3.Tate_Cohomology(i)
            H^-4 :  [2, 2]
            H^-3 :  [2, 12]
            H^-2 :  [2, 2]
            H^-1 :  [2]
            H^0 :  [2]
            H^1 :  [12]
            H^2 :  []
            H^3 :  [12]
            H^4 :  [2]
            H^5 :  [12]


        """
        return AlgebraicTorus(self._lattice.norm_one_restriction_of_scalars(group,True))
