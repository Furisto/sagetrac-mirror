r"""



#############################################################
#
#       CLASSES OF LATTICES
#
#############################################################


Lattices are seen as the standard lattice in ZZ^n with a group action

We allow trivial group actions.


All lattices inherit from the class Lattice_generic, and there are currently three 
two types of lattices : ambient lattices (Lattice_ambient) and sublattices of ambient 
lattices (SubLattice)

One can define a lattice in 3 different ways :

############################################
# Declaring a lattice with a group and matrix actions for each generator using 
# Lattice_ambient(group,actions).
############################################

EXAMPLES::

    sage: G=PermutationGroup([(1,2),(3,4,5)])
    sage: G.gens()
    [(3,4,5), (1,2)]
    sage: act1=matrix(3,[0,1,0,0,0,1,1,0,0])
    sage: act2=matrix(3,[1,0,0,0,1,0,0,0,1])
    sage: act=[act1,act2]

We created the group G as C2 x C3, and the action where C2 acts trivially
One has to be careful when defining the action to respect sage's order of the generators

::        
    sage: Lattice_ambient(G,act)
    Ambient free module of rank 3 over the principal ideal domain Integer Ring
    
    sage: Lattice_ambient(G,act)._action_matrices
    [
    [0 1 0]  [1 0 0]
    [0 0 1]  [0 1 0]
    [1 0 0], [0 0 1]
    ]

################################
# Declaring a lattice With a group and an integer using 
# Lattice_ambient(group, n)
###############################

This will return the lattice of rank n with trivial action of the group

EXAMPLES::

    sage: Lattice_ambient(SymmetricGroup(3),2)
    Ambient free module of rank 2 over the principal ideal domain Integer Ring
    sage: Lattice_ambient(SymmetricGroup(3),2)._action_matrices
    [
    [1 0]  [1 0]
    [0 1], [0 1]
    ]

#######################################
# Declaring a Lattice with a list of matrices using 
# Lattice_ambient(List_of_matrices)
#######################################

This will return the lattice of rank equal to the size of the matrices, and 
the group will be understood to be the matrix subgroup of GL(ZZ) generated by this list

EXAMPLES::

    sage: m1=matrix(3,[0,0,1,-1,-1,-1,1,0,0])
    sage: m2=matrix(3,[-1,0,0,0,-1,0,0,0,-1])
    sage: m3=matrix(3,[0,1,0,1,0,0,-1,-1,-1])
    sage: Lattice_ambient([m1,m2,m3])
    Ambient free module of rank 3 over the principal ideal domain Integer Ring


    sage: Lattice_ambient([m1,m2,m3])._action_matrices
    [
    [ 0  0  1]  [-1  0  0]  [ 0  1  0]
    [-1 -1 -1]  [ 0 -1  0]  [ 1  0  0]
    [ 1  0  0], [ 0  0 -1], [-1 -1 -1]
    ]

#######################################
#With a Lattice and a set of generators for a sublattice
#Using SubLattice(lattice, generators)
#######################################

This will create a SubLattice of the object lattice, generated by the specified generators

EXAMPLES::

    sage: L=Lattice_ambient(DihedralGroup(6),3)
    sage: SubLattice(L,[L.basis()[0],L.basis()[1]+2*L.basis()[2]])
    Free module of degree 3 and rank 2 over Integer Ring
    Echelon basis matrix:
    [1 0 0]
    [0 1 2]

The algorithm checks if the sublattice is stable under the group action.
::

    sage: L=Lattice_ambient(SymmetricGroup(2),[matrix([[0,1],[1,0]])])
    sage: SubLattice(L,[L.basis()[0]])
    [...]
    ValueError: The basis is not stable under the action of the group



########LIST OF ATTRIBUTES OF A LATTICE########

    - Lattice._group : returns the group acting on the lattice
    - Lattice._generators : returns the generators of that group
    - Lattice._rank : returns the rank of the lattice
    - Lattice._action_matrices : returns the matrices through which the group acts
    - Lattice._action._morphism : returns the map (as a group homomorphism in GAP) from
      the group to GL(rank,ZZ)
    - Lattice._GAPMap : returns the SAGE Map element representing Lattice.action_morphism
    - Lattice._action : returns the SAGE action of the group on the lattice

########LIST OF METHODS OF A LATTICE#######
Let us create a few lattices to test the methods.

EXAMPLES:: 


    sage: G=PermutationGroup([(1,2),(3,4,5)])
    sage: G.gens()
    [(3,4,5), (1,2)]
    sage: act1=matrix(3,[0,1,0,0,0,1,1,0,0])
    sage: act2=matrix(3,[1,0,0,0,1,0,0,0,1])
    sage: act=[act1,act2]
    sage: L1=Lattice_ambient(G,act)

L1 is the group C2xC3 acting on ZZ^3 via the identity for the first component and 
oder 3 permutation for the second component.
::

    sage: L2=Lattice_ambient(SymmetricGroup(3),4)

L2 is the symmetric group S3 acting trivially on ZZ^4
:: 

    sage: m1=matrix(3,[0,0,1,-1,-1,-1,1,0,0])
    sage: m2=matrix(3,[-1,0,0,0,-1,0,0,0,-1])
    sage: m3=matrix(3,[0,1,0,1,0,0,-1,-1,-1])
    sage: L3=Lattice_ambient([m1,m2,m3])

L3 is the lattice with action of the group generated by the matrices m1, m2, m3, which is also
the group of GAP ID (3,3,3,3)

- lattice.group() : returns the group acting on the lattice

EXAMPLES:: 

    sage: L1.group()
    Permutation Group with generators [(3,4,5), (1,2)]
    sage: L2.group()
    Symmetric group of order 3! as a permutation group
    sage: L3.group()
    Matrix group over Integer Ring with 3 generators (
    [ 0  0  1]  [-1  0  0]  [ 0  1  0]
    [-1 -1 -1]  [ 0 -1  0]  [ 1  0  0]
    [ 1  0  0], [ 0  0 -1], [-1 -1 -1]
    )

- lattice._act(group_element,lattice_element) computes the action of the group_element on the lattice_element

EXAMPLES:: 
    
    sage: L1._act(L1.group()[1],L1.basis()[0])
    (0, 0, 1)

    sage: L2._act(L2.group()[1],L2.basis()[0])
    (1, 0, 0, 0)


- lattice.isomorphic_ambient_lattice() : returns an isomorphic ambient lattice, it is the identity in the lattices
  that are already ambient, it is mostly useful for sublattice which are not ambient

EXAMPLES::


    sage: SL=SubLattice(L1,[L1.basis()[0]-L1.basis()[1],L1.basis()[1]-L1.basis()[2]])
    sage: L1.isomorphic_ambient_lattice() is L1
    True
    sage: SL.isomorphic_ambient_lattice() 
    Ambient free module of rank 2 over the principal ideal domain Integer Ring
    sage: _._action_matrices
    [
    [ 0 -1]  [1 0]
    [ 1 -1], [0 1]
    ]

::

    sage: L=Lattice_ambient(SymmetricGroup(2),[matrix([[0,1],[1,0]])])
    sage: SL=SubLattice(L,[L.basis()[0]+L.basis()[1]])
    sage: SL.isomorphic_ambient_lattice()
    Ambient free module of rank 1 over the principal ideal domain Integer Ring
    sage: _.basis()
    [
    (1)
    ]
    sage: __._action_matrices
    [[1]]


- lattice.GAPMatrixGroup() : returns the image of the group inside GL(rank,ZZ) as a GAP group.

EXAMPLES:: 

    sage: L1.GAPMatrixGroup()
    Group([ [ [ 0, 1, 0 ], [ 0, 0, 1 ], [ 1, 0, 0 ] ], 
      [ [ 1, 0, 0 ], [ 0, 1, 0 ], [ 0, 0, 1 ] ] ])
    sage: L2.GAPMatrixGroup()
    Group([ [ [ 1, 0, 0, 0 ], [ 0, 1, 0, 0 ], [ 0, 0, 1, 0 ], [ 0, 0, 0, 1 ] ], 
      [ [ 1, 0, 0, 0 ], [ 0, 1, 0, 0 ], [ 0, 0, 1, 0 ], [ 0, 0, 0, 1 ] ] ])
    sage: L3.GAPMatrixGroup()
    Group([ [ [ 0, 0, 1 ], [ -1, -1, -1 ], [ 1, 0, 0 ] ], 
      [ [ -1, 0, 0 ], [ 0, -1, 0 ], [ 0, 0, -1 ] ], 
      [ [ 0, 1, 0 ], [ 1, 0, 0 ], [ -1, -1, -1 ] ] ])


- lattice.colattice() : returns the lattice on which the action of the group is composed with the inverse transpose automorphism of GL(n,ZZ)

EXAMPLES::

    sage: L=Lattice_ambient(CyclicPermutationGroup(6),[matrix([[0,1],[-1,-1]])])
    sage: L._action_matrices
    [
    [ 0  1]
    [-1 -1]
    ]
    sage: L.colattice()._action_matrices
    [
    [-1  1]
    [-1  0]
    ]



- lattice.TateCohomology(n) : returns the isomorphism type of the n-th Tate Cohomology group.

EXAMPLES:

For L1 
::

    sage: for i in range(-5,5) : L1.TateCohomology(i)
    []
    [2]
    []
    [2]
    []
    [2]
    []
    [2]
    []
    [2]

For L2
::

    sage: for i in range(-5,5) : L2.TateCohomology(i)
    []
    [6, 6, 6, 6]
    []
    [2, 2, 2, 2]
    []
    [6, 6, 6, 6]
    []
    [2, 2, 2, 2]
    []
    [6, 6, 6, 6]

For L3
::    

    sage: for i in range(-5,5) : L3.TateCohomology(i)
    [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]
    [2, 2, 2, 2, 2, 2, 2, 2]
    [2, 2, 2, 2, 2, 2]
    [2, 2, 2]
    [2]
    []
    [2]
    [2]
    [2, 2, 2]
    [2, 2, 2, 2]



- lattice.induced_lattice(group,build=True) : returns the ambient lattice obtained by inducing the representation of the group to a bigger group. 
  If build is set to False, then it just returns the matrices to define the action on the induced lattice but doesn't build the lattice.  


EXAMPLES::

    sage: L1.induced_lattice(SymmetricGroup(5))
    Ambient free module of rank 60 over the principal ideal domain Integer Ring
    sage: L2.induced_lattice(SymmetricGroup(4),False)
    [
    [0 0 0 0|0 0 0 0|0 0 0 0|1 0 0 0]  [1 0 0 0|0 0 0 0|0 0 0 0|0 0 0 0]
    [0 0 0 0|0 0 0 0|0 0 0 0|0 1 0 0]  [0 1 0 0|0 0 0 0|0 0 0 0|0 0 0 0]
    [0 0 0 0|0 0 0 0|0 0 0 0|0 0 1 0]  [0 0 1 0|0 0 0 0|0 0 0 0|0 0 0 0]
    [0 0 0 0|0 0 0 0|0 0 0 0|0 0 0 1]  [0 0 0 1|0 0 0 0|0 0 0 0|0 0 0 0]
    [-------+-------+-------+-------]  [-------+-------+-------+-------]
    [1 0 0 0|0 0 0 0|0 0 0 0|0 0 0 0]  [0 0 0 0|1 0 0 0|0 0 0 0|0 0 0 0]
    [0 1 0 0|0 0 0 0|0 0 0 0|0 0 0 0]  [0 0 0 0|0 1 0 0|0 0 0 0|0 0 0 0]
    [0 0 1 0|0 0 0 0|0 0 0 0|0 0 0 0]  [0 0 0 0|0 0 1 0|0 0 0 0|0 0 0 0]
    [0 0 0 1|0 0 0 0|0 0 0 0|0 0 0 0]  [0 0 0 0|0 0 0 1|0 0 0 0|0 0 0 0]
    [-------+-------+-------+-------]  [-------+-------+-------+-------]
    [0 0 0 0|1 0 0 0|0 0 0 0|0 0 0 0]  [0 0 0 0|0 0 0 0|0 0 0 0|1 0 0 0]
    [0 0 0 0|0 1 0 0|0 0 0 0|0 0 0 0]  [0 0 0 0|0 0 0 0|0 0 0 0|0 1 0 0]
    [0 0 0 0|0 0 1 0|0 0 0 0|0 0 0 0]  [0 0 0 0|0 0 0 0|0 0 0 0|0 0 1 0]
    [0 0 0 0|0 0 0 1|0 0 0 0|0 0 0 0]  [0 0 0 0|0 0 0 0|0 0 0 0|0 0 0 1]
    [-------+-------+-------+-------]  [-------+-------+-------+-------]
    [0 0 0 0|0 0 0 0|1 0 0 0|0 0 0 0]  [0 0 0 0|0 0 0 0|1 0 0 0|0 0 0 0]
    [0 0 0 0|0 0 0 0|0 1 0 0|0 0 0 0]  [0 0 0 0|0 0 0 0|0 1 0 0|0 0 0 0]
    [0 0 0 0|0 0 0 0|0 0 1 0|0 0 0 0]  [0 0 0 0|0 0 0 0|0 0 1 0|0 0 0 0]
    [0 0 0 0|0 0 0 0|0 0 0 1|0 0 0 0], [0 0 0 0|0 0 0 0|0 0 0 1|0 0 0 0]
    ]


This is not yet implemented when a lattice is declared with a matrix group since
SAGE doesn't handle cosets for matrix groups.


- lattice.zero_sum_sublattice(ambient=False): returns the sublattice of elements whose coordinates sum up to zero.
  If ambient is True, then it will give it as an ambient lattice, otherwise just a sublattice.

EXAMPLES::

    sage: L1.zero_sublattice()
    Free module of degree 3 and rank 2 over Integer Ring
    Echelon basis matrix:
    [ 1  0 -1]
    [ 0  1 -1]
    sage: L2.zero_sublattice()
    Free module of degree 4 and rank 3 over Integer Ring
    Echelon basis matrix:
    [ 1  0  0 -1]
    [ 0  1  0 -1]
    [ 0  0  1 -1]


We can make them directly ambient lattices 
::


    sage: L1.zero_sublattice(True)
    Ambient free module of rank 2 over the principal ideal domain Integer Ring
    sage: _._action_matrices
    [
    [ 0  1]  [1 0]
    [-1 -1], [0 1]
    ]
    sage: L2.zero_sublattice(True)
    Ambient free module of rank 3 over the principal ideal domain Integer Ring
    sage: _._action_matrices
    [
    [1 0 0]  [1 0 0]
    [0 1 0]  [0 1 0]
    [0 0 1], [0 0 1]
    ]


- lattice.norm_one_restriction(self,group,build=True) : combines the induction and zero sum methods to return the character lattice corresponding to a norm 1 
  restriction of scalars of a Torus.


EXAMPLES::

    sage: L1.norm_one_restriction_of_scalars(SymmetricGroup(5))
    Free module of degree 3 and rank 2 over Integer Ring
    Echelon basis matrix:
    [ 1  0 -1]
    [ 0  1 -1]
    sage: L2.norm_one_restriction_of_scalars(SymmetricGroup(4))
    Free module of degree 4 and rank 3 over Integer Ring
    Echelon basis matrix:
    [ 1  0  0 -1]
    [ 0  1  0 -1]
    [ 0  0  1 -1]

We can check the actions on each norm one restriction

    sage: L1.norm_one_restriction_of_scalars(SymmetricGroup(5))
    Free module of degree 3 and rank 2 over Integer Ring
    Echelon basis matrix:
    [ 1  0 -1]
    [ 0  1 -1]
    sage: L2.norm_one_restriction_of_scalars(SymmetricGroup(4))
    Free module of degree 4 and rank 3 over Integer Ring
    Echelon basis matrix:
    [ 1  0  0 -1]
    [ 0  1  0 -1]
    [ 0  0  1 -1]




##################################################
#
#   CLASS FOR TORI
#
##################################################
"""   


from __future__ import print_function, absolute_import



from sage.schemes.generic.scheme import Scheme
from sage.categories.morphism import SetMorphism
"""
from sage.modules.free_module import FreeModule_generic_pid
"""
from sage.matrix.action import MatrixMulAction
from sage.categories.action import PrecomposedAction
from six import integer_types
from sage.rings.integer_ring import ZZ
from sage.groups.perm_gps.permgroup import PermutationGroup
from sage.groups.perm_gps.permgroup_element import SymmetricGroupElement
from sage.categories.map import Map
from sage.modules.free_module import FreeModule_ambient_pid 
from sage.modules.free_module import FreeModule_generic
from sage.modules.free_module import FreeModule_submodule_pid
import sage.groups.libgap_group
import sage.matrix.matrix0
from sage.categories.homset import Hom
from sage.groups.matrix_gps.catalog import GL
from sage.libs.gap.element import GapElement
import sage.groups.libgap_wrapper 
import sage.groups.libgap_group
import sage.libs.gap.util
from sage.libs.gap.libgap import libgap
from sage.interfaces.gap import gap
from sage.matrix.constructor import matrix
from sage.combinat.permutation import Permutation
from sage.matrix.matrix_space import MatrixSpace
from sage.groups.matrix_gps.finitely_generated import MatrixGroup
from sage.groups.perm_gps.permgroup import load_hap
from sage.matrix.special import block_matrix



###############################################################################
#
# Base class for all group schemes
#
###############################################################################


def is_GroupScheme(X):
    return isinstance(X,GroupScheme)



class GroupScheme(Scheme):
    """Group_scheme"""
    def __init__(self, X=None):
        Scheme.__init__(self,X)
        








class GAPMap_toGLn(Map):
    """Get a Sage Map from a GAP group homomorphism with values in matrices  """
    def __init__(self, galois,rank, hom):
        Map.__init__(self,Hom(galois,GL(rank,ZZ)))
        self._morphism=hom
        self._domain=galois
        self._codomain=GL(rank,ZZ)
    def _call_(self,element):
        if element is tuple:
            Elt=Permutation(element)
        else:
            Elt=element
        return matrix((gap.Image(self._morphism,Elt)).sage())
        



###############################################################################
#
# Base class for all lattices
#
###############################################################################




class Lattice_generic(FreeModule_generic):


 

    def __init__(self, galois, action=1, check=True):
        if type(galois)==list :
            self._group=MatrixGroup(galois)
            self._generators=galois
            self._rank = galois[0].nrows()
            self._action_matrices=galois
            FreeModule_generic.__init__(self,ZZ,self._rank,self._rank)
            A=libgap(galois)
            G=gap.GroupByGenerators(A)
            self._action_morphism=gap.GroupHomomorphismByImages(G,G,A,A)
        else:
            self._group=galois
            self._generators=galois.gens()
            if action  in ZZ: 
                FreeModule_generic.__init__(self,ZZ,action,action)
                self._rank=action
                self._action_matrices=[matrix.identity(action) for i in range(len(self._generators))]
            elif not len(action) :
                raise ValueError('The module is missing the action of the Galois group.')
            else:
                self._action_matrices=action    
                for x in action: 
                    if not x.nrows()==x.ncols():
                        raise ValueError('The matrices for the action need to be squares.')
                    elif not x.nrows()==action[0].nrows(): 
                        raise ValueError('The matrices fot the action need to have same dimension.')
                    elif not x in GL(action[0].nrows(),ZZ):
                     raise ValueError('The matrices need to be invertible in ZZ.')
                    else :
                        self._rank=action[0].nrows()
                        FreeModule_generic.__init__(self,ZZ,self._rank,self._rank)
                if not len(self._generators)==len(action):
                    raise ValueError('The number of action matrices needs to match the number of generators of the Galois group.')
            G=gap(self._group)
            GenG=gap(self._generators)
            Mats=gap(self._action_matrices)
            if self._rank==1 : 
                gl=gap.Group([ [ [ -1 ] ] ])
            else :
                gl=gap.GL(self._rank,ZZ)
            self._action_morphism=gap.GroupHomomorphismByImages(G,gl,GenG,Mats)
            if check and gap.IsBool(self._action_morphism) :
                raise ValueError('The action is not well defined') 

        self._GAPMap=GAPMap_toGLn(self._group,self._rank,self._action_morphism)
        MZ=MatrixSpace(ZZ,self._rank)
        A=MZ.get_action(self)
        self._action=PrecomposedAction(A,self._GAPMap,None)
    def _act(self,g,e):
        return  self._action.act(g,e)






    ##### METHODS FOR LATTICES WITH GROUP ACTIONS######
    def group(self):
        return self._group

    def isomorphic_ambient_lattice(self):
        return self.ambientify()

    def GAPMatrixGroup(self):
        f=self._GAPMap
        return gap.Image(f._morphism)


    def colattice(self):
        newacts = [ i.inverse().transpose() for i in self._action_matrices]
        return Lattice_ambient(self._group,newacts)
    

    def TateCohomology(self,n):
        return self.TCohomology(n)

    def induced_lattice(self,group,build=True):
        return self.induction(group,build)

    def zero_sum_sublattice(self,ambient=False):
        return self.zero_sublattice()
    def norm_one_restriction_of_scalars(self,group):
        return self.norm_one_restriction_of_scalars(self,group)









class Lattice_ambient(FreeModule_ambient_pid,Lattice_generic):
    """
    Generates the Character lattice  with Galois action
    If the parameter action is an integer, it will be the rank of the ZZ-module, seen with trivial Galois action. Otherwise, action should be an r-tuple of matrice where r is the number of generators or the group.


    """

    def __init__(self, galois, action=1, check=True):
        Lattice_generic.__init__(self,galois,action,check)
        FreeModule_ambient_pid.__init__(self,ZZ,self._rank)


    def ambientify(self):
        return self








    def TCohomology(self,n):
        
        MG=self.GAPMatrixGroup()

        if type(self._group[0]) is PermutationGroupElement :
            G=libgap(self._group)  
        elif type(self._group[0]) is SymmetricGroupElement :
            G=gap.Group([gap(i) for i in self._generators])
        else :
            G=gap.Group(self._action_matrices)
        #This is a slight adaptation of the code from Hoshi and Yamasaki done on GAP
        if n==0 :
            M=matrix.zero(self._rank)
            if type(self._group[0]) is PermutationGroupElement or type(self._group[0]) is SymmetricGroupElement  :
                Lst=[libgap(i) for i in self._group]
            else:
                Lst=[i.gap() for i in self._group]
            for i in Lst:
                M+=matrix(gap.Image(self._action_morphism,i).sage())
            #M=matrix((libgap.Sum(MG)).sage())
            S=M.smith_form(False,True)
            R=S.rank()
            RR=[S[i][i] for i in range(R)]
            return [i for i in RR if i>1]
        elif n==-1 :
            m=gap([])
            for i in gap.GeneratorsOfGroup(MG) : 
                m=gap.Concatenation(m,i-gap.Identity(MG))
            ms=matrix(m.sage())
            s=ms.smith_form(False,True)
            r=s.rank()
            rr=gap([s[i][i] for i in range(r)])
            return [i for i in rr if i>1]
        else  :
            load_hap()
            if n>0 :
                #This computes the standard resolution of G in HAP
                R = gap.ResolutionFiniteGroup(G,n+1)
                #Then applies the map to the action to the resolution
                TR = gap.HomToIntegralModule(R,self._action_morphism)
                #Might have a problem because gap does only right actions ?
                return (gap.Cohomology(TR,n)).sage()
            else :
                R = gap.ResolutionFiniteGroup(G,-n)
                TR = gap.TensorWithIntegralModule(R,self._action_morphism)
                return (gap.Homology(TR,-n-1)).sage()



    #.self._induction(containing_group,build) computes the lattice obtained by induction from 
    #the group defining the lattice to a bigger group "containing_group" 


    #The build argument will ensure that we build the lattice if it is true, 
    #otherwise it just gives us the matrices needed to build the lattice with
    #the group we input, this will be useful to get other constructions like 
    #the character lattice of the norm 1 restriction of scalars torus



    def induction(self,group,build=True):
        LCos=group.cosets(self._group,'left')
        LCosReps=[i[0] for i in LCos]
        LCosnum=len(LCos)
    #get_coset_index will take an element g of G and return the index of the coset it belongs to
        def get_coset_index(g):
            for i in range(LCosnum):
                if g in LCos[i]:
                    return i
            raise ValueError('Found an element which does not belong to any coset')

    #decomp takes an element g of the big group G, and returns a pair
        def decomp(g):
            i=get_coset_index(g)
            return [i,(LCosReps[i].inverse())*g]
        r"""
        decomp2(element,index) will do the main computation for the group action on the 
        induced lattice (we deal with finite groups so induced is the same as coinduced)
        -\ZZ[G]\otimes_{\ZZ[H]} L -

         To do so, we look at the multiplication g*gi where gi is a representative of the
         ith left coset
        """

        def decomp2(g,i):
            return decomp(g*LCosReps[i])


        #Now we create block matrices corresponding to actions of each generator of G, it 
        #is the composition of a block unimodular matrix for permutation of blocks
        #and the block diagonal matrix applying the correct element of H to each block

        def make_matrix(g):
            Lst=[]
            Bigmatlist = []
            for i in range(LCosnum) : 
                Lst.append(decomp2(g,i))
            Matlist=[matrix.zero(self._rank) for j in range(LCosnum)]
            Matlist=[ matrix((gap.Image(self._action_morphism,gap(j[1]))).sage())   for j in Lst]
            for i in range(LCosnum):
                Bigmatlist+=[Matlist[j] if Lst[j][0]==i else matrix.zero(self._rank)   for j in range(LCosnum)]
            return block_matrix(LCosnum,LCosnum,Bigmatlist)

  

        GGen=self._generators




    



        gens_induced_act = [make_matrix(g) for g in group.gens()]
        if build :
            return Lattice_ambient(group,gens_induced_act)   
        else:
            return gens_induced_act
    #now we build the character lattice for the norm 1 restrictions of scalars        
    def zero_sublattice(self,ambient=False):
        if ambient:
            A=self
            acts=self._action_matrices
            newacts=[A[[i for i in range(A.ncols()-1)],[i for i in range(A.ncols()-1)]]-A[[i for i in range(A.ncols()-1)],[A.ncols()-1]]*matrix(1,[1 for i in range(A.ncols()-1)]) for A in acts]
            return Lattice_ambient(self._group,newacts)
        else :
            oldBasis=self.basis()
            newBasis = [ oldBasis[i]-oldBasis[len(oldBasis)-1]     for i in range(len(oldBasis)-1)  ]
            return SubLattice(self,newBasis)
        r"""
        This does the following, for each nxn matrix defining the action of the induced representation, 
        it extracts two blocks
        (        |   )
        (    A   | B )     A which is of size n-1 x n-1
        (        |   ) and B which is of size n-1 x 1 
        (------------)
        (    C   | D )

        Then it computes the action for the norm 1 restriction of scalars, which is
        A - B * (1,1,...,1)


        Indeed, since the norm 1 restriction lattice will be the sublattice 
        of elements summing up to 1, so we only consider the first n-1 basis elements, 
        doing the matrix computation, the element l=(l_1,...l_(n-1)) is sent to 
        A *l + B * (-sum_i l_i), which is the transformation A-B*(1,...,1)
        """

    def norm_one_restriction_of_scalars(self,group):
        return self.zero_sum_sublattice(self.induction(group))


 


class SubLattice(Lattice_generic,FreeModule_submodule_pid):
    def __init__(self, lattice,basis,check=True):
        Lattice_generic.__init__(self,lattice._group,lattice._action_matrices)
        FreeModule_submodule_pid.__init__(self,lattice,basis)
        self._parent_lattice=lattice
        if check:
            for i in lattice._group.gens():
                for j in basis:
                    if not lattice._act(i,j) in self:
                        raise ValueError("The basis is not stable under the action of the group")

    def ambientify(self):
        oldBasis=self.basis()
        act_builder=[]
        for g in self._group.gens() :
            mat_builder=[]
            for i in oldBasis:
                mat_builder.append(self.coordinate_vector(self._act(g,i)))
            act_builder.append(matrix(mat_builder))
        return Lattice_ambient(self._group,act_builder)

    def TCohomology(self,n):
        return self.ambientify().TCohomology(n)

    def induction(self,group):
        return self.ambientify().induction(group)

    def norm_one_restriction_of_scalars(self,group):
        return self.ambientify().induction(group)
    


        """
        TO FINISH
    def zero_sum_sublattice(self):
        oldBasis=self.basis()
        newBasis=[]
        diagonal=0
        for i in self._parent_lattice.basis():
            diagonal+=i
        for i in self.basis():
            newBasis.append()
        return 1
        """



		
		
class AlgebraicTorus(GroupScheme):
    """
    Creates an algebraic torus through its equivalence of categories with the action of a Galois Group on an integral lattice.




    """

    def __init__(self, lattice):
        """
        TO DO

        """
        GroupScheme.__init__(self)
        if lattice is None:
        	raise ValueError('You have to specify a lattice.')
        else:
            self._lattice = lattice
    def _repr_(self):
        return "Algebraic Torus of rank %s defined by the following lattice :\n"%(self.rank())+self._lattice._repr_()+"\nand an action by the galois group of the form :\n"+self._lattice._group._repr_() 
    def Tate_Cohomology(self,n):
        #This gives the isomorphism type of the nth cohomology group using Tate-Nakayama duality 
        return self._lattice.TateCohomology(2-n)
    def galois_group(self):
        return self._lattice._group
    def character_lattice(self):
        return self._lattice
    def rank(self):
        return self._lattice._rank
    def cocharacter_lattice(self):
        return self._lattice.colattice()

        #gives the torus representing the Restriction of scalars. 
        #Right now, for a torus defined over K, splitting over L, 
        #to compute the restriction of scalars to k inside K, 
        #the user has to enter the galois group of the extension L/k
        #In the future, when we will have a better notion for Galois group
        #perhaps we can deal with fields directly.


    def restriction_of_scalars(self,group):
        return AlgebraicTorus(self._lattice.induced_lattice(group))
    def norm_one_restriction(self,group):
        return AlgebraicTorus(self._lattice.norm_one_restriction(group))