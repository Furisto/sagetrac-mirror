r"""
Examples of Vertex Algebras

- Abelian Vertex Algebra

  An Abelian vertex algebra is a unital, commutative, associative,
  differential algebra. The `\lambda`-bracket vanishes identically.

- Affine Vertex Algebra

  Given a simple finite dimensional Lie algebra `\mathfrak{g}` over a
  commutative ring `R` and an element `k \in R`, the *universal affine
  vertex algebra of level* `k` is the vertex algebra generated by
  `\mathfrak{g}` with `\lambda`-brackets:

  .. MATH::

      [a_\lambda b] = [a,b] + \lambda (a,b) k |0\rangle, \qquad a,b \in
      \mathfrak{g},

  where `(\cdot,\cdot) : \mathfrak{g} \otimes_R \mathfrak{g} \rightarrow
  R` is the invariant, non-degenerate, bilinear form on `\mathfrak{g}`
  normalized so that the highest root has square-norm `2`.

- Free Bosons Vertex Algebra

  Let `R` be a commutative ring and `V` be a free `R`-module with a
  non-degenerate symmetric pairing
  `(\cdot,\cdot): V \otimes V \rightarrow R`. The *Free Bosons* vertex
  algebra is generated by `V` with `\lambda`-brackets:

  .. MATH::

      [v_\lambda w] = \lambda (v,w) |0\rangle, \qquad v,w \in V.

  This is a conformal vertex algebra of central charge `\mathrm{dim} V`
  where each generator has conformal weight `1`.

- Free Fermions Vertex Algebra

  Let `R` be a commutative ring and `V` be a free `R`-module with a
  non-degenerate symmetric pairing
  `(\cdot,\cdot): V \otimes V \rightarrow R`. The *Free Fermions* super
  vertex algebra is generated by `\Pi V` (an odd copy of `V`) with
  `\lambda`-brackets:

  .. MATH::

      [v_\lambda w] = (v,w) |0\rangle, \qquad v,w \in V.

  This is a conformal vertex algebra of central charge
  `\frac{\mathrm{dim} V}{2}`
  where each generator has conformal weight `\frac{1}{2}`.


- Virasoro Vertex Algebra

  The Virasoro Vertex algebra of central charge `c` is the `H`-graded
  vertex algebra generated by a vector `L` of conformal weight `2` with
  `\lambda`-bracket

  .. MATH::

      [L_\lambda L] = T L + 2 \lambda L + \frac{\lambda^3}{12} c
      |0\rangle.

- Neveu-Schwarz Super Vertex Algebra

  The `N=1` or *Neveu-Schwarz* super vertex algebra is a super
  extension of the Virasoro vertex algebra of central charge `c` with
  generator `L` by an odd primary generator `G` of conformal weight
  `3/2`. The remaining `\lambda`-bracket is given by:

  .. MATH::

      [G_\lambda G] = 2L + \frac{\lambda^2 c}{3} |0\rangle.

- N=2 Super Vertex Algebra

  The `N=2` super vertex algebra of central charge `c` is an extension of
  the Virasoro vertex algebra of central charge `c` (with generator `L`)
  by an even generator `J` which is primary of conformal weight `1` and
  two odd generators `G_1,G_2` which are primary of conformal weight
  `3/2`. The remaining `\lambda`-brackets are given by:

  .. MATH::

      [J_\lambda J] &= \frac{\lambda}{3} c |0\rangle, \\
      [J_\lambda G_1] &= G_1, \\
      [J_\lambda G_2] &= -G_2, \\
      [{G_1}_\lambda G_1] &= [{G_2}_\lambda G_2 ] = 0, \\
      [{G_1}_\lambda G_2] &= L + \frac{1}{2} TJ + \lambda J +
      \frac{\lambda^2}{6}c |0\rangle.

- Weyl Vertex Algebra

  Given a commutative ring `R`, a free `R`-module `M` and a
  non-degenerate, skew-symmetric, bilinear pairing
  `\langle \cdot,\cdot\rangle: M \otimes_R M \rightarrow R`. The *Weyl*
  vertex algebra associated to this datum is the vertex algebra generated
  by `M` with `\lambda`-brackets given by:

  .. MATH::

      [v_\lambda w] = \langle v, w\rangle |0\rangle.

  This is not an H-graded vertex algebra. The choice of a
  Lagrangian decomposition `M = L \oplus L^*` determines an H-graded
  structure, however half the generators have conformal weight ``0`` and
  therefore the graded pieces of this vertex algebra are not finite
  dimensional.

  .. SEEALSO::

      :class:`Bosonic Ghosts Lie conformal algebra<sage.algebras.lie_conformal_algebras.examples.BosonicGhostsLieConformalAlgebra>`

AUTHORS:

- Reimundo Heluani (2020-06-15): Initial implementation.
"""

#******************************************************************************
#       Copyright (C) 2019 Reimundo Heluani <heluani@potuz.net>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# (at your option) any later version.
#                  http://www.gnu.org/licenses/
#*****************************************************************************

from .universal_enveloping_vertex_algebra import \
                                                UniversalEnvelopingVertexAlgebra
from sage.sets.family import Family

class AbelianVertexAlgebra(UniversalEnvelopingVertexAlgebra):
    def __init__(self, R, ngens=1, weights=None, parity=None, names=None,
                 index_set=None):
        r"""
        The Abelian vertex algebra.

        INPUT:

        - ``R`` -- a commutative ring; the base ring of this vertex
          algebra
        - ``ngens`` -- a positive integer (default: ``1``); the number
          of generators of this Lie conformal algebra
        - ``weights`` -- a list of positive rational numbers (default:
          ``1`` for each generator); the weights of the generators.
          The resulting vertex algebra is `H`-graded
        - ``parity`` -- ``None`` or a list of ``0`` or ``1`` (default:
          ``None``); The parity of the generators. If not ``None`` the
          resulting Lie Conformal algebra is a Super Lie conformal
          algebra
        - ``names`` -- a list of ``str`` or ``None`` (default: ``None``
          ); alternative names for the generators
        - ``index_set`` -- an enumerated set or ``None`` (default:
          ``None``); indexing set for the generators

        OUTPUT:

        The Abelian vertex algebra with generators `a_i`,
        `i=1,...,n` and vanishing `\lambda`-brackets, where `n` is
        ``ngens``.

        EXAMPLES::

            sage: F = AbelianVertexAlgebra(QQ,2,weights=(2,3/2),parity=(0,1),names=('L','G'))
            sage: F.inject_variables()
            Defining L, G
            sage: (L*L)*L*G
            L_-2L_-2L_-2G_-3/2|0>

        .. TODO::

            implement its own class to speed up arithmetics in this
            case.
        """
        from sage.algebras.lie_conformal_algebras.examples import \
                                                    AbelianLieConformalAlgebra

        ML = AbelianLieConformalAlgebra(R, ngens=ngens, weights=weights,
                                        parity=parity, names=names,
                                        index_set=index_set)

        super(AbelianVertexAlgebra,self).__init__(R,ML)

    def _repr_(self):
        """
        The name of this vertex algebra.

        EXAMPLES::

            sage: V = AbelianVertexAlgebra(QQ); V
            The Abelian vertex algebra over Rational Field with generators (a_-1|0>,)
        """
        return "The Abelian vertex algebra over {} with generators {}".\
               format(self.base_ring(), self.gens())

    from .vertex_algebra_element import UniversalEnvelopingVertexAlgebraElement

    class Element(UniversalEnvelopingVertexAlgebraElement):
        """
        An element of an Abelian vertex algebra.

        EXAMPLES::

            sage: R = AbelianVertexAlgebra(QQ)
            sage: R.an_element()
            |0> + 2*a_-1|0> + 3*a_-1a_-1|0> + a_-1a_-1a_-1a_-1|0>
        """
        def _bracket_(self,other):
            r"""
            The `\lambda` bracket of these two elements.

            EXAMPLES::

                sage: R = AbelianVertexAlgebra(QQ); R.inject_variables()
                Defining a
                sage: a.bracket(a)
                {}
            """
            return {}


class AffineVertexAlgebra(UniversalEnvelopingVertexAlgebra):
    def __init__(self, R, ct, k, names=None):
        r"""
        The universal affine vertex algebra.

        INPUT:

        - ``R`` -- a commutative ring; the base ring of this vertex
          algebra.
        - ``ct`` -- a ``str`` or a
          :mod:`CartanType<sage.combinat.root_system.cartan_type>`;
          the cartan type of the corresponding finite dimensional Lie
          algebra `\mathfrak{g}`
        - ``k`` -- an element of ``R``; the level
        - ``names`` -- a list of ``str`` or ``None`` (default:
          ``None``); alternative names for the generators of this
          vertex algebra

        EXAMPLES:

        We construct the universal affine vertex algebra of
        `\mathfrak{sl}_2` at level `1`::

            sage: V = AffineVertexAlgebra(QQ, 'A1', 1, names=('e','h','f')); V
            The universal affine vertex algebra of CartanType ['A', 1] at level 1 over Rational Field
            sage: V.central_charge()
            1
            sage: V.inject_variables()
            Defining e, h, f

        We check that the Sugawara construction gives a Virasoro
        vector of central charge `1`::

            sage: L = (e*f + h*h/2 + f*e)/6
            sage: L.bracket(L) == {0: L.T(), 1: 2*L, 3: 1/2*V.vacuum()}
            True

        We find all singular vectors of conformal weight `2` and
        construct the irreducible quotient::

            sage: sing = V.find_singular(2); sing
            (e_-1e_-1|0>,
             e_-1h_-1|0> + e_-2|0>,
             h_-1h_-1|0> - 2*e_-1f_-1|0> + h_-2|0>,
             h_-1f_-1|0> + f_-2|0>,
             f_-1f_-1|0>)
            sage: I = V.ideal(sing); I
            ideal of The universal affine vertex algebra of CartanType ['A', 1] at level 1 over Rational Field generated by (e_-1e_-1|0>, e_-1h_-1|0> + e_-2|0>, h_-1h_-1|0> - 2*e_-1f_-1|0> + h_-2|0>, h_-1f_-1|0> + f_-2|0>, f_-1f_-1|0>)
            sage: Q = V.quotient(I)
            sage: Q.hilbert_series(4)           # long time (2 seconds)
            1 + 3*q + 4*q^2 + 7*q^3 + O(q^4)
            sage: Q.find_singular(2)            # long time (1 second)
            ()

        TESTS::

            sage: V = AffineVertexAlgebra(QQ, CartanType('A1'),1); V
            The universal affine vertex algebra of CartanType ['A', 1] at level 1 over Rational Field
        """
        from sage.algebras.lie_conformal_algebras.examples import \
                                                    AffineLieConformalAlgebra
        if names is not None:
            prefix = ''
            bracket = ''
        else:
            prefix = 'E'
            bracket = '('
        ML = AffineLieConformalAlgebra(R, ct, names=names, prefix=prefix,
                                       bracket=bracket)
        cp = Family({ML.central_elements()[0]: k})
        super(AffineVertexAlgebra,self).__init__(R, ML, central_parameters=cp)

        self._level = k
        self._ct = self._lca.cartan_type()
        if not self.is_critical():
           self._c = k*self._ngens/(k+self._ct.dual_coxeter_number())

    def level(self):
        r"""
        The level of this affine vertex algebra.

        EXAMPLES::

            sage: V = AffineVertexAlgebra(QQ, 'B3', 1); V
            The universal affine vertex algebra of CartanType ['B', 3] at level 1 over Rational Field
            sage: V.level()
            1
        """
        return self._level

    def cartan_type(self):
        """
        The Cartan Type of this affine vertex algebra.

        EXAMPLES::

            sage: V = AffineVertexAlgebra(QQ, 'B3', 1); V
            The universal affine vertex algebra of CartanType ['B', 3] at level 1 over Rational Field
            sage: V.cartan_type()
            ['B', 3]
        """
        return self._ct

    def is_critical(self):
        """
        Whether the level is critical.

        The level is critical if it equals the negative of the dual
        Coxeter number of its Cartan Type.

        EXAMPLES::

            sage: V = AffineVertexAlgebra(QQ, 'A1', -2); V
            The universal affine vertex algebra of CartanType ['A', 1] at critical level over Rational Field
            sage: V.is_critical()
            True
        """
        return self.level() == -self.cartan_type().dual_coxeter_number()

    def _repr_(self):
        """
        The name of this vertex algebra.

        EXAMPLES::
            sage: V = AffineVertexAlgebra(QQ, 'A1', -2); V
            The universal affine vertex algebra of CartanType ['A', 1] at critical level over Rational Field
            sage: V = AffineVertexAlgebra(QQbar, 'A1', 1, names=('e','h','f')); V
            The universal affine vertex algebra of CartanType ['A', 1] at level 1 over Algebraic Field
        """
        if self.is_critical():
            return "The universal affine vertex algebra of CartanType {} at"\
                   " critical level over {}".format(self.cartan_type(),
                   self.base_ring())
        else:
            return "The universal affine vertex algebra of CartanType {} at "\
                   "level {} over {}".format(self.cartan_type(),
                                             self.level(), self.base_ring())

class FreeBosonsVertexAlgebra(UniversalEnvelopingVertexAlgebra):
    def __init__(self, R, ngens=None, gram_matrix=None, names=None,
                 index_set=None):
        r"""
        The Free Bosons vertex algebra.

        INPUT:

        - ``R`` -- a commutative ring; the base ring of this vertex
          algebra
        - ``ngens`` -- a positive Integer (default ``1``); the number of
          generators of this vertex algebra.
        - ``gram_matrix``: a symmetric square matrix with coefficients
          in ``R`` (default: ``identity_matrix(ngens)``); the Gram
          matrix of the inner product

        OUTPUT:

        The Free Bosons vertex algebra with generators
         `\alpha_i`, `i=1,...,n` and `\lambda`-brackets

         .. MATH::

            [{\alpha_i}_{\lambda} \alpha_j] = \lambda M_{ij} |0\rangle,

        where `n` is the number of generators ``ngens`` and `M` is
        the ``gram_matrix``. This vertex
        algebra is `H`-graded where every generator has conformal weight
        `1`.

        EXAMPLES:

        The normally ordered product is not associative::

            sage: V = FreeBosonsVertexAlgebra(QQ); V.inject_variables()
            Defining alpha
            sage: (alpha*alpha)*alpha - alpha*(alpha*alpha)
            2*alpha_-3|0>

        On the classical limit it is::

            sage: P = V.classical_limit()
            sage: a = P(alpha); a
            alpha_1
            sage: (a*a)*a
            alpha_1^3
            sage: (a*a)*a - a*(a*a)
            0

        With respect to the standard Virasoro vector, the generating
        vector is primary of conformal weight 1::

            sage: V.central_charge()
            1
            sage: L = alpha*alpha/2
            sage: L.bracket(alpha)
            {0: alpha_-2|0>, 1: alpha_-1|0>}

        We can use an explicit Gram Matrix::

            sage: V = FreeBosonsVertexAlgebra(QQ, gram_matrix=Matrix([[0,1],[1,0]]))
            sage: V
            The Free Bosons vertex algebra with generators (alpha0_-1|0>, alpha1_-1|0>) over Rational Field
            sage: V.inject_variables()
            Defining alpha0, alpha1
            sage: alpha0.bracket(alpha1)
            {1: |0>}
        """
        from sage.algebras.lie_conformal_algebras.examples import \
                                                 FreeBosonsLieConformalAlgebra

        ML = FreeBosonsLieConformalAlgebra(R,gram_matrix=gram_matrix,
                        ngens=ngens,names=names,index_set=index_set)

        cp = Family({ML.gen(-1):R.one()})

        super(FreeBosonsVertexAlgebra,self).__init__(R, ML,
                                                     central_parameters=cp)

        self._c = self._ngens

    def gram_matrix(self):
        """
        The Gramian of the inner product on the generators.

        EXAMPLES::

            sage: V = FreeBosonsVertexAlgebra(QQ, gram_matrix=Matrix([[0,1],[1,0]]))
            sage: V.gram_matrix()
            [0 1]
            [1 0]
        """
        return self._lca.gram_matrix()

    def _repr_(self):
        """
        The name of this vertex algebra.

        EXAMPLES::

            sage: FreeBosonsVertexAlgebra(QQbar)
            The Free Bosons vertex algebra with generators (alpha_-1|0>,) over Algebraic Field

        """
        return "The Free Bosons vertex algebra with generators {} over {}".\
                format(self.gens(),self.base_ring())

class FreeFermionsVertexAlgebra(UniversalEnvelopingVertexAlgebra):
    def __init__(self,R,ngens=None,gram_matrix=None,names=None,
                 index_set=None):
        r"""
        The Free Fermions Super vertex algebra.

        INPUT:

        - ``R`` -- a commutative ring; the base ring of this vertex
          algebra
        - ``ngens``: a positive Integer (default ``1``); the number of
          generators of this vertex algebra
        - ``gram_matrix``: a symmetric square matrix with coefficients
          in ``R`` (default: ``identity_matrix(ngens)``); the Gram
          matrix of the inner product of the generators
        - ``names`` -- a list of ``str`` or ``None`` (default:
          ``None``); alternative names for the generators
        - ``index_set`` -- an enumerated set or ``None`` (default:
          ``None``); alternative indexing set for the generators

        OUTPUT:

        The Free Fermions super vertex algebra with generators
         `\psi_i`, `i=1,...,n` and `\lambda`-brackets

         .. MATH::

            [{\psi_i}_{\lambda} \psi_j] = \lambda M_{ij} |0\rangle,

        where `n` is the number of generators ``ngens`` and `M` is the
        ``gram_matrix``. This super vertex
        algebra is `H`-graded where every generator has conformal weight
        `1/2`.

        EXAMPLES:

        The Bosonization of the charged Free Fermions::

            sage: F = FreeFermionsVertexAlgebra(QQ, 2, gram_matrix = Matrix([[0,1],[1,0]])); F
            The Free Fermions super vertex algebra with generators (psi_0_-1/2|0>, psi_1_-1/2|0>) over Rational Field
            sage: F.inject_variables()
            Defining psi_0, psi_1
            sage: alpha = psi_0*psi_1
            sage: alpha.bracket(alpha)
            {1: |0>}

        The standard conformal vector makes the generators have
        conformal weight `1/2`::

            sage: L = psi_0.T()*psi_1/2 + psi_1.T()*psi_0/2
            sage: L.bracket(L) == {0:L.T(), 1:2*L, 3: F.vacuum()/2}
            True
            sage: L.bracket(psi_0)
            {0: psi_0_-3/2|0>, 1: 1/2*psi_0_-1/2|0>}
            sage: L.bracket(psi_1)
            {0: psi_1_-3/2|0>, 1: 1/2*psi_1_-1/2|0>}

        The conformal vector coincides with the standard conformal
        vector for the Free Boson::

            sage: L == alpha*alpha/2
            True

        TESTS::

            sage: psi_1*psi_1
            0
        """
        from sage.algebras.lie_conformal_algebras.examples import \
                                                FreeFermionsLieConformalAlgebra

        ML = FreeFermionsLieConformalAlgebra(R,gram_matrix=gram_matrix,
                        ngens=ngens,names=names,index_set=index_set)

        cp = Family({ML.gen(-1):R.one()})

        super(FreeFermionsVertexAlgebra,self).__init__(R, ML,
                                                       central_parameters=cp)
        self._c = self._ngens/2

    def gram_matrix(self):
        """
        The Gram matrix of the generators.

        EXAMPLES::

            sage: F = FreeFermionsVertexAlgebra(QQ,2); F
            The Free Fermions super vertex algebra with generators (psi_0_-1/2|0>, psi_1_-1/2|0>) over Rational Field
            sage: F.gram_matrix()
            [1 0]
            [0 1]
        """
        return self._lca.gram_matrix()
    def _repr_(self):
        """
        The name of this vertex algebra.

        EXAMPLES::

            sage: F = FreeFermionsVertexAlgebra(QQ); F
            The Free Fermions super vertex algebra with generators (psi_-1/2|0>,) over Rational Field
        """
        return "The Free Fermions super vertex algebra with generators {} over"\
               " {}".format(self.gens(),self.base_ring())

class N2VertexAlgebra(UniversalEnvelopingVertexAlgebra):
    def __init__(self, R, c=0):
        """
        The N=2 super vertex algebra.

        INPUT:

        - ``R`` -- a commutative ring; the base ring.
        - ``c`` -- an element of ``R`` (default: ``0``); the central
          charge.

        EXAMPLES::

            sage: V = N2VertexAlgebra(QQ, 1)
            sage: V.inject_variables()
            Defining L, J, G1, G2
            sage: G1*G2 + G2*G1
            L_-3|0>

        The topological twist is a Virasoro vector with central
        charge 0::

            sage: L2 = L - 1/2*J.T()
            sage: L2.bracket(L2) == {0: L2.T(), 1: 2*L2}
            True

        A singular vector in conformal weight 2::

            sage: V.find_singular(2)
            (L_-2|0> - 3/2*J_-1J_-1|0>,)
        """
        from sage.algebras.lie_conformal_algebras.examples import \
                                                          N2LieConformalAlgebra

        ML = N2LieConformalAlgebra(R)
        cp = Family({ML.gen(-1):c})
        super(N2VertexAlgebra,self).__init__(R, ML, central_parameters=cp)
        self._c = c

    def _repr_(self):
        """
        The name of this vertex algebra.

        EXAMPLES::

            sage: V = N2VertexAlgebra(QQ); V
            The N=2 super vertex algebra of central charge 0 over Rational Field
        """
        return "The N=2 super vertex algebra of central charge {} over {}"\
                .format(self.central_charge(),self.base_ring())

class NeveuSchwarzVertexAlgebra(UniversalEnvelopingVertexAlgebra):
    def __init__(self,R,c=0):
        """
        The Neveu-Schwarz super vertex algebra.

        INPUT:

        - ``R`` -- a commutative ring; the base ring.
        - ``c`` -- an element of ``R`` (default: ``0``); the central
          charge.

        EXAMPLES:

        Some vectors in the `N=1` super vertex algebra of central
        charge `7/10`::

            sage: V = NeveuSchwarzVertexAlgebra(QQ,7/10)
            sage: M = V.get_weight(8)
            sage: [v.lift() for v in M.basis()]
            [L_-2L_-2L_-2L_-2|0>,
             L_-2L_-2G_-5/2G_-3/2|0>,
             L_-3L_-3L_-2|0>,
             L_-4L_-2L_-2|0>,
             L_-4G_-5/2G_-3/2|0>,
             L_-3G_-7/2G_-3/2|0>,
             L_-2G_-7/2G_-5/2|0>,
             L_-2G_-9/2G_-3/2|0>,
             L_-4L_-4|0>,
             L_-5L_-3|0>,
             L_-6L_-2|0>,
             G_-9/2G_-7/2|0>,
             G_-11/2G_-5/2|0>,
             G_-13/2G_-3/2|0>,
             L_-8|0>]

        A quotient by the ideal generated by the singular vector in
        conformal weight 4::

            sage: sing = V.find_singular(4); sing
            (L_-2L_-2|0> - 3/2*G_-5/2G_-3/2|0> + 3/10*L_-4|0>,)
            sage: Q = V.quotient(V.ideal(sing))
            sage: Q
            Quotient of The Neveu-Schwarz super vertex algebra of central charge 7/10 over Rational Field by the ideal generated by (L_-2L_-2|0> - 3/2*G_-5/2G_-3/2|0> + 3/10*L_-4|0>,)

        The Virasoro generator is nilpotent in the classical limit::

            sage: P = Q.classical_limit(); P.inject_variables()
            Defining L, G
            sage: L**2
            0
        """
        from sage.algebras.lie_conformal_algebras.examples import \
                                                 NeveuSchwarzLieConformalAlgebra

        ML = NeveuSchwarzLieConformalAlgebra(R)
        cp = Family({ML.gen(2):c})
        super(NeveuSchwarzVertexAlgebra,self).__init__(R, ML,
                                                       central_parameters=cp)
        self._c = c

    def _repr_(self):
        """
        The name of this vertex algebra.

        EXAMPLES::

            sage: V = NeveuSchwarzVertexAlgebra(QQ,7/10); V
            The Neveu-Schwarz super vertex algebra of central charge 7/10 over Rational Field
        """
        return "The Neveu-Schwarz super vertex algebra of central charge {}"\
               " over {}".format(self.central_charge(),self.base_ring())

class VirasoroVertexAlgebra(UniversalEnvelopingVertexAlgebra):
    def __init__(self, R, c=0):
        r"""
        The universal Virasoro vertex algebra

        INPUT:

        - ``R`` -- a commutative ring; the base ring of this vertex
          algebra.

        - ``c`` -- an element of ``R`` (default: ``0``); the central
          charge of this vertex algebra.

        EXAMPLES::

            sage: V = VirasoroVertexAlgebra(QQ,1/2); V
            The Virasoro vertex algebra of central charge 1/2 over Rational Field
            sage: V.inject_variables()
            Defining L
            sage: L.nmodeproduct(L.T()*L,0)
            5*L_-3L_-2|0>
        """
        from sage.algebras.lie_conformal_algebras.examples import \
                                                    VirasoroLieConformalAlgebra
        ML = VirasoroLieConformalAlgebra(R)
        cp = Family({ML.gen(1):c})
        super(VirasoroVertexAlgebra,self).__init__(R, ML, central_parameters=cp)
        self._c = c

    def _repr_(self):
        """
        The name of this vertex algebra.

        EXAMPLES::

            sage: VirasoroVertexAlgebra(QQbar)
            The Virasoro vertex algebra of central charge 0 over Algebraic Field
        """
        return "The Virasoro vertex algebra of central charge {} over {}".\
                format(self.central_charge(),self.base_ring())

class WeylVertexAlgebra(UniversalEnvelopingVertexAlgebra):

    def __init__(self, R, ngens=None, gram_matrix=None, names=None,
                 index_set=None):
        r"""
        The Weyl vertex algebra.

        INPUT:

        - ``R`` -- a commutative ring; the base ring of this vertex
          algebra

        - ``ngens``: an even positive Integer (Default `2`); The number
          of generators of this vertex algebra.

        - ``gram_matrix`` -- a non-singular, skew-symmetric square
          matrix with values in ``R`` (default: `None`); the Gram
          matrix of the inner product of the generators

        - ``names`` -- a list or tuple of ``str``; alternative names
          for the generators

        - ``index_set`` -- an enumerated set; alternative indexing set
          for the generators

        OUTPUT:

        The Weyl Lie conformal algebra with generators
         `\alpha_i`, `i=1,...,ngens` and `\lambda`-brackets

        .. MATH::

            [{\alpha_i}_{\lambda} \alpha_j] = M_{ij} |0\rangle,

        where `M` is the ``gram_matrix`` above.

        .. NOTE::

            The returned vertex algebra is not `H`-graded.

        EXAMPLES::

            sage: V = WeylVertexAlgebra(QQ, 4)
            sage: V.inject_variables()
            Defining alpha0, alpha1, alpha2, alpha3
            sage: alpha0.bracket(alpha2*alpha2)
            {0: 2*alpha2_(-1)|0>}
        """
        from sage.algebras.lie_conformal_algebras.examples import\
                                                    WeylLieConformalAlgebra
        ML = WeylLieConformalAlgebra(R, ngens=ngens, gram_matrix=gram_matrix,
                                      names=names, index_set=index_set)
        cp = Family({ML.gen(-1):R.one()})
        super(WeylVertexAlgebra,self).__init__(R, ML,
                                            central_parameters=cp)

    def _repr_(self):
        """
        The name of this vertex algebra.

        EXAMPLES::

            sage: V = WeylVertexAlgebra(QQ, 4); V
            The Weyl vertex algebra with generators (alpha0_(-1)|0>, alpha1_(-1)|0>, alpha2_(-1)|0>, alpha3_(-1)|0>) over Rational Field
        """
        return "The Weyl vertex algebra with generators {} over {}".format(
                self.gens(),self.base_ring())

    def gram_matrix(self):
        """
        The Gram matrix of the inner product of the generators.

        EXAMPLES::

            sage: V = WeylVertexAlgebra(QQ, 4)
            sage: V.gram_matrix()
            [ 0  0| 1  0]
            [ 0  0| 0  1]
            [-----+-----]
            [-1  0| 0  0]
            [ 0 -1| 0  0]
        """
        return self._lca.gram_matrix()
