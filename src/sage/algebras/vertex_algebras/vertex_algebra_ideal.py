"""
Vertex Algebra Ideals

AUTHORS:

- Reimundo Heluani (08-09-2019): Initial implementation.
"""

#******************************************************************************
#       Copyright (C) 2019 Reimundo Heluani <heluani@potuz.net>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# (at your option) any later version.
#                  http://www.gnu.org/licenses/
#*****************************************************************************
from sage.categories.vertex_algebras import VertexAlgebras
from sage.categories.commutative_rings import CommutativeRings
from sage.categories.modules import Modules
from sage.arith.functions import lcm
from sage.combinat.free_module import CombinatorialFreeModule
from sage.structure.unique_representation import UniqueRepresentation
from sage.rings.integer import Integer
from sage.categories.infinite_enumerated_sets import InfiniteEnumeratedSets
from sage.structure.parent import Parent
from sage.modules.with_basis.indexed_element import IndexedFreeModuleElement
from sage.misc.lazy_attribute import lazy_attribute
from sage.rings.all import QQ
from sage.categories.fields import Fields
from sage.structure.element_wrapper import ElementWrapper

class VertexAlgebraIdeal(UniqueRepresentation):
    r"""
    Base class for vertex algebra ideals.

    INPUT:

    - ``V`` -- a vertex algebra; the ambient of this ideal.
        We only support
        H-graded vertex algebras finitely generated by vectors of
        positive rational conformal weights.

    - ``gens`` a tuple of elements of ``V``; the generators of this
        ideal. We only support ideals generated by singular vectors. In
        addition we require that the subspace of ``V`` generated by 
        ``gens`` is invariant by the `0`-th product action of ``V`` (
        see the EXAMPLES section below).

    - ``check`` -- a boolean (default: ``True``): whether to check
      that the generators satisfy the conditions described above. 

    EXAMPLES::

        sage: V = VirasoroVertexAlgebra(QQ,1/2);V.find_singular(6)
        (L_-2L_-2L_-2|0> + 93/64*L_-3L_-3|0> - 33/8*L_-4L_-2|0> - 27/16*L_-6|0>,)
        sage: v = _[0]; I = V.ideal(v)
        sage: I
        ideal of The Virasoro vertex algebra of central charge 1/2 over Rational Field generated by (L_-2L_-2L_-2|0> + 93/64*L_-3L_-3|0> - 33/8*L_-4L_-2|0> - 27/16*L_-6|0>,)
        sage: V = AffineVertexAlgebra(QQ,'A1',3);e = V.gen(0)
        sage: I = V.ideal(e)
        Traceback (most recent call last):
        ...
        ValueError: Generators must be singular vectors of The universal affine vertex algebra of CartanType ['A', 1] at level 3 over Rational Field
    """
    @staticmethod
    def __classcall_private__(cls, ambient=None, gens=None, **kwds):
        known_keywords = ['check']
        for key in kwds:
            if key not in known_keywords:
                raise TypeError("VertexAlgebraIdeal(): got an unexpected "\
                                "keyword argument '%s'"%key)

        try:
            R = ambient.base_ring()
        except AttributeError:
            R = None

        if R not in CommutativeRings() or ambient not in VertexAlgebras(R):
            raise ValueError("ambient must be a vertex algebra, got {}".format(
                              ambient))

        if not isinstance(gens, (list, tuple)):
            gens = [gens]
        gens = [ambient(x) for x in gens if x]
        gens = tuple(gens)

        if len(gens)==0: gens=(ambient.zero(),)

        if ambient in VertexAlgebras(ambient.base_ring()).\
                                Graded().FinitelyGenerated():
            return GradedVertexAlgebraIdeal(ambient,gens,
                    kwds.get('check',True))

        raise NotImplementedError('Ideals are not implemented for {}'.format(
                                  ambient))

    def __init__(self, ambient, category=None):
        #stick to modules until we have a proper category of modules.
        #or even better of ideals. 
        category=Modules(ambient.base_ring()).or_subcategory(category)
        super(VertexAlgebraIdeal,self).__init__(ambient.base_ring(),
                                                category=category)
        self._ambient = ambient

class GradedVertexAlgebraIdeal(VertexAlgebraIdeal,CombinatorialFreeModule):
    def __init__(self,V,gens,check):
        r"""
        An ideal of the vertex algebra `V` generated by the list
        of vectors ``gens``.

        INPUT:

        - ``V`` -- a vertex algebra; the ambient of this ideal.
            We only support
            H-graded vertex algebras finitely generated by vectors of
            positive rational conformal weights.

        - ``gens`` a tuple of elements of ``V``; the generators of this
            ideal. We only support ideals generated by singular vectors. In
            addition we require that the subspace of ``V`` generated by 
            ``gens`` is invariant by the `0`-th product action of ``V`` (
            see the EXAMPLES section below).

        - ``check`` -- a boolean (default: ``True``): whether to check
          that the generators satisfy the conditions described above. 

        EXAMPLES:
        
        We construct the maximal ideal of the Ising module::

            sage: V = VirasoroVertexAlgebra(QQ,1/2);V.find_singular(6)
            (L_-2L_-2L_-2|0> + 93/64*L_-3L_-3|0> - 33/8*L_-4L_-2|0> - 27/16*L_-6|0>,)
            sage: v = _[0]; I = V.ideal(v)
            sage: I
            ideal of The Virasoro vertex algebra of central charge 1/2 over Rational Field generated by (L_-2L_-2L_-2|0> + 93/64*L_-3L_-3|0> - 33/8*L_-4L_-2|0> - 27/16*L_-6|0>,)

        Generators need to be closed under the `0`-th product::

            sage: V = AffineVertexAlgebra(QQ, 'A1', 1, names=('e', 'h', 'f'))
            sage: sing = V.find_singular(2); sing
            (e_-1e_-1|0>,
             e_-1h_-1|0> + e_-2|0>,
             h_-1h_-1|0> - 2*e_-1f_-1|0> + h_-2|0>,
             h_-1f_-1|0> + f_-2|0>,
             f_-1f_-1|0>)
            sage: V.ideal(sing[0:2])
            Traceback (most recent call last):
            ...
            ValueError: gens must span an invariant subspaceof V under 0-th product

        This works if we include all singular vectors of the Affine
        algebra:

        .. link::

            sage: V.ideal(sing)
            ideal of The universal affine vertex algebra of CartanType ['A', 1] at level 1 over Rational Field generated by (e_-1e_-1|0>, e_-1h_-1|0> + e_-2|0>, h_-1h_-1|0> - 2*e_-1f_-1|0> + h_-2|0>, h_-1f_-1|0> + f_-2|0>, f_-1f_-1|0>)

        Generators need to be singular vectors::

            sage: V = AffineVertexAlgebra(QQ,'A1',3);e = V.gen(0)
            sage: I = V.ideal(e)
            Traceback (most recent call last):
            ...
            ValueError: Generators must be singular vectors of The universal affine vertex algebra of CartanType ['A', 1] at level 3 over Rational Field
        """
        if V not in VertexAlgebras(V.base_ring()).Graded().FinitelyGenerated():
            raise ValueError ("V needs to be a finitely generated H-graded"\
                    "vertex algebra, got {}".format(V) )

        if check:
            if any(not g.is_singular() for g in gens):
                raise ValueError ("Generators must be singular vectors of {}"\
                                  .format(V))

            M=V.submodule(gens)
            for v in V.gens(): 
                for g in gens:
                    try:
                        M.reduce(v.nmodeproduct(g,0))
                    except ValueError:
                        raise ValueError("gens must span an invariant subspace"\
                                         "of V under 0-th product")
             
        
        #TODO: develop vertex-algebra modules to have a right category
        #here
        category = Modules(V.base_ring())
        if V in VertexAlgebras(V.base_ring()).Super():
            category = category.Super()
        category = category.WithBasis().Graded()
        VertexAlgebraIdeal.__init__(self,V,category)
        self._gens = gens
        basis = VertexAlgebraIdealBasis(V,gens)
        CombinatorialFreeModule.__init__(self,V.base_ring(), basis_keys=basis,
                                         category=category,
                                        element_class=VertexAlgebraIdealElement)

        self._unitriangular = bool(V.base_ring() in Fields())
        self.lift.register_as_coercion()

    def lift_on_basis(self,item):
        return item.value[1].lift()

    def _repr_(self):
        return "ideal of {0} generated by {1}".format(self._ambient, self._gens)

    def _inverse_on_support(self,i):
        M = self.get_weight(i.energy())
        v = M.lift._inverse_on_support(i)
        if v is None:
            return v
        return self._indices((i.energy(),v))

    @lazy_attribute
    def lift(self):

        key = self._ambient.basis().keys().rank
        return self.module_morphism(self.lift_on_basis,
                                    codomain=self._ambient,
                                    triangular="lower",
                                    unitriangular=self._unitriangular,
                                    key=key,
                                    inverse_on_support=self._inverse_on_support)

    def get_weight(self,n):
        r"""
        Returns the homogeneous component of weight ``n`` in the ideal.

        INPUT: a positive rational number ``n``.

        OUTPUT: a subspace of the ambient vertex algebra of this ideal.

        EXAMPLES::

            sage: V = VirasoroVertexAlgebra(QQ,1/2); I = V.ideal(V.find_singular(6))
            sage: I.get_weight(6)
            Free module generated by {0} over Rational Field
            sage: I.get_weight(6).an_element().lift()
            2*L_-2L_-2L_-2|0> + 93/32*L_-3L_-3|0> - 33/4*L_-4L_-2|0> - 27/8*L_-6|0>
            sage: M = I.get_weight(7); M
            Free module generated by {0} over Rational Field
            sage: M.reduce(I.gens()[0].T())
            0
            sage: V = AffineVertexAlgebra(QQ,'A1',1); I = V.ideal(V.find_singular(2))
            sage: I
            ideal of The universal affine vertex algebra of CartanType ['A', 1] at level 1 over Rational Field generated by (alpha[1]_-1alpha[1]_-1|0>, alpha[1]_-1alphacheck[1]_-1|0> + alpha[1]_-2|0>, alphacheck[1]_-1alphacheck[1]_-1|0> - 2*alpha[1]_-1-alpha[1]_-1|0> + alphacheck[1]_-2|0>, alphacheck[1]_-1-alpha[1]_-1|0> + -alpha[1]_-2|0>, -alpha[1]_-1-alpha[1]_-1|0>)
            sage: I.get_weight(3)
            Free module generated by {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14} over Rational Field
        """
        return self._indices.get_weight(n)

    def get_weight_less_than(self,n):
        """
        Returns the subspace of vectors of conformal weight less than
        ``n`` in this ideal.

        EXAMPLES::

            sage: V = VirasoroVertexAlgebra(QQ,1/2); I = V.ideal(V.find_singular(6))
            sage: I.get_weight_less_than(7)
            Free module generated by {0} over Rational Field
            sage: M = I.get_weight_less_than(9); M
            Free module generated by {0, 1, 2, 3} over Rational Field
            sage: M.an_element().lift()
            2*L_-2L_-2L_-2|0> + 93/32*L_-3L_-3|0> - 33/4*L_-4L_-2|0> - 27/8*L_-6|0> + 2*L_-3L_-2L_-2|0> + 9/8*L_-4L_-3|0> - 25/4*L_-5L_-2|0> - 27/16*L_-7|0> + 3*L_-2L_-2L_-2L_-2|0> - 1071/64*L_-4L_-2L_-2|0> - 2511/1024*L_-4L_-4|0> + 19809/2048*L_-5L_-3|0> - 657/256*L_-6L_-2|0> - 9945/2048*L_-8|0>
            sage: I.get_weight_less_than(6)
            Free module generated by {} over Rational Field
        """
        if n not in QQ or n < 0:
            raise ValueError("n must be a positive rational number")

        basis = []
        for i in self._indices:
            if i.value[0] < n:
                basis.append(i.value[1].lift())
            else:
                break
        return self._ambient.submodule(basis)

    def ambient(self):
        r"""Return the ambient vertex algebra of this ideal

        EXAMPLES::

            sage: V = VirasoroVertexAlgebra(QQ,1/2); v = V.find_singular(6)[0]; I = V.ideal(v); I
            ideal of The Virasoro vertex algebra of central charge 1/2 over Rational Field generated by (L_-2L_-2L_-2|0> + 93/64*L_-3L_-3|0> - 33/8*L_-4L_-2|0> - 27/16*L_-6|0>,)
            sage: I.ambient()
            The Virasoro vertex algebra of central charge 1/2 over Rational Field
        """
        return self._ambient

    def reduce(self,x):
        """
        The reduction of the element `x` modulo this ideal.

        INPUT:

        - ``x`` -- an element of the ambient vertex algebra

        EXAMPLES::

            sage: V = VirasoroVertexAlgebra(QQ,1/2); I = V.ideal(V.find_singular(6)); I
            ideal of The Virasoro vertex algebra of central charge 1/2 over Rational Field generated by (L_-2L_-2L_-2|0> + 93/64*L_-3L_-3|0> - 33/8*L_-4L_-2|0> - 27/16*L_-6|0>,)
            sage: L = V.0; I.reduce(L*(L*L))
            -93/64*L_-3L_-3|0> + 33/8*L_-4L_-2|0> + 27/16*L_-6|0>
            sage: I.reduce(L+L.T())
            L_-2|0> + L_-3|0>
        """
        if x.is_zero():
            return x
        if x.is_homogeneous():
            w = x.weight()
            I = self.get_weight(w)
            A = self._ambient.get_weight(w)
            M = A.submodule([A.retract(v.lift()) for v in I.basis()])
            return M.reduce(A.retract(x)).lift()
        return sum(self.reduce(m) for m in x.homogeneous_terms())

    def __contains__(self,x):
        if super(GradedVertexAlgebraIdeal,self).__contains__(x):
            return True
        if x in self._ambient:
            return not self.reduce(x)
        return False

    def an_element(self):
        B = self.basis()
        return B[self._indices[0]] + 3*B[self._indices[2]] + 5*B[self._indices[3]]

    def gens(self):
        """
        The generators of this ideal.

        EXAMPLES::

            sage: V = AffineVertexAlgebra(QQ,'A1',1, names = ('e','h','f'));
            sage: I = V.ideal(V.find_singular(2))
            sage: I.gens()
            (e_-1e_-1|0>,
             e_-1h_-1|0> + e_-2|0>,
             h_-1h_-1|0> - 2*e_-1f_-1|0> + h_-2|0>,
             h_-1f_-1|0> + f_-2|0>,
             f_-1f_-1|0>)
        """
        return self._gens

class VertexAlgebraIdealElement(IndexedFreeModuleElement):
    
    def _repr_(self):
        return repr(self.lift())

    def lift(self):
        return self.parent().lift(self)

class VertexAlgebraIdealBasis(Parent):
    def __init__(self,V,gens):
        self._ambient = V
        self._gens = gens
        Parent.__init__(self, category=InfiniteEnumeratedSets())

    def _repr_(self):
        return "Basis of the vertex algebra ideal of {} generated by {}".format(
            self._ambient,self._gens)

    def _element_constructor_(self,x):
        if not isinstance(x,(tuple,list)) or len(x) != 2:
            raise ValueError("Do not know how to convert {} into {}".format(x,
                             self))
        if x[0] not in QQ or x[0] < 0:
            raise ValueError("Do not know how to convert {} into {}".format(x,
                             self))
        B = self.get_weight(x[0]).basis()
        if x[1] in B.keys():
            return self.element_class(self,(x[0],B[x[1]]))
        if x[1] in B:
            return self.element_class(self,tuple(x))

        raise ValueError("Do not know how to convert {} into {}".format(x,self))

    class Element(ElementWrapper):
        pass

    def __iter__(self):
        vgens = self._ambient.gens()
        weights = [g.degree() for g in vgens]
        step = lcm([w.denominator() for w in weights])
        n = 0
        while True:
            M = self.get_weight(n/step)
            for y in M.basis():
                yield self.element_class(self,(n/step,y))
            n += 1

    def get_weight(self,n):
        vgens = self._ambient.gens()
        weights = [g.degree() for g in vgens]
        regular = [2*g.is_even_odd() for g in vgens]
        # Do we need to add T(g) here if the Vertex algebra is not
        # conformal?
        basis = [g._action_from_partition_tuple(pt) for g in self._gens if\
                 n-g.weight() >= 0 for pt in _negative_pt(weights,regular,
                 n-g.weight())]
        return self._ambient.submodule(basis)

    def __getitem__(self,r):
        if isinstance(r,self.element_class):
            return r
        if isinstance(r,(int,Integer)):
            return self.unrank(r)
        elif isinstance(r,slice):
            start=0 if r.start is None else r.start
            stop=r.stop
            if stop is None:
                raise ValueError('infinite set')
            count=0
            parts=[]
            for t in self:
                if count==stop:
                    break
                if count>=start:
                    parts.append(t)
                count+=1
            if count==stop or stop is None:
                return parts
            raise IndexError('value out of range')
        raise NotImplementedError('Do not know how to look for {}'.format(r))
        
def _negative_pt(weights,regular,energy=None):
    """
    helper function to compute tuples of shifted modes.

    These are to be fed into
    :meth:`algebras.lie_conformal_algebras.lie_conformal_algebra_element._action_from_partition_tuple`

    EXAMPLES::

        sage: from sage.algebras.vertex_algebras.vertex_algebra_ideal import _negative_pt
        sage: [p for p in _negative_pt((2,3/2),(0,2),5/2)]
        [([1, 1], [1/2]), ([2], [1/2]), ([1], [3/2]), ([], [5/2])]
        sage: [p for p in _negative_pt((2,3/2),(0,2),0)]
        [([], [])]
        sage: L = _negative_pt((2,3/2),(0,2))
        sage: [next(L) for i in range(8)]
        [([], []),
         ([], [1/2]),
         ([1], []),
         ([1], [1/2]),
         ([], [3/2]),
         ([1, 1], []),
         ([2], []),
         ([], [3/2, 1/2])]
    """
    from sage.arith.misc import integer_floor
    from .energy_partition_tuples import EnergyPartitionTuples
    newwgts = [w-integer_floor(w) for w in weights]
    newwgts = [w if w else w+1 for w in newwgts]
    if energy is not None:
        from sage.rings.rational_field import QQ
        if energy not in QQ or energy < 0:
            raise ValueError("energy needs to be a non-negative rational")

        EPT = EnergyPartitionTuples(newwgts,len(weights),energy,regular=regular)
    else:
        EPT = EnergyPartitionTuples(newwgts,len(weights),regular=regular)

    for p in EPT:
        modp = p.to_list()
        modp = [[part + w -1 for part in l] for l,w in zip(modp,newwgts)]
        yield tuple(modp)

    def is_submodule(self,other):
        if other is self._ambient or other is self:
            return True
        raise NotImplementedError()
