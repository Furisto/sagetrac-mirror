r"""
Vertex algebra ideals
AUTHORS

- Reimundo Heluani (08-09-2019): Initial implementation
"""

#******************************************************************************
#       Copyright (C) 2019 Reimundo Heluani <heluani@potuz.net>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# (at your option) any later version.
#                  http://www.gnu.org/licenses/
#*****************************************************************************
from sage.modules.module import Module
from sage.categories.vertex_algebras import VertexAlgebras
from sage.combinat.partition import Partitions
from sage.combinat.partition_tuple import PartitionTuples, PartitionTuples_level

class VertexAlgebraIdeal(Module):
    def __init__(self,V,gens):
        if V not in VertexAlgebras(V.base_ring()).HGraded().FinitelyGenerated():
            raise ValueError ("V needs to be a finitely and strongly generated "
                    "vertex algebra, got {}".format(V) )
        gens = tuple(gens)
        if not all(g.is_singular() for g in gens):
            raise ValueError ("Generators must be singular vectors of {}"\
                .format(V))
        super(VertexAlgebraIdeal,self).__init__(V.base_ring(), 
            category=V.category().Subobjects())
        self._gens = gens
        self._ambient = V

    def _repr_(self):
        return "ideal of {0} generated by {1}".format(self._ambient, self._gens)
    def get_degree(self,n):
        A = self._ambient.get_degree(n)
        ngens = self._ambient.ngens()
        if ngens == 1:
            basis = [g._action_from_partition_tuple(PartitionTuples_level(1)(
                [p,])) for m in range(n+1) for g in self._gens if 
                g.degree() <= m for p in Partitions(m-g.degree()) ]
        else:
            basis = [ g._action_from_partition_tuple(p) for m in range(n+1)
            for g in self._gens if g.degree() <= m for p in 
            PartitionTuples(level=ngens, size = m-g.degree()) ] 

        basis = [ A._from_dict(b.value.monomial_coefficients()) for b in basis ]
        return A.submodule(basis)

    def get_graded_part(self,n):
        A = self._ambient.get_graded_part(n)
        ngens = self._ambient.ngens()
        if ngens == 1:
            basis = [g._action_from_partition_tuple(PartitionTuples_level(1)(
                [p,])) for g in self._gens if 
                g.degree() <= n for p in Partitions(n-g.degree()) ]
        else:
            basis = [ g._action_from_partition_tuple(p) for
            g in self._gens if g.degree() <= n for p in 
            PartitionTuples(level=ngens, size = n-g.degree()) ] 

        basis = [ A._from_dict(b.value.monomial_coefficients()) for b in basis ]
        return A.submodule(basis)

    def ambient(self):
        return self._ambient

    def reduce(self,x):
        S = self.get_degree(x.weight())
        A = S.ambient()
        return S.reduce(A._from_dict(x.value.monomial_coefficients()))

    def gens(self):
        return self._gens

