"""
Vertex Algebra Ideals

AUTHORS

- Reimundo Heluani (08-09-2019): Initial implementation.
"""

#******************************************************************************
#       Copyright (C) 2019 Reimundo Heluani <heluani@potuz.net>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# (at your option) any later version.
#                  http://www.gnu.org/licenses/
#*****************************************************************************
from sage.categories.vertex_algebras import VertexAlgebras
from sage.combinat.partition import Partitions
from sage.combinat.partition_tuple import PartitionTuples, PartitionTuples_level
from sage.structure.parent import Parent
from sage.structure.unique_representation import UniqueRepresentation
from sage.categories.commutative_rings import CommutativeRings

class VertexAlgebraIdeal(Parent, UniqueRepresentation):
    r"""
    Base class for vertex algebra ideals.

    INPUT:

    - ``V`` -- a vertex algebra; the ambient of this ideal.
        We only support
        H-graded vertex algebras finitely generated by vectors of
        positive rational conformal weights.

    - ``gens`` a tuple of elements of ``V``; the generators of this
        ideal. We only support ideals generated by singular vectors

    - ``check`` -- a boolean (default: ``True``): whether to check
      that the generators are singular.

    EXAMPLES::

        sage: V = VirasoroVertexAlgebra(QQ,1/2);V.find_singular(6)
        (L_-2L_-2L_-2|0> + 93/64*L_-3L_-3|0> - 33/8*L_-4L_-2|0> - 27/16*L_-6|0>,)
        sage: v = _[0]; I = V.ideal(v)
        sage: I
        ideal of The Virasoro vertex algebra at central charge 1/2 generated by (L_-2L_-2L_-2|0> + 93/64*L_-3L_-3|0> - 33/8*L_-4L_-2|0> - 27/16*L_-6|0>,)
        sage: V = AffineVertexAlgebra(QQ,'A1',3);e = V.gen(0)
        sage: I = V.ideal(e)
        Traceback (most recent call last):
        ...
        ValueError: Generators must be singular vectors of The universal affine vertex algebra of CartanType ['A', 1] at level 3
    """
    def __classcall_private__(cls, ambient=None, gens=None, **kwds):
        known_keywords = ['check']
        for key in kwds:
            if key not in known_keywords:
                raise TypeError("LieConformalAlgebra(): got an unexpected " +
                                "keyword argument '%s'"%key)

        try:
            R = ambient.base_ring()
        except AttributeError:
            R = None

        if R not in CommutativeRings() or ambient not in VertexAlgebras(R):
            raise ValueError("ambient must be a vertex algebra, got {}".format(
                              ambient))

        if not isinstance(gens, (list, tuple)):
            gens = [gens]
        gens = [ambient(x) for x in gens if x]
        gens = tuple(gens)
        if len(gens)==0: gens=(ambient.zero(),)

        if ambient in VertexAlgebras(ambient.base_ring()).\
                                Graded().FinitelyGenerated():
            return GradedVertexAlgebraIdeal(ambient,gens,
                    kwds.get('check',True))

        raise NotImplementedError('Ideals are not implemented for {}'.format(
                                  ambient))

    def __init__(self, ambient, category=None):
        category=ambient.category().Subobjects().or_subcategory(category)
        super(VertexAlgebraIdeal,self).__init__(category=category)
        self._ambient = ambient

class GradedVertexAlgebraIdeal(VertexAlgebraIdeal):
    def __init__(self,V,gens,check):
        r"""
        An ideal of the vertex algebra `V` generated by the list
        of vectors ``gens``.

        INPUT:

        - ``V`` -- a vertex algebra; the ambient of this ideal.
            We only support
            H-graded vertex algebras finitely generated by vectors of
            positive rational conformal weights.

        - ``gens`` a tuple of elements of ``V``; the generators of this
            ideal. We only support ideals generated by singular vectors

        - ``check`` -- a boolean (default: ``True``): whether to check
          that the generators are singular.

        EXAMPLES::

            sage: V = VirasoroVertexAlgebra(QQ,1/2);V.find_singular(6)
            (L_-2L_-2L_-2|0> + 93/64*L_-3L_-3|0> - 33/8*L_-4L_-2|0> - 27/16*L_-6|0>,)
            sage: v = _[0]; I = V.ideal(v)
            sage: I
            ideal of The Virasoro vertex algebra at central charge 1/2 generated by (L_-2L_-2L_-2|0> + 93/64*L_-3L_-3|0> - 33/8*L_-4L_-2|0> - 27/16*L_-6|0>,)
            sage: V = AffineVertexAlgebra(QQ,'A1',3);e = V.gen(0)
            sage: I = V.ideal(e)
            Traceback (most recent call last):
            ...
            ValueError: Generators must be singular vectors of The universal affine vertex algebra of CartanType ['A', 1] at level 3
        """
        if V not in VertexAlgebras(V.base_ring()).Graded().FinitelyGenerated():
            raise ValueError ("V needs to be a finitely and strongly generated "
                    "vertex algebra, got {}".format(V) )

        if check:
            if any(not g.is_singular() for g in gens):
                raise ValueError ("Generators must be singular vectors of {}"\
                                  .format(V))

        VertexAlgebraIdeal.__init__(self,V)
        self._gens = gens

    def _repr_(self):
        return "ideal of {0} generated by {1}".format(self._ambient, self._gens)

    def get_weight(self,n):
        r"""
        Returns the homogeneous component of weight ``n`` in the ideal.

        INPUT: a positive rational number ``n``.

        OUTPUT: a subspace of the ambient vertex algebra of this ideal.

        EXAMPLES::

            sage: V = VirasoroVertexAlgebra(QQ,1/2); I = V.ideal(V.find_singular(6))
            sage: I.get_weight(6)
            Free module generated by {0} over Rational Field
            sage: I.get_weight(6).an_element().lift()
            2*L_-2L_-2L_-2|0> + 93/32*L_-3L_-3|0> - 33/4*L_-4L_-2|0> - 27/8*L_-6|0>
            sage: M = I.get_weight(7); M
            Free module generated by {0} over Rational Field
            sage: M.reduce(I.gens()[0].T())
            0
            sage: V = AffineVertexAlgebra(QQ,'A1',1); I = V.ideal(V.find_singular(2))
            sage: I
            ideal of The universal affine vertex algebra of CartanType ['A', 1] at level 1 generated by (-alpha[1]_-1-alpha[1]_-1|0>, -alpha[1]_-2|0> + alphacheck[1]_-1-alpha[1]_-1|0>, alphacheck[1]_-1alphacheck[1]_-1|0> + alphacheck[1]_-2|0> - 2*alpha[1]_-1-alpha[1]_-1|0>, alpha[1]_-1alphacheck[1]_-1|0> + alpha[1]_-2|0>, alpha[1]_-1alpha[1]_-1|0>)
            sage: I.get_weight(3)
            Free module generated by {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14} over Rational Field
        """
        vgens = self._ambient.gens()
        weights = [g.degree() for g in vgens]
        regular = [2*g.is_even_odd() for g in vgens]
        basis = [g._action_from_partition_tuple(pt) for g in self._gens if\
                 n-g.weight() >= 0 for pt in _negative_pt(weights,regular,
                 n-g.weight())]
        return self._ambient.submodule(basis)

    def get_weight_less_than(self,n):
        """
        Returns the subspace of vectors of conformal weight less than
        ``n`` in this ideal.

        EXAMPLES::

            sage: V = VirasoroVertexAlgebra(QQ,1/2); I = V.ideal(V.find_singular(6))
            sage: I.get_weight_less_than(6)
            Free module generated by {0} over Rational Field
            sage: I.get_weight_less_than(8)
            Free module generated by {0, 1, 2, 3} over Rational Field
            sage: I.get_weight_less_than(5)
            Free module generated by {} over Rational Field
        """
        vgens = self._ambient.gens()
        weights = [g.degree() for g in vgens]
        regular = [2*g.is_even_odd() for g in vgens]
        basis = []
        for g in self._gens:
            w = g.weight()
            for i in _negative_pt(weights,regular):
                if sum(sum(j for j in p) for p in i)+w <= n:
                    basis.append(g._action_from_partition_tuple(i))
                else:
                    break
        return self._ambient.submodule(basis)

    def ambient(self):
        r"""Return the ambient vertex algebra of this ideal

        EXAMPLES::

            sage: V = VirasoroVertexAlgebra(QQ,1/2); v = V.find_singular(6)[0]; I = V.ideal(v); I
            ideal of The Virasoro vertex algebra at central charge 1/2 generated by (L_-2L_-2L_-2|0> + 93/64*L_-3L_-3|0> - 33/8*L_-4L_-2|0> - 27/16*L_-6|0>,)
            sage: I.ambient()
            The Virasoro vertex algebra at central charge 1/2

        """
        return self._ambient

    def reduce(self,x):
        """
        The reduction of the element `x` modulo this ideal.

        INPUT:

        - ``x`` -- an element of the ambient vertex algebra

        EXAMPLES::

            sage: V = VirasoroVertexAlgebra(QQ,1/2); I = V.ideal(V.find_singular(6)); I
            ideal of The Virasoro vertex algebra at central charge 1/2 generated by (L_-2L_-2L_-2|0> + 93/64*L_-3L_-3|0> - 33/8*L_-4L_-2|0> - 27/16*L_-6|0>,)
            sage: L = V.0; I.reduce(L*(L*L))
            -93/64*L_-3L_-3|0> + 33/8*L_-4L_-2|0> + 27/16*L_-6|0>
            sage: I.reduce(L+L.T())
            L_-2|0> + L_-3|0>

        """
        if x.is_homogeneous():
            w = x.weight()
            I = self.get_weight(w)
            A = self._ambient.get_weight(w)
            M = A.submodule([A.retract(v.lift()) for v in I.basis()])
            return M.reduce(A.retract(x)).lift()
        return sum(self.reduce(m) for m in x.homogeneous_terms())

    def gens(self):
        """
        The generators of this ideal.

        EXAMPLES::

            sage: V = AffineVertexAlgebra(QQ,'A1',1, names = ('e','h','f'));
            sage: I = V.ideal(V.find_singular(2))
            sage: I.gens()
            (f_-1f_-1|0>,
             f_-2|0> + h_-1f_-1|0>,
             h_-1h_-1|0> + h_-2|0> - 2*e_-1f_-1|0>,
             e_-1h_-1|0> + e_-2|0>,
             e_-1e_-1|0>)
        """
        return self._gens


def _negative_pt(weights,regular,energy=None):
    """
    helper function to compute tuples of shifted modes.

    These are to be fed into
    :meth:`algebras.lie_conformal_algebras.lie_conformal_algebra_element._action_from_partition_tuple`

    EXAMPLES::

        sage: from sage.algebras.vertex_algebras.vertex_algebra_ideal import _negative_pt
        sage: [p for p in _negative_pt((2,3/2),(0,2),5/2)]
        [([], [5/2]), ([2], [1/2]), ([1], [3/2]), ([1, 1], [1/2])]
        sage: [p for p in _negative_pt((2,3/2),(0,2),0)]
        [([], [])]
        sage: L = _negative_pt((2,3/2),(0,2))
        sage: [next(L) for i in range(8)]
        [([], []),
         ([], [1/2]),
         ([1], []),
         ([], [3/2]),
         ([1], [1/2]),
         ([], [3/2, 1/2]),
         ([2], []),
         ([1, 1], [])]
    """
    from sage.arith.misc import integer_floor
    from .energy_partition_tuples import EnergyPartitionTuples
    newwgts = [w-integer_floor(w) for w in weights]
    newwgts = [w if w else w+1 for w in newwgts]
    if energy is not None:
        from sage.rings.rational_field import QQ
        if energy not in QQ or energy < 0:
            raise ValueError("energy needs to be a non-negative rational")

        EPT = EnergyPartitionTuples(newwgts,len(weights),energy,regular=regular)
    else:
        EPT = EnergyPartitionTuples(newwgts,len(weights),regular=regular)

    for p in EPT:
        modp = p.to_list()
        modp = [[part + w -1 for part in l] for l,w in zip(modp,newwgts)]
        yield tuple(modp)


