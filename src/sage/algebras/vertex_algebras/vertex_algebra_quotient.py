r"""
Quotients of vertex algebras 
AUTHORS

- Reimundo Heluani (08-09-2019): Initial implementation
"""

#******************************************************************************
#       Copyright (C) 2019 Reimundo Heluani <heluani@potuz.net>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# (at your option) any later version.
#                  http://www.gnu.org/licenses/
#*****************************************************************************

from sage.structure.element_wrapper import ElementWrapper
from sage.structure.element import parent
from sage.structure.parent import Parent
from sage.structure.unique_representation import UniqueRepresentation
from sage.categories.modules import Modules
from sage.misc.cachefunc import cached_method 

class VertexAlgebraQuotient_space_element(ElementWrapper):
    #An element of the underlying vector space of a quotient of a vertex
    #algebra. Elements in this implementation are given by a pair of a degree
    # and a 
    #``CombinatorialFreeModule`` with the same basis as the Vertex algebra,
    #truncated to this given degree and then divided by the submodule generated by
    #the ideal up to that same degree. This way we can lift elements simply using
    #the same dictionary keys from their monomial coefficients
    def _repr_(self):
        V = self.parent().ambient()
        M = V.module()
        return repr(V(M._from_dict(self.value[1].monomial_coefficients())))

    def _add_(self,right):
        p = self.parent()
        m = max(self.value[0], right.value[0]) 
        S = p._submodule.get_degree(m)
        A = S.ambient()
        Q = A.quotient_module(S)
        #coerce self and right to A
        qx = self.value[1].parent()
        x = A._from_dict(qx.lift(self.value[1]).monomial_coefficients())
        qy = right.value[1].parent()
        y = A._from_dict(qy.lift(right.value[1]).monomial_coefficients())
        return p((m,Q.retract(x+y)))

    def _sub_(self,right):
        p = self.parent()
        m = max(self.value[0], right.value[0]) 
        S = p._submodule.get_degree(m)
        A = S.ambient()
        Q = A.quotient_module(S)
        #coerce self and right to A
        qx = self.value[1].parent()
        x = A._from_dict(qx.lift(self.value[1]).monomial_coefficients())
        qy = right.value[1].parent()
        y = A._from_dict(qy.lift(right.value[1]).monomial_coefficients())
        return p((m,Q.retract(x-y)))

    def _acted_upon_(self,scalar, self_on_left=False):
        scalar_parent = parent(scalar)
        if scalar_parent != self.parent().base_ring():
            if self.parent().base_ring() \
                    .has_coerce_map_from(scalar_parent):
                scalar = self.parent().base_ring()( scalar )
            else:
                return None
        if self_on_left:
            return type(self)(self.parent(), (self.value[0], 
                                            self.value[1]*scalar))
        return type(self)(self.parent(),
                            (self.value[0],scalar*self.value[1]))

    def monomial_coefficients(self):
        r"""The monomial coefficients of this elements

        EXAMPLES::

            sage: V = VirasoroVertexAlgebra(QQ, 1/2); Q=V.quotient(V.ideal(V.find_singular(6)[0]))
            sage: L = Q.gen(0)
            sage: v = L*L.T()*L; sorted(v.monomial_coefficients().items())
            [((7, B[([3, 2])]), 7/16), ((7, B[([4, 1])]), 49/8), ((7, B[([6])]), 35/32)]

        """
        p = self.value[1].parent()
        return { (self.value[0],p(k)):v for k,v in 
                            self.value[1].monomial_coefficients().items()}

    def length(self):
        r"""Return the number of monomials in this element"""
        return len(self.monomial_coefficients())

    def is_monomial(self):
        """return whether this element is a monomial"""
        return self.length() == 1 

    def __getitem__(self,i):
        return self.value[1].__getitem__(i)

    def filtered_degree(self):
        r"""Let this element be an element of `Q`,a vertex algebra quotient of
        the graded vertex algebra 
        `V` by a possibly non-homogeneous ideal. Then this method returns a
        degree `n` such that this element is in the image of the quotient map
        from `\sum_{k \geq n} V_k`. It is not guaranteed that this is the
        minimum such `n`. 

        EXAMPLES::

            sage: V = VirasoroVertexAlgebra(QQ, 1/2); Q=V.quotient(V.ideal(V.find_singular(6)[0]))
            sage: L = Q(Q.gen(0))
            sage: v = L*L.T()*L; v.filtered_degree()
            7
        
        """
        return self.value[0]

    def __nonzero__(self):
        return bool(self.value[1])

    def lift(self):
        r"""Return an element on the ambient vertex algebra in the preimage of
        this element by the quotient map

        EXAMPLES::
        
            sage: V = VirasoroVertexAlgebra(QQ, 1/2); Q=V.quotient(V.ideal(V.find_singular(6)[0]))
            sage: L = Q(Q.gen(0))
            sage: v = L*(L*L)
            sage: v
            33/8*L_-4L_-2|0>-93/64*L_-3L_-3|0>+27/16*L_-6|0>
            sage: v.parent()
            Quotient of The Virasoro vertex algebra at central charge 1/2 by the ideal generated by (L_-2L_-2L_-2|0>-33/8*L_-4L_-2|0>+93/64*L_-3L_-3|0>-27/16*L_-6|0>,)
            sage: v.lift().parent()
            The Virasoro vertex algebra at central charge 1/2

        """
        return self.parent().lift(self)

    def is_zero(self):
        """Whether this element is zero or not"""
        #for some reason need to implement here the otherwise default
        return not self.__nonzero__()

    def __eq__(self,other):
        return (self - other).is_zero()
    

class VertexAlgebraQuotient_space(Parent, UniqueRepresentation):

    def __init__(self, submodule, **kwds):
        r"""This class implements the underlying vector space of a quotient
        vertex algebra"""
        category = kwds.get('category', Modules(submodule.base_ring()))
        names = kwds.get('names', None)
        super(VertexAlgebraQuotient_space,self).__init__(base = submodule.base_ring(), 
                    category=category, names=names  )
        self._submodule = submodule
        self._ambient = submodule.ambient()

    Element = VertexAlgebraQuotient_space_element

    def ambient(self):
        """If this vertex algebra is a quotient of `V`, this method returns `V`

        EXAMPLES::

            sage: V = VirasoroVertexAlgebra(QQ, 1/2); Q=V.quotient(V.ideal(V.find_singular(6)[0]))
            sage: Q.module()
            Quotient of The Virasoro vertex algebra at central charge 1/2 by the ideal generated by (L_-2L_-2L_-2|0>-33/8*L_-4L_-2|0>+93/64*L_-3L_-3|0>-27/16*L_-6|0>,)
            sage: Q.module().ambient()
            The Virasoro vertex algebra at central charge 1/2
            sage: Q.module().ambient() is V
            True

        """
        return self._ambient

    def lift(self, x):
        r"""Return an element on the ambient vertex algebra in the preimage of
        ``x`` by the quotient map

        EXAMPLES::
        
            sage: V = VirasoroVertexAlgebra(QQ, 1/2); Q=V.quotient(V.ideal(V.find_singular(6)[0]))
            sage: L = Q(Q.gen(0))
            sage: v = L*(L*L)
            sage: v
            33/8*L_-4L_-2|0>-93/64*L_-3L_-3|0>+27/16*L_-6|0>
            sage: v.parent()
            Quotient of The Virasoro vertex algebra at central charge 1/2 by the ideal generated by (L_-2L_-2L_-2|0>-33/8*L_-4L_-2|0>+93/64*L_-3L_-3|0>-27/16*L_-6|0>,)
            sage: v.lift().parent()
            The Virasoro vertex algebra at central charge 1/2

        """
        assert x in self
        V = self._ambient
        return V(V.module()._from_dict(x.value[1].lift().\
                    monomial_coefficients()))
    
    def retract(self, x):
        r"""Let this vertex algebra `Q` be the quotient of `V` by the ideal `I`
        and ``x`` be an element of `V`. This method returns the reduction of `x`
        modulo `I`. That is the image of ``x`` under the quotient map. 

        EXAMPLES::

            sage: V = VirasoroVertexAlgebra(QQ, 1/2); Q=V.quotient(V.ideal(V.find_singular(6)[0]))
            sage: L = V.gen(0)
            sage: v = L*(L*L)
            sage: Q.retract(v)
            33/8*L_-4L_-2|0>-93/64*L_-3L_-3|0>+27/16*L_-6|0>
            sage: Q.retract(v).parent()
            Quotient of The Virasoro vertex algebra at central charge 1/2 by the ideal generated by (L_-2L_-2L_-2|0>-33/8*L_-4L_-2|0>+93/64*L_-3L_-3|0>-27/16*L_-6|0>,)
            sage: v.parent()
            The Virasoro vertex algebra at central charge 1/2

        """
        if x == 0:
            n = 0 
        else:
            n = x.filtered_degree()
        S = self._submodule.get_degree(n)
        A = S.ambient()
        y = A._from_dict(x.value.monomial_coefficients())
        Q = A.quotient_module(S)

        return self.element_class(self, (n,Q.retract(S.reduce(y))))

    def _element_constructor_(self,v):
        if v == self.base_ring().zero():
            return self.zero()
        if v in self._ambient:
            return self.retract(self._ambient(v))
        return self.element_class(self, v)

    def _coerce_map_from_(self,other):
        if self._ambient.has_coerce_map_from(other):
            return True
    
    @cached_method
    def li_filtration(self,n,m=None):
        r"""Returns the vector space of conformal weight ``n`` in this vertex
        algebra, filtered by the Li filtration `F_\bullet Q_n`. 
        If ``m`` is specified, it returns the `m`-th filtered part `F_mQ_n`. 

        EXAMPLES::

            sage: V = VirasoroVertexAlgebra(QQ, 1/2); Q=V.quotient(V.ideal(V.find_singular(6)[0]))
            sage: Q.li_filtration(8)
            {0: Free module generated by {0, 1, 2, 3, 4} over Rational Field,
             1: Free module generated by {0, 1, 2, 3, 4} over Rational Field,
             2: Free module generated by {0, 1, 2, 3, 4} over Rational Field,
             3: Free module generated by {0, 1, 2, 3} over Rational Field,
             4: Free module generated by {0, 1, 2, 3} over Rational Field,
             5: Free module generated by {0} over Rational Field,
             6: Free module generated by {0} over Rational Field,
             7: Free module generated by {} over Rational Field,
             8: Free module generated by {} over Rational Field,
             9: Free module generated by {} over Rational Field}
            sage: Q.li_filtration(8,4)
            Free module generated by {0, 1, 2, 3} over Rational Field
            sage: B = Q.li_filtration(8,4).basis()
        
        """
        S = self._submodule.get_graded_part(n)
        A = S.ambient()
        Q = A.quotient_module(S)
        F = self._ambient.li_filtration(n,m)
        if m is not None:
            F = {m:F}
        G = {m: Q.submodule([Q.retract(b.lift()) for b in F[m].basis()]) for
                m in F.keys() }
        if m is not None:
            G = G[m]
        return G
    
    @cached_method
    def get_graded_part(self,n,m=None):
        r"""
        Returns the vector space `Q_n` of conformal weight ``n`` vectors
        of this vertex algebra. If ``m`` is specified, it returns the associated
        graded `F_m Q_n / F_{m+1} Q_n` with respect to the Li filtration. To
        obtain a basis of vectors in `Q_n` use :meth:`basis` instead.

        EXAMPLES::

            sage: V = VirasoroVertexAlgebra(QQ, 1/2); Q=V.quotient(V.ideal(V.find_singular(6)[0]))
            sage: Q.get_graded_part(8)
            Free module generated by {([2, 2, 1]), ([5, 1]), ([4, 2]), ([3, 3]), ([7])} over Rational Field
            sage: Q.get_graded_part(8,3)
            Free module generated by {} over Rational Field
            sage: Q.get_graded_part(8,4)
            Free module generated by {0, 1, 2} over Rational Field

        """
        S = self._submodule.get_graded_part(n)
        A = S.ambient()
        Q = A.quotient_module(S)
        if m == None:
            return Q
        G = self.li_filtration(n,m)
        if m >= n+1:
            return G
        H = self.li_filtration(n,m+1)
        return G.quotient_module([G.retract(b.lift()) for b in H.basis()])
    
    def dimension(self,n):
        r"""Return the dimension of the conformal weight `n` part of this vertex
        algebra. 

        EXAMPLES::

            sage: V = VirasoroVertexAlgebra(QQ, 1/2); Q=V.quotient(V.ideal(V.find_singular(6)[0]))
            sage: V.dimension(5) == Q.dimension(5)
            True
            sage: V.dimension(9)
            8
            sage: Q.dimension(9)
            5

        """
        return self.get_graded_part(n).dimension()

    @cached_method
    def basis(self, n):
        r"""Returns a basis of the space  of conformal weight `n` in this vertex
        algebra

        EXAMPLES::

            sage: V = VirasoroVertexAlgebra(QQ, 1/2); Q=V.quotient(V.ideal(V.find_singular(6)[0]))
            sage: B = Q.basis(9)
            sage: [v for v in B]
            [L_-3L_-3L_-3|0>, L_-7L_-2|0>, L_-6L_-3|0>, L_-5L_-4|0>, L_-9|0>]

        """
        return [ self((n,b)) for b in self.get_graded_part(n).basis()]
    
    @cached_method
    def zero(self):
        r"""The zero vector in this vertex algebra"""
        return self.retract(self._ambient.zero())

        
class VertexAlgebraQuotient(VertexAlgebraQuotient_space):
    def __init__(self, ideal):
        r"""Base class for vertex algebra quotients

        INPUT:
        
        - ``ideal`` a vertex algebra ideal.
        """
        category = ideal.ambient().category().Quotients()
        try:
            names = ideal.ambient().variable_names()
        except ValueError:
            names = None

        super(VertexAlgebraQuotient,self).__init__(ideal,
            names = names, category=category)
        
    def _repr_(self):
        return "Quotient of {0} by the ideal generated by {1}".format(self._ambient,
                self._submodule._gens)

    def module(self):
        r"""The underlying vector space of this vertex algebra"""
        return self

    def defining_ideal(self):
        r"""The defining ideal of this quotient vertex algebra

        EXAMPLES::

            sage: V = VirasoroVertexAlgebra(QQ, 1/2); Q=V.quotient(V.ideal(V.find_singular(6)[0]))
            sage: Q.defining_ideal()
            ideal of The Virasoro vertex algebra at central charge 1/2 generated by (L_-2L_-2L_-2|0>-33/8*L_-4L_-2|0>+93/64*L_-3L_-3|0>-27/16*L_-6|0>,)

        """
        return self._submodule

    def vacuum(self):
        r"""The vacuum vector of this vertex algebra"""
        return self.retract(self._ambient.vacuum())

    def gens(self):
        r"""The generators of this vertex algebra"""
        return [self(v) for v in self._ambient.gens()]

    def gen(self,i):
        r"""The `i`-th generator of this Vertex Algebra"""
        return self.gens()[i]

    class Element(VertexAlgebraQuotient_space_element):
        def _mul_(self,right):
            p = self.parent()
            return p.retract(self.lift()._mul_(right.lift()))
        def _bracket_(self, other):
            br = self.lift()._bracket_(other.lift())
            return { k:self.parent().retract(v) for k,v in br.items() }

        def T(self,n=1):
            r"""The `n`-th derivative of this element. If ``n`` is not provided
            it defaults to `1`. 

            EXAMPLES::

                sage: V = VirasoroVertexAlgebra(QQ,1/2); V.inject_variables()
                Defining L
                sage: L.T()
                L_-3|0>
                sage: v = V.vacuum(); v.T()
                0
                sage: L.T(3)
                6*L_-5|0>
                sage: (L*L).T()
                2*L_-3L_-2|0>+L_-5|0>

            """
            return self.parent().retract(self.lift().T(n))

        def weight(self):
            r"""The conformal weight o this element. It raises an error if the
            element is not homogeneous
            
            EXAMPLES::

                sage: V = AffineVertexAlgebra(QQ, 'A1', 1); e = V.gen(0); f = V.gen(2);
                sage: (e*f).weight()
                2
                sage: V.vacuum().weight()
                0
                sage: V.zero().weight()
                +Infinity
                sage: f*e
                E(alpha[1])_-1E(-alpha[1])_-1|0>-E(alphacheck[1])_-2|0>
                sage: (f*e).weight()
                2
                sage: (e*f + e).weight()
                Traceback (most recent call last):
                ...
                ValueError: E(alpha[1])_-1E(-alpha[1])_-1|0>+E(alpha[1])_-1|0> is not homogeneous!

            """
            return self.lift().weight()

               



        

