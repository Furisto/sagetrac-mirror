r"""
Quotients of Vertex Algebras.

Given a :class:`VertexAlgebra` `V` and its
:class:`Ideal<sage.algebras.vertex_algebras.vertex_algebra_ideal.VertexAlgebraIdeal>`
`I\subset V`, the quotient space
`V/I` is naturally a vertex algebra. If `V` is `H`-graded and `I` is
generated by homogeneous singular vectors, then `V/I` is also
`H`-graded. 

This module implements quotients of `H`-graded vertex (super) algebras
by their ideals finitely generated by singular vectors. 

AUTHORS:

- Reimundo Heluani (2019-08-09): Initial implementation.
"""

#******************************************************************************
#       Copyright (C) 2019 Reimundo Heluani <heluani@potuz.net>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# (at your option) any later version.
#                  http://www.gnu.org/licenses/
#*****************************************************************************

from sage.rings.all import Integer
from sage.combinat.free_module import CombinatorialFreeModule
from sage.categories.vertex_algebras import VertexAlgebras
from sage.modules.with_basis.indexed_element import IndexedFreeModuleElement
from .energy_partition_tuples import EnergyPartitionTuples_all
from sage.sets.family import Family

class VertexAlgebraQuotientBasis(EnergyPartitionTuples_all):
    def __init__(self,I):
        """
        A basis of a quotient vertex algebra

        EXAMPLES::

            sage: V = VirasoroVertexAlgebra(QQ,1/2); I = V.ideal(V.find_singular(6))
            sage: Q = V.quotient(I)
            sage: Q._indices
            Basis of the quotient of The Virasoro vertex algebra of central charge 1/2 over Rational Field by ideal of The Virasoro vertex algebra of central charge 1/2 over Rational Field generated by (L_-2L_-2L_-2|0> + 93/64*L_-3L_-3|0> - 33/8*L_-4L_-2|0> - 27/16*L_-6|0>,)
        """
        vgens = I.ambient().gens()
        weights = [g.degree() for g in vgens]
        regular = [2*g.is_even_odd() for g in vgens]
        super(VertexAlgebraQuotientBasis,self).__init__(weights, len(weights),
                                                        regular=regular)
        self._ideal = I

    def _repr_(self):
        """
        String representation of this class.

        EXAMPLES::
        
            sage: V = VirasoroVertexAlgebra(QQ,1/2); I = V.ideal(V.find_singular(6))
            sage: Q = V.quotient(I)
            sage: Q._indices
            Basis of the quotient of The Virasoro vertex algebra of central charge 1/2 over Rational Field by ideal of The Virasoro vertex algebra of central charge 1/2 over Rational Field generated by (L_-2L_-2L_-2|0> + 93/64*L_-3L_-3|0> - 33/8*L_-4L_-2|0> - 27/16*L_-6|0>,)
        """
        return "Basis of the quotient of {} by {}".format(self._ideal.ambient(),
                                                          self._ideal)

    def _element_constructor_(self,x):
        """
        Construct an element in this basis.

        INPUT:

        - ``x`` -- a basis index for the cover vertex algebra

        EXAMPLES::

            sage: V = VirasoroVertexAlgebra(QQ,1/2); 
            sage: Q = V.quotient(V.ideal(V.find_singular(6)))
            sage: v = V([[5,3,2]]); v           # long time (4 seconds)
            L_-6L_-4L_-3|0>
            sage: Q._indices(v.index())
            ([5, 3, 2])
            sage: v = V([[2,2,1]]); v
            L_-3L_-3L_-2|0>
            sage: Q._indices(v.index())
            Traceback (most recent call last):
            ...
            ValueError: Do not know how to convert ([2, 2, 1]) into Basis of the quotient of The Virasoro vertex algebra of central charge 1/2 over Rational Field by ideal of The Virasoro vertex algebra of central charge 1/2 over Rational Field generated by (L_-2L_-2L_-2|0> + 93/64*L_-3L_-3|0> - 33/8*L_-4L_-2|0> - 27/16*L_-6|0>,)
            sage: v = V([[2,1]]); v
            L_-3L_-2|0>
            sage: Q._indices(v.index())
            ([2, 1])
        """
        ambient_indices = self._ideal.ambient().indices()
        if not x in ambient_indices:
            raise ValueError("Do not know how to convert {} into {}".format(x,
                             self))

        x = ambient_indices(x)
        if self._ideal._inverse_on_support(x) is None:
                return self.element_class(self,x)
        raise ValueError("Do not know how to convert {} into {}".format(x,self))

    def an_element(self):
        """
        An element of this Basis.

        EXAMPLES::

            sage: V = VirasoroVertexAlgebra(QQ,1/2)
            sage: Q = V.quotient(V.ideal(V.find_singular(6)))
            sage: B = Q._indices
            sage: B.an_element()
            ([2, 1])
        """
        try:
            return self[5]
        except ValueError:
            return self[0]
        
    def __contains__(self,x):
        """
        Whether this basis contains this index.

        INPUT:

        - ``x`` -- a basis index for the cover vertex algebra

        EXAMPLES::

            sage: V = VirasoroVertexAlgebra(QQ,1/2); 
            sage: Q = V.quotient(V.ideal(V.find_singular(6)))
            sage: v = V([[2,1]]); v
            L_-3L_-2|0>
            sage: v.index() in Q._indices
            True
        """
        try:
            self(x)
        except ValueError:
            return False
        return True

    def __iter__(self):
        """
        List indices of this basis.

        EXAMPLES::

            sage: V = AffineVertexAlgebra(QQ, 'A1',1, names=('e','h','f'));
            sage: Q = V.quotient(V.ideal(V.find_singular(2)))
            sage: Q._indices[0:10]  # long time (4 seconds)
            [([], [], []),
             ([1], [], []),
             ([], [1], []),
             ([], [], [1]),
             ([1], [], [1]),
             ([2], [], []),
             ([], [2], []),
             ([], [], [2]),
             ([1], [2], []),
             ([], [2, 1], [])]
        """
        for i in EnergyPartitionTuples_all.__iter__(self):
            if self._ideal._inverse_on_support(i) is None:
                yield(self.element_class(self,i))

    def __getitem__(self,r):
        """
        List indices of this basis.

        INPUT:

        - ``r`` -- an element of this basis, or a positive integer or
          a ``slice``. 

        EXAMPLES::

            sage: V = NeveuSchwarzVertexAlgebra(QQ,7/10)
            sage: Q = V.quotient(V.ideal(V.find_singular(4)))
            sage: I = Q._indices
            sage: I[0]
            ([], [])
            sage: I[1:3]
            [([], [1]), ([1], [])]
            sage: I(I[0])
            ([], [])
        """
        if isinstance(r,self.element_class):
            return r
        if isinstance(r,(int,Integer)):
            return self.unrank(r)
        elif isinstance(r,slice):
            start=0 if r.start is None else r.start
            stop=r.stop
            if stop is None:
                raise ValueError('infinite set')
            count=0
            parts=[]
            for t in self:
                if count==stop:
                    break
                if count>=start:
                    parts.append(t)
                count+=1
            if count==stop or stop is None:
                return parts
            raise IndexError('value out of range')
        raise NotImplementedError('Do not know how to look for {}'.format(r))

    def subset(self, energy=None):
        """
        The subset of basis elements indexing vectors of conformal
        weight ``energy``.

        INPUT:

        - ``energy`` -- a non-negative rational number or ``None``

        OUTPUT:

        If ``energy`` is a positive rational number, it returns a
        finite family of elements in this basis parametrizing vectors
        of conformal weight ``energy``. If ``energy`` is ``None``
        it returns this basis. 

        EXAMPLES::

            sage: V = NeveuSchwarzVertexAlgebra(QQ,7/10)
            sage: Q = V.quotient(V.ideal(V.find_singular(4)))
            sage: I = Q._indices
            sage: I.subset(6)               # long time (1 second)
            Family (([3, 1], []), ([], [3, 2]), ([], [4, 1]), ([5], []))
        """
        if energy==None:
            return self
        return Family([self(i) for i in EnergyPartitionTuples_all.subset(self,
                                            energy=energy) if i in self ])

class VertexAlgebraQuotientElement(IndexedFreeModuleElement):
    """
    Base class for elements of quotient vertex algebras.
    """
    def _repr_(self):
        """
        A string representation of this element.

        EXAMPLES::

            sage: V = NeveuSchwarzVertexAlgebra(QQ,7/10)
            sage: Q = V.quotient(V.ideal(V.find_singular(4)))
            sage: Q.an_element()
            |0> + 2*G_-3/2|0> + 3*L_-2|0> + L_-2G_-3/2|0>
        """
        return repr(self.lift())

    def lift(self):
        """
        A preimage of this element in the cover vertex algebra.

        EXAMPLES::

            sage: V = NeveuSchwarzVertexAlgebra(QQ,7/10)
            sage: Q = V.quotient(V.ideal(V.find_singular(4)))
            sage: v = Q.an_element(); v
            |0> + 2*G_-3/2|0> + 3*L_-2|0> + L_-2G_-3/2|0>
            sage: v.parent() is Q
            True
            sage: v.lift()
            |0> + 2*G_-3/2|0> + 3*L_-2|0> + L_-2G_-3/2|0>
            sage: _.parent() is V
            True
        """
        return self.parent().lift(self)

    def is_even_odd(self):
        """
        Returns ``1`` if this element is even and ``0`` if it is odd.

        EXAMPLES::

            sage: V = NeveuSchwarzVertexAlgebra(QQ,7/10)
            sage: Q = V.quotient(V.ideal(V.find_singular(4)))
            sage: v = Q([[1],[1]]); v
            L_-2G_-3/2|0>
            sage: v.is_even_odd()
            1
        """
        #__mro__ picks Modules before VertexAlgebras.Quotients
        return self.lift().is_even_odd()

class VertexAlgebraQuotient(CombinatorialFreeModule):

    def __init__(self, ideal, names=None, category=None):
        """
        A quotient of a vertex algebra by its ideal.

        INPUT:

        - ``ideal`` -- a :class:`VertexAlgebraIdeal`; an ideal of a
          vertex algebra
        - ``names`` -- a list of ``str`` or ``None`` (default: ``None``);
          alternative names for the generators
        - ``category`` -- a :class:`Category`; the category where this
          quotient is a parent


        .. NOTE::

            This class is not meant to be called directly by the user.
            Use instead :meth:`~sage.categories.vertex_algebras.VertexAlgebras.ParentMethods.quotient`.
        """
        default_category = VertexAlgebras(ideal.category().base_ring())\
                            .Quotients()
        category = default_category.or_subcategory(category, join=True)
        self._ideal = ideal
        self._ambient = ideal.ambient()
        indices = VertexAlgebraQuotientBasis(ideal)

        if names is None:
            try:
                names = self._ambient.variable_names()
            except ValueError:
                pass

        CombinatorialFreeModule.__init__(self,ideal.base_ring(),
                                    basis_keys=indices,
                                    element_class=VertexAlgebraQuotientElement,
                                    category=category, names=names)

    def _element_constructor_(self,x):
        """
        Construct an element of this quotient.

        INPUT:

        - ``x`` -- an element of the cover vertex algebra or an index
          of the basis. 

        EXAMPLES::

            sage: V = NeveuSchwarzVertexAlgebra(QQ,7/10)
            sage: Q = V.quotient(V.ideal(V.find_singular(4)))
            sage: Q(V.an_element())
            |0> + 2*G_-3/2|0> + 3*L_-2|0> + L_-2G_-3/2|0>
            sage: Q(Q._indices.an_element())
            L_-2G_-3/2|0>
        """
        if x in self._ambient:
            return self.retract(x)
        return super(VertexAlgebraQuotient,self)._element_constructor_(x)

    def _repr_(self):
        """
        String representation of this quotient.

        EXAMPLES::

            sage: V = NeveuSchwarzVertexAlgebra(QQ,7/10)
            sage: Q = V.quotient(V.ideal(V.find_singular(4))); Q
            Quotient of The Neveu-Schwarz super vertex algebra of central charge 7/10 over Rational Field by the ideal generated by (L_-2L_-2|0> - 3/2*G_-5/2G_-3/2|0> + 3/10*L_-4|0>,)
        """
        #Why does this pick up CombinatorialFreeModule instead of
        #VertexAlgebras().Quotients().parent_class()?
        return "Quotient of {} by the {}".format(self._ambient,
                                                 self._ideal._repr_short())

    def cover_algebra(self):
        """
        The covering vertex algebra of this quotient.

        EXAMPLES::

            sage: V = VirasoroVertexAlgebra(QQ, 1/2)
            sage: Q=V.quotient(V.ideal(V.find_singular(6)[0]))
            sage: Q.cover_algebra()
            The Virasoro vertex algebra of central charge 1/2 over Rational Field
        """
        return self._ambient

    def defining_ideal(self):
        """
        The defining ideal of this quotient.

        EXAMPLES::

            sage: V = NeveuSchwarzVertexAlgebra(QQ,7/10)
            sage: Q = V.quotient(V.ideal(V.find_singular(4)))
            sage: Q.defining_ideal()
            ideal of The Neveu-Schwarz super vertex algebra of central charge 7/10 over Rational Field generated by (L_-2L_-2|0> - 3/2*G_-5/2G_-3/2|0> + 3/10*L_-4|0>,)
        """
        return self._ideal

    def lift(self, x):
        r"""
        A preimage of this element in the cover vertex algebra.

        EXAMPLES::

            sage: V = VirasoroVertexAlgebra(QQ, 1/2); Q=V.quotient(V.ideal(V.find_singular(6)[0]))
            sage: L = Q(Q.gen(0))
            sage: v = L*(L*L)
            sage: v
            -93/64*L_-3L_-3|0> + 33/8*L_-4L_-2|0> + 27/16*L_-6|0>
            sage: v.parent()
            Quotient of The Virasoro vertex algebra of central charge 1/2 over Rational Field by the ideal generated by (L_-2L_-2L_-2|0> + 93/64*L_-3L_-3|0> - 33/8*L_-4L_-2|0> - 27/16*L_-6|0>,)
            sage: v.lift().parent()
            The Virasoro vertex algebra of central charge 1/2 over Rational Field
        """
        assert x in self
        return self._ambient._from_dict(x._monomial_coefficients)

    def retract(self, x):
        """
        The image of this element of the cover vertex algebra by the
        quotient map. 

        EXAMPLES::

            sage: V = VirasoroVertexAlgebra(QQ, 1/2); Q=V.quotient(V.ideal(V.find_singular(6)[0]))
            sage: L = V.gen(0)
            sage: v = L*(L*L)
            sage: Q.retract(v)
            -93/64*L_-3L_-3|0> + 33/8*L_-4L_-2|0> + 27/16*L_-6|0>
            sage: Q.retract(v).parent()
            Quotient of The Virasoro vertex algebra of central charge 1/2 over Rational Field by the ideal generated by (L_-2L_-2L_-2|0> + 93/64*L_-3L_-3|0> - 33/8*L_-4L_-2|0> - 27/16*L_-6|0>,)
            sage: v.parent()
            The Virasoro vertex algebra of central charge 1/2 over Rational Field

        """
        return self._from_dict(self._ideal.reduce(x)._monomial_coefficients)

    def arc_algebra(self):
        r"""
        The arc algebra of this vertex algebra.

        The graded :mod:`PoissonVertexAlgebra\
        <sage.algebras.poisson_vertex_algebras.poisson_vertex_algebra>`
        freely generated as a differential algebra by the `C_2`
        quotient of this vertex algebra.

        .. TODO::

            We only support arc algebras of universal enveloping
            vertex algebras and their quotients.

        EXAMPLES::

            sage: V = VirasoroVertexAlgebra(QQ, 1/2); P = V.arc_algebra()
            sage: P.category()
            Category of finitely generated H-graded Poisson vertex algebras with basis over Rational Field
            sage: P is V.classical_limit()
            True
            sage: Q = V.quotient(V.ideal(V.find_singular(6)))
            sage: R = Q.arc_algebra(); R
            Quotient of The classical limit of The Virasoro vertex algebra of central charge 1/2 over Rational Field by the ideal generated by (L_2^3,)
            sage: R.cover_algebra() is P
            True
        """
        P = self._ambient.arc_algebra()
        gens = [g.li_filtration_lt() for g in self._ideal.gens()]
        gens = tuple([P(g) for g in gens if g.li_filtration_degree() == 0])
        I = P.ideal(gens)
        return P.quotient(I)

