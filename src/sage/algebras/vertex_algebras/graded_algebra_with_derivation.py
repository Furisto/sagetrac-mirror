r"""
Graded commutative algebras with derivation
AUTHORS

- Reimundo Heluani (08-09-2019): Initial implementation

"""


#******************************************************************************
#       Copyright (C) 2019 Reimundo Heluani <heluani@potuz.net>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# (at your option) any later version.
#                  http://www.gnu.org/licenses/
#*****************************************************************************

from sage.categories.commutative_algebras import CommutativeAlgebras
from sage.categories.commutative_rings import CommutativeRings
from sage.rings.ring import CommutativeRing
from sage.combinat.free_module import CombinatorialFreeModule
from sage.combinat.partition_tuple import PartitionTuples_level
from sage.combinat.partition import Partition
from sage.structure.element_wrapper import ElementWrapper
from sage.structure.element import MonoidElement
from sage.misc.lazy_import import lazy_import
from sage.rings.power_series_ring import PowerSeriesRing
from sage.rings.polynomial.multi_polynomial_libsingular import MPolynomial_libsingular
lazy_import('sage.algebras.vertex_algebras.poisson_vertex_algebra','partmultiply')
lazy_import('sage.algebras.vertex_algebras.vertex_algebra', 'partderiv')

class DifferentialIdeal(MonoidElement):
    def __init__(self, ambient, gens, coerce=True):
        self._ambient = ambient
        if not isinstance(gens, (list,tuple)):
            gens = [gens]
        if coerce:
            gens = [ambient(x) for x in gens]

        gens = tuple(gens)
        if len(gens)==0: gens=(ambient.zero(),)
        self._gens = gens
        MonoidElement.__init__(self,ambient.ideal_monoid())

    def ambient(self):
        return self._ambient

    def base_ring(self):
        return self._ambient.base_ring()

    def gens(self):
        return self._gens

    def gen(self,i):
        return self._gens[i]

    def ngens(self):
        return len(self._gens)
    
    def _repr_(self):
        return "Differential ideal of {0} generated by {1}".format(
                self._ambient, self._gens)

    def ring(self):
        return self._ambient

    def category(self):
        import sage.categories.all
        return sage.categories.all.Ideals(self._ambient)
    
    def _ideal_gens(self, ord):
        return tuple(g.T(j) for g in self._gens 
                     for j in range(ord+1-g.degree()))

    def _groebner_basis(self, ord):
        P = self._ambient._polynomial_ring(ord)
        I = P.ideal([P(m._to_polynomial(ord)) for m in self._ideal_gens(ord)])
        return I.groebner_basis(deg_bound=ord)

    def hilbert_series(self, ord):
        P = self._ambient._polynomial_ring(ord)
        GB = self._groebner_basis(ord)
        GBLM = [a.lm() for a in GB if a.degree() < ord + 1]
        J = P.ideal(GBLM)
        mydegreelist = [d.degree() for d in P.gens()] 
        q = PowerSeriesRing(P.base_ring(),'q',default_prec=ord+1).gen()
        return J.hilbert_series(grading=mydegreelist)(q)

    def reduce(self, x):
        pol = x._to_polynomial()
        P = pol.parent()
        I = P.ideal([P(m._to_polynomial(x.degree())) for m in 
                    self._ideal_gens(x.degree())])
        return self._ambient(I.reduce(pol))



class GradedCommutativeAlgebraWithDerivation(CommutativeRing):
    def __init__(self, R, names, weights, 
                 termorder, category=None):
        if R not in CommutativeRings:
            raise ValueError("R must be a commutative ring, got {}".format(R))
        category = CommutativeAlgebras(R).Graded().or_subcategory(category)
        super(GradedCommutativeAlgebraWithDerivation, self).__init__(
            R, names=names, category=category)
        self._termorder = termorder
        self._weights = weights

    def variable_degrees(self):
        return (v.degree() for v in self.gens())

    def differential_ideal(self,gens):
        return DifferentialIdeal(self, gens)

    def termorder(self):
        return self._termorder


class AffineArcAlgebra(GradedCommutativeAlgebraWithDerivation):
    def __init__(self, R, names, weights=None,
                 termorder='wdegrevlex', category=None):
        self._ngens = len(names)
        if weights == None:
            weights=[1,]*self._ngens

        super(AffineArcAlgebra,self).__init__(R, names, weights=weights, 
                                              termorder=termorder, 
                                              category=category)

        self._module = CombinatorialFreeModule(R, PartitionTuples_level(
                                               self._ngens))

    def _repr_(self):
        return "The arc algebra over {0} generated by {1}".format(
                    self.base_ring(), self.variable_names())

    def _element_constructor_(self,x):
        #we first try to see if it coerces to some polynomial approximation
        if isinstance(x,MPolynomial_libsingular):
            d = max(m.degree() for m in x.monomials())
            P = self._polynomial_ring(d)
            try:
                x = P(x)
            except ValueError:
                if x.parent().has_coerce_map_from(P):
                    P = x.parent()
                    #its too risky to just assume P works, so at least
                    #let's take a parent that coerces to self
                    d = max([ g.degree() for g in P.gens()])
                    P = self._polynomial_ring(d)
                    x = P(x)
            if x in P:
                pgens = {g:i for i,g in enumerate(self.gens())}
                weights = [g.degree() for g in P.gens()]
                varlist = [(v,j) for v in self.gens() for j in 
                           range(v.degree(), d+1)] 
                if self._termorder == "wdegrevlex":
                    varlist = sorted(varlist,
                                     key = lambda x : (x[1], pgens[v]))
                if self._termorder == "wdeglex":
                    varlist = sorted(varlist,
                                     key = lambda x : (-x[1],pgens[v]))
                if self._termorder == "lexwdeg":
                    varlist = sorted(varlist,
                                     key = lambda x : (pgens[v],-x[1]))
                ret = self.zero()
                for k in P(x).dict().items():
                    etup = {varlist[i]:k[0][i] for i in range(len(k[0]))}
                    ret += k[1]*self([Partition(exp=[etup[(v,j)] for j in
                                range(v.degree(), d+1)])
                                for v in self.gens()])
                return ret
        #Now partition tuples:
        try:
            v = self._module(x)
        except TypeError:
            raise TypeError("Do not know how to convert {0} into an"\
                            " element of {1}".format(x,self))
        return self.element_class(self, v)
        
    def zero(self):
        return self(self._module.zero())

    def gens(self):
        ret = []
        n = self._ngens
        for i in range(n):
            l = [[],]*n
            l[i] = [1]
            ret.append(self(l))
        return ret 

    def gen(self,i):
        return self.gens()[i]

    def ngens(self):
        return self._ngens

    def quotient(self,I,names=None):
        return GradedCommutativeAlgebraWithDerivationQuotient(I,names=names)

    def _weights(self):
        return self._weights

    def _gen_degree(self,i):
        return self._weights[i]

    def _polynomial_ring(self, ord):
        names = self.variable_names()
        pgens = {g:(i,names[i]) for i,g in enumerate(self.gens())}
        
        from sage.calculus.var import var
        vardict = {(v,j) :var("{}_{}".format(pgens[v][1],j))
                   for v in pgens.keys() for j in range(v.degree(),ord+1)}
        termorder = self.termorder()
        if termorder == "wdegrevlex":
            varlist = tuple((vardict[v],v[1]) for v in sorted(vardict,
                key=lambda x:(x[1],pgens[x[0]][0])))
        elif termorder == "wdeglex":
            varlist = tuple((vardict[v],v[1]) for v in sorted(vardict,
                key=lambda x:(ord-x[1],pgens[x[0]][0])))
        elif termorder == "revlexwdeg":
            varlist = tuple((vardict[v],v[1]) for v in sorted(vardict,
                key=lambda x:(pgens[x[0]][0],x[1])))
            termorder = "wdegrevlex"
        elif termorder == "lexwdeg":
            varlist = tuple((vardict[v],v[1]) for v in sorted(vardict,
                key=lambda x:(pgens[x[0]][0],ord-x[1])))
            termorder = "wdeglex"

        from sage.rings.polynomial.polynomial_ring_constructor import PolynomialRing
        from sage.rings.polynomial.term_order import TermOrder
        varnames = tuple(a[0] for a in varlist)
        vardegs = tuple(a[1] for a in varlist)
        return PolynomialRing(self.base_ring(), len(varnames), varnames, 
                              order=TermOrder(termorder,vardegs))
    def _monomial_basis(self,n):
        P = self._polynomial_ring(n)
        one = self.base_ring().one()
        weights = [m.degree() for m in P.gens()]
        from sage.combinat.integer_vector_weighted import\
            WeightedIntegerVectors
        wiv = WeightedIntegerVectors(n,weights) 
        return sorted([P({v:one}) for v in wiv])

    def basis(self,n):
        return [self(m) for m in self._monomial_basis(n)]

    class Element(ElementWrapper):
        def _repr_(self):
            ord = max(m.degree() for m in self.monomials())
            return repr(self._to_polynomial(ord))

        def _add_(self,right):
            return type(self)(self.parent(), self.value + right.value)

        def _sub_(self, right):
            return type(self)(self.parent(), self.value - right.value)

        def _neg_(self):
            return type(self)(self.parent(), -self.value)

        def _mul_(self,other):
            p = self.parent()
            return sum(sc*oc*p(partmultiply(sv,ov)) for sv,sc in 
                       self.value.monomial_coefficients().items() for
                       ov,oc in other.value.monomial_coefficients().items())

        def T(self,n=1):
            if n==0:
                return self
            if n > 1:
                return self.T().T(n-1)
            coef = self.value.monomial_coefficients()
            p = self.parent()
            ret = p.zero()
            for k in coef.keys():
                c = coef[k]
                for i in range(len(k)):
                    jdic = partderiv(k[i])
                    for j in jdic.keys():
                        pt = k.components()
                        pt[i] = j
                        ret += c*jdic[j]*p(pt)
            return ret

        def _acted_upon_(self, scalar, self_on_left=False):
            try:
                r = self.base_ring()(scalar)
            except TypeError:
                raise TypeError("Do not know how to act by {0} on {1}"\
                                .format(scalar,self))
            return type(self)(self.parent(), r*self.value)

        def monomial_coefficients(self):
            p = self.parent()
            return {p(k):v for k,v in
                        self.value.monomial_coefficients().items()}

        def monomials(self):
            return (v*k for k,v in self.monomial_coefficients().items())

        def degree(self):
            p = self.parent()
            if self.is_zero():
                return p.base_ring().zero()
            ls = []
            for idx in self.value.monomial_coefficients().keys():
                ret = sum(len(idx[i])*(p._gen_degree(i)-1) + idx[i].size() 
                    for i in range(p.ngens()))
                ls.append(ret)
            if ls[1:] == ls[:-1]:
                return ls[0]
            raise ValueError("{} is not homogeneous!".format(self)) 

        def _to_polynomial(self,ord=None):
            p = self.parent()
            if ord == None or ord < self.degree():
                ord = self.degree()
            PR = p._polynomial_ring(ord)
            ret = PR.zero()
            for m in self.value.monomial_coefficients().items():
                lexp = [m[0][i].to_exp(ord - p._weights[i] + 1) 
                        for i in range(len(m[0]))]
                tuplexp = [(i,j,lexp[i][j]) for i in range(len(lexp)) 
                           for j in range(len(lexp[i]))]
                if p.termorder() == "wdegrevlex":
                    k = tuple(t[2] for t in sorted(tuplexp, 
                              key = lambda x : (p._weights[x[0]]+x[1],x[0])))
                elif p.termorder() == "wdeglex":
                    k = tuple(t[2] for t in sorted(tuplexp, 
                              key = lambda x: (ord-p._weights[x[0]]-x[1],
                                               x[0])))
                elif p.termorder() == "revlexwdeg":
                    k = tuple(t[2] for t in sorted(tuplexp,
                              key = lambda x: (x[0],x[1])))
                elif p.termorder() == "lexwdeg":
                    k = tuple(t[2] for t in sorted(tuplexp,
                              key = lambda x : (x[0], ord - x[1])))
                else:
                    raise NotImplementedError("Do not know how to convert to "
                                      "polynomial. The termorder {} of this Arc "
                                      "algebra is not implemented".format(
                                      p.termorder()))
                ret += PR({k:m[1]})
            return ret
                    
class GradedCommutativeAlgebraWithDerivationQuotient(
                            GradedCommutativeAlgebraWithDerivation):
    def __init__(self, I, names=None, category=None):
        ambient = I._ambient
        if names == None:
            names = ["{}bar".format(v) for v in ambient.variable_names()]
        weights = [g.degree() for g in ambient.gens()]
        termorder = ambient.termorder()
        if category == None:
            category = ambient.category().Quotients()
        category = CommutativeAlgebras(I.base_ring()).Graded().Quotients().\
                    or_subcategory(category)
        self._I = I
        super(GradedCommutativeAlgebraWithDerivationQuotient, self)\
            .__init__(I.base_ring(), names, weights=weights,
                      termorder=termorder, category=category)

    def defining_differential_ideal(self):
        return self._I

    def cover_ring(self):
        return self._I.ambient()

    def quotient(self,I):
        ambient = self.cover_ring()
        gens = self._I.gens() + tuple(d.lift() for d in I.gens())
        J = self.differential_ideal(gens)
        return GradedCommutativeAlgebraWithDerivationQuotient(ambient, J)

    def _polynomial_ring(self,ord):
        P = self.cover_ring()._polynomial_ring(ord)
        I = P.ideal([P(m._to_polynomial(ord)) 
                    for m in self._I._ideal_gens(ord)])
        return P.quotient_ring(I)

    def hilbert_series(self,ord):
        return self._I.hilbert_series(ord)

    def ngens(self):
        return self.cover_ring().ngens()

    def _repr_(self):
        return "Quotient of {0} by the differential ideal generated by {1}"\
                .format(self.cover_ring(),self._I.gens())

    def _monomial_basis(self, n):
        P = self._polynomial_ring(n)
        free_basis = self.cover_ring()._monomial_basis(n)
        ret = []
        for v in free_basis:
            pv = P(v)
            di = pv.lift().dict()
            if len(di) == 1:
                if di == v.dict():
                    ret.append(pv)
        return ret
