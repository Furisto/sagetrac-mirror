r"""
Graded commutative algebras with derivation

This module implements differential polynomial algebras and their quotients,
including for example the algebra of functions of arc spaces to affine varieties. 

These are `\mathbb{Z}_+` graded commutative algebras with a derivation of degree
`+1`. We implement here the free such algebra generated -- as a differential
algebra -- by a weighted polynomial ring, as well as their quotient by a
differential ideal. 

Let `A = \oplus_{n \geq 0} A_n` be a `\mathbb{Z}_+`-graded commutative algebra
with a derivation `\partial: A_\bullet \rightarrow A_{\bullet + 1}`. Let
`\{f_i\}`, `i \in I` be some elements of `A`. The *differential ideal* of `A`
generated by `\{f_i\}` is the ideal `J \subset A` generated by `\{ \partial^j
f_i \}`, `i \in I, j \geq 0`. 

EXAMPLES::

- We construct the algebra of functions of the arc space of the *fat origin of
  the line* `\mathbb{A}^1` over the rationals and compute its graded
  dimension::

    sage: A = AffineArcAlgebra(QQ,'x'); A
    The arc algebra over Rational Field generated by ('x',)
    sage: A.inject_variables()
    Defining x
    sage: I = A.differential_ideal(x**2)
    sage: I.hilbert_series(15)
    1 + q + q^2 + q^3 + 2*q^4 + 2*q^5 + 3*q^6 + 3*q^7 + 4*q^8 + 5*q^9 + 6*q^10 + 7*q^11 + 9*q^12 + 10*q^13 + 12*q^14 + 14*q^15 + O(q^16)

- We compute the classical limit of an affine Kac-Moody vertex algebra at
  integral level::

    sage: V = AffineVertexAlgebra(QQ,'A1',1);
    sage: I = V.ideal(V.find_singular(2))
    sage: Q = V.quotient(I); 
    sage: A = Q.arc_space(); A
    Quotient of The arc algebra over Rational Field generated by ('x0', 'x1', 'x2') by the differential ideal generated by (x0_1*x1_1, x0_1^2, -1/2*x1_1^2 + x0_1*x2_1, x1_1*x2_1, x2_1^2)
    sage: A.hilbert_series(9)
    1 + 3*q + 4*q^2 + 7*q^3 + 13*q^4 + 19*q^5 + 29*q^6 + 43*q^7 + 62*q^8 + 90*q^9 + O(q^10)

- We reduce some elements modulo a differential ideal::

    sage: A = AffineArcAlgebra(QQ, 'L', weights=(2,)); A.inject_variables()
    Defining L
    sage: I = A.differential_ideal(L**3)
    sage: L**2*L.T()*L.T(2)
    2*L_2^2*L_3*L_4
    sage: I.reduce(L**2*L.T())
    0

AUTHORS

- Reimundo Heluani (08-09-2019): Initial implementation

"""


#******************************************************************************
#       Copyright (C) 2019 Reimundo Heluani <heluani@potuz.net>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# (at your option) any later version.
#                  http://www.gnu.org/licenses/
#*****************************************************************************

from sage.structure.unique_representation import UniqueRepresentation
from sage.categories.commutative_algebras import CommutativeAlgebras
from sage.categories.commutative_rings import CommutativeRings
from sage.rings.ring import CommutativeRing
from sage.combinat.free_module import CombinatorialFreeModule
from sage.combinat.partition_tuple import PartitionTuples_level
from sage.combinat.partition import Partition
from sage.structure.element_wrapper import ElementWrapper
from sage.structure.element import MonoidElement
from sage.misc.lazy_import import lazy_import
from sage.rings.power_series_ring import PowerSeriesRing
from sage.rings.polynomial.multi_polynomial_libsingular import MPolynomial_libsingular
lazy_import('sage.algebras.vertex_algebras.poisson_vertex_algebra','partmultiply')

class DifferentialIdeal(MonoidElement):
    def __init__(self, ambient, gens, coerce=True):
        r"""A differential ideal on the ``ambient`` graded commutative algebra
        with derivation. 

        INPUT:

        - ``ambient`` a :class:`GradedCommutativeAlgebraWithDerivation`.
        - ``gens`` a list of elements of ``ambient``, the generators of this
          differential ideal.

        EXAMPLES::

            sage: A = AffineArcAlgebra(QQ,('x','y')); A.inject_variables()
            Defining x, y
            sage: A.differential_ideal((x.T(2)+y,y**2))
            Differential ideal of The arc algebra over Rational Field generated by ('x', 'y') generated by (2*x_3 + y_1, y_1^2)
        """
        self._ambient = ambient
        if not isinstance(gens, (list,tuple)):
            gens = [gens]
        if coerce:
            gens = [ambient(x) for x in gens]

        gens = tuple(gens)
        if len(gens)==0: gens=(ambient.zero(),)
        self._gens = gens
        MonoidElement.__init__(self,ambient.ideal_monoid())

    def __nonzero__(self):
        return not all(v.is_zero() for v in self._gens)

    def is_zero(self):
        r"""Whether this differential ideal is null"""
        #Why are we force to implement this?
        return not self.__nonzero__()

    def ambient(self):
        r"""The ambient graded commutative algebra with derivation

        EXAMPLES::
        
            sage: V = VirasoroVertexAlgebra(QQ, 1/2); Q=V.quotient(V.ideal(V.find_singular(6)[0]));
            sage: Q.arc_space()
            Quotient of The arc algebra over Rational Field generated by ('L',) by the differential ideal generated by (L_2^3,)
            sage: I = Q.arc_space().defining_differential_ideal(); I
            Differential ideal of The arc algebra over Rational Field generated by ('L',) generated by (L_2^3,)
            sage: I.ambient()
            The arc algebra over Rational Field generated by ('L',)

        """
        return self._ambient

    def base_ring(self):
        r"""The base ring of the ambient graded commutative algebra with
        derivation"""
        return self._ambient.base_ring()

    def gens(self):
        r"""The generators of this differential ideal"""
        return self._gens

    def gen(self,i):
        r"""The `i`-th generator of this differential ideal"""
        return self._gens[i]

    def ngens(self):
        r"""The number of generators of this differential ideal"""
        return len(self._gens)
    
    def _repr_(self):
        return "Differential ideal of {0} generated by {1}".format(
                self._ambient, self._gens)

    def ring(self):
        r"""Same as :meth:`ambient`"""
        return self._ambient

    def category(self):
        #Why is this public?
        r"""Returns the category of ideals of the ambient commutative algebra
        with derivation"""
        import sage.categories.all
        return sage.categories.all.Ideals(self._ambient)
    
    def _ideal_gens(self, ord):
        return tuple(g.T(j) for g in self._gens 
                     for j in range(ord+1-g.degree()))

    def _groebner_basis(self, ord):
        P = self._ambient._polynomial_ring(ord)
        I = P.ideal([P(m._to_polynomial(ord)) for m in self._ideal_gens(ord)])
        return I.groebner_basis(deg_bound=ord)

    def hilbert_series(self, ord):
        r"""The hilbert series of the quotient by this ideal, up to order
        ``ord``.

        EXAMPLES:

        - We compute the first few terms of the Ising Virasoro minimal model::

            sage: V = VirasoroVertexAlgebra(QQ, 1/2); Q=V.quotient(V.ideal(V.find_singular(6)[0]));
            sage: A = Q.arc_space()
            sage: A.defining_differential_ideal()
            Differential ideal of The arc algebra over Rational Field generated by ('L',) generated by (L_2^3,)
            sage: A.defining_differential_ideal().hilbert_series(15)
            1 + q^2 + q^3 + 2*q^4 + 2*q^5 + 3*q^6 + 3*q^7 + 5*q^8 + 6*q^9 + 8*q^10 + 9*q^11 + 13*q^12 + 14*q^13 + 19*q^14 + 22*q^15 + O(q^16)

        - We compute a similar Hilbert series related to the Lie algebra 'A1'::

            sage: A = AffineArcAlgebra(QQ,('e','h','f')); A.inject_variables()
            Defining e, h, f
            sage: I = A.differential_ideal((e*e,h*e,f*e+h**2))
            sage: I.hilbert_series(15)
            1 + 3*q + 6*q^2 + 12*q^3 + 23*q^4 + 40*q^5 + 68*q^6 + 112*q^7 + 179*q^8 + 281*q^9 + 432*q^10 + 651*q^11 + 969*q^12 + 1423*q^13 + 2062*q^14 + 2958*q^15 + O(q^16)

        """
        P = self._ambient._polynomial_ring(ord)
        GB = self._groebner_basis(ord)
        GBLM = [a.lm() for a in GB if a.degree() < ord + 1]
        J = P.ideal(GBLM)
        mydegreelist = [d.degree() for d in P.gens()] 
        q = PowerSeriesRing(P.base_ring(),'q',default_prec=ord+1).gen()
        return J.hilbert_series(grading=mydegreelist)(q)

    def reduce(self, x):
        r"""Return the reduction of ``x`` modulo this ideal.

        EXAMPLES::

            sage: A = AffineArcAlgebra(QQ,('e','h','f')); A.inject_variables()
            Defining e, h, f
            sage: I = A.differential_ideal((e*e,h*e,f*e+h**2))
            sage: I.reduce(e*e.T())
            0
            sage: I.reduce(e*(h.T()))
            e_1*h_2
            sage: I.reduce(h**2)
            -e_1*f_1

        """
        pol = x._to_polynomial()
        P = pol.parent()
        I = P.ideal([P(m._to_polynomial(x.degree())) for m in 
                    self._ideal_gens(x.degree())])
        return self._ambient(I.reduce(pol))



class GradedCommutativeAlgebraWithDerivation(CommutativeRing):
    def __init__(self, R, names, weights, 
                 termorder, category=None):
        r"""The base class of graded commutative algebras with a derivation of
        degree `+1`. 

        INPUT:

        - ``R`` a commutative ring. The base ring for this algebra.
        - ``names`` a list of names for the differential generators of this
          algebra.
        - ``weights`` a list of non-negative integers that are the
          degree of the generators (Default: 1 for each generator).
        - ``termorder`` A monomial ordering (default: `wdegrevlex`).

        EXAMPLES::

            sage: V = VirasoroVertexAlgebra(QQ, 1/2); Q=V.quotient(V.ideal(V.find_singular(6)[0]));
            sage: A = Q.arc_space()
            sage: A.defining_differential_ideal()
            Differential ideal of The arc algebra over Rational Field generated by ('L',) generated by (L_2^3,)
            sage: A.defining_differential_ideal().hilbert_series(15)
            1 + q^2 + q^3 + 2*q^4 + 2*q^5 + 3*q^6 + 3*q^7 + 5*q^8 + 6*q^9 + 8*q^10 + 9*q^11 + 13*q^12 + 14*q^13 + 19*q^14 + 22*q^15 + O(q^16)

            sage: A = AffineArcAlgebra(QQ,('e','h','f')); A.inject_variables()
            Defining e, h, f
            sage: I = A.differential_ideal((e*e,h*e,f*e+h**2))
            sage: I.hilbert_series(15)
            1 + 3*q + 6*q^2 + 12*q^3 + 23*q^4 + 40*q^5 + 68*q^6 + 112*q^7 + 179*q^8 + 281*q^9 + 432*q^10 + 651*q^11 + 969*q^12 + 1423*q^13 + 2062*q^14 + 2958*q^15 + O(q^16)

        """
        if R not in CommutativeRings:
            raise ValueError("R must be a commutative ring, got {}".format(R))
        category = CommutativeAlgebras(R).Graded().or_subcategory(category)
        super(GradedCommutativeAlgebraWithDerivation, self).__init__(
            R, names=names, category=category)
        self._termorder = termorder
        self._weights = weights

    def differential_ideal(self,gens):
        r"""Return the differential ideal of this algebra generated by ``gens``
        
        EXAMPLES::

            sage: A = AffineArcAlgebra(QQ,('e','h','f')); A.inject_variables()
            Defining e, h, f
            sage: I = A.differential_ideal((e*e,h*e,f*e+h**2))
            sage: I
            Differential ideal of The arc algebra over Rational Field generated by ('e', 'h', 'f') generated by (e_1^2, e_1*h_1, h_1^2 + e_1*f_1)
            sage: A = AffineArcAlgebra(QQ,('x','y')); A.inject_variables()
            Defining x, y
            sage: I = A.differential_ideal(x**2); I
            Differential ideal of The arc algebra over Rational Field generated by ('x', 'y') generated by (x_1^2,)
            sage: I.reduce(x*x.T())
            0

        """
        return DifferentialIdeal(self, gens)

    def termorder(self):
        r"""The monomial ordering of this Graded Commutative algebra

        EXAMPLES::

            sage: A = AffineArcAlgebra(QQ,('a','b'),weights=(1,2),termorder='wdegrevlex');A.inject_variables()
            Defining a, b
            sage: (a**2 + b).lm()
            a_1^2
            sage: A = AffineArcAlgebra(QQ,('a','b'),weights=(1,2),termorder='wdeglex');A.inject_variables()
            Defining a, b
            sage: (a**2 + b).lm()
            b_2

        """
        return self._termorder


class AffineArcAlgebra(GradedCommutativeAlgebraWithDerivation,
                       UniqueRepresentation):
    def __init__(self, R, names, weights=None,
                 termorder='wdegrevlex', category=None):
        r"""A freely generated polynomial differential algebra.

        INPUT:

        - ``R`` a commutative ring. The base ring of this algebra
        - ``names`` a tuple of names for the differential generators of this
          algebra.
        - ``weights`` A tuple of non-negative integer numbers which are the
          degrees of the generators (Default `1` for each generator)
        - ``termorder`` A monomial ordering (default: `wdegrevlex`).

        EXAMPLES::


            sage: A = AffineArcAlgebra(QQ,'L');A
            The arc algebra over Rational Field generated by ('L',)
            sage: A = AffineArcAlgebra(QQ,'L',weights=(2,));A
            The arc algebra over Rational Field generated by ('L',)
            sage: A.inject_variables()
            Defining L
            sage: L.degree()
            2
            
        """
        self._ngens = len(names)
        if weights == None:
            weights=[1,]*self._ngens

        super(AffineArcAlgebra,self).__init__(R, names, weights=weights, 
                                              termorder=termorder, 
                                              category=category)

        self._module = CombinatorialFreeModule(R, PartitionTuples_level(
                                               self._ngens))

    def _repr_(self):
        return "The arc algebra over {0} generated by {1}".format(
                    self.base_ring(), self.variable_names())

    def one(self):
        r"""The unit of this algebra"""
        PT = PartitionTuples_level(self._ngens)
        pt = [[],]*self._ngens
        v = self._module(pt)
        return self.element_class(self,v)

    def _element_constructor_(self,x):
        #we first try to see if it coerces to some polynomial approximation
        if isinstance(x,MPolynomial_libsingular):
            d = x.degree()
            P = self._polynomial_ring(d)
            try:
                x = P(x)
            except ValueError:
                if x.parent().has_coerce_map_from(P):
                    P = x.parent()
                    #its too risky to just assume P works, so at least
                    #let's take a parent that coerces to self
                    d = max([ g.degree() for g in P.gens()])
                    P = self._polynomial_ring(d)
                    x = P(x)
            if x in P:
                pgens = {g:i for i,g in enumerate(self.gens())}
                weights = [g.degree() for g in P.gens()]
                varlist = [(v,j) for v in self.gens() for j in 
                           range(v.degree(), d+1)] 
                if self._termorder == "wdegrevlex":
                    varlist = sorted(varlist,
                                     key = lambda x : (x[1], pgens[x[0]]))
                if self._termorder == "wdeglex":
                    varlist = sorted(varlist,
                                     key = lambda x : (-x[1],pgens[x[0]]))
                if self._termorder == "lexwdeg":
                    varlist = sorted(varlist,
                                     key = lambda x : (pgens[x[0]],-x[1]))
                ret = self.zero()
                for k in P(x).dict().items():
                    etup = {varlist[i]:k[0][i] for i in range(len(k[0]))}
                    ret += k[1]*self([Partition(exp=[etup[(v,j)] for j in
                                range(v.degree(), d+1)])
                                for v in self.gens()])
                return ret
        #Now the ring:
        if x in self.base_ring():
            return self.one()._acted_upon(self.base_ring()(x))

        #Now partition tuples:
        if x in PartitionTuples_level(self._ngens):
            v = self._module(x)
            return self.element_class(self, v)

        if x in self._module:
            return self.element_class(self,x)

        raise TypeError("Do not know how to convert {0} into an"\
                            " element of {1}".format(x,self))

        
    def zero(self):
        r"""The zero element of this algebra"""
        return self(self._module.zero())

    def gens(self):
        r"""The generators of this algebra

        EXAMPLES::

            sage: A = AffineArcAlgebra(QQ,('a','b','c'), weights=(2,1,1)); A
            The arc algebra over Rational Field generated by ('a', 'b', 'c')
            sage: A.gens()
            [a_2, b_1, c_1]
            sage: A.inject_variables()
            Defining a, b, c
            sage: a
            a_2

        """
        ret = []
        n = self._ngens
        for i in range(n):
            l = [[],]*n
            l[i] = [1]
            ret.append(self(l))
        return ret 

    def gen(self,i):
        r"""The `i`-th generator of this algebra"""
        return self.gens()[i]

    def ngens(self):
        """The number of generators of this algebra"""
        return self._ngens

    def quotient(self,I,names=None):
        r"""Return the quotient of this algebra by its differential ideal ``I``

        EXAMPLES::

            sage: A = AffineArcAlgebra(QQ,('a','b','c'), weights=(2,1,1)); A.inject_variables()
            Defining a, b, c
            sage: I = A.differential_ideal((a**2,b.T()+a*c)); I
            Differential ideal of The arc algebra over Rational Field generated by ('a', 'b', 'c') generated by (a_2^2, c_1*a_2 + b_2)
            sage: Q = A.quotient(I)
            sage: Q
            Quotient of The arc algebra over Rational Field generated by ('a', 'b', 'c') by the differential ideal generated by (a_2^2, c_1*a_2 + b_2)

        """
        if I.is_zero():
            return self
        return GradedCommutativeAlgebraWithDerivationQuotient(I,names=names)

    def _weights(self):
        return self._weights

    def _gen_degree(self,i):
        return self._weights[i]

    def _polynomial_ring(self, ord):
        names = self.variable_names()
        pgens = {g:(i,names[i]) for i,g in enumerate(self.gens())}
        
        from sage.calculus.var import var
        vardict = {(v,j) :var("{}_{}".format(pgens[v][1],j))
                   for v in pgens.keys() for j in range(v.degree(),ord+1)}
        termorder = self.termorder()
        if termorder == "wdegrevlex":
            varlist = tuple((vardict[v],v[1]) for v in sorted(vardict,
                key=lambda x:(x[1],pgens[x[0]][0])))
        elif termorder == "wdeglex":
            varlist = tuple((vardict[v],v[1]) for v in sorted(vardict,
                key=lambda x:(ord-x[1],pgens[x[0]][0])))
        elif termorder == "revlexwdeg":
            varlist = tuple((vardict[v],v[1]) for v in sorted(vardict,
                key=lambda x:(pgens[x[0]][0],x[1])))
            termorder = "wdegrevlex"
        elif termorder == "lexwdeg":
            varlist = tuple((vardict[v],v[1]) for v in sorted(vardict,
                key=lambda x:(pgens[x[0]][0],ord-x[1])))
            termorder = "wdeglex"

        from sage.rings.polynomial.polynomial_ring_constructor import PolynomialRing
        from sage.rings.polynomial.term_order import TermOrder
        varnames = tuple(a[0] for a in varlist)
        vardegs = tuple(a[1] for a in varlist)
        return PolynomialRing(self.base_ring(), len(varnames), varnames, 
                              order=TermOrder(termorder,vardegs))
    def _monomial_basis(self,n):
        P = self._polynomial_ring(n)
        one = self.base_ring().one()
        weights = [m.degree() for m in P.gens()]
        from sage.combinat.integer_vector_weighted import\
            WeightedIntegerVectors
        wiv = WeightedIntegerVectors(n,weights) 
        return sorted([P({v:one}) for v in wiv])

    def basis(self,n):
        r"""A basis for the space of degree ``n`` in this algebra. Notice that
        the order of the basis depends on the termorder

        EXAMPLES::

            sage: A = AffineArcAlgebra(QQ,('a','b','c'), weights=(2,1,1)); A.basis(3)
            [c_3,
             b_3,
             a_3,
             c_1*c_2,
             b_1*c_2,
             c_1*b_2,
             b_1*b_2,
             c_1*a_2,
             b_1*a_2,
             c_1^3,
             b_1*c_1^2,
             b_1^2*c_1,
             b_1^3]

            sage: A = AffineArcAlgebra(QQ,('a','b','c'), weights=(2,1,1),termorder='wdeglex'); A.basis(3)
            [c_1^3,
             b_1*c_1^2,
             b_1^2*c_1,
             b_1^3,
             c_2*c_1,
             c_2*b_1,
             b_2*c_1,
             b_2*b_1,
             a_2*c_1,
             a_2*b_1,
             c_3,
             b_3,
             a_3]

        """
        return [self(m) for m in self._monomial_basis(n)]

    class Element(ElementWrapper):
        def _lmul_(self,scalar):
            return self._acted_upon_(scalar)

        def _repr_(self):
            ord = max([m.degree() for m in self.monomials()],default=0)
            return repr(self._to_polynomial(ord))

        def _add_(self,right):
            return type(self)(self.parent(), self.value + right.value)

        def _sub_(self, right):
            return type(self)(self.parent(), self.value - right.value)

        def _neg_(self):
            return type(self)(self.parent(), -self.value)

        def _mul_(self,other):
            p = self.parent()
            return sum(sc*oc*p(partmultiply(sv,ov)) for sv,sc in 
                       self.value.monomial_coefficients().items() for
                       ov,oc in other.value.monomial_coefficients().items())

        def T(self,n=1):
            r"""The ``n``-th derivative of this element. Default is `n=1`. 

            EXAMPLES::

                sage: A = AffineArcAlgebra(QQ,('a','b','c'));a = A.0
                sage: a.T(3)
                6*a_4

            """
            if n==0:
                return self
            if n > 1:
                return self.T().T(n-1)
            coef = self.value.monomial_coefficients()
            p = self.parent()
            ret = p.zero()
            for k in coef.keys():
                c = coef[k]
                for i in range(len(k)):
                    jdic = partderiv(k[i])
                    for j in jdic.keys():
                        pt = k.components()
                        pt[i] = j
                        ret += c*jdic[j]*p(pt)
            return ret

        def _acted_upon_(self, scalar, self_on_left=False):
            try:
                r = self.base_ring()(scalar)
            except TypeError:
                raise TypeError("Do not know how to act by {0} on {1}"\
                                .format(scalar,self))
            return type(self)(self.parent(), r*self.value)

        def monomial_coefficients(self):
            r"""The monomial coefficients of this element 

            EXAMPLES::

                sage: A = AffineArcAlgebra(QQ,('a','b','c'));a = A.0
                sage: x = a**2+ a.T()*a + a.T(2); x
                a_1*a_2 + 2*a_3 + a_1^2
                sage: sorted(x.monomial_coefficients().items())
                [(a_1^2, 1), (a_1*a_2, 1), (a_3, 2)]

            """
            p = self.parent()
            return {p(k):v for k,v in
                        self.value.monomial_coefficients().items()}

        def monomials(self):
            r"""The list of monomials in this element

            EXAMPLES::

                sage: A = AffineArcAlgebra(QQ,('a','b','c'));a = A.0
                sage: x = a**2+ a.T()*a + a.T(2); x
                a_1*a_2 + 2*a_3 + a_1^2
                sage: x.monomials()
                [a_1^2, a_1*a_2, 2*a_3]

            """
            return [v*k for k,v in self.monomial_coefficients().items()]
            

        def degree(self):
            r"""The degree of this element

            EXAMPLES::
            
                sage: A = AffineArcAlgebra(QQ,('a','b','c'),weights=(2,1,1));
                sage: A.inject_variables()
                Defining a, b, c
                sage: a
                a_2
                sage: a.degree()
                2
                sage: c
                c_1
                sage: c.degree()
                1
                sage: a.T()*c**2
                c_1^2*a_3
                sage: _.degree()
                5

            """
            p = self.parent()
            if self.is_zero():
                return p.base_ring().zero()
            ls = []
            for idx in self.value.monomial_coefficients().keys():
                ret = sum(len(idx[i])*(p._gen_degree(i)-1) + idx[i].size() 
                    for i in range(p.ngens()))
                ls.append(ret)
            return max(ls)

        def _to_polynomial(self,ord=None):
            p = self.parent()
            if ord == None or ord < self.degree():
                ord = self.degree()
            PR = p._polynomial_ring(ord)
            ret = PR.zero()
            for m in self.value.monomial_coefficients().items():
                lexp = [m[0][i].to_exp(ord - p._weights[i] + 1) 
                        for i in range(len(m[0]))]
                tuplexp = [(i,j,lexp[i][j]) for i in range(len(lexp)) 
                           for j in range(len(lexp[i]))]
                if p.termorder() == "wdegrevlex":
                    k = tuple(t[2] for t in sorted(tuplexp, 
                              key = lambda x : (p._weights[x[0]]+x[1],x[0])))
                elif p.termorder() == "wdeglex":
                    k = tuple(t[2] for t in sorted(tuplexp, 
                              key = lambda x: (ord-p._weights[x[0]]-x[1],
                                               x[0])))
                elif p.termorder() == "revlexwdeg":
                    k = tuple(t[2] for t in sorted(tuplexp,
                              key = lambda x: (x[0],x[1])))
                elif p.termorder() == "lexwdeg":
                    k = tuple(t[2] for t in sorted(tuplexp,
                              key = lambda x : (x[0], ord - x[1])))
                else:
                    raise NotImplementedError("Do not know how to convert to "
                                      "polynomial. The termorder {} of this Arc "
                                      "algebra is not implemented".format(
                                      p.termorder()))
                ret += PR({k:m[1]})
            return ret
            
        def lm(self):
            r"""The leading monomial of this element with respect to the
            monomial ordering

            EXAMPLES::

                sage: A = AffineArcAlgebra(QQ,('a','b','c')); A.inject_variables()
                Defining a, b, c
                sage: (a**2*a.T()+a**3*b).lm()
                a_1^3*b_1
                sage: (a**2*a.T()+a**3*b+b.T(3)+a**4).lm()
                a_1^4
                sage: (a**2*a.T()+a*a.T(2)+b.T(3)).lm()
                a_1^2*a_2

            """
            p = self.parent()
            pol = self._to_polynomial()
            return p(pol.lm())

        def lt(self):
            r"""The leading term of this element with respect to the
            monomial ordering

            EXAMPLES::

                sage: A = AffineArcAlgebra(QQ,'L',weights=(2,)); A.inject_variables()
                Defining L
                sage: pol = L.T(2)*L +  L.T()**2
                sage: pol
                L_3^2 + 2*L_2*L_4
                sage: pol.lt()
                L_3^2
                sage: pol.T(3)
                120*L_4*L_5 + 120*L_3*L_6 + 120*L_2*L_7
                sage: pol.T(3).lt()
                120*L_4*L_5

            """
            p = self.parent()
            pol = self._to_polynomial()
            return p(pol.lt())


class GradedCommutativeAlgebraWithDerivationQuotient(
                            GradedCommutativeAlgebraWithDerivation):
    def __init__(self, I, names=None, category=None):
        r"""A quotient of a graded commutative algebra with a derivation by its
        differential ideal ``I``"""
        ambient = I._ambient
        if names == None:
            names = ["{}bar".format(v) for v in ambient.variable_names()]
        weights = [g.degree() for g in ambient.gens()]
        termorder = ambient.termorder()
        if category == None:
            category = ambient.category().Quotients()
        category = CommutativeAlgebras(I.base_ring()).Graded().Quotients().\
                    or_subcategory(category)
        self._I = I
        super(GradedCommutativeAlgebraWithDerivationQuotient, self)\
            .__init__(I.base_ring(), names, weights=weights,
                      termorder=termorder, category=category)
    
    class Element(ElementWrapper):
        def lift(self):
            r"""Returns an element of the cover ring in the preimage of this
            element

            """
            return self.value
        
        def _mul_(self,other):
            return self.parent()(self.value._mul_(other.value))

        def _add_(self,other):
            return self.parent()(self.value._add_(other.value))

        def _sub_(self, right):
            return type(self)(self.parent(), self.value - right.value)

        def _neg_(self):
            return type(self)(self.parent(), -self.value)

        def degree(self):
            r"""The degree of this element

            EXAMPLES::
            
                sage: A = AffineArcAlgebra(QQ,('a','b','c'),weights=(2,1,1));
                sage: A.inject_variables()
                Defining a, b, c
                sage: a
                a_2
                sage: a.degree()
                2
                sage: c
                c_1
                sage: c.degree()
                1
                sage: a.T()*c**2
                c_1^2*a_3
                sage: _.degree()
                5

            """
            return self.value.degree()

        def T(self,n=1):
            r"""The ``n``-th derivative of this element. Default is `n=1`. 

            EXAMPLES::

                sage: A = AffineArcAlgebra(QQ,('a','b','c'));a = A.0
                sage: a.T(3)
                6*a_4

            """
            return type(self)(self.parent(),self.value.T(n))

        def is_zero(self):
            #TODO:Why do we need to implement this?
            """Wether this element is zero or not"""
            return self.value.is_zero()

 
    def defining_differential_ideal(self):
        r"""The defining differential ideal of this quotient
        
        EXAMPLES::

            sage: V = VirasoroVertexAlgebra(QQ, 1/2); Q=V.quotient(V.ideal(V.find_singular(6)[0]));
            sage: A = Q.arc_space()
            sage: A.defining_differential_ideal()
            Differential ideal of The arc algebra over Rational Field generated by ('L',) generated by (L_2^3,)

        """
        return self._I

    def cover_ring(self):
        r"""If this algebra is a quotient of `A` by its ideal `I`. This method
        returns `A`

        EXAMPLES::

            sage: A = AffineArcAlgebra(QQ,('a','b','c')); A.inject_variables(); 
            Defining a, b, c
            sage: I = A.differential_ideal((a**2,b.T()+a*c)); Q = A.quotient(I)
            sage: Q
            Quotient of The arc algebra over Rational Field generated by ('a', 'b', 'c') by the differential ideal generated by (a_1^2, a_1*c_1 + b_2)
            sage: Q.cover_ring()
            The arc algebra over Rational Field generated by ('a', 'b', 'c')
            sage: Q.cover_ring() is A
            True
            
        An example with a vertex algebra arc space::

            sage: V = VirasoroVertexAlgebra(QQ, 1/2); Q=V.quotient(V.ideal(V.find_singular(6)[0]));
            sage: Q.arc_space()
            Quotient of The arc algebra over Rational Field generated by ('L',) by the differential ideal generated by (L_2^3,)
            sage: Q.arc_space().cover_ring()
            The arc algebra over Rational Field generated by ('L',)

        """
        return self._I.ambient()

    def quotient(self,I):
        r"""A quotient of this quotient algebra with its ideal `I`. This is the
        same as a quotient of the ambient algebra by the preimage of `I`.

        EXAMPLES::

            sage: V = VirasoroVertexAlgebra(QQ, 1/2);Q=V.quotient(V.ideal(V.find_singular(6)[0]));A = Q.arc_space(); L = A.0
            sage: J = A.differential_ideal(L.T(4))
            sage: J
            Differential ideal of Quotient of The arc algebra over Rational Field generated by ('L',) by the differential ideal generated by (L_2^3,) generated by (24*L_6,)
            sage: R = A.quotient(J)
            sage: R
            Quotient of The arc algebra over Rational Field generated by ('L',) by the differential ideal generated by (L_2^3, 24*L_6)

        """
        ambient = self.cover_ring()
        gens = self._I.gens() + tuple(d.lift() for d in I.gens())
        J = ambient.differential_ideal(gens)
        return ambient.quotient(J)
    

    def zero(self):
        """The zero element of this algebra"""
        return self.element_class(self,self.cover_ring().zero())

    def one(self):
        """The unit of this algebra"""
        return self.element_class(self,self.cover_ring().one())

    def _element_constructor_(self,x):
        if x in self.cover_ring():
            return self.element_class(self,self._I.reduce(x))

    def _polynomial_ring(self,ord):
        P = self.cover_ring()._polynomial_ring(ord)
        I = P.ideal([P(m._to_polynomial(ord)) 
                    for m in self._I._ideal_gens(ord)])
        return P.quotient_ring(I)

    def hilbert_series(self,ord):
        r"""The graded dimension of this quotient algebra

        EXAMPLES::

            sage: V = VirasoroVertexAlgebra(QQ, 1/2); Q=V.quotient(V.ideal(V.find_singular(6)[0]));
            sage: A = Q.arc_space()
            sage: A.hilbert_series(15)
            1 + q^2 + q^3 + 2*q^4 + 2*q^5 + 3*q^6 + 3*q^7 + 5*q^8 + 6*q^9 + 8*q^10 + 9*q^11 + 13*q^12 + 14*q^13 + 19*q^14 + 22*q^15 + O(q^16)

        """
        return self._I.hilbert_series(ord)

    def gens(self):
        """The generators of this quotient algebra are the images of the
        generators of the cover ring"""
        return [self(v) for v in self.cover_ring().gens()]

    def gen(self,i):
        r"""The `i`-th generator of this algebra"""
        return self.gens()[i]

    def ngens(self):
        """The number of generators of this quotient"""
        return self.cover_ring().ngens()

    def _repr_(self):
        return "Quotient of {0} by the differential ideal generated by {1}"\
                .format(self.cover_ring(),self._I.gens())

    def retract(self,x):
        r"""return the image of ``x`` by the quotient map

        EXAMPLES::
        
            sage: V = VirasoroVertexAlgebra(QQ, 1/2); Q=V.quotient(V.ideal(V.find_singular(6)[0]))
            sage: B = V.arc_space(); B
            The arc algebra over Rational Field generated by ('L',)
            sage: A = Q.arc_space(); A
            Quotient of The arc algebra over Rational Field generated by ('L',) by the differential ideal generated by (L_2^3,)
            sage: B.inject_variables()
            Defining L
            sage: A.retract(L**2*L.T() + L.T(3))
            6*L_5
            sage: A.cover_ring() is B
            True
        
        """
        return self(x)

    def _monomial_basis(self, n):
        P = self._polynomial_ring(n)
        free_basis = self.cover_ring()._monomial_basis(n)
        ret = []
        for v in free_basis:
            pv = P(v)
            di = pv.lift().dict()
            if len(di) == 1:
                if di == v.dict():
                    ret.append(pv)
        return ret

def partderiv(p):
    l = p.to_exp()
    ret = {}
    for i in range(len(l)):
        if l[i] > 0:
            l2 = list(l)
            l2[i] -= 1 
            try:
                l2[i+1]+=1 
            except IndexError:
                l2.append(1)
            ret[Partition(exp=l2)] = l[i]*(i+1)
    return ret
        

