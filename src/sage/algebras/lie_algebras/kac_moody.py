"""
Kac-Moody Algebras

AUTHORS:

- Travis Scrimshaw (2013-05-03): Initial version
"""

#*****************************************************************************
#  Copyright (C) 2013 Travis Scrimshaw <tscrim@ucdavis.edu>
#
#  Distributed under the terms of the GNU General Public License (GPL)
#
#    This code is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty
#    of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
#
#  See the GNU General Public License for more details; the full text
#  is available at:
#
#                  http://www.gnu.org/licenses/
#*****************************************************************************

from sage.structure.parent import Parent
from sage.structure.unique_representation import UniqueRepresentation
from sage.structure.element import RingElement
from sage.structure.indexed_generators import IndexedGenerators
from sage.categories.algebras import Algebras
from sage.categories.lie_algebras import LieAlgebras
from sage.misc.cachefunc import cached_method
from sage.misc.misc import repr_lincomb

from sage.algebras.free_algebra import FreeAlgebra
from sage.algebras.lie_algebras.lie_algebra import FinitelyGeneratedLieAlgebra
from sage.algebras.lie_algebras.finitely_presented import FinitelyPresentedLieAlgebra
from sage.algebras.lie_algebras.lie_algebra_element import LieAlgebraElement
from sage.algebras.lie_algebras.free_lie_algebra import FreeLieAlgebra
from sage.combinat.root_system.cartan_matrix import CartanMatrix
from sage.combinat.root_system.cartan_type import CartanType
from sage.combinat.free_module import CombinatorialFreeModule
from sage.rings.arith import binomial
from sage.sets.family import Family

class KacMoodyAlgebra(FinitelyPresentedLieAlgebra):
    r"""
    A Kac-Moody algebra.

    A Kac-Moody algebra over a ring `R` is given by the following data,
    known as Cartan datum:

    - a `n \times n` (generalized) Cartan matrix `A = (a_{ij})` of rank `r`,

    - a vector space `\mathfrak{h}` over `R` of dimension `2n - r`,

    - a set of `n` linearly independent simple coroots `\alpha_i^{\vee} \in
      \mathfrak{h}` and roots `\alpha_i \in \mathfrak{h}^*` such that
      `\alpha_i(\alpha_i^{\vee}) = a_{ij}`.

    The Kac-Moody algerba is the Lie algebra generated by `e_i, f_i`, and
    `h \in \mathfrak{h}` which satisfy the following relations:

    .. MATH::

        \begin{aligned}
        [h, h^{\prime}] &= 0,
        \\ [h, e_i] &= \alpha_i(h) e_i,
        \\ [h, f_i] &= -\alpha_i(h) f_i,
        \\ [e_i, f_j] &= \delta_{ij} \alpha_i^{\vee},
        \\ \mathrm{ad}_{e_i}^{1-a_{ij}} e_j &= 0,
        \\ \mathrm{ad}_{f_i}^{1-a_{ij}} f_j &= 0.
        \end{aligned}

    where `\mathrm{ad}_x y = [x, y]`, the adjoint operator of `\mathfrak{g}`.
    """
    @staticmethod
    def __classcall_private__(cls, R, cm, index_set=None):
        """
        Normalize arguments to ensure a unique representation.

        TESTS::

            sage: KM1 = KacMoodyAlgebra(QQ, ['A', 3])
            sage: KM2 = KacMoodyAlgebra(QQ, 'A3')
            sage: KM3 = KacMoodyAlgebra(QQ, CartanType(['A', 3]))
            sage: KM1 is KM2 and KM2 is KM3
            True
        """
        cm = CartanMatrix(cm, index_set=index_set) # index_set not currently supported
        return super(KacMoodyAlgebra, cls).__classcall__(cls, R, cm)

    def __init__(self, R, cm):
        """
        Initialize ``self``.

        TESTS::

            sage: TestSuite(KacMoodyAlgebra(QQ, ['B', 3])).run()
            sage: TestSuite(KacMoodyAlgebra(QQ, ['G', 2])).run()
            sage: TestSuite(KacMoodyAlgebra(QQ, ['A', 2, 1])).run()
            sage: TestSuite(KacMoodyAlgebra(QQ, ['E', 6, 2])).run()
        """
        index_set = cm.index_set()
        n = len(index_set)
        self._n = n
        self._cartan_matrix = cm

        # Construct the base free Lie algebra
        names  = ['e{}'.format(i) for i in index_set]
        names += ['f{}'.format(i) for i in index_set]
        names += ['h{}'.format(i) for i in index_set]
        names += ['d{}'.format(i) for i in range(n-cm.rank())]
        F = FreeLieAlgebra(R, names).Lyndon()
        e = F.gens()[:n]
        f = F.gens()[n:2*n]
        h = F.gens()[2*n:3*n]
        d = F.gens()[3*n:]

        # Construct the basic relations
        P_check = h+d
        rels = [F.bracket(x, y) for i,x in enumerate(P_check) for y in P_check[i+1:]]
        rels += [F.bracket(x, y) - cm[i,j]*x for i,x in enumerate(e) for j,y in enumerate(h)]
        rels += [F.bracket(x, y) for x in e for y in d]
        rels += [F.bracket(x, y) + cm[i,j]*x for i,x in enumerate(f) for j,y in enumerate(h)]
        rels += [F.bracket(x, y) for x in f for y in d]
        for i,x in enumerate(e):
            for j,y in enumerate(f):
                if i == j:
                    rels.append(F.bracket(x, y) - h[i])
                else:
                    rels.append(F.bracket(x, y))

        # Construct the Serre relations
        for i in range(n):
            for j in range(n):
                if i != j:
                    cur_e = e[i]
                    cur_f = f[i]
                    for k in range(1-cm[i,j]):
                        cur_e = F.bracket(e[j], cur_e)
                        cur_f = F.bracket(f[j], cur_f)
                    rels.append(cur_e)
                    rels.append(cur_f)

        category = LieAlgebras(R).WithBasis()
        if cm.is_finite():
            category = category.FiniteDimensional()
        FinitelyPresentedLieAlgebra.__init__(self, F, tuple(rels), names=names, category=category)

        # Define the actual generators
        elt = lambda x: self.element_class(self, x)
        self._e = map(elt, e)
        self._f = map(elt, f)
        self._h = map(elt, h)
        self._d = map(elt, d)

    def _repr_(self):
        """
        Return a string representation of ``self``.

        EXAMPLES::

            sage: KacMoodyAlgebra(QQ, ['B',2])
            Kac-Moody algebra of type ['B', 2]
            sage: cm = CartanMatrix([[2,-5],[-4,2]])
            sage: KacMoodyAlgebra(QQ, cm)
            Kac-Moody algebra with Cartan matrix:
            [ 2 -5]
            [-4  2]
        """
        ct = self._cartan_matrix.cartan_type()
        if ct is not self._cartan_matrix:
            return "Kac-Moody algebra of type {}".format(ct)
        return "Kac-Moody algebra with Cartan matrix:\n{}".format(self._cartan_matrix)

    def _basis_cmp(self, x, y):
        """
        Return the ``cmp`` of two basis elements ``x`` and ``y``.
        """
        return cmp(x,y)
        #return cmp(x.value, y.value)

    def _construct_UEA(self):
        """
        Return the universal enveloping algebra of ``self``.

        EXAMPLES::

            sage: K = KacMoodyAlgebra(QQ, ['B',2])
            sage: UEA = K.universal_enveloping_algebra() # indirect doctest
            sage: UEA
            Poincare-Birkhoff-Witt basis corresponding to Kac-Moody algebra of type ['B', 2]
            sage: TestSuite(UEA).run()
        """
        indices = map(lambda x: x.value.leading_support(), self.basis())
        return self.pbw_basis(indices)

    def cartan_type(self):
        """
        Return the Cartan type of ``self``.

        EXAMPLES::

            sage: KM = KacMoodyAlgebra(QQ, ['B',2])
            sage: KM.cartan_type()
            ['B', 2]
            sage: cm = CartanMatrix([[2,-5],[-4,2]])
            sage: KM = KacMoodyAlgebra(QQ, cm)
            sage: KM.cartan_type()
            [ 2 -5]
            [-4  2]
        """
        return self._cartan_matrix.cartan_type()

    def cartan_matrix(self):
        """
        Return the defining Cartan matrix of ``self``.

        EXAMPLES::

            sage: KM = KacMoodyAlgebra(QQ, ['B',2])
            sage: KM.cartan_matrix()
            [ 2 -1]
            [-2  2]
            sage: cm = CartanMatrix([[2,-5],[-4,2]])
            sage: KM = KacMoodyAlgebra(QQ, cm)
            sage: KM.cartan_matrix()
            [ 2 -5]
            [-4  2]
        """
        return self._cartan_matrix

    @cached_method
    def basis(self):
        """
        Return a basis of ``self``.

        EXAMPLES::

            sage: KM = KacMoodyAlgebra(QQ, ['B',2])
            sage: sorted(KM.basis(), cmp=lambda x,y: cmp(x.value, y.value))
            [e1,
             -[e1, [e1, e2]],
             [e1, [e1, e2]],
             -[e1, e2],
             [e1, e2],
             e2,
             f1,
             -[f1, [f1, f2]],
             [f1, [f1, f2]],
             -[f1, f2],
             [f1, f2],
             f2,
             h1,
             h2]
        """
        if not self._cartan_matrix.is_finite():
            raise NotImplementedError

        todo_e = list(self._e)
        todo_f = list(self._f)
        basis = set(self.gens())
        while len(todo_e) > 0:
            next_e = todo_e.pop()
            next_f = todo_f.pop()
            for i,e in enumerate(self._e):
                f = self._f[i]
                print e, next_e
                b = self.bracket(e, next_e)
                if b != self.zero() and b not in basis:
                    print "===== new basis element ===="
                    print b
                    print "----------------------------"
                    basis.add(b)
                    todo_e.append(b)
                    b = self.bracket(f, next_f)
                    basis.add(b)
                    todo_f.append(b)

        return Family(basis)

    def alpha(self, i, x):
        r"""
        The `i`-th simple root `\alpha_i` applied to ``x``.
        """
        for j in range(self._n):
            if x == self._h[j]:
                return self._cartan_matrix[i][j]
        return 0

    def e(self, i):
        r"""
        Return the generator `e_i`.
        """
        return self._e[i]

    def f(self, i):
        r"""
        Return the generator `f_i`.
        """
        return self._f[i]

    def h(self, i):
        """
        Return the generator `h_i`.
        """
        return self._h[i]

    def d(self, i):
        """
        Return the generator `d_i`.
        """
        return self._d[i]

# This will need work
# This is the free object in the category of Kac-Moody algebras where
#   GCM entries correspond to -oo
class NoSerreKacMoodyAlgebra(KacMoodyAlgebra):
    """
    This is the Lie algebra generated by `e_i`, `f_i`, and `h_i` subject
    with all relations as for Kac-Moody algebras except for the Serre
    relations.
    """
    @staticmethod
    def __classcall_private__(cls, R, cm, index_set=None):
        """
        Normalize arguments to ensure a unique representation.

        TESTS::

            sage: KM1 = NoSerreKacMoodyAlgebra(QQ, ['A', 3])
            sage: KM2 = NoSerreKacMoodyAlgebra(QQ, 'A3')
            sage: KM3 = NoSerreKacMoodyAlgebra(QQ, CartanType(['A', 3]))
            sage: KM1 is KM2 and KM2 is KM3
            True
        """
        cm = CartanMatrix(cm, index_set=index_set) # index_set not currently supported
        return super(KacMoodyAlgebra, cls).__classcall__(cls, R, cm)

    def __init__(self, R, cm):
        """
        Initialize ``self``.

        TESTS::
        """
        index_set = cm.index_set()
        n = len(index_set)
        self._n = n
        self._cartan_matrix = cm

        # Construct the base free Lie algebra
        names  = ['e{}'.format(i) for i in index_set]
        names += ['f{}'.format(i) for i in index_set]
        names += ['h{}'.format(i) for i in index_set]
        names += ['d{}'.format(i) for i in range(n-cm.rank())]
        F = FreeLieAlgebra(R, names).Lyndon()
        e = F.gens()[:n]
        f = F.gens()[n:2*n]
        h = F.gens()[2*n:3*n]
        d = F.gens()[3*n:]

        # Construct the basic relations
        P_check = h+d
        rels = [F.bracket(x, y) for i,x in enumerate(P_check) for y in P_check[i+1:]]
        rels += [F.bracket(x, y) - cm[i,j]*x for i,x in enumerate(e) for j,y in enumerate(h)]
        rels += [F.bracket(x, y) for x in e for y in d]
        rels += [F.bracket(x, y) + cm[i,j]*x for i,x in enumerate(f) for j,y in enumerate(h)]
        rels += [F.bracket(x, y) for x in f for y in d]
        for i,x in enumerate(e):
            for j,y in enumerate(f):
                if i == j:
                    rels.append(F.bracket(x, y) - h[i])
                else:
                    rels.append(F.bracket(x, y))

        category = LieAlgebras(R).WithBasis()
        if cm.is_finite():
            category = category.FiniteDimensional()
        FinitelyPresentedLieAlgebra.__init__(self, F, rels, category=category)

        # Define the actual generators
        elt = lambda x: self.element_class(self, x)
        self._e = map(elt, e)
        self._f = map(elt, f)
        self._h = map(elt, h)
        self._d = map(elt, d)

