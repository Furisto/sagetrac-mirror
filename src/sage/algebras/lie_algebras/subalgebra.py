"""
(Lie) Subalgebras of Lie Algebras

AUTHORS:

- Travis Scrimshaw (2013-05-03): Initial version
"""

#*****************************************************************************
#  Copyright (C) 2013 Travis Scrimshaw <tscrim@ucdavis.edu>
#
#  Distributed under the terms of the GNU General Public License (GPL)
#
#    This code is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty
#    of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
#
#  See the GNU General Public License for more details; the full text
#  is available at:
#
#                  http://www.gnu.org/licenses/
#*****************************************************************************

from sage.misc.cachefunc import cached_method
from sage.structure.parent import Parent
from sage.structure.unique_representation import UniqueRepresentation
from sage.algebras.lie_algebras.lie_algebra import LieAlgebra
from sage.algebras.lie_algebras.lie_algebra_element import LieAlgebraElementWrapper
from sage.rings.all import ZZ

# TODO: A class for finite dimensional subalgebras so we can give an echonized basis
class LieSubalgebra(LieAlgebra):
    r"""
    The Lie subalgebra `\mathfrak{h}` of a Lie algebra `\mathfrak{g}`.
    """
    def __init__(self, ambient, gens, names=None, index_set=None, category=None):
        """
        Initialize ``self``.

        INPUT:

        - ``ambient`` -- the ambient Lie algebra

        - ``gens`` -- the generators for this subalgebra

        - ``names`` -- (optional) the names for the generators

        - ``index_set`` -- (optional) the index set for the generators

        - ``category`` -- (optional) the category

        EXAMPLES::
        """
        self._ambient = ambient
        self._gens = gens
        if category is None:
            category = ambient.category()
        if names is None and index_set is None:
            index_set = range(len(gens))
        LieAlgebra.__init__(self, ambient.base_ring(), names, index_set, category)

    def _repr_(self):
        """
        Return a string representation of ``self``.
        """
        return "Subalgebra generated by {} of {}".format(self._gens, self._ambient)

    def gens(self):
        """
        Return the generators of ``self``.
        """
        return self._gens

    def subalgebra(self, gens, names=None):
        """
        Return the subalgebra of ``self`` generated by ``gens``.
        """
        return LieSubalgebra(self._ambient, map(lambda x: x.value, gens), names)

    def product_space(self, Y):
        """
        Return the product space ``[self, Y]`` in the ambient space
        of ``self``.

        INPUT:

        - ``Y`` -- another subspace of the ambient space of ``self``
        """
        X_gens = map(self._ambient, self.gens())
        Y_gens = map(self._ambient, Y.gens())
        return self._ambient.subalgebra(X_gens + Y_gens)

    def free_module(self):
        """
        Return ``self`` as (a subspace of) a free module.
        """
        return self._ambient.free_module().subspace(map(lambda x: x.to_vector(), self.gens))

    class Element(LieAlgebraElementWrapper):
        """
        An element in a Lie subalgebra.
        """
        def _bracket_(self, rhs):
            """
            Return the bracket ``[self, rhs]``.

            EXAMPLES::
            """
            return self.__class__(self.parent(), self.value.bracket(rhs.value))

        def _acted_upon_(self, scalar, self_on_left=False):
            """
            Return the action of a scalar on ``self``.

            EXAMPLES::
            """
            # With the current design, the coercion model does not have
            # enough information to detect apriori that this method only
            # accepts scalars; so it tries on some elements(), and we need
            # to make sure to report an error.
            if hasattr( scalar, 'parent' ) and scalar.parent() != self.base_ring():
                # Temporary needed by coercion (see Polynomial/FractionField tests).
                if self.base_ring().has_coerce_map_from(scalar.parent()):
                    scalar = self.base_ring()( scalar )
                else:
                    return None
            if self_on_left:
                return self.__class__(self.parent(), self.value * scalar)
            return self.__class__(self.parent(), scalar * self.value)

