"""
(Lie) Subalgebras of Lie Algebras

AUTHORS:

- Travis Scrimshaw (2013-05-03): Initial version
"""

#*****************************************************************************
#  Copyright (C) 2013 Travis Scrimshaw <tscrim@ucdavis.edu>
#
#  Distributed under the terms of the GNU General Public License (GPL)
#
#    This code is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty
#    of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
#
#  See the GNU General Public License for more details; the full text
#  is available at:
#
#                  http://www.gnu.org/licenses/
#*****************************************************************************

from sage.misc.cachefunc import cached_method
from sage.structure.parent import Parent
from sage.structure.unique_representation import UniqueRepresentation
from sage.algebras.lie_algebras.lie_algebra_element import LieAlgebra
from sage.rings.all import ZZ
from sage.algebras.lie_algebras.free_lie_algebra import is_lyndon

class LieSubalgebra(LieAlgebra):
    r"""
    The Lie subalgebra `\mathfrak{h}` of a Lie algebra `\mathfrak{g}`.
    """
    def __init__(self, ambient, gens, names=None, category=None):
        """
        Initialize ``self``.

        INPUT:

        - ``ambient`` -- the ambient Lie algebra

        - ``gens`` -- the generators for this ideal

        - ``names`` -- (optional) the names for the generators

        - ``category`` -- (optional) the category

        EXAMPLES::
        """
        self._ambient = ambient
        self._gens = gens
        if category is None:
            category = ambient.category()
        LieAlgebra.__init__(self, ambient.base_ring(), names, category)

    def _repr_(self):
        """
        Return a string representation of ``self``.
        """
        return "Subalgebra generated by {} of {}".format(self._gens, self._ambient)

    def gens(self):
        """
        Return the generators of ``self``.
        """
        return self._gens

    def subalgebra(self, gens, names=None):
        """
        Return the subalgebra of ``self`` generated by ``gens``.
        """
        from sage.algebras.lie_algebras.subalgea import LieSubalgebra
        return LieSubalgebra(self._ambient, map(lambda x: x.value, gens), names)

    def product_space(self, Y, ambient=None):
        """
        Return the product space ``[self, Y]`` in ``ambient``.

        INPUT:

        - ``Y`` -- the other subspace of ``ambient``
        - ``ambient`` -- (optional) the ambient space to compute the
          product space; the default is to use the ambient space of ``self``
        """
        if ambient is None:
            ambient = self._ambient
            X_gens = self.gens()
        else:
            X_gens = map(ambient, self.gens())
        Y_gens = map(ambient, Y.gens())
        return ambient.subalgebra(X_gens + Y_gens)

    def _dense_free_module(self):
        """
        Return the ambient module of ``self``.
        """
        return self._ambient._dense_free_module()

    class Element(ElementWrapper):
        """
        An element in a Lie subalgebra.
        """
        def _bracket_(self, rhs):
            """
            Return the bracket ``[self, rhs]``.

            EXAMPLES::
            """
            return self.__class__(self.parent(), self.value.bracket(rhs.value))

        def _add_(self, rhs):
            """
            Add ``self`` and ``rhs``.

            EXAMPLES::
            """
            return self.__class__(self.parent(), self.value + rhs.value)

        def _sub_(self, rhs):
            """
            Subtract ``self`` and ``rhs``.

            EXAMPLES::
            """
            return self.__class__(self.parent(), self.value - rhs.value)

        def _acted_upon_(self, scalar, self_on_left=False):
            """
            Return the action of a scalar on ``self``.

            EXAMPLES::
            """
            # With the current design, the coercion model does not have
            # enough information to detect apriori that this method only
            # accepts scalars; so it tries on some elements(), and we need
            # to make sure to report an error.
            if hasattr( scalar, 'parent' ) and scalar.parent() != self.base_ring():
                # Temporary needed by coercion (see Polynomial/FractionField tests).
                if self.base_ring().has_coerce_map_from(scalar.parent()):
                    scalar = self.base_ring()( scalar )
                else:
                    return None
            if self_on_left:
                return self.__class__(self.parent(), self.value * scalar)
            return self.__class__(self.parent(), scalar * self.value)

        def __neg__(self):
            """
            Return the negation of ``self``.

            EXAMPLES::
            """
            return self.__class__(self.parent(), -self.value)

