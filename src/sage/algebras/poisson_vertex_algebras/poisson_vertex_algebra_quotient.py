"""
Quotients of Poisson Vertex Algebras.

AUTHORS

- Reimundo Heluani (06-17-2020): Initial implementation.
"""

#******************************************************************************
#       Copyright (C) 2019 Reimundo Heluani <heluani@potuz.net>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# (at your option) any later version.
#                  http://www.gnu.org/licenses/
#*****************************************************************************

from sage.combinat.free_module import CombinatorialFreeModule
from sage.categories.poisson_vertex_algebras import PoissonVertexAlgebras
from sage.sets.family import Family 

class PoissonVertexAlgebraQuotient(CombinatorialFreeModule):

    @staticmethod
    def __classcall_private__(cls, ideal, category=None):
        if ideal.is_zero():
            return ideal.ambient()

        default_category = PoissonVertexAlgebras(ideal.category().base_ring())\
                                                                  .Quotients()
        category = default_category.or_subcategory(category, join=True)

        return PoissonVertexAlgebraQuotient.__classcall__(cls, ideal, category)

    def __init__(self, ideal, category=None):
        self._ideal = ideal
        self._ambient = ideal.ambient()
        from sage.algebras.vertex_algebras.vertex_algebra_quotient import \
                      VertexAlgebraQuotientBasis, VertexAlgebraQuotientElement
        indices = VertexAlgebraQuotientBasis(ideal)
        try:
            names = self._ambient.variable_names()
        except AttributeError:
            names = None
        
        CombinatorialFreeModule.__init__(self, ideal.base_ring(),
                                    basis_keys=indices,
                                    element_class=VertexAlgebraQuotientElement,
                                    category=category, names=names)

    def _element_constructor_(self,x):
        if x in self._ambient:
            return self.retract(x)
        return super(PoissonVertexAlgebraQuotient,self)._element_constructor_(x)

    def _repr_(self):
        return "Quotient of {} by {}".format(self._ambient,
                                             self._ideal._repr_short())

    def cover_algebra(self):
        """If this vertex algebra is a quotient of `V`, this method returns `V`

        EXAMPLES::

            sage: V = VirasoroVertexAlgebra(QQ, 1/2); Q=V.quotient(V.ideal(V.find_singular(6)[0]))
            sage: Q.module()
            Quotient of The Virasoro vertex algebra of central charge 1/2 by the ideal generated by (L_-2L_-2L_-2|0>-33/8*L_-4L_-2|0>+93/64*L_-3L_-3|0>-27/16*L_-6|0>,)
            sage: Q.module().ambient()
            The Virasoro vertex algebra of central charge 1/2
            sage: Q.module().ambient() is V
            True

        """
        return self._ambient

    def defining_ideal(self):
        return self._ideal

    def lift(self, x):
        r"""Return an element on the ambient vertex algebra in the preimage of
        ``x`` by the quotient map

        EXAMPLES::

            sage: V = VirasoroVertexAlgebra(QQ, 1/2); Q=V.quotient(V.ideal(V.find_singular(6)[0]))
            sage: L = Q(Q.gen(0))
            sage: v = L*(L*L)
            sage: v
            33/8*L_-4L_-2|0>-93/64*L_-3L_-3|0>+27/16*L_-6|0>
            sage: v.parent()
            Quotient of The Virasoro vertex algebra of central charge 1/2 by the ideal generated by (L_-2L_-2L_-2|0>-33/8*L_-4L_-2|0>+93/64*L_-3L_-3|0>-27/16*L_-6|0>,)
            sage: v.lift().parent()
            The Virasoro vertex algebra of central charge 1/2

        """
        assert x in self
        return self.cover_algebra()._from_dict(x._monomial_coefficients)
    
    def basis(self):
        return Family(self._indices, self.monomial)


    def retract(self, x):
        r"""Let this vertex algebra `Q` be the quotient of `V` by the ideal `I`
        and ``x`` be an element of `V`. This method returns the reduction of `x`
        modulo `I`. That is the image of ``x`` under the quotient map.

        EXAMPLES::

            sage: V = VirasoroVertexAlgebra(QQ, 1/2); Q=V.quotient(V.ideal(V.find_singular(6)[0]))
            sage: L = V.gen(0)
            sage: v = L*(L*L)
            sage: Q.retract(v)
            33/8*L_-4L_-2|0>-93/64*L_-3L_-3|0>+27/16*L_-6|0>
            sage: Q.retract(v).parent()
            Quotient of The Virasoro vertex algebra of central charge 1/2 by the ideal generated by (L_-2L_-2L_-2|0>-33/8*L_-4L_-2|0>+93/64*L_-3L_-3|0>-27/16*L_-6|0>,)
            sage: v.parent()
            The Virasoro vertex algebra of central charge 1/2

        """
        return self._from_dict(self._ideal.reduce(x)._monomial_coefficients)

    def hilbert_series(self,ord):
        try:
            P = self._ambient.jet_algebra(ord)
        except NotImplementedError:
            #TODO: Check why the call to self.category().parent_class()
            #.hilbert_series(ord) fails to get the generators. 
            from sage.arith.functions import lcm
            from sage.functions.other import floor
            from sage.rings.all import QQ, ZZ
            weights = [g.weight() for g in self.gens()]
            if any([w not in QQ or w < 0 for w in weights]):
                raise NotImplementedError("hilbert_series is not "\
                                  "implemented for {}".format(self))
            if ord not in QQ or ord < 0:
                raise ValueError("ord must be a positive rational "\
                                 "number")
            l = lcm([g.weight().denominator() for g in self.gens()])
            if l==1:
                from sage.rings.power_series_ring import\
                                                    PowerSeriesRing
                q = PowerSeriesRing(ZZ,'q', default_prec=ord).gen()
                return sum(self.dimension_at_weight(n)*q**n for\
                           n in range(floor(ord))).O(floor(ord))
            else:
                from sage.rings.puiseux_series_ring import\
                                                  PuiseuxSeriesRing
                q = PuiseuxSeriesRing(ZZ,'q').gen()
                ord = floor(ord*l)
                f = sum(self.dimension_at_weight(n/l)*q**(n/l) for\
                        n in range(ord))
                return f.add_bigoh(ord/l)
        return self._ideal.hilbert_series(ord)
