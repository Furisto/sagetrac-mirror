"""
Quotients of Poisson Vertex Algebras.

AUTHORS:

- Reimundo Heluani (2020-06-17): Initial implementation.
"""

#******************************************************************************
#       Copyright (C) 2019 Reimundo Heluani <heluani@potuz.net>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# (at your option) any later version.
#                  http://www.gnu.org/licenses/
#*****************************************************************************

from sage.combinat.free_module import CombinatorialFreeModule
from sage.categories.poisson_vertex_algebras import PoissonVertexAlgebras
from sage.sets.family import Family
from sage.rings.all import ZZ
from sage.algebras.vertex_algebras.vertex_algebra_quotient import \
                      VertexAlgebraQuotientBasis, VertexAlgebraQuotientElement

class PoissonVertexAlgebraQuotientElement(VertexAlgebraQuotientElement):
    """
    Base class for elements of quotients of Poisson vertex algebras.
    """
    def _im_gens_(self, codomain, im_gens, base_map=None):
        """
        The image of this element by the morphism defined on generators.

        INPUT:

        - ``codomain`` -- a Poisson vertex agebra; the codomain of the
          morphism
        - ``im_gens`` -- a tuple; the images by the morphism of the
          generators

        EXAMPLES::

            sage: V = vertex_algebras.Virasoro(QQ,1/2)
            sage: P = V.classical_limit()
            sage: I = P.ideal(P.0**3)
            sage: S = P.quotient(I)
            sage: S.inject_variables()
            Defining L
            sage: v = L.T(3)*L**2/18 + L.T(2)*L.T()*L; v
            2*L_4*L_3*L_2 + 1/3*L_5*L_2^2
            sage: Q = V.quotient(V.ideal(V.find_singular(6)),names=('Lbar',))
            sage: R = Q.classical_limit(); R
            The classical limit of Quotient of The Virasoro vertex algebra of central charge 1/2 over Rational Field by the ideal generated by (L_-2L_-2L_-2|0> + 93/64*L_-3L_-3|0> - 33/8*L_-4L_-2|0> - 27/16*L_-6|0>,)
            sage: R.inject_variables()
            Defining Lbar
            sage: v._im_gens_(R,(Lbar,))
            0
        """
        from sage.functions.other import factorial
        from sage.misc.misc_c import prod
        ret = codomain.zero()
        for k,c in self._monomial_coefficients.items():
            ret += c*prod(g.T(n-1)/factorial(n-1) for i,g in enumerate(im_gens)\
                          for n in k[i])
        return ret

    def _to_polynomial(self,ord=None, termorder='wdegrevlex'):
        r"""
        Convert this element to a polynomial in the Jet algebra.

        The Jet algebra of order ``ord`` is the quotient of this
        Poisson vertex algebra by the ideal of elements of degree
        greater than ``ord `` in the Li filtration grading. For
        certain Poisson vertex, namely classical limits of universal
        enveloping algebras of integrally graded (non-super) vertex
        algebras, and their quotients by differential ideals, we can
        use a Polynomial implementation of these algebras in order to
        use the machinery of Groebner bases, etc.

        We implement different monomial orderings on these polynomial
        implementations. Suppose this Poisson vertex algebra is
        generated by vectors `g_1,...,g_n` with conformal weights
        `d_1,...,d_n`. The generators of the corresponding polynomial
        ring are `T^k g_i` for `k \geq 0` and `i = 1, \ldots,n`. These
        generators have degree `k+d_i` (with respect to the conformal
        weight grading), degree `k` with respect to the Li filtration
        grading.

        - ``'wdegrevlex'`` -- We order the generators first by degree,
          then in lexicographic order `g_1 > g_2 > \dots` and then
          we use the ``wdegrevlex`` order of the polynomial algebra.

        - ``'wdeglex'`` -- We order the generators in decreasing
          order by degree and then in increasing lexicographic order.
          Finally we use the ``'wdeglex'`` order of the polynomial
          algebra.

        - ``'revlexwdeg'`` -- We order the generators first by
          lexicographic order and then by degree in the Li filtration
          grading. Finally we use the ``'wdegrevlex'`` ordering of the
          polynomial algebra.

        - ``'lexwdeg'`` -- We order the generators first by
          lexicographic order and then decreasing by degree in the Li
          filtration grading. Finally we use the ``'wdeglex'`` order
          in the Polynomial algebra.

        INPUT:

        - ``ord`` -- a positive Integer or ``None``
          (default: ``None``); if ``None``, the degree of this element
          is used.
        - ``termorder`` -- one of ``'wdegrevlex'``, ``'wdeglex'``,
          ``'revlexwdeg'`` or ``'lexwdeg'``
          (default: ``'wdegrevlex'``); the monomial order to use

        EXAMPLES::

            sage: V = vertex_algebras.Affine(QQ, 'A1',1, names=('e','h','f'))
            sage: Q = V.quotient(V.ideal(V.find_singular(2)))
            sage: A = Q.arc_algebra()
            sage: v = A(A._indices[10]); v
            e_1*f_2
            sage: w = v._to_polynomial(3); w
            e_1bar*f_2bar
            sage: J = A.jet_algebra(3)
            sage: w in J
            True
        """
        #Not exposed yet until we have a working framework connected
        #with jet/arc schemes
        p = self.parent()
        if ord == None or ord < self.degree():
            ord = ZZ(self.degree())
        try:
            PR = p.jet_algebra(ord,termorder)
        except NotImplementedError:
            raise NotImplementedError("_to_polynomial is not implemented for "\
                                      "elements of {}".format(p))
        return PR(self.lift()._to_polynomial(ord,termorder))

class PoissonVertexAlgebraQuotient(CombinatorialFreeModule):
    """
    A quotient of a Poisson vertex algebra.

    INPUT:

    - ``ideal`` -- a
      :class:`~.poisson_vertex_algebra_ideal.PoissonVertexAlgebraIdeal`;
      an ideal of a Poisson vertex algebra
    - ``names`` --  a list of ``str`` or ``None`` (default: ``None``);
      alternative names for the generators
    - ``category``--  a :class:`Category`; the category where this
      quotient is a parent

    .. NOTE::

        This class is not meant to be called directly by the user.
        Use instead :meth:`~sage.categories.poisson_vertex_algebras.PoissonVertexAlgebras.ParentMethods.quotient`.
    """
    @staticmethod
    def __classcall_private__(cls, ideal, names=None, category=None):
        """
        Construct a quotient of a Poisson vertex algebra.

        EXAMPLES::

            sage: V = vertex_algebras.Virasoro(QQ,1/2)
            sage: P = V.classical_limit(); P.inject_variables()
            Defining L
            sage: I = P.ideal(L**3)
            sage: Q = P.quotient(I)
            sage: from sage.algebras.poisson_vertex_algebras.poisson_vertex_algebra_quotient \
                                                import PoissonVertexAlgebraQuotient
            sage: T = PoissonVertexAlgebraQuotient(I, category=P.category().Quotients())
            sage: Q is T
            True
        """
        if ideal.is_zero():
            return ideal.ambient()

        default_category = PoissonVertexAlgebras(ideal.category().base_ring())\
                                                                  .Quotients()
        category = default_category.or_subcategory(category, join=True)

        return PoissonVertexAlgebraQuotient.__classcall__(cls, ideal,
                                                          names=names,
                                                          category=category)

    def __init__(self, ideal, names=None, category=None):
        """
        Initialize self.

        EXAMPLES::

            sage: V = vertex_algebras.Virasoro(QQ,1/2)
            sage: P = V.classical_limit()
            sage: Q = P.quotient(P.ideal(P.0**3))
            sage: TestSuite(Q).run()    # not tested
        """
        self._ideal = ideal
        self._ambient = ideal.ambient()
        indices = VertexAlgebraQuotientBasis(ideal)
        if names is None:
            try:
                names = self._ambient.variable_names()
            except AttributeError:
                pass

        CombinatorialFreeModule.__init__(self, ideal.base_ring(),
                             basis_keys=indices,
                             element_class=PoissonVertexAlgebraQuotientElement,
                             category=category, names=names)

    def _element_constructor_(self,x):
        """
        An element of this quotient.

        INPUT:

        - ``x`` -- an element of the cover poisson vertex algebra or an
          index of the basis.

        EXAMPLES::

            sage: V = vertex_algebras.Virasoro(QQ)
            sage: P = V.classical_limit()
            sage: P.inject_variables()
            Defining L
            sage: R = P.quotient(P.ideal(L**3))
            sage: B = R._indices
            sage: R(P.an_element())
            1 + 2*L_2 + 3*L_3
            sage: R(B.an_element())
            L_3*L_2
        """
        if x in self._ambient:
            return self.retract(x)
        return super(PoissonVertexAlgebraQuotient,self)._element_constructor_(x)

    def _repr_(self):
        """
        The name of this quotient.

        EXAMPLES::

            sage: V = vertex_algebras.Virasoro(QQ)
            sage: P = V.classical_limit()
            sage: P.inject_variables()
            Defining L
            sage: R = P.quotient(P.ideal(L**3))
            sage: R
            Quotient of The classical limit of The Virasoro vertex algebra of central charge 0 over Rational Field by the ideal generated by (L_2^3,)
        """
        return "Quotient of {} by {}".format(self._ambient,
                                             self._ideal._repr_short())

    def cover_algebra(self):
        """
        The covering vertex algebra of this quotient.

        EXAMPLES::

            sage: V = vertex_algebras.Virasoro(QQ)
            sage: P = V.classical_limit()
            sage: P.inject_variables()
            Defining L
            sage: R = P.quotient(P.ideal(L**3))
            sage: R.cover_algebra()
            The classical limit of The Virasoro vertex algebra of central charge 0 over Rational Field
        """
        return self._ambient

    def _is_valid_homomorphism_(self, codomain, im_gens, base_map=None):
        """
        Whether the morphism defined on generators is well defined.

        INPUT:

        - ``codomain`` -- a Poisson Vertex algebra
        - ``im_gens`` -- a list of elements of ``codomain``

        EXAMPLES::

            sage: V = vertex_algebras.Virasoro(QQ,1/2); V.register_lift()
            sage: Q = V.quotient(V.ideal(V.find_singular(6)))
            sage: A = Q.arc_algebra()
            sage: P = Q.classical_limit()
            sage: P.inject_variables()
            Defining L
            sage: A._is_valid_homomorphism_(P,(L,))
            True
            sage: A._is_valid_homomorphism_(P,(L+L.T(),))
            False
        """
        f = self._ambient.hom(im_gens, codomain=codomain,base_map=base_map)
        return all (f(g).is_zero() for g in self._ideal.gens())

    def cover(self):
        """
        The quotient map from the covering Poisson vertex algebra.

        EXAMPLES::

            sage: V = vertex_algebras.Virasoro(QQ,1/2);
            sage: Q = V.quotient(V.ideal(V.find_singular(6)))
            sage: A = Q.arc_algebra()
            sage: A.cover()
            Ring morphism:
              From: The classical limit of The Virasoro vertex algebra of central charge 1/2 over Rational Field
              To:   Quotient of The classical limit of The Virasoro vertex algebra of central charge 1/2 over Rational Field by the ideal generated by (L_2^3,)
              Defn: L_2 |--> L_2
        """
        return self.cover_algebra().hom(self.gens(), codomain=self)

    def defining_ideal(self):
        """
        The defining ideal of this quotient.

        EXAMPLES::

            sage: V = vertex_algebras.Virasoro(QQ,1/2);
            sage: Q = V.quotient(V.ideal(V.find_singular(6)))
            sage: A = Q.arc_algebra()
            sage: A.defining_ideal()
            ideal of The classical limit of The Virasoro vertex algebra of central charge 1/2 over Rational Field generated by (L_2^3,)
        """
        return self._ideal

    def lift(self, x):
        """
        A preimage of this element in the cover Poisson vertex algebra.

        EXAMPLES::

            sage: V = vertex_algebras.Virasoro(QQ,1/2);
            sage: Q = V.quotient(V.ideal(V.find_singular(6)))
            sage: A = Q.arc_algebra()
            sage: v = A.an_element().lift(); v
            1 + 2*L_2 + 3*L_3 + L_3*L_2
            sage: v.parent()
            The classical limit of The Virasoro vertex algebra of central charge 1/2 over Rational Field
        """
        assert x in self
        return self.cover_algebra()._from_dict(x._monomial_coefficients)

    def basis(self):
        """
        The basis of this quotient.

        EXAMPLES::

            sage: V = vertex_algebras.Virasoro(QQ,1/2);
            sage: Q = V.quotient(V.ideal(V.find_singular(6)))
            sage: A = Q.arc_algebra()
            sage: A.basis()
            Lazy family (Term map from Basis of the quotient of The classical limit of The Virasoro vertex algebra of central charge 1/2 over Rational Field by ideal of The classical limit of The Virasoro vertex algebra of central charge 1/2 over Rational Field generated by (L_2^3,) to Quotient of The classical limit of The Virasoro vertex algebra of central charge 1/2 over Rational Field by the ideal generated by (L_2^3,)(i))_{i in Basis of the quotient of The classical limit of The Virasoro vertex algebra of central charge 1/2 over Rational Field by ideal of The classical limit of The Virasoro vertex algebra of central charge 1/2 over Rational Field generated by (L_2^3,)}
        """
        return Family(self._indices, self.monomial)


    def retract(self, x):
        """
        The image of this element of the cover vertex algebra by the
        quotient map.

        EXAMPLES::

            sage: V = vertex_algebras.Abelian(QQ, 6, weights = (1,1,1,1/2,1/2,1/2), parity=(0
            ....: ,0,0,1,1,1), names = ('a0','a1','a2','b0','b1','b2'))
            sage: P = V.classical_limit()
            sage: P.inject_variables()
            Defining a0, a1, a2, b0, b1, b2
            sage: A = P.quotient(P.ideal(a0**3 + a1*a2*b0*b1))
            sage: A.retract(a0**3)
            -a1_1*a2_1*b0_1/2*b1_1/2
        """
        return self._from_dict(self._ideal.reduce(x)._monomial_coefficients)

    def jet_algebra(self, ord, termorder='wdegrevlex'):
        r"""
        The quotient of this Poisson vertex algebra by the ideal of
        elements of Li filtration degree bigger than ``ord``.

        The Jet algebra of order ``ord`` is the quotient of this
        Poisson vertex algebra by the ideal of elements of degree
        greater than ``ord`` in the Li filtration grading. For
        certain Poisson vertex, namely classical limits of universal
        enveloping algebras of integrally graded (non-super) vertex
        algebras, and their quotients by differential ideals, we can
        use a Polynomial implementation of these algebras in order to
        use the machinery of Groebner bases, etc.

        We implement different monomial orderings on these polynomial
        implementations. Suppose this Poisson vertex algebra is
        generated by vectors `g_1,...,g_n` with conformal weights
        `d_1,...,d_n`. The generators of the corresponding polynomial
        ring are `T^k g_i` for `k \geq 0` and `i = 1, \ldots,n`. These
        generators have degree `k+d_i` (with respect to the conformal
        weight grading), degree `k` with respect to the Li filtration
        grading.

        - ``'wdegrevlex'`` -- We order the generators first by degree,
          then in lexicographic order `g_1 > g_2 > \dots` and then
          we use the ``wdegrevlex`` order of the polynomial algebra.

        - ``'wdeglex'`` -- We order the generators in decreasing
          order by degree and then in increasing lexicographic order.
          Finally we use the ``'wdeglex'`` order of the polynomial
          algebra.

        - ``'revlexwdeg'`` -- We order the generators first by
          lexicographic order and then by degree in the Li filtration
          grading. Finally we use the ``'wdegrevlex'`` ordering of the
          polynomial algebra.

        - ``'lexwdeg'`` -- We order the generators first by
          lexicographic order and then decreasing by degree in the Li
          filtration grading. Finally we use the ``'wdeglex'`` order
          in the Polynomial algebra.

        INPUT:

        - ``ord`` -- a positive Integer
        - ``termorder`` -- one of ``'wdegrevlex'``, ``'wdeglex'``,
          ``'revlexwdeg'`` or ``'lexwdeg'``
          (default: ``'wdegrevlex'``); the monomial order to use

        EXAMPLES::

            sage: V = vertex_algebras.Affine(QQ, 'A1',1, names=('e','h','f'))
            sage: Q = V.quotient(V.ideal(V.find_singular(2)))
            sage: P = Q.arc_algebra()
            sage: P.jet_algebra(3)
            Quotient of Multivariate Polynomial Ring in e_1, h_1, f_1, e_2, h_2, f_2, e_3, h_3, f_3 over Rational Field by the ideal (e_1*e_2, h_1*e_2 + e_1*h_2, f_1*e_2 - h_1*h_2 + e_1*f_2, f_1*h_2 + h_1*f_2, f_1*f_2, e_1^2, e_1*h_1, h_1^2 - 2*e_1*f_1, h_1*f_1, f_1^2)
            sage: P.jet_algebra(3,'wdeglex')
            Quotient of Multivariate Polynomial Ring in e_3, h_3, f_3, e_2, h_2, f_2, e_1, h_1, f_1 over Rational Field by the ideal (e_2*e_1, e_2*h_1 + h_2*e_1, e_2*f_1 - h_2*h_1 + f_2*e_1, h_2*f_1 + f_2*h_1, f_2*f_1, h_1^3, e_1^2, e_1*h_1, e_1*f_1 - 1/2*h_1^2, h_1*f_1, f_1^2)

        We can convert elements of this quotient to polynomials in
        the Jet algebra::

            sage: v = P(P._indices[10]); v
            e_1*f_2
            sage: w = v._to_polynomial(3); w
            e_1bar*f_2bar
            sage: J = P.jet_algebra(3)
            sage: w in J
            True
        """
        try:
            A = self._ambient.jet_algebra(ord, termorder)
        except NotImplementedError:
            raise NotImplementedError("jet_algebra is not implemented for "\
                                      "{}".format(self))
        I = self._ideal._groebner_basis(ord, termorder)
        return A.quotient(A.ideal(I))

    def hilbert_series(self,ord):
        """
        The graded character of this quotient.

        INPUT:

        - ``ord`` -- a non-negative rational

        EXAMPLES::

            sage: V = vertex_algebras.Affine(QQ, 'A1',1, names=('e','h','f'))
            sage: Q = V.quotient(V.ideal(V.find_singular(2)))
            sage: A = Q.arc_algebra()
            sage: A.hilbert_series(8)
            1 + 3*q + 4*q^2 + 7*q^3 + 13*q^4 + 19*q^5 + 29*q^6 + 43*q^7 + O(q^8)
        """
        try:
            self._ambient.jet_algebra(ord)
        except NotImplementedError:
            #TODO: Check why the call to self.category().parent_class()
            #.hilbert_series(ord) fails to get the generators.
            from sage.arith.functions import lcm
            from sage.functions.other import floor
            from sage.rings.all import QQ, ZZ
            weights = [g.weight() for g in self.gens()]
            if any([w not in QQ or w < 0 for w in weights]):
                raise NotImplementedError("hilbert_series is not "\
                                  "implemented for {}".format(self))
            if ord not in QQ or ord < 0:
                raise ValueError("ord must be a positive rational "\
                                 "number")
            l = lcm([g.weight().denominator() for g in self.gens()])
            if l==1:
                from sage.rings.power_series_ring import\
                                                    PowerSeriesRing
                q = PowerSeriesRing(ZZ,'q', default_prec=ord).gen()
                return sum(self.dimension_at_weight(n)*q**n for\
                           n in range(floor(ord))).O(floor(ord))
            else:
                from sage.rings.puiseux_series_ring import\
                                                  PuiseuxSeriesRing
                q = PuiseuxSeriesRing(ZZ,'q').gen()
                ord = floor(ord*l)
                f = sum(self.dimension_at_weight(n/l)*q**(n/l) for\
                        n in range(ord))
                return f.add_bigoh(ord/l)
        return self._ideal.hilbert_series(ord)
