r"""
Vertex Algebra Classical Limit

For a vertex algebra `V`, it's *Li Filtration* is a decreasing
filtration `V = F_0 V \supsetneq F_1 V \supsetneq ...`, where `F_p V`
is the linear span of vectors of the form

.. MATH::

    a^1_{(-n_1-1)}a^2_{(-n_2-1)} \cdots a^k_{(-n_k -1)} |0\rangle,
    \qquad a^1,\ldots,a^k \in V, \: \sum_{i=1}^k n_i \geq p.

The associated graded of `V` with respect to this filtration is a
`\mathbb{Z}_+`-graded Poisson vertex algebra known as the
*classical limit* or the *singular support* of `V`. The operations are
defined by:

.. MATH::

    \sigma_p(a) \cdot \sigma_q(b) = \sigma_{p+q} (a_{(-1)} b), \qquad
    \{\sigma_p(a)_\lambda \sigma_q(b)\} = \sum_{j \geq 0}
    \frac{\lambda^j}{j!} \sigma_{p+q-j} \bigl( a_{(j)} b \bigr), \qquad
    T \sigma_p a = \sigma_{p+1} Ta

where `\sigma_p` is the principal symbol map. The multiplication and
`\lambda`-bracket are of degree `0`.

If `V` is also `H`-graded its classical limit acquires an extra
grading. We call this extra grading the *conformal weight* grading. With
respect to the conformal weight grading, the multiplication is of degree `0`
while the `\lambda` bracket is of degree `-1`.

AUTHORS:

- Reimundo Heluani (2020-06-15): Initial implementation.

"""


#******************************************************************************
#       Copyright (C) 2020 Reimundo Heluani <heluani@potuz.net>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# (at your option) any later version.
#                  http://www.gnu.org/licenses/
#*****************************************************************************

from sage.categories.poisson_vertex_algebras import PoissonVertexAlgebras
from sage.categories.proto_poisson_vertex_algebras import ProtoPoissonVertexAlgebras
from sage.categories.vertex_algebras import VertexAlgebras
from sage.categories.proto_vertex_algebras import ProtoVertexAlgebras
from sage.modules.with_basis.indexed_element import IndexedFreeModuleElement
from sage.combinat.free_module import CombinatorialFreeModule
from sage.misc.cachefunc import cached_method
from sage.combinat.family import Family
from sage.misc.misc import repr_lincomb
from sage.combinat.partition import Partition
from sage.rings.all import QQ, ZZ
from sage.misc.lazy_attribute import lazy_attribute
from sage.rings.morphism import RingHomomorphism_im_gens
from sage.categories.homset import Hom

class SingularSupportCoverMorphism(RingHomomorphism_im_gens):
    """
    The quotient map from the arc algebra to the classical limit of
    a vertex algebra ``V``.

    INPUT:

    - ``domain`` -- a Poisson vertex algebra; the arc algebra of a
      vertex algebra ``V``.
    - ``codomain`` -- a Poisson vertex algebra; the classical
      limit of the vertex algebra ``V``.

    .. TODO::

        Implement the category of morphisms of Poisson vertex
        algebras

    EXAMPLES::

        sage: V = vertex_algebras.Affine(QQ, 'A1',1, names=('e','h','f'))
        sage: Q = V.quotient(V.ideal(V.find_singular(2)))
        sage: P = Q.classical_limit()
        sage: f = P.arc_algebra_cover; f
        Ring morphism:
          From: Quotient of The classical limit of The universal affine vertex algebra of CartanType ['A', 1] at level 1 over Rational Field by the ideal generated by (e_1^2, e_1*h_1, h_1^2 - 2*e_1*f_1, h_1*f_1, f_1^2)
          To:   The classical limit of Quotient of The universal affine vertex algebra of CartanType ['A', 1] at level 1 over Rational Field by the ideal generated by (e_-1e_-1|0>, e_-1h_-1|0> + e_-2|0>, h_-1h_-1|0> - 2*e_-1f_-1|0> + h_-2|0>, h_-1f_-1|0> + f_-2|0>, f_-1f_-1|0>)
          Defn: e_1 |--> e_1
                h_1 |--> h_1
                f_1 |--> f_1
    """
    def __init__(self, domain, codomain):
        """
        Initialize self.

        TESTS::

            sage: V = vertex_algebras.Affine(QQ, 'A1',1, names=('e','h','f'))
            sage: Q = V.quotient(V.ideal(V.find_singular(2)))
            sage: P = Q.classical_limit()
            sage: f = P.arc_algebra_cover
            sage: TestSuite(f).run()        # not tested
        """
        H = Hom(domain,codomain)
        RingHomomorphism_im_gens.__init__(self, H, codomain.gens())

    def kernel(self, deg):
        """
        The kernel of this quotient map in degree ``deg``.

        INPUT:

        - ``deg`` -- a positive rational number

        .. TODO::

            This method should return an infinite dimensional
            :class:`CombinatorialFreeModule` with a lazy basis
            like the approach to
            :class:`~sage.algebras.vertex_algebras.vertex_algebra_ideal.VertexAlgebraIdeal`

        EXAMPLES::

            sage: V = vertex_algebras.NeveuSchwarz(QQ, 7/10)
            sage: Q = V.quotient(V.ideal(V.find_singular(4)))
            sage: P = Q.classical_limit()
            sage: f = P.arc_algebra_cover
            sage: K = f.kernel(11/2); K     # long time (1 second)
            Free module generated by {0} over Rational Field
            sage: K.an_element().lift()     # long time
            2*L_3*G_5/2 - 12*L_4*G_3/2 + 16*L_2*G_7/2
        """
        source = self.domain().get_weight(deg)
        target = self.codomain().get_weight(deg)
        B = source.basis()
        linear = source.module_morphism(on_basis=lambda v: target.retract(
                                        self(B[v])),codomain=target)
        return self.domain().submodule([v.lift() for v in\
                                        linear.kernel_basis()])

class ClassicalLimitElement(IndexedFreeModuleElement):
    """
    Base class for elements of a classical limit.
    """
    def _repr_(self):
        """
        String representation.

        EXAMPLES::

            sage: V = vertex_algebras.FreeFermions(AA, 6)
            sage: P = V.classical_limit(); P.an_element()
            1 + 2*psi_0_1/2 + 3*psi_1_1/2 + psi_4_1/2
        """
        if self.is_zero():
            return "0";
        p = self.parent()
        terms = [("".join(["".join([ "{}_{}^{}*".format(p.variable_names()[j],\
                 i+p.gen(j).weight(),r) if r > 1\
            else "{}_{}*".format(p.variable_names()[j],i+p.gen(j).weight())\
            for i,r in reversed(list(enumerate(mu))) if r])\
            for j,mu in enumerate(k.to_exp())]), v) for k,v in \
            sorted(self.monomial_coefficients().items())]
        terms = [(m[:-1],v) for m,v in terms]
        terms = [(k,v) if k or v != 1 else ('1',1) for k,v in terms]
        return repr_lincomb(terms,strip_one = True)

    def _latex_(self):
        r"""
        A visual representation.

        EXAMPLES::

            sage: F = vertex_algebras.FreeFermions(QQ,6)
            sage: P = F.classical_limit()
            sage: v = P.an_element(); v
            1 + 2*psi_0_1/2 + 3*psi_1_1/2 + psi_4_1/2
            sage: latex(v)
            1 + 2\psi_{0}_{-1/2} + 3\psi_{1}_{-1/2} + \psi_{4}_{-1/2}
        """
        if self.is_zero():
            return "0";
        p = self.parent()
        terms = [("".join(["".join(["{}_{{{}}}^{{{}}}".format(
                p._latex_names[j],-1+i+p.gen(j).weight(),r) if r >1\
                else "{}_{{{}}}".format(p._latex_names[j],
               -1+i+p.gen(j).weight())  for i,r in reversed(list(enumerate(
               mu))) if r]) for j,mu in enumerate(k)]), v)\
              for k,v in sorted(self.monomial_coefficients().items())]
        terms = [(k,v) if k or v != 1 else ('1',1) for k,v in terms]
        return repr_lincomb(terms,strip_one = True, is_latex=True)

    def index(self):
        """
        The basis index of this monomial.

        EXAMPLES::

            sage: V = vertex_algebras.NeveuSchwarz(QQ, 1)
            sage: P = V.classical_limit()
            sage: v = P([[3,2],[1]]); v
            L_4*L_3*G_3/2
            sage: v.index()
            ([3, 2], [1])
        """
        return self.lift().index()

    def weight(self):
        """
        The conformal weight of this element.

        EXAMPLES::

            sage: V = vertex_algebras.NeveuSchwarz(QQ, 1)
            sage: P = V.classical_limit()
            sage: v = P([[3,2],[1]]); v
            L_4*L_3*G_3/2
            sage: v.weight()
            17/2
        """
        if self.is_zero():
            from sage.rings.infinity import Infinity
            return +Infinity
        weights = [k.energy() for k,v in self._monomial_coefficients.items()]
        if weights[1:] == weights[:-1]:
            return weights[0]
        raise ValueError("{} is not homogeneous".format(self))

    def is_homogeneous(self):
        """
        Whether this element is homogeneous with respect to conformal
        weight.

        EXAMPLES::

            sage: V = vertex_algebras.NeveuSchwarz(QQ, 1)
            sage: P = V.classical_limit()
            sage: v = P.an_element(); v
            1 + 2*G_3/2 + 3*L_2 + L_2*G_3/2
            sage: v.is_homogeneous()
            False
            sage: P.inject_variables()
            Defining L, G
            sage: v = L.T(3)*G.T(5) + L.T(8)*G; v
            720*L_5*G_13/2 + 40320*L_10*G_3/2
            sage: v.is_homogeneous()
            True
        """
        weights = [k.energy() for k,v in self._monomial_coefficients.items()]
        return weights[1:] == weights[:-1]

    def li_filtration_lt(self):
        """
        The leading terms of this element with respect to the
        Li filtration grading.

        EXAMPLES::

            sage: V = vertex_algebras.Affine(QQ, 'A1',1, names=('e','h','f'))
            sage: P = V.classical_limit()
            sage: P.inject_variables()
            Defining e, h, f
            sage: v = e + f**2 + 3*h*f*e + 2*h.T(2) + 5*f.T()*e; v
            e_1 + f_1^2 + 3*e_1*h_1*f_1 + 5*e_1*f_2 + 4*h_3
            sage: v.li_filtration_lt()
            e_1 + f_1^2 + 3*e_1*h_1*f_1
        """
        deg = self.li_filtration_degree()
        pz = self.parent().zero()
        return sum([m for m in self.terms() if
                    m._li_filtration_monomial_degree() == deg],pz)

    def li_filtration_degree(self):
        """
        The degree of this element with respect to the Li filtration
        grading.

        EXAMPLES::

            sage: V = vertex_algebras.Affine(QQ, 'A1',1, names=('e','h','f'))
            sage: P = V.classical_limit()
            sage: v = P.an_element(); v
            1 + 2*e_1 + 3*h_1 + e_1^4*h_2*h_1^2*f_3*f_1
            sage: v.li_filtration_degree()
            0
        """
        return self.lift().li_filtration_degree()

    def _li_filtration_monomial_degree(self):
        """
        The degree of this monomial in the Li filtration grading.

        EXAMPLES::

            sage: V = vertex_algebras.Affine(QQ, 'A1',1, names=('e','h','f'))
            sage: P = V.classical_limit()
            sage: v = P([[4,3,2],[3,1],[1,1,1]]); v
            e_4*e_3*e_2*h_3*h_1*f_1^3
            sage: v._li_filtration_monomial_degree()
            8
        """
        return self.lift()._li_filtration_monomial_degree()

    def lift(self):
        """
        Lift this element to the quantization of this classical limit.

        EXAMPLES::

            sage: V = vertex_algebras.Virasoro(QQ,1)
            sage: P = V.classical_limit()
            sage: v = P.an_element(); v
            1 + 2*L_2 + 3*L_3 + L_2^4
            sage: v.lift()
            |0> + 2*L_-2|0> + 3*L_-3|0> + L_-2L_-2L_-2L_-2|0>
        """
        return self.parent()._ambient._from_dict(self._monomial_coefficients)

    def is_even_odd(self):
        """
        Return ``0`` if this element is *even* and ``1`` if it is
        *odd*.

        EXAMPLES::

            sage: V = vertex_algebras.FreeFermions(QQ,3)
            sage: P = V.classical_limit()
            sage: P.inject_variables()
            Defining psi_0, psi_1, psi_2
            sage: v = psi_0*psi_1.T(3)*psi_2.T() + psi_1.T(5); v
            6*psi_0_1/2*psi_1_7/2*psi_2_3/2 + 120*psi_1_11/2
            sage: v.is_even_odd()
            1
            sage: v = psi_0*psi_1; v.is_even_odd()
            0
        """
        return self.lift().is_even_odd()

    def T(self, n=1):
        r"""
        The ``n``-th derivative of this element.

        INPUT:

        - ``n`` -- a non-negative integer (default: ``1``); the number
          of derivatives to apply.

        EXAMPLES::

            sage: V = vertex_algebras.Virasoro(QQ,1)
            sage: P = V.classical_limit()
            sage: v = P([[3,2,1,1]]); v
            L_4*L_3*L_2^2
            sage: v.T(3)
            24*L_4^2*L_3^2 + 24*L_4^3*L_2 + 18*L_5*L_3^3 + 156*L_5*L_4*L_3*L_2 + 54*L_5^2*L_2^2 + 72*L_6*L_3^2*L_2 + 96*L_6*L_4*L_2^2 + 60*L_7*L_3*L_2^2
        """
        #This implementation now only works for universal enveloping
        if self.is_zero() or n == 0:
            return self
        if n > 1:
            return self.T().T(n-1)
        if self.is_monomial():
            p = self.parent()
            ds = self._li_filtration_monomial_degree()
            a,b,c = self._pbw_one_less()
            if b == p.one():
                if a == p.one():
                    return p.zero()
                pt = a.index().to_list()
                i = next((j for j,x in enumerate(pt) if x))
                c = c*(pt[i][0])
                pt[i][0] += 1
                pt = p._ambient.indices()(pt)
                if p._ambient in ProtoVertexAlgebras(p.base_ring()).Quotients():
                    ret = c*p._ambient.cover_algebra()(pt)
                    ret = p._ambient.retract(ret)
                    ret = sum([m for m in ret.terms() if\
                            m._li_filtration_monomial_degree() == ds+1],
                            p._ambient.zero())
                else:
                    ret = c*p._ambient(pt)
                return p._from_dict(ret._monomial_coefficients)
            return c*(a.T()*b + a*b.T())
        return sum(m.T() for m in self.terms())

    def _mul_(self,other):
        """
        The product of these two elements.

        EXAMPLES::

            sage: V = vertex_algebras.Virasoro(QQ,1)
            sage: P = V.classical_limit()
            sage: P.inject_variables()
            Defining L
            sage: L*L.T()
            L_3*L_2

        TESTS::

            sage: F = vertex_algebras.FreeFermions(QQ)
            sage: P = F.classical_limit()
            sage: P.0*P.0
            0
        """
        p = self.parent()
        if self.is_zero() or other.is_zero():
            return p.zero()
        if self.is_monomial() and other.is_monomial():
            a,b,c = self._pbw_one_less()
            if b == p.one():
                if a == p.one():
                    return c*other
                idx = self.index().to_list()
                odx,c2 = next(iter(other._monomial_coefficients.items()))
                i = next((j for j,x in enumerate(idx) if x))
                n = idx[i][0]
                sgn = p._parity_list[i]
                sgn = sum(p._parity_list[i]*p._parity_list[j]*len(odx[j])\
                          for j in range(i))
                sgn += p._parity_list[i]*len([j for j in odx[i] if j > n])
                sgn = (-1)**(sgn)
                odx = other.index().to_exp(n)
                odx[i][n-1] += 1
                #Ugly test, how to do this more efficiently?
                #recall we are given either a universal enveloping
                #vertex algebra or a quotient of such.
                if p._ambient in ProtoVertexAlgebras(p.base_ring()).Quotients():
                    try:
                        pt = p._ambient.cover_algebra().indices()(tuple([
                                        Partition(exp=m) for m in odx]))
                        ret = sgn*c*c2*p._ambient.cover_algebra()(pt)
                        ret = p._ambient.retract(ret)
                    except ValueError:
                        # pt is not a regular partition, we are squaring
                        # a Fermion
                        ret = p._ambient.zero()
                else:
                    try:
                        pt = p._ambient.indices()(tuple([Partition(exp=m)\
                                                     for m in odx]))
                        ret = sgn*c*c2*p._ambient(pt)
                    except ValueError:
                        # pt is not a regular partition, we are squaring
                        # a Fermion
                        ret = p._ambient.zero()
                ds = self._li_filtration_monomial_degree()
                do = other._li_filtration_monomial_degree()
                ret = sum([m for m in ret.terms() if\
                            m._li_filtration_monomial_degree() == ds+do],
                            p._ambient.zero())
                return p._from_dict(ret._monomial_coefficients)
            return c*a._mul_(b._mul_(other))
        return sum(i._mul_(j) for i in self.terms() for j in other.terms())

    def _bracket_(self,other):
        r"""
        The `\lambda`-bracket of these two elements.

        EXAMPLES::

                sage: V = vertex_algebras.Affine(QQ, 'A1',1, names=('e','h','f'))
                sage: V.inject_variables()
                Defining e, h, f
                sage: e.bracket(f)
                {0: h_-1|0>, 1: |0>}
                sage: P = V.classical_limit()
                sage: P.inject_variables()
                Defining e, h, f
                sage: e.bracket(f)
                {0: h_1}
        """
        p = self.parent()
        if self.is_zero() or other.is_zero():
            return {}
        if self.is_monomial() and other.is_monomial():
            ds = self._li_filtration_monomial_degree()
            do = other._li_filtration_monomial_degree()
            br = self.lift()._bracket_(other.lift())
            ret = {k:sum([p._from_dict(t._monomial_coefficients) for t in
                    v.terms() if t._li_filtration_monomial_degree() ==\
                    ds + do - k],p.zero()) for k,v in br.items()}
            return {k:v for k,v in ret.items() if v}

        diclist = [i._bracket_(j) for i in self.terms() for j in other.terms()]
        ret = {}
        for d in diclist:
            for k in d:
                ret[k] = ret.get(k,p.zero()) + d[k]
        return {k:v for k,v in ret.items() if v}

    def is_monomial(self):
        """
        Whether this element is a monomial.

        EXAMPLES::

            sage: V = vertex_algebras.Affine(QQ, 'A1',1, names=('e','h','f'))
            sage: P = V.classical_limit()
            sage: v = P.an_element(); v
            1 + 2*e_1 + 3*h_1 + e_1^4*h_2*h_1^2*f_3*f_1
            sage: v.is_monomial()
            False
            sage: v = 4*P([[3,2],[1,1,1],[2,1]]); v
            4*e_3*e_2*h_1^3*f_2*f_1
            sage: v.is_monomial()
            True

        TESTS::

            sage: P.zero().is_monomial()
            True
            sage: P.one().is_monomial()
            True
        """
        return len(self._monomial_coefficients) == 1 or self.is_zero()

    def _pbw_one_less(self):
        """
        Expresses this element as a product of two elements lower in
        the PBW filtration.

        OUTPUT:

        A triple ``(a,b,c)`` such that ``self=c*a*b`` with
        ``c`` a scalar and ``a`` a monomial of PBW degree ``1``.

        EXAMPLES::

            sage: V = vertex_algebras.Affine(QQ, 'A1',1, names=('e','h','f'))
            sage: P = V.classical_limit()
            sage: v = 4*P([[3,2],[1,1,1],[2,1]]); v
            4*e_3*e_2*h_1^3*f_2*f_1
            sage: v._pbw_one_less()
            (e_3, e_2*h_1^3*f_2*f_1, 4)
        """
        if self.is_zero():
            return (None, None, None)
        svmc = self.monomial_coefficients()
        if len(svmc) != 1:
            raise ValueError("{} is not a monomial.".format(self))
        k = next(iter(svmc))
        c = svmc[k]
        p = self.parent()
        i = next((j for j,x in enumerate(k) if x), None)
        if i is None:
            return (p.one(), p.one(), c)
        l = [[],]*len(k)
        l[i] = [k[i].get_part(0)]
        sf = k.to_list()
        sf[i] = sf[i][1:]
        return (p(l),p(sf),c)

    def _to_polynomial(self,ord=None, termorder='wdegrevlex'):
        r"""
        Convert this element to a polynomial in the Jet algebra.

        The Jet algebra of order ``ord`` is the quotient of this
        Poisson vertex algebra by the ideal of elements of degree
        greater than ``ord `` in the Li filtration grading. For
        certain Poisson vertex, namely classical limits of universal
        enveloping algebras of integrally graded (non-super) vertex
        algebras, and their quotients by differential ideals, we can
        use a Polynomial implementation of these algebras in order to
        use the machinery of Groebner bases, etc.

        We implement different monomial orderings on these polynomial
        implementations. Suppose this Poisson vertex algebra is
        generated by vectors `g_1,...,g_n` with conformal weights
        `d_1,...,d_n`. The generators of the corresponding polynomial
        ring are `T^k g_i` for `k \geq 0` and `i = 1, \ldots,n`. These
        generators have degree `k+d_i` (with respect to the conformal
        weight grading), degree `k` with respect to the Li filtration
        grading.

        - ``'wdegrevlex'`` -- We order the generators first by degree,
          then in lexicographic order `g_1 > g_2 > \dots` and then
          we use the ``wdegrevlex`` order of the polynomial algebra.

        - ``'wdeglex'`` -- We order the generators in decreasing
          order by degree and then in increasing lexicographic order.
          Finally we use the ``'wdeglex'`` order of the polynomial
          algebra.

        - ``'revlexwdeg'`` -- We order the generators first by
          lexicographic order and then by degree in the Li filtration
          grading. Finally we use the ``'wdegrevlex'`` ordering of the
          polynomial algebra.

        - ``'lexwdeg'`` -- We order the generators first by
          lexicographic order and then decreasing by degree in the Li
          filtration grading. Finally we use the ``'wdeglex'`` order
          in the Polynomial algebra.

        INPUT:

        - ``ord`` -- a positive Integer or ``None``
          (default: ``None``); if ``None``, the degree of this element
          is used.
        - ``termorder`` -- one of ``'wdegrevlex'``, ``'wdeglex'``,
          ``'revlexwdeg'`` or ``'lexwdeg'``
          (default: ``'wdegrevlex'``); the monomial order to use

        EXAMPLES::

            sage: V = vertex_algebras.Affine(QQ, 'A1',1, names=('e','h','f'))
            sage: P = V.classical_limit()
            sage: v = P([[5,4,3],[4,3],[3,2]]); v
            e_5*e_4*e_3*h_4*h_3*f_3*f_2
            sage: v._to_polynomial()
            f_2*e_3*h_3*f_3*e_4*h_4*e_5
            sage: v._to_polynomial(24, 'wdeglex')
            e_5*e_4*h_4*e_3*h_3*f_3*f_2
            sage: v._to_polynomial(24, 'revlexwdeg')
            e_3*e_4*e_5*h_3*h_4*f_2*f_3
            sage: v._to_polynomial(24, 'lexwdeg')
            e_5*e_4*e_3*h_4*h_3*f_3*f_2
        """
        #Not exposed yet until we have a working framework connected
        #with jet/arc schemes
        p = self.parent()
        if ord == None or ord < self.degree():
            ord = ZZ(self.degree())
        try:
            PR = p.jet_algebra(ord,termorder)
        except NotImplementedError:
            raise NotImplementedError("_to_polynomial is not implemented for "\
                                      "elements of {}".format(p))
        ret = PR.zero()
        weights = tuple(ZZ(g.weight()) for g in p.gens())
        for m,c in self.monomial_coefficients().items():
            lexp = [part.to_exp(ord - w +1) for part,w in zip(m,weights)]
            tuplexp = [(i,j,item) for i,part in enumerate(lexp) for j,item in\
                       enumerate(part)]
            if termorder == "wdegrevlex":
                k = tuple(t[2] for t in sorted(tuplexp,
                          key = lambda x : (weights[x[0]]+x[1],x[0])))
            elif termorder == "wdeglex":
                k = tuple(t[2] for t in sorted(tuplexp,
                          key = lambda x: (ord-weights[x[0]]-x[1], x[0])))
            elif termorder == "revlexwdeg":
                k = tuple(t[2] for t in sorted(tuplexp,
                                               key = lambda x: (x[0],x[1])))
            elif termorder == "lexwdeg":
                k = tuple(t[2] for t in sorted(tuplexp,
                          key = lambda x : (x[0], ord - x[1])))
            else:
                raise NotImplementedError("termorder not implemented")
            ret += PR({k:c})
        return ret

    def _im_gens_(self, codomain, im_gens, base_map=None):
        """
        The image of this element by the morphism defined on generators.

        INPUT:

        - ``codomain`` -- a Poisson vertex agebra; the codomain of the
          morphism
        - ``im_gens`` -- a tuple; the images by the morphism of the
          generators

        EXAMPLES::

            sage: V = vertex_algebras.Virasoro(QQ,1)
            sage: B = vertex_algebras.FreeBosons(QQ)
            sage: P = V.classical_limit(); P.inject_variables()
            Defining L
            sage: R = B.classical_limit(); R.inject_variables()
            Defining alpha
            sage: v = L*L.T(); v
            L_3*L_2
            sage: v._im_gens_(R, (alpha**2/2,))
            1/2*alpha_2*alpha_1^3
        """
        if self.is_monomial():
            k,c = next(iter(self._monomial_coefficients.items()))
            from sage.functions.other import factorial
            from sage.misc.misc_c import prod
            return c*prod(g.T(n-1)/factorial(n-1) for i,g in enumerate(im_gens)\
                          for n in k[i])
        return sum(m._im_gens_(codomain, im_gens, base_map) for m in self.terms())

class VertexAlgebraClassicalLimit(CombinatorialFreeModule):
    """
    The classical limit of ``V``.

    INPUT:

    - ``R`` -- a commutative ring; the base of this Poisson vertex
      algebra
    - ``V`` -- a :class:`VertexAlgebra`
    - ``category`` -- a :class:`Category` (default: ``None``); the
      category this Poisson vertex algebra belongs to.

    .. NOTE::

        This class should not be called directly by the user.
        The user should call
        :meth:`~sage.categories.vertex_algebras.VertexAlgebras.ParentMethods.classical_limit`
        instead.

    EXAMPLES::

        sage: from sage.algebras.poisson_vertex_algebras.vertex_algebra_classical_limit import VertexAlgebraClassicalLimit
        sage: V = vertex_algebras.FreeBosons(QQ)
        sage: VertexAlgebraClassicalLimit(QQ,V)
        The classical limit of The Free Bosons vertex algebra with generators (alpha_-1|0>,) over Rational Field
    """
    def __init__(self, R, V, category=None):
        """
        Initialize self.

        TESTS::

            sage: V = vertex_algebras.Virasoro(QQ,1/2)
            sage: P = V.classical_limit()
            sage: TestSuite(P).run()
        """
        assert V in ProtoVertexAlgebras(R).Graded().FinitelyGenerated().WithBasis()
        from sage.algebras.vertex_algebras.universal_enveloping_vertex_algebra\
            import UniversalEnvelopingVertexAlgebra as UEA
        if not isinstance(V, UEA):
            if not V in ProtoVertexAlgebras(R).Quotients():
                raise NotImplementedError("classical limit is not implemented"\
                                          "for {}".format(V))
        if V in VertexAlgebras(R).Super():
            defcat = PoissonVertexAlgebras(R).Super().Graded().FinitelyGenerated().WithBasis()
        else:
            defcat = PoissonVertexAlgebras(R).Graded().FinitelyGenerated().WithBasis()

        category = defcat.or_subcategory(category)

        try:
            names = V.variable_names()
        except ValueError:
            names = ['L_%d'%i for i in range(V.ngens())]

        try:
            self._latex_names = V._latex_names
        except AttributeError:
            self._latex_names = names

        CombinatorialFreeModule.__init__(self, R, basis_keys=V._indices,
                                         element_class=ClassicalLimitElement,
                                         category=category, names=names)
        self._ambient = V
        self._parity_list = tuple(g.is_even_odd() for g in V.gens())

    def _element_constructor_(self,x):
        """
        Construct an element in this classical limit.

        INPUT:

        - ``x`` -- an element on the underlying module of this Poisson
          vertex algebra or an element of the quantization vertex
          algebra.

        EXAMPLES::

            sage: V = vertex_algebras.FreeBosons(QQ);
            sage: P = V.classical_limit()
            sage: v = V.an_element(); v
            |0> + 2*alpha_-1|0> + 3*alpha_-1alpha_-1|0> + alpha_-1alpha_-1alpha_-1alpha_-1|0>
            sage: P(v)
            1 + 2*alpha_1 + 3*alpha_1^2 + alpha_1^4
            sage: P([[3,2]])
            alpha_3*alpha_2
        """
        try:
            return CombinatorialFreeModule._element_constructor_(self,x)
        except (ValueError,TypeError):
            pass

        if x in self._ambient:
            return self._from_dict(x.monomial_coefficients())

        raise ValueError("Do not know how to convert {} into an element of {}"\
                         .format(x,self))

    def __contains__(self,x):
        """
        Whether this Poisson vertex algebra contains this element.

        EXAMPLES::

            sage: V = vertex_algebras.FreeBosons(QQ);
            sage: P = V.classical_limit()
            sage: P.inject_variables()
            Defining alpha
            sage: (alpha.T(3) + alpha) in P
            True
        """
        if self.has_coerce_map_from(x.parent()):
            return True
        return super(VertexAlgebraClassicalLimit, self).__contains__(x)

    def basis(self):
        """
        The basis of this Poisson vertex algebra.

        EXAMPLES::

            sage: V = vertex_algebras.Virasoro(QQ,1/2);
            sage: P = V.classical_limit()
            sage: P.basis()
            Lazy family (Term map from (0,)-Regular Energy Partition Tuples of level 1 with weights (2,) to The classical limit of The Virasoro vertex algebra of central charge 1/2 over Rational Field(i))_{i in (0,)-Regular Energy Partition Tuples of level 1 with weights (2,)}
            sage: Q = V.quotient(V.ideal(V.find_singular(6)))
            sage: R = Q.classical_limit()
            sage: R.basis()
            Lazy family (Term map from Basis of the quotient of The Virasoro vertex algebra of central charge 1/2 over Rational Field by ideal of The Virasoro vertex algebra of central charge 1/2 over Rational Field generated by (L_-2L_-2L_-2|0> + 93/64*L_-3L_-3|0> - 33/8*L_-4L_-2|0> - 27/16*L_-6|0>,) to The classical limit of Quotient of The Virasoro vertex algebra of central charge 1/2 over Rational Field by the ideal generated by (L_-2L_-2L_-2|0> + 93/64*L_-3L_-3|0> - 33/8*L_-4L_-2|0> - 27/16*L_-6|0>,)(i))_{i in Basis of the quotient of The Virasoro vertex algebra of central charge 1/2 over Rational Field by ideal of The Virasoro vertex algebra of central charge 1/2 over Rational Field generated by (L_-2L_-2L_-2|0> + 93/64*L_-3L_-3|0> - 33/8*L_-4L_-2|0> - 27/16*L_-6|0>,)}
            sage: A = Q.arc_algebra()
            sage: A.basis()
            Lazy family (Term map from Basis of the quotient of The classical limit of The Virasoro vertex algebra of central charge 1/2 over Rational Field by ideal of The classical limit of The Virasoro vertex algebra of central charge 1/2 over Rational Field generated by (L_2^3,) to Quotient of The classical limit of The Virasoro vertex algebra of central charge 1/2 over Rational Field by the ideal generated by (L_2^3,)(i))_{i in Basis of the quotient of The classical limit of The Virasoro vertex algebra of central charge 1/2 over Rational Field by ideal of The classical limit of The Virasoro vertex algebra of central charge 1/2 over Rational Field generated by (L_2^3,)}
        """
        return Family(self._indices, self.monomial)

    def _repr_(self):
        """
        The name of this Poisson vertex algebra.

        EXAMPLES::

            sage: V = vertex_algebras.Abelian(QQ)
            sage: V.classical_limit()
            The classical limit of The Abelian vertex algebra over Rational Field with generators (a_-1|0>,)
        """
        return "The classical limit of {}".format(self._ambient)

    def dimension_at_weight(self,n):
        """
        The dimension of the space of conformal weight ``n``.

        INPUT:

        - ``n`` -- a non-negative rational

        EXAMPLES::

            sage: V = vertex_algebras.NeveuSchwarz(QQ, 1)
            sage: P = V.classical_limit()
            sage: P.dimension_at_weight(11/2)
            5

        TESTS::

            sage: P.dimension_at_weight(1/3)
            0
            sage: P.dimension_at_weight(0)
            1
        """
        return self._ambient.dimension_at_weight(n)

    @cached_method
    def one(self):
        """
        The unit of this Poisson vertex algebra.

        EXAMPLES::

            sage: V = vertex_algebras.NeveuSchwarz(QQ, 1)
            sage: P = V.classical_limit()
            sage: P.one()
            1
        """
        return self.monomial(self._ambient.vacuum().index())

    @cached_method
    def gens(self):
        """
        The generators of this Poisson vertex algebra.

        EXAMPLES::

            sage: V = vertex_algebras.NeveuSchwarz(QQ, 1)
            sage: P = V.classical_limit()
            sage: P.gens()
            (L_2, G_3/2)
        """
        return tuple(self._from_dict(g._monomial_coefficients) for g in \
                     self._ambient.gens())

    def ideal(self,*gens, check=True):
        r"""
        The ideal of this Poisson vertex algebra generated by ``gens``.

        INPUT:

        - ``gens`` a tuple of homogeneous elements of this Poisson
          vertex algebra; the generators. We only support ideals such
          that the `R`-submodule `M` generated by ``gens``
          satisfies the following two conditions for every generator
          `g` of `V`:

          1. `g_{(n)} M = 0` for `n>0`,
          2. `g_{(0)} M \subset M`.

        - ``check`` -- a boolean (default: ``True``); whether to check
          that the generators satisfy the condition above.

        EXAMPLES::

            sage: V = vertex_algebras.NeveuSchwarz(QQ, 1)
            sage: P = V.classical_limit()
            sage: P.inject_variables()
            Defining L, G
            sage: I = P.ideal(L**2); I
            ideal of The classical limit of The Neveu-Schwarz super vertex algebra of central charge 1 over Rational Field generated by (L_2^2,)
        """
        from .poisson_vertex_algebra_ideal import PoissonVertexAlgebraIdeal
        return PoissonVertexAlgebraIdeal(self,*gens,check=check)

    def quotient(self, I, names=None):
        """
        The quotient of this Poisson vertex algebra by its ideal ``I``.

        INPUT:

        - ``I`` -- a :class:`PoissonVertexAlgebraIdeal`
        - ``names`` a list of ``str`` or ``None`` (default: ``None``);
          alternative names for the generators

        EXAMPLES::

            sage: V = vertex_algebras.NeveuSchwarz(QQ, 1)
            sage: P = V.classical_limit()
            sage: P.inject_variables()
            Defining L, G
            sage: I = P.ideal(L**2);
            sage: Q = P.quotient(I); Q
            Quotient of The classical limit of The Neveu-Schwarz super vertex algebra of central charge 1 over Rational Field by the ideal generated by (L_2^2,)
        """
        from .poisson_vertex_algebra_quotient import \
                                                   PoissonVertexAlgebraQuotient
        return PoissonVertexAlgebraQuotient(I, names=names,
                                           category=self.category().Quotients())

    def hilbert_series(self,ord=None):
        """
        The graded character of this Poisson vertex algebra.

        INPUT:

        - ``ord`` -- a non-negative rational; the maximum order to
          compute

        EXAMPLES:

        Computing the graded character of classical limits of universal
        enveloping vertex algebras is fast::

            sage: V = vertex_algebras.Virasoro(QQ,1/2)
            sage: P = V.classical_limit()
            sage: P.hilbert_series(10)
            1 + q^2 + q^3 + 2*q^4 + 2*q^5 + 4*q^6 + 4*q^7 + 7*q^8 + 8*q^9 + O(q^10)

        So is for arc algebras of quotients::

            sage: Q = V.quotient(V.ideal(V.find_singular(6)))
            sage: P = Q.arc_algebra()
            sage: P.hilbert_series(10)
            1 + q^2 + q^3 + 2*q^4 + 2*q^5 + 3*q^6 + 3*q^7 + 5*q^8 + 6*q^9 + O(q^10)

        Computations on classical limits of quotient vertex algebras
        are much more demanding::

            sage: P = Q.classical_limit()
            sage: P.hilbert_series(10)          #long time (8 seconds)
            1 + q^2 + q^3 + 2*q^4 + 2*q^5 + 3*q^6 + 3*q^7 + 5*q^8 + 5*q^9 + O(q^10)

        We may get a :mod:`Puiseux Series<sage.rings.puiseux_series_ring>`
        if the algebra is not integrally graded::

            sage: V = vertex_algebras.NeveuSchwarz(QQ, 1)
            sage: P = V.classical_limit()
            sage: P.hilbert_series(11/2)
            1 + q^(3/2) + q^2 + q^(5/2) + q^3 + 2*q^(7/2) + 3*q^4 + 3*q^(9/2) + 3*q^5 + O(q^(11/2))
        """
        try:
            R = self.jet_algebra(ord)
        except NotImplementedError:
            from sage.arith.functions import lcm
            from sage.functions.other import floor
            weights = [g.weight() for g in self.gens()]
            if any([w not in QQ or w < 0 for w in weights]):
                raise NotImplementedError("hilbert_series is not "\
                                  "implemented for {}".format(self))
            if ord not in QQ or ord < 0:
                raise ValueError("ord must be a positive rational "\
                                 "number")
            l = lcm([g.weight().denominator() for g in self.gens()])
            if l==1:
                from sage.rings.power_series_ring import\
                                                    PowerSeriesRing
                q = PowerSeriesRing(ZZ,'q', default_prec=ord).gen()
                return sum(self.dimension_at_weight(n)*q**n for\
                           n in range(floor(ord))).O(floor(ord))
            else:
                from sage.rings.puiseux_series_ring import\
                                                  PuiseuxSeriesRing
                q = PuiseuxSeriesRing(ZZ,'q').gen()
                ord = floor(ord*l)
                f = sum(self.dimension_at_weight(n/l)*q**(n/l) for\
                        n in range(ord))
                return f.add_bigoh(ord/l)

        weights = tuple(g.degree() for g in R.gens())
        from sage.rings.power_series_ring import PowerSeriesRing
        q = PowerSeriesRing(ZZ, 'q', default_prec=ord).gen()
        return R.ideal(0).hilbert_series(grading=weights)(q)

    def _is_valid_homomorphism_(self, codomain, im_gens, base_map=None):
        """
        Wether the images of generators define a homomorphism from
        this Poisson vertex algebra.

        INPUT:

        - ``codomain`` -- a Poisson Vertex algebra
        - ``im_gens`` -- a list of elements of ``codomain``

        EXAMPLES::

            sage: V = vertex_algebras.Virasoro(QQ,1/2)
            sage: P = V.classical_limit()
            sage: W = vertex_algebras.NeveuSchwarz(QQ,1)
            sage: R = W.classical_limit()
            sage: R.inject_variables()
            Defining L, G
            sage: P._is_valid_homomorphism_(R,(L**2,))
            True
            sage: P._is_valid_homomorphism_(P,(L**2,))
            False
            sage: P._is_valid_homomorphism_(R,(G,))
            False
        """
        from sage.algebras.vertex_algebras.universal_enveloping_vertex_algebra\
            import UniversalEnvelopingVertexAlgebra as UEA
        if not isinstance(self._ambient, UEA):
           raise NotImplementedError("morphisms are not implemented for "\
                                     "{}".format(self))
        if not codomain in ProtoPoissonVertexAlgebras(self.base_ring()):
            return False
        if len(im_gens) != self.ngens():
            return False
        if any(x not in codomain for x in im_gens):
            return False
        if any(x.is_even_odd() != y.is_even_odd() for x,y in\
               zip(im_gens,self.gens())):
            return False
        return True

    @lazy_attribute
    def arc_algebra_cover(self):
        """
        The surjection from the arc algebra to this classical limit.

        EXAMPLES::

            sage: V = vertex_algebras.Virasoro(QQ,1/2)
            sage: Q = V.quotient(V.ideal(V.find_singular(6)))
            sage: P = Q.classical_limit()
            sage: P.arc_algebra_cover
            Ring morphism:
              From: Quotient of The classical limit of The Virasoro vertex algebra of central charge 1/2 over Rational Field by the ideal generated by (L_2^3,)
              To:   The classical limit of Quotient of The Virasoro vertex algebra of central charge 1/2 over Rational Field by the ideal generated by (L_-2L_-2L_-2|0> + 93/64*L_-3L_-3|0> - 33/8*L_-4L_-2|0> - 27/16*L_-6|0>,)
              Defn: L_2 |--> L_2
        """
        if self._ambient in ProtoVertexAlgebras(self.base_ring()).Quotients():
            P = self._ambient.arc_algebra()
            return SingularSupportCoverMorphism(P,self)

        from sage.categories.homset import End
        return End(self).identity()

    def jet_algebra(self, ord, termorder='wdegrevlex'):
        r"""
        The quotient of this classical limit by the ideal of elements
        of Li filtration degree bigger than ``ord``.

        The Jet algebra of order ``ord`` is the quotient of this
        Poisson vertex algebra by the ideal of elements of degree
        greater than ``ord`` in the Li filtration grading. For
        certain Poisson vertex, namely classical limits of universal
        enveloping algebras of integrally graded (non-super) vertex
        algebras, and their quotients by differential ideals, we can
        use a Polynomial implementation of these algebras in order to
        use the machinery of Groebner bases, etc.

        We implement different monomial orderings on these polynomial
        implementations. Suppose this Poisson vertex algebra is
        generated by vectors `g_1,...,g_n` with conformal weights
        `d_1,...,d_n`. The generators of the corresponding polynomial
        ring are `T^k g_i` for `k \geq 0` and `i = 1, \ldots,n`. These
        generators have degree `k+d_i` (with respect to the conformal
        weight grading), degree `k` with respect to the Li filtration
        grading.

        - ``'wdegrevlex'`` -- We order the generators first by degree,
          then in lexicographic order `g_1 > g_2 > \dots` and then
          we use the ``wdegrevlex`` order of the polynomial algebra.

        - ``'wdeglex'`` -- We order the generators in decreasing
          order by degree and then in increasing lexicographic order.
          Finally we use the ``'wdeglex'`` order of the polynomial
          algebra.

        - ``'revlexwdeg'`` -- We order the generators first by
          lexicographic order and then by degree in the Li filtration
          grading. Finally we use the ``'wdegrevlex'`` ordering of the
          polynomial algebra.

        - ``'lexwdeg'`` -- We order the generators first by
          lexicographic order and then decreasing by degree in the Li
          filtration grading. Finally we use the ``'wdeglex'`` order
          in the Polynomial algebra.

        INPUT:

        - ``ord`` -- a positive Integer
        - ``termorder`` -- one of ``'wdegrevlex'``, ``'wdeglex'``,
          ``'revlexwdeg'`` or ``'lexwdeg'``
          (default: ``'wdegrevlex'``); the monomial order to use

        EXAMPLES::

            sage: V = vertex_algebras.Affine(QQ, 'A1',1, names=('e','h','f'))
            sage: P = V.classical_limit()
            sage: P.jet_algebra(2)
            Multivariate Polynomial Ring in e_1, h_1, f_1, e_2, h_2, f_2 over Rational Field
            sage: P.jet_algebra(2,'wdeglex')
            Multivariate Polynomial Ring in e_2, h_2, f_2, e_1, h_1, f_1 over Rational Field
            sage: P.jet_algebra(2,'revlexwdeg')
            Multivariate Polynomial Ring in e_1, e_2, h_1, h_2, f_1, f_2 over Rational Field
            sage: A = P.jet_algebra(2,'lexwdeg'); A
            Multivariate Polynomial Ring in e_2, e_1, h_2, h_1, f_2, f_1 over Rational Field
            sage: A.inject_variables()
            Defining e_2, e_1, h_2, h_1, f_2, f_1
            sage: e_2.degree()
            2

        We can convert elements of this Poisson vertex algebra to the
        corresponding Jet algebra::

            sage: v = 3*P([[5,4,2],[3,3],[4,3]]) + 2*P([[5,5],[4,4,4],[2]]); v
            3*e_5*e_4*e_2*h_3^2*f_4*f_3 + 2*e_5^2*h_4^3*f_2
            sage: A = P.jet_algebra(24)
            sage: w = v._to_polynomial(); w
            3*e_2*h_3^2*f_3*e_4*f_4*e_5 + 2*f_2*h_4^3*e_5^2
            sage: w.parent() is A
            True
            sage: w.lt()
            3*e_2*h_3^2*f_3*e_4*f_4*e_5
        """
        if self in PoissonVertexAlgebras(self.base_ring()).Super():
            raise NotImplementedError("jet_algebra is not implemented for "\
                                      "super Poisson vertex algebras.")

        from sage.algebras.vertex_algebras.universal_enveloping_vertex_algebra\
            import UniversalEnvelopingVertexAlgebra as UEA
        if not isinstance(self._ambient, UEA):
           raise NotImplementedError("jet_algebra is not implemented for "\
                                     "{}".format(self))

        if any (g.weight() not in ZZ or g.weight() < 0 for g in self.gens()):
            raise NotImplementedError("generators must have integral weight")

        names = self.variable_names()
        pgens = {g:(i,names[i]) for i,g in enumerate(self.gens())}

        vardict = {(v,j) : "{}_{}".format(pgens[v][1],j)
                   for v in self.gens() for j in range(v.weight(),ord+1)}

        if termorder == "wdegrevlex":
            varlist = tuple((vardict[v],v[1]) for v in sorted(vardict,
                key=lambda x:(x[1],pgens[x[0]][0])))
        elif termorder == "wdeglex":
            varlist = tuple((vardict[v],v[1]) for v in sorted(vardict,
                key=lambda x:(ord-x[1],pgens[x[0]][0])))
        elif termorder == "revlexwdeg":
            varlist = tuple((vardict[v],v[1]) for v in sorted(vardict,
                key=lambda x:(pgens[x[0]][0],x[1])))
            termorder = "wdegrevlex"
        elif termorder == "lexwdeg":
            varlist = tuple((vardict[v],v[1]) for v in sorted(vardict,
                key=lambda x:(pgens[x[0]][0],ord-x[1])))
            termorder = "wdeglex"
        else:
            raise ValueError("termorder needs to be one of 'wdegrevlex', "\
                             "'wdeglex', 'revlexwdeg' or 'lexwdeg'")

        from sage.rings.polynomial.polynomial_ring_constructor import\
                                                                PolynomialRing
        from sage.rings.polynomial.term_order import TermOrder
        varnames = tuple(a[0] for a in varlist)
        vardegs = tuple(a[1] for a in varlist)
        return PolynomialRing(self.base_ring(), len(varnames), varnames,
                              order=TermOrder(termorder,vardegs))

