"""
Poisson Vertex Algebra Ideals

AUTHORS:

- Reimundo Heluani (06-15-2020): Initial implementation.
"""

#******************************************************************************
#       Copyright (C) 2019 Reimundo Heluani <heluani@potuz.net>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# (at your option) any later version.
#                  http://www.gnu.org/licenses/
#*****************************************************************************
from sage.structure.unique_representation import UniqueRepresentation
from sage.categories.commutative_rings import CommutativeRings
from sage.categories.poisson_vertex_algebras import PoissonVertexAlgebras
from sage.categories.infinite_enumerated_sets import InfiniteEnumeratedSets
from sage.combinat.free_module import CombinatorialFreeModule
from sage.structure.parent import Parent
from sage.modules.with_basis.indexed_element import IndexedFreeModuleElement
from sage.misc.lazy_attribute import lazy_attribute
from sage.arith.functions import lcm
from sage.categories.modules import Modules
from sage.rings.all import QQ, ZZ
from sage.categories.fields import Fields
from sage.structure.element_wrapper import ElementWrapper
from sage.rings.integer import Integer
from sage.functions.other import floor

class PoissonVertexAlgebraIdeal(UniqueRepresentation):
    r"""
    Base class for vertex algebra ideals.

    INPUT:

    - ``V`` -- a Poisson vertex algebra; the ambient of this ideal.
        We only support
        H-graded Poisson vertex algebras finitely generated by vectors
        of positive rational conformal weights.

    - ``gens`` a tuple of elements of ``V``; the generators of this
        ideal. We only support ideals generated by singular vectors

    - ``check`` -- a boolean (default: ``True``): whether to check
      that the generators are singular.

    EXAMPLES::

        sage: V = VirasoroVertexAlgebra(QQ,1/2);V.find_singular(6)
        (L_-2L_-2L_-2|0> + 93/64*L_-3L_-3|0> - 33/8*L_-4L_-2|0> - 27/16*L_-6|0>,)
        sage: v = _[0]; I = V.ideal(v)
        sage: I
        ideal of The Virasoro vertex algebra of central charge 1/2 generated by (L_-2L_-2L_-2|0> + 93/64*L_-3L_-3|0> - 33/8*L_-4L_-2|0> - 27/16*L_-6|0>,)
        sage: V = AffineVertexAlgebra(QQ,'A1',3);e = V.gen(0)
        sage: I = V.ideal(e)
        Traceback (most recent call last):
        ...
        ValueError: Generators must be singular vectors of The universal affine vertex algebra of CartanType ['A', 1] at level 3
    """
    @staticmethod
    def __classcall_private__(cls, ambient=None, gens=None, **kwds):
        known_keywords = ['check']
        for key in kwds:
            if key not in known_keywords:
                raise TypeError("PoissonVertexAlgebraIdeal(): got an "
                                "unexpected keyword argument '%s'"%key)
        try:
            R = ambient.base_ring()
        except AttributeError:
            R = None

        if R not in CommutativeRings() or\
            ambient not in PoissonVertexAlgebras(R):
            raise ValueError("ambient must be a Poisson vertex algebra, got {}"\
                            .format(ambient))

        if not isinstance(gens, (list, tuple)):
            gens = [gens]
        gens = [ambient(x) for x in gens if x]
        gens = tuple(gens)
        if len(gens)==0: gens=(ambient.zero(),)

        if ambient in PoissonVertexAlgebras(ambient.base_ring()).\
                                Graded().FinitelyGenerated():
            return GradedPoissonVertexAlgebraIdeal(ambient,gens,
                    kwds.get('check',True))

        raise NotImplementedError('Ideals are not implemented for {}'.format(
                                  ambient))

    def __init__(self, ambient, category=None):
        #stick to modules until we have a proper category of modules.
        #or even better of ideals.
        category=Modules(ambient.base_ring()).or_subcategory(category)
        super(PoissonVertexAlgebraIdeal,self).__init__(ambient.base_ring(),
                                                       category=category)
        self._ambient = ambient

class GradedPoissonVertexAlgebraIdeal(PoissonVertexAlgebraIdeal,
                                      CombinatorialFreeModule):
    def __init__(self, V, gens, check):
        r"""
        An ideal of the Poisson vertex algebra `V` generated by the list
        of vectors ``gens``.

        INPUT:

        - ``V`` -- a Poisson vertex algebra; the ambient of this ideal.
            We only support
            H-graded vertex algebras finitely generated by vectors of
            positive rational conformal weights.

        - ``gens`` a tuple of elements of ``V``; the generators of this
            ideal. We only support ideals such that rhe `R`-submodule
            `M \subset V` generated by ``gens``
            satisfies the following two conditions for every generator
            `g` of `V`:

            1. `g_{(n)} M = 0` for `n>0`,
            2. `g_{(0)} M \subset M`.

        - ``check`` -- a boolean (default: ``True``): whether to check
          that the generators satisfy the condition above.

        EXAMPLES::

            sage: V = VirasoroVertexAlgebra(QQ,1/2);V.find_singular(6)
            (L_-2L_-2L_-2|0> + 93/64*L_-3L_-3|0> - 33/8*L_-4L_-2|0> - 27/16*L_-6|0>,)
            sage: v = _[0]; I = V.ideal(v)
            sage: I
            ideal of The Virasoro vertex algebra of central charge 1/2 generated by (L_-2L_-2L_-2|0> + 93/64*L_-3L_-3|0> - 33/8*L_-4L_-2|0> - 27/16*L_-6|0>,)
            sage: V = AffineVertexAlgebra(QQ,'A1',3);e = V.gen(0)
            sage: I = V.ideal(e)
            Traceback (most recent call last):
            ...
            ValueError: Generators must be singular vectors of The universal affine vertex algebra of CartanType ['A', 1] at level 3
        """
        if V not in PoissonVertexAlgebras(V.base_ring()).Graded()\
            .FinitelyGenerated():
            raise ValueError ("V needs to be a finitely generated H-graded "\
                    "Poisson vertex algebra, got {}".format(V))

        if check:
                M = V.submodule(gens)
                for g in V.gens():
                    for b in gens:
                        br = g._bracket_(b)
                        try:
                            M.reduce(br.pop(0,V.zero()))
                        except ValueError:
                            raise ValueError("Generators must be stable "\
                                "under the zeroth product")
                        if br:
                            raise ValueError("Generators must be singular"\
                                             "vectors of {}".format(V))

        category = Modules(V.base_ring())
        if V in PoissonVertexAlgebras(V.base_ring()).Super():
            category = category.Super()
        category = category.WithBasis().Graded()
        PoissonVertexAlgebraIdeal.__init__(self, V, category)
        self._gens = gens
        basis = PoissonVertexAlgebraIdealBasis(V, gens)
        CombinatorialFreeModule.__init__(self, V.base_ring(),
                                basis_keys=basis, category=category,
                                element_class=PoissonVertexAlgebraIdealElement)

        self._unitriangular = bool(V.base_ring() in Fields())
        self.lift.register_as_coercion()
        self.coerce_embedding = self.lift

    def lift_on_basis(self,item):
        return item.value[1].lift()

    def _repr_(self):
        return "ideal of {} generated by {}".format(self._ambient, self._gens)

    def _repr_short(self):
        return "the ideal generated by {}".format(self._gens)

    def _inverse_on_support(self,i):
        M = self.get_weight(i.energy())
        v = M.lift._inverse_on_support(i)
        if v is None:
            return v
        return self._indices((i.energy(),v))

    @lazy_attribute
    def lift(self):
        key = self._ambient.basis().keys().rank
        return self.module_morphism(self.lift_on_basis,
                                    codomain=self._ambient,
                                    triangular="lower",
                                    unitriangular=self._unitriangular,
                                    key=key,
                                    inverse_on_support=self._inverse_on_support)

    def get_weight(self,n):
        r"""
        Returns the homogeneous component of weight ``n`` in the ideal.

        INPUT: a positive rational number ``n``.

        OUTPUT: a subspace of the ambient Poisson vertex algebra of
        this ideal.

        EXAMPLES::
        """
        return self._indices.get_weight(n)

    def get_weight_less_than(self,n):
        """
        Returns the subspace of vectors of conformal weight less than
        ``n`` in this ideal.

        OUTPUT: a subspace of the ambient Poisson vertex algebra of
        this ideal.
        """
        if n not in QQ or n < 0:
            raise ValueError("n must be a positive rational number")

        basis = []
        for i in self._indices:
            if i.value[0] < n:
                basis.append(i.value[1].lift())
            else:
                break
        return self._ambient.submodule(basis)

    def ambient(self):
        r"""Return the ambient vertex algebra of this ideal

        EXAMPLES::
        """
        return self._ambient

    def reduce(self,x):
        """
        The reduction of the element `x` modulo this ideal.

        INPUT:

        - ``x`` -- an element of the ambient Poisson vertex algebra.

        EXAMPLES::
        """
        if x.is_zero():
            return x
        if x.is_homogeneous():
            w = x.weight()
            I = self.get_weight(w)
            A = self._ambient.get_weight(w)
            M = A.submodule([A.retract(v.lift()) for v in I.basis()])
            return M.reduce(A.retract(x)).lift()
        return sum(self.reduce(m) for m in x.homogeneous_terms())

    def __contains__(self,x):
        if super(GradedPoissonVertexAlgebraIdeal,self).__contains__(x):
            return True
        if x in self._ambient:
            return not self.reduce(x)
        return False

    def an_element(self):
        B = self.basis()
        return B[self._indices[0]] + 3*B[self._indices[2]] + 5*B[self._indices[3]]

    def gens(self):
        return self._gens

    def is_zero(self):
        return all(g.is_zero() for g in self.gens())

    def _ideal_gens(self, ord):
        return tuple(g.T(j) for g in self.gens()\
                     for j in range(ord+1-g.weight()))

    def _groebner_basis(self, ord):
        try:
            P = self._ambient.jet_algebra(ord)
        except NotImplementedError:
            raise NotImplemented("_groebner_basis is not implemented for "\
                                 "ideals of {}".format(self._ambient))

        I = P.ideal([P(m._to_polynomial(ord)) for m in self._ideal_gens(ord)])
        return I.groebner_basis(deg_bound=ord)

    def hilbert_series(self,ord):
        if self.is_zero():
            return self._ambient.hilbert_series(ord)
        try:
            P = self._ambient.jet_algebra(ord)
        except NotImplementedError:
            return self._ambient.quotient(self).hilbert_series(ord)
        GB = self._groebner_basis(ord)
        GBLM = [a.lm() for a in GB if a.degree() <= ord]
        J = P.ideal(GBLM)
        mydegreelist = [d.degree() for d in P.gens()] 
        from sage.rings.power_series_ring import PowerSeriesRing
        q = PowerSeriesRing(ZZ,'q',default_prec=ord).gen()
        return J.hilbert_series(grading=mydegreelist)(q)

class PoissonVertexAlgebraIdealElement(IndexedFreeModuleElement):

    def _repr_(self):
        return repr(self.lift())

    def lift(self):
        return self.parent().lift(self)


class PoissonVertexAlgebraIdealBasis(Parent):
    def __init__(self,V,gens):
        self._ambient = V
        self._gens = gens
        Parent.__init__(self, category=InfiniteEnumeratedSets())

    def _repr_(self):
        return "Basis of the Poisson vertex algebra ideal of {} generated by "\
               "{}".format(self._ambient,self._gens)

    def _element_constructor_(self,x):
        if not isinstance(x,(tuple,list)) or len(x) != 2:
            raise ValueError("Do not know how to convert {} into {}".format(x,
                             self))
        if x[0] not in QQ or x[0] < 0:
            raise ValueError("Do not know how to convert {} into {}".format(x,
                             self))
        B = self.get_weight(x[0]).basis()
        if x[1] in B.keys():
            return self.element_class(self,(x[0],B[x[1]]))
        if x[1] in B:
            return self.element_class(self,tuple(x))

        raise ValueError("Do not know how to convert {} into {}".format(x,self))

    class Element(ElementWrapper):
        pass

    def __iter__(self):
        vgens = self._ambient.gens()
        weights = [g.degree() for g in vgens]
        step = lcm([w.denominator() for w in weights])
        n = 0
        while True:
            M = self.get_weight(n/step)
            for y in M.basis():
                yield self.element_class(self,(n/step,y))
            n += 1

    def get_weight(self,n):
        p = self._ambient
        basis = [p(pt)*g.T(m) for g in self._gens for m in range(floor(n)-
                 g.weight()+1) for pt in p.indices().subset(
                 energy=n-g.weight()-m)]
        return self._ambient.submodule(basis)

    def __getitem__(self,r):
        if isinstance(r,self.element_class):
            return r
        if isinstance(r,(int,Integer)):
            return self.unrank(r)
        elif isinstance(r,slice):
            start=0 if r.start is None else r.start
            stop=r.stop
            if stop is None:
                raise ValueError('infinite set')
            count=0
            parts=[]
            for t in self:
                if count==stop:
                    break
                if count>=start:
                    parts.append(t)
                count+=1
            if count==stop or stop is None:
                return parts
            raise IndexError('value out of range')
        raise NotImplementedError('Do not know how to look for {}'.format(r))

