r"""
Poisson Vertex Algebra

Let `R` be a commutative ring. A *super Poisson vertex algebra* over `R`
is a tuple `(P, T, \mathbb{1}, \{\cdot_\lambda \cdot\}, \cdot)` such that:

- `(P,\mathbb{1}, \cdot)` is a unital super commutative and associative
  algebra over `R`.
- `(P, T, \{ \cdot_\lambda \cdot \})` is a super
  :mod:`Lie conformal algebra<sage.categories.lie_conformal_algebras>`
  over `R`.
- `T` is an even derivation of the commutative product `\cdot`.
- The following *Leibniz* identity holds in `P[\lambda]`:

    .. MATH::

        \{a_\lambda b\cdot c\} = \{a_\lambda b\}\cdot c  + (-1)^{p(a)p(b)}
        b \cdot \{a_\lambda c\}, \qquad a,b,c \in P

where `p(a)` is `0` if `a` is *even* and `1` if it is *odd*

Given a :mod:`super vertex algebra<sage.categories.vertex_algebras>` `V` the
associated graded `P = \mathrm{gr}^F V` with respect to the
:mod:`Li
filtration<sage.algebras.poisson_vertex_algebras.vertex_algebra_classical_limit>`
is canonically a super Poisson vertex algebra. The operations are defined by:

.. MATH::

    \sigma_p(a) \cdot \sigma_q(b) = \sigma_{p+q} (a_{(-1)} b), \qquad
    \{\sigma_p(a)_\lambda \sigma_q(b)\} = \sum_{j \geq 0}
    \frac{\lambda^j}{j!} \sigma_{p+q-j} \bigl( a_{(j)} b \bigr), \qquad
    T \sigma_p a = \sigma_{p+1} Ta

where `\sigma_p` is the principal symbol map. This algebra is graded: the
multiplication and `\lambda` bracket are of degree `0`. This graded super
Poisson vertex algebra is known as the
:meth:`classical
limit<sage.categories.vertex_algebras.VertexAlgebras.ParentMethods.classical_limit>`
or the *singular support* of `V`. It's degree `0` part

.. MATH::

   R_V = \mathrm{gr}^F_0 V = V/C_2(V) = V/V_{(-2)}V,

is a super Poisson algebra known as *Zhu's* `C_2` *quotient of* `V`. Its
spectrum is known as the *associated scheme* of `V`.

When `V` is also `H`-graded its classical limit is
bigraded. We call this extra grading the *conformal weight* grading. With
respect to the conformal weight grading, the multiplication is of degree `0`
while the `\lambda` bracket is of degree `-1`.

There is another super Poisson vertex algebra canonically associated to any
super vertex algebra. This is the
:meth:`arc algebra<sage.categories.vertex_algebras.VertexAlgebras.ParentMethods.arc_algebra>`
of `V`. It is the super commutative differential algebra `JR_V` freely generated
by `R_V`, in other words: the algebra of functions on the arc space of the
associated scheme of `V`. It has a canonical super Poisson vertex algebra
structure and by the universal property there exists a canonical surjection

.. MATH::

   JR_V \twoheadrightarrow \mathrm{gr}^F V

of super Poisson vertex algebras.

EXAMPLES:

- The classical limit of the universal Virasoro vertex algebra is the
  polynomial algebra in infinitely many generators. `R[L_{-2},L_{-3},\ldots]`
  The generator `L_{-n}` is in Li filtration degree `n-2` and conformal
  weight degree `n`. As an `R[T]` module it is freely generated by `L_{-2}`.
  The `\lambda` bracket vanishes on `P`.

- The classical limit of the universal affine vertex algebra
  `V^k(\mathfrak{g})` associated to a finite dimensional Lie algebra
  `\mathfrak{g}` is also a commutative algebra with infinitely many
  generators: `P = Sym^* t^{-1}\mathfrak{g}[t^{-1}]`. The generators
  `t^{-n-1}a` for `n \geq 0` and `a \in \mathfrak{g}` are in bidegree
  `(n,n)`.  As an `R[T]`-module it
  is finitely generated by `t^{-1} \mathfrak{g}`, the action of `T` is given
  by `\frac{d}{d t}`. The `\lambda` bracket among generators is given by

  .. MATH::

        \left\{t^{-1}a_\lambda t^{-1}b \right\} = t^{-1}[a,b]

EXAMPLES:

The classical limit of the Virasoro vertex algebra is a polynomial
differential algebra with vanishing `\lambda`-bracket::

    sage: V = vertex_algebras.Virasoro(QQ,1/2)
    sage: P = V.classical_limit()
    sage: P.inject_variables()
    Defining L
    sage: L.bracket(L)
    {}
    sage: L**3
    L_2^3
    sage: v = L.T(3)*L**2/18 + L.T(2)*L.T()*L; v
    2*L_4*L_3*L_2 + 1/3*L_5*L_2^2

It equals the *arc algebra* of ``V``::

    sage: P is V.arc_algebra()
    True

The classical limit of other vertex algebras may have quite a
complicated structure. This happens even in very simple cases. Consider
for example the classical limit of the Virasoro *ising* model::

    sage: Q = V.quotient(V.ideal(V.find_singular(6))); Q
    Quotient of The Virasoro vertex algebra of central charge 1/2 over Rational Field by the ideal generated by (L_-2L_-2L_-2|0> + 93/64*L_-3L_-3|0> - 33/8*L_-4L_-2|0> - 27/16*L_-6|0>,)
    sage: R = Q.classical_limit()
    sage: R.inject_variables()
    Defining L
    sage: L**3
    0

The same expression as ``v`` above vanishes on ``R``::

    sage: L.T(3)*L**2/18 + L.T(2)*L.T()*L     # long time (1 second)
    0

This can be seen from the Li filtration of the vertex algebra::

    sage: v.lift()
    2*L_-4L_-3L_-2|0> + 1/3*L_-5L_-2L_-2|0>
    sage: v.lift().li_filtration_degree()
    3
    sage: w = Q(v.lift()); w
    -15/16*L_-5L_-4|0> + 9/8*L_-6L_-3|0> + 29/4*L_-7L_-2|0> + 49/32*L_-9|0>
    sage: w.li_filtration_degree()
    5

Another way of checking this is by constructing the *arc algebra* of
``Q``. This is a Poisson vertex algebra that surjects to ``R``::

    sage: A = Q.arc_algebra(); A
    Quotient of The classical limit of The Virasoro vertex algebra of central charge 1/2 over Rational Field by the ideal generated by (L_2^3,)
    sage: A.cover_algebra() is P
    True

    sage: A = Q.arc_algebra(); A
    Quotient of The classical limit of The Virasoro vertex algebra of central charge 1/2 over Rational Field by the ideal generated by (L_2^3,)
    sage: A.cover_algebra() is P
    True
    sage: f = R.arc_algebra_cover; f
    Ring morphism:
      From: Quotient of The classical limit of The Virasoro vertex algebra of central charge 1/2 over Rational Field by the ideal generated by (L_2^3,)
      To:   The classical limit of Quotient of The Virasoro vertex algebra of central charge 1/2 over Rational Field by the ideal generated by (L_-2L_-2L_-2|0> + 93/64*L_-3L_-3|0> - 33/8*L_-4L_-2|0> - 27/16*L_-6|0>,)
      Defn: L_2 |--> L_2

We can see that it is a proper surjection and compute the above vector
in the kernel::

    sage: R.hilbert_series(10)              # long time (8 seconds)
    1 + q^2 + q^3 + 2*q^4 + 2*q^5 + 3*q^6 + 3*q^7 + 5*q^8 + 5*q^9 + O(q^10)
    sage: A.hilbert_series(10)
    1 + q^2 + q^3 + 2*q^4 + 2*q^5 + 3*q^6 + 3*q^7 + 5*q^8 + 6*q^9 + O(q^10)
    sage: K = f.kernel(9); K                # long time (10 seconds)
    Free module generated by {0} over Rational Field
    sage: K.an_element().lift()             # long time
    2*L_4*L_3*L_2 + 1/3*L_5*L_2^2

Computations in the arc algebra are much more efficient than in the
classical limit because we can convert it to a quotient of a polynomial
ring::

    sage: J = A.jet_algebra(10)
    sage: J
    Quotient of Multivariate Polynomial Ring in L_2, L_3, L_4, L_5, L_6, L_7, L_8, L_9, L_10 over Rational Field by the ideal (L_3^2*L_4 + L_2*L_4^2 + 2*L_2*L_3*L_5 + L_2^2*L_6, L_3^3 + 6*L_2*L_3*L_4 + 3*L_2^2*L_5, L_2*L_3^2 + L_2^2*L_4, L_2^2*L_3, L_2^3)
    sage: J.inject_variables()
    Defining L_2bar, L_3bar, L_4bar, L_5bar, L_6bar, L_7bar, L_8bar, L_9bar, L_10bar
    sage: J.cover_ring() is P.jet_algebra(10)
    True
    sage: L_4bar.lift().degree()
    4

It's defining ideal has access to methods such as ``groeber_basis`` or
``hilbert_series``::

    sage: I = A.defining_ideal(); I
    ideal of The classical limit of The Virasoro vertex algebra of central charge 1/2 over Rational Field generated by (L_2^3,)
    sage: I._groebner_basis(10)
    [L_3^2*L_4 + L_2*L_4^2 + 2*L_2*L_3*L_5 + L_2^2*L_6, L_3^3 + 6*L_2*L_3*L_4 + 3*L_2^2*L_5, L_2*L_3^2 + L_2^2*L_4, L_2^2*L_3, L_2^3]
    sage: I.hilbert_series(10)
    1 + q^2 + q^3 + 2*q^4 + 2*q^5 + 3*q^6 + 3*q^7 + 5*q^8 + 6*q^9 + O(q^10)

Arc algebras work for super-algebras as well, but their jet algebras
are not implemented::

    sage: V = vertex_algebras.NeveuSchwarz(QQ,7/10)
    sage: Q = V.quotient(V.ideal(V.find_singular(4)))
    sage: A = Q.arc_algebra(); A
    Quotient of The classical limit of The Neveu-Schwarz super vertex algebra of central charge 7/10 over Rational Field by the ideal generated by (L_2^2,)
    sage: A.an_element()
    1 + 2*G_3/2 + 3*L_2 + L_2*G_3/2
    sage: A.jet_algebra(10)
    Traceback (most recent call last):
    ...
    NotImplementedError: jet_algebra is not implemented for Quotient of The classical limit of The Neveu-Schwarz super vertex algebra of central charge 7/10 over Rational Field by the ideal generated by (L_2^2,)

AUTHORS:

- Reimundo Heluani (2019-08-09): Initial implementation.

"""


#******************************************************************************
#       Copyright (C) 2019 Reimundo Heluani <heluani@potuz.net>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# (at your option) any later version.
#                  http://www.gnu.org/licenses/
#*****************************************************************************


from sage.structure.unique_representation import UniqueRepresentation
from sage.categories.proto_vertex_algebras import ProtoVertexAlgebras
from sage.categories.poisson_vertex_algebras import PoissonVertexAlgebras
from sage.categories.commutative_rings import CommutativeRings
from sage.structure.parent import Parent

class PoissonVertexAlgebra(UniqueRepresentation, Parent):
    """
    Poisson vertex algebra factory.

    INPUT:

    - ``R`` -- a commutative ring; the base ring of this Poisson vertex
      algebra
    - ``arg0`` -- a :class:`VertexAlgebra`
    - ``category`` -- a :class:`Category`; the category this Poisson
      vertex algebra belongs to

    OUTPUT:

    The *classical limit* or *singular support* of ``arg0``.

    .. NOTE::

        This class is not meant to be called directly by the user.
        Rather, the users should invoke
        :meth:`~sage.categories.vertex_algebras.ParentMethods.classical_limit`
        of ``arg0``.

    .. TODO::

        Implement ``termorder`` as a keyword to change the monomial
        ordering of the Poisson vertex algebra upon construction.

    """
    @staticmethod
    def __classcall_private__(cls, R=None, arg0=None, category=None, **kwds):
        """
        Construct a Poisson Vertex Algebra.

        EXAMPLES::

            sage: V = vertex_algebras.Virasoro(QQ)
            sage: P = V.classical_limit()
            sage: R = PoissonVertexAlgebra(QQ, V)
            sage: P is R
            True
        """
        if not R in CommutativeRings():
            raise ValueError("R must be a commutative ring, got {}".format(R))

        #This is the only exposed class so we clean keywords here
        known_keywords = ['term_order']

        for key in kwds:
            if key not in known_keywords:
                raise ValueError("PoissonVertexAlgebra(): got an unexpected " +
                                "keyword argument '%s'"%key)

        if kwds:
            raise NotImplementedError("{} is not implemented yet".format(
                                      kwds.keys()))

        category = PoissonVertexAlgebras(R).or_subcategory(category)

        #Until ModulesWithBasis(R) has a working `change_ring` method
        #We need to check the base ring of arg0 is the same as R
        if arg0 in ProtoVertexAlgebras(R).Graded().FinitelyGenerated().WithBasis():
            from .vertex_algebra_classical_limit import \
                                                    VertexAlgebraClassicalLimit
            category = category.Graded().FinitelyGenerated().WithBasis()
            if arg0 in ProtoVertexAlgebras(R).Super():
                category = category.Super()
            return VertexAlgebraClassicalLimit(R, arg0, category=category)

        raise ValueError ("arg0 needs to be a finitely generated H-graded"\
                        "vertex algebra with basis over R, got {}".format(arg0))
