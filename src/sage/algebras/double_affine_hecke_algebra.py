#*****************************************************************************
#       Copyright (C) 2014 Mark Shimozono <mshimo at vt.edu>
#
#  Distributed under the terms of the GNU General Public License (GPL)
#                  http://www.gnu.org/licenses/
#*****************************************************************************
#
# Double affine Hecke algebras
#
################################

import functools

from sage.structure.parent import Parent
from sage.structure.unique_representation import UniqueRepresentation
from sage.misc.abstract_method import abstract_method
from sage.misc.bindable_class import BindableClass
from sage.misc.cachefunc import cached_method
from sage.misc.functional import is_even
from sage.categories.algebras_with_basis import AlgebrasWithBasis
from sage.categories.category import Category
from sage.categories.homset import Hom
from sage.categories.modules_with_basis import ModulesWithBasis
from sage.categories.morphism import SetMorphism
from sage.categories.realizations import Category_realization_of_parent, Realizations
from sage.categories.tensor import tensor
from sage.sets.family import Family, FiniteFamily
from sage.sets.set import Set
from sage.rings.rational_field import QQ
from sage.rings.integer_ring import ZZ
from sage.algebras.multiparameter_hecke_algebra import MultiParameterHeckeAlgebra, ParameterFamilies
from sage.algebras.smash_product_algebra import SmashProductAlgebra
from sage.algebras.affine_hecke_algebra import AffineHeckeAlgebra, DoubledNodes
from sage.modules.free_module_element import vector
from sage.structure.sage_object import SageObject

class DoubleAffineType(SageObject):
    r"""
    Class which specifies a double affine Hecke algebra
    of not-necessarily-reduced possibly-extended affine type.

    INPUT:

        - ``cartan_type`` -- An irreducible finite Cartan type
        - ``untwisted`` -- True or False (default: True); whether to use the untwisted or twisted affinization
        - ``reduced`` -- True or False (default: True); whether the affine root system is reduced
        - ``dual_reduced`` -- True or False (default: True); whether the "dual" affine root system is reduced
        - ``prefix`` -- (default: None)
        - ``parameters`` -- keyword arguments for parameters

    EXAMPLES::

        sage: DoubleAffineType("A1")
        Double Affine Type ['A', 1, 1] reduced dual-reduced
        sage: DoubleAffineType(['C',3], untwisted=True, reduced=False, dual_reduced=True)
        Double Affine Type ['C', 3, 1] reduced dual-reduced
        sage: DoubleAffineType(['F',4], untwisted=False, reduced=True, dual_reduced=False)
        Double Affine Type ['F', 4, 1]^* relabelled by {0: 0, 1: 4, 2: 3, 3: 2, 4: 1} reduced dual-reduced
        sage: K = QQ['q,v,vl,v0,v2,vz'].fraction_field()
        sage: q,v,vl,v0,v2,vz = K.gens()
        sage: DoubleAffineType(['B',2], untwisted=False, reduced=False, dual_reduced=False, null_root=q,short=v,long=vl,zero=v0,doubled=v2,zero_doubled=vz)
        Double Affine Type ['C', 2, 1]^* nonreduced nondual-reduced

    ..RUBRIC:: Untwisted, dual untwisted, and mixed.

    There is a trichotomy of irreducible affine Cartan types: untwisted, dual untwisted (meaning the dual of an
    untwisted affine type) and mixed. The mixed types, `A_{2n}^{(2)}` and its dual, are the ones with three root lengths.

    ..RUBRIC:: Pair of affine Cartan types `\tilde{X}` and `\tilde{Y}`

    The inputs ``cartan_type`` and ``untwisted`` determine a pair of affine Cartan types `\tilde{X}` and `\tilde{Y}`
    which are both untwisted or both dual untwisted. Define

        - `X` -- The irreducible reduced finite Cartan type given by ``cartan_type``

        - `\tilde{X} -- if ``untwisted``, the untwisted affinization of `X`; otherwise, obtained from `X` by taking the dual, then the untwisted affinization, then the affine dual.

        - `W_a(\tilde{X})` -- The nonextended affine Weyl group of type `\tilde{X}`. It is generated by the simple reflections `s_i` for `i` in the affine Dynkin node set `I^X`.

        - `R_{red}(\tilde{X})` -- The set of affine real roots for the reduced affine root system. It is the set of affine root lattice elements of the form `u \alpha_i` where `u \in W_a(\tilde{X})` and `\alpha_i` is a simple root for `i \in I^X`.

        - `Y` -- Equal to `X` if not ``untwisted``; otherwise the dual of `X`

        - `\tilde{Y}` -- Equal to `\tilde{X}` if not ``untwisted``; otherwise the untwisted affinization of `Y`
        
    `W_a(\tilde{Y})` and `R_{red}(\tilde{Y})` are analogously defined.

    Since `X` and `Y` are either equal or dual, there is a natural bijection between their classical
    Dynkin node sets `I^X_0 = I^X \setminus \{0^X\}` and `I^Y_0`. This induces an isomorphism `W(X)\cong W(Y)` of
    the finite Weyl groups.

    ..RUBRIC:: Extended affine Weyl groups

    See :meth:`sage.combinat.root_system.ExtendedAffineWeylGroup` for definitions for extended affine Weyl groups.
    Define

        - `W_e(\tilde{X})` -- The extended affine Weyl group of type `\tilde{X}`.

        - `F^X` -- The fundamental group of `W_e(\tilde{X})` of length zero elements.

    Using the notation `W` for either of the isomorphic groups `W(X)` or `W(Y)` and letting
    `Q^Y` and `P^Y` be the root and weight lattices of type `Y`, there are isomorphisms

    ..MATH::

        W_a(\tilde{X}) \cong W \ltimes Q^Y \\
        W_e(\tilde{X}) \cong W \ltimes P^Y \cong F^X \ltimes W_a(\tilde{X})

    Note: The usual convention in the untwisted case is to use the coroot and coweight lattices of type `X`.

    The group `F^X` acts on `W_a(\tilde{X})` by the group automorphisms

    ..MATH::

        \pi^X s^X_i (\pi^X)^{-1} = s^X_{\pi^X(i)}

    for all `\pi^X \in F^X` and `i \in I^X` where the affine Dynkin automorphism `\pi^X` is regarded as a
    permutation of `I^X`. Similarly we have

    ..MATH::

        W_a(\tilde{Y}) \cong W \ltimes Q^X \\
        W_e(\tilde{Y}) \cong W \ltimes P^X \cong F^Y \ltimes W_a(\tilde{Y})

    ..RUBRIC:: Affine Hecke algebra `H(W_a(\tilde{X}))`

    Let `K` be a commutative ring. For `i \in I^X` let `v_{\alpha_i^X} \in K` be an invertible element.
    They must satisfy `v_{\alpha_i^X} = v_{\alpha_j^X}` if `\alpha_i^X` and `\alpha_j^X` are in the
    same `W_a(\tilde{X})`-orbit. The mnemonic for these parameters is `v^X`.

    The Hecke algebra `H(W_a(\tilde{X});v^X)` is the `K`-algebra with algebra generators
    `T^X_i` for `i \in I^X` with the `T^X_i` satisfying the same braid relations as the
    `s^X_i` do in `W_a(\tilde{X})`, together with the quadratic relations

    ..MATH::

        (T^X_i - v_{\alpha_i^X})(T^X_i + v_{\alpha_i^X}^{-1}) = 0

    for all `i \in I^X`.

    For `w \in W_a(\tilde{X})` let `w=s^X_{i_1}\dotsm s^X_{i_l}` be a reduced expression
    (one with `l` minimal) where `i_1,\dotsc,i_l \in I^X`. There is a well-defined element

    ..MATH::

        T^X_w = T^X_{i_1} \dotsm T^X_{i_l}.

    These form a `K`-basis of `H(W_a(\tilde{X}))`.

    ..RUBRIC:: Extended affine Hecke algebra of `W_e(\tilde{X})`

    Let `K` and `v_{\alpha_i^X}` be as for `H(W_a(\tilde{X}))` except that we impose the additional
    condition that `v_{\alpha_i^X} = v_{\alpha_j^X}` if `\alpha_i^X` and `\alpha_j^X` are in the
    same `W_e(\tilde{X})`-orbit (as opposed to the same `W_a(\tilde{X})`-orbit).
    Recalling that `W_e(\tilde{X}) \cong F^X \ltimes W_a(\tilde{X})`,
    the extended affine Hecke algebra `H(W_e(\tilde{X}),v^X)` is linearly the tensor product

    ..MATH::

        K[F^X] \otimes H(W_a(\tilde{X}),v^X)

    where `K[F^X]` is the group algebra, and `K[F^X]` acts on `H(W_a(\tilde{X}),v^X)` by

    ..MATH::

        \pi^X T^X_i (\pi^X)^{-1} = T^X_{\pi^X(i)}.

    for all `\pi^X \in F^X` and `i \in I^X`.

    Let `v \in W_e(\tilde{X})` be written `v = \pi^X w` with `\pi^X \in F^X` and `w \in W_a(\tilde{X})`.
    `H(W_e(\tilde{X}))` has a basis given by the elements

    ..MATH::

        T^X_v = \pi^X T^X_w.

    ..RUBRIC:: Not-necessarily-reduced affine root systems

    The pair of boolean inputs ``reduced`` and ``dual_reduced`` affects the choice of root versus weight lattices,
    nonextended and extended affine Weyl groups, and nonreduced versus reduced root systems.

    A node `i \in I^X` is *doubleable* if the evaluation `\alpha_i^\vee(\alpha_j)`
    of the `i`-th simple coroot `\alpha_i^\vee` on the `j`-th simple root, is even for all `j \in I^X`.

    Here are some examples of affine cartan types and their sets of doubleable nodes::

        sage: DoubledNodes(['A',1,1])
        (0, 1)
        sage: DoubledNodes(['A',2,1])
        ()
        sage: DoubledNodes(['B',3,1])
        (3,)
        sage: DoubledNodes(['D',4,2])
        (0, 3)
        sage: DoubledNodes(['C',2,1])
        (1,)
        sage: DoubledNodes(['C',3,1])
        ()

    Fact: The only untwisted or dual untwisted affine root systems
    with doubleable nodes, are `A_1^{(1)}` nodes `0,1`; `C_2^{(1)}` node `1`; `B_n^{(1)}` node `n`;
    and `D_{n+1}^{(2)}`, nodes `0,n`.

    ..RUBRIC: Notation

        - `S^X` -- if the input ``reduced`` is False, the set of doubleable nodes in `I^X`;
        otherwise, the empty set. We call this is the set of doubled nodes.
        - `R(\tilde{X})` -- the union of `R_{red}(\tilde{X})` with the elements `u (2\alpha_i)` 
        for `u \in W_a(\tilde{X})` and `i \in S^X`. This is the not-necessarily reduced
        affine root system.

    We say that `R(\tilde{X})` is reduced if it equals `R_{red}(\tilde{X})` (that is, `S^X` is empty)
    and is nonreduced otherwise. Even if ``reduced`` is set to False, if there are no
    doubleable nodes then `R(\tilde{X})` is still reduced.
     
    `S^Y` and `R(\tilde{Y})` are defined analogously, using `\tilde{Y}` instead of `\tilde{X}` and the input boolean
    ``dual_reduced`` instead of ``reduced``.

    ..RUBRIC:: Lattices `X` and `Y` and possibly extended affine Weyl groups `W(\tilde{X})` and `W(\tilde{Y})`

        - `X` -- By abuse of notation this symbol stands for the weight lattice `P^X` if `R(\tilde{Y})` is reduced (no typo with
          the Y here); otherwise, for the root lattice `Q^X`.

        - `\tilde{X}` -- This stands for the direct sum of the lattice `X` with the integer multiples of the affine null root
          `\delta^X`. It is a sublattice of the level-zero part of the affine weight lattice.

        - `W(\tilde{X})` -- If `R(\tilde{Y})` is reduced, this is the extended affine Weyl group `W_e(\tilde{X})`, and otherwise it is the nonextended affine Weyl group `W_a(\tilde{X})`.

        - `Y`, `\tilde{Y}`, `W(\tilde{Y})` -- Defined analogously with the roles of `X` and `Y` interchanged.

    Observe that the lattice `Y` (resp. `X`) provides the translation elements for the "other" affine Weyl group
    `W(\tilde{X})` (resp. `W(\tilde{Y})`):

    ..MATH::

        W(\tilde{X}) \cong W(Y) \ltimes Y
        W(\tilde{Y}) \cong W(X) \ltimes X

    Let `\Pi^X \subset F^X` be the trivial subgroup if `R(\tilde{Y})` is nonreduced and otherwise let `\Pi^X=F^X`.
    Make similar definitions for `\Pi^Y \subset F^Y`. Then

    ..MATH::

        W(\tilde{X}) \cong \Pi^X \ltimes W_a(\tilde{X})
        W(\tilde{Y}) \cong \Pi^Y \ltimes W_a(\tilde{Y})

    ..RUBRIC:: The base ring `K` of the DAHA and parameters

    We assume `K` is a commutative ring and `QQ`-algebra.

    For every `i \in I^X` there is an invertible element `v_{\alpha_i^X}\in K` and
    for every `i \in S^X` an invertible element `v_{2\alpha_i^X} \in K`.
    For convenience we define `v_{2\alpha_i^X}=v_{\alpha_i^X}` for `i \in I^X \setminus S^X`.
    They must satisfy the compatibility that `v_\alpha=v_\beta` if `\alpha` and `\beta` are in the
    same `W(\tilde{X})`-orbit in `R(\tilde{X})`.

    Finally, there is an invertible element `q \in K`. It represents the exponential of the null root
    `\delta^X` and also the exponential of `-\delta^Y`.
    Under this identification there are group homomorphisms
    `\tilde{X} \to K[X]` and `\tilde{Y} \to K[Y]`. We assume `q` is transcendental over `QQ` so that these maps are injective.
    In particular it makes sense to refer to `X^{\alpha_0^X} \in K[X]`.
    
    There is also an action of `W(\tilde{X})` on `K[X]` by `K`-algebra automorphisms:

    ..MATH::

        \begin{align*}
            s^X_i \cdot X^\lambda &= X^{s^X_i(\lambda)} \\
            \pi^X \cdot X^{\alpha_i^X} &= X^{\alpha_{\pi^X(i)}}
        \end{align*}

    where `i \in I^X`, `\lambda \in \tilde{X}`, and `\pi^X \in F^X`. 
    The action of `s^X_0` involves `q` since `\alpha^X_0` does.
    The action of `\Pi^X` has only been defined on the affine root lattice,
    which is only a sublattice of `\tilde{X}`, but this sublattice spans over
    the rationals. The action of `\Pi^X` can also involve `q`.

    ..RUBRIC:: The possibly-extended affine Hecke algebra `H(W(\tilde{X}))`.

    Define the possibly extended affine Hecke algebra `H(W(\tilde{X}))` to be `H(W_e(\tilde{X}))` or
    `H(W_a(\tilde{X}))` according as `W(\tilde{X})` equals `W_e(\tilde{X})` or `W_a(\tilde{X})`.

    ..RUBRIC:: The DAHA, at last!

    Linearly it is the tensor product

    ..MATH::

        H(X,Y;v^X) = H(W(\tilde{X}),v^X) \otimes K[X]

    To define the product it is enough to specify the commutation of the `T^X_i` with `X^\lambda`
    for `i \in I^X` and `\lambda \in X`. This is achieved using the very interesting Demazure-Lusztig operators.

    For nondoubled nodes `i \in I^X \setminus S^X` we have

    ..MATH::

        T^X_i X^\lambda - X^{s_i^X(\lambda)} T^X_i = (v_{\alpha_i^X} - v_{\alpha_i^X}^{-1})
            \dfrac{X^\lambda - X^{s_i^X(\lambda)}}{1 - X^{\alpha_i^X}}

    For doubled nodes `i \in S^X` we have

    ..MATH::

        T^X_i X^\lambda - X^{s_i^X(\lambda)} T^X_i =
            (v_{\alpha_i^X} - v_{\alpha_i^X}^{-1} + (v_{2\alpha_i^X} - v_{2\alpha_i^X}^{-1})X^{\alpha_i^X}
            \dfrac{X^\lambda - X^{s_i^X(\lambda)}}{1 - X^{2 \alpha_i^X}}

    In particular it follows that the DAHA `H(X,Y;v^X)` has bases of the form

    ..MATH::

        T_v X^\lambda \qquad\text{ and }\qquad X^\lambda T_v

    where `v \in W(\tilde{X})` and `\lambda \in X`. We call these bases the "TX_X" and "X_TX" bases respectively.

    ..RUBRIC:: Dual Hecke parameters

    Recall the parameters `v_{\alpha_i^X}` and `v_{2\alpha_i^X}`. 
    Recall that `v_{2\alpha_i^X} = v_{\alpha_i^X}` if `i \in I^X \setminus S^X`.

    The "dual Hecke parameters" are the following relabelling of the Hecke
    parameters::

        - `v_{\alpha_i^Y} = v_{\alpha_i^X}` -- for `i\ne 0`, 
        - `v_{\alpha_0^Y} = v_{2\alpha_r^X}` -- for `r \in I^X \setminus\{0\}` with `\alpha_r^X` short
        - `v_{2\alpha_i^Y} = v_{\alpha_0^X}` -- if `i \in S^Y\setminus \{0\}`
        - `v_{2\alpha_0^Y} = v_{2\alpha_0^X}` -- if `0 \in S^Y`

    where `v_{2\alpha_i^Y} = v_{\alpha_i^Y}` if `i \in I^Y \setminus S^Y`.
    The parameters `v_{\alpha_i^Y}` and `v_{2\alpha_i^Y}` are collectively labeled `v^Y`.

    ..RUBRIC:: Dual presentation of the DAHA

    The DAHA `H(X,Y;v^X)` has a `K`-algebra isomorphism

    ..MATH::

        H(X,Y;v^X) \cong H(W(\tilde{Y});v^Y) \otimes K[Y]

    We first give the commutation between `T^Y_i` and `Y^\lambda` to define the multiplication on
    the right hand side, and then describe the preimages of the right hand side's generators.

    For `i \in I^Y \setminus S^Y` and `\lambda \in Y` we have

    ..MATH::

        T^Y_i Y^\lambda - Y^{s_i^Y(\lambda)} T^Y_i = (v_{\alpha_i^Y} - v_{\alpha_i^Y}^{-1})
            \dfrac{Y^\lambda - X^{s_i^Y(\lambda)}}{1 - Y^{-\alpha_i^Y}}

    which looks like the `X`-analogue except for the `-\alpha_i^Y`.
    For doubled nodes `i \in S^Y` we have

    ..MATH::

        T^Y_i Y^\lambda - Y^{s_i^Y(\lambda)} T^Y_i =
            (v_{\alpha_i^Y} - v_{\alpha_i^Y}^{-1} + (v_{2\alpha_i^Y} - v_{2\alpha_i^Y}^{-1})Y^{-\alpha_i^Y}
            \dfrac{Y^\lambda - Y^{s_i^Y(\lambda)}}{1 - Y^{- 2 \alpha_i^Y}}

    For nonzero `i` we have `T^Y_i = T^X_i`. We have

    ..MATH::

        T^Y_0 = (X^\varphi T_{s_{\varphi}})^{-1}

    where `\varphi \in X` is the dominant short root (its associated coroot is the highest coroot).
    
    For `\pi_i^Y \in \Pi^Y` where `i` is a special node in `I^Y`, if `i=0^Y` then `\pi_i^Y` is the identity.
    For `i \ne 0^Y` let `\omega_i^X` be the `i`-th fundamental weight and `u_i \in W(X)` the shortest element
    such that `u_i(\omega_i)` is antidominant. Then

    ..MATH::

        \pi^Y_i = X^{\omega_i^X} T_{u_i^{-1}}.

    In particular it follows that the DAHA `H(X,Y;v^X)` has bases of the form

    ..MATH::

        T_v Y^\lambda \qquad\text{ and }\qquad Y^\lambda T_v

    where `v \in W(\tilde{Y})` and `\lambda \in Y`. We call these bases the "TY_Y" and "Y_TY" bases respectively.

    ..RUBRIC:: Bases

    Using the isomorphism `K[X] \otimes H(W) \cong H(W(\tilde{Y}))`
    of the type `\tilde{Y}` affine Hecke algebra, we have
    the following presentations of the DAHA.

        - "X_TX" -- `K[X] \otimes H(W(\tilde{X}))`
        - "X_T_Y" -- `K[X] \otimes H(W) \otimes K[Y]`
        - "TY_Y" -- `H(W(\tilde{Y})) \otimes K[Y]`

    The DAHA has a basis corresponding to each of the permutations of the tensor factors
    of these forms. The various bases of the DAHA are implemented by smash product algebras.

    ..RUBRIC:: Implementation of Hecke parameters

    The default base ring is the field `K` given by

    ::

        sage: K = QQ['q,v,vl,v0,v2,vz'].fraction_field()
        sage: q,v,vl,v0,v2,vz = K.gens()

    This can be customized using the ``parameters`` option. Every parameter must be an invertible element of the
    base ring. The default parameters have the following names.

        - `q`  -- 'null_root'. Recall that `q=X^{\delta^X}= Y^{-\delta^Y}`)
        - `v`  -- 'short' (orbit of short `\alpha_i^X` for some nonzero `i`)
        - `vl` -- 'long' (orbit of long `\alpha_i^X` for some nonzero `i` if not simply-laced)
        - `v0` -- 'zero' (orbit of `\alpha_0^X`)
        - `v2` -- 'doubled' (orbit of `2\alpha_i^X` for nonzero doubled node `i`)
        - `vz` -- 'zero_doubled' (orbit of `2\alpha_0^X`)

    In any given case only some of these parameters are used and often they may have the same value.

    EXAMPLES::

        sage: K = QQ['q,v'].fraction_field()
        sage: q,v=K.gens()
        sage: dat = DoubleAffineType(['A',2], untwisted=True, reduced=True, dual_reduced=True, null_root=q, short=v)
        sage: dat.parameter('short')
        v
        sage: dat.parameter('long')
        Traceback (most recent call last):
        ...
        ValueError: No parameter 'long'
        sage: K = QQ['q,v,vl,v0,v2,vz'].fraction_field()
        sage: q,v,vl,v0,v2,vz=K.gens()
        sage: dat = DoubleAffineType(['B',2], untwisted=False, reduced=False, dual_reduced=False, null_root=q,short=v,long=vl,zero=v0,doubled=v2,zero_doubled=vz)
        sage: dat.parameter('null_root')
        q
        sage: dat.parameter('doubled')
        v2
        sage: dat.parameter('zero')
        v0
        sage: dat.parameter('zero_doubled')
        vz

    REFERENCES:

    .. [Haiman_ICM] M. Haiman, Cherednik algebras, Macdonald polynomials and combinatorics,
       Proceedings of the International Congress of Mathematicians,
       Madrid 2006, Vol. III, 843-872.
    """
    
    def __init__(self, cartan_type, untwisted=True, reduced=True, dual_reduced=True, prefix=None, **parameters):
        from sage.combinat.root_system.cartan_type import CartanType
        self._cartan_type_classical = CartanType(cartan_type)
        if not self._cartan_type_classical.is_finite():
            raise ValueError, "Cartan type is not finite"
        if self._cartan_type_classical.rank() == 1:
            self._cartan_type_classical = CartanType(['A',1])
        if not prefix:
            prefix = ''
        # check that parameters are invertible
        for par_name in parameters.keys():
            try:
                (parameters[par_name])**(-1)
            except ZeroDivisionError:
                raise ValueError, "Parameters must be invertible"
        if self._cartan_type_classical.is_simply_laced():
            # in simply-laced type, override `untwisted`
            self._untwisted = True
        else:
            self._untwisted = untwisted
        if untwisted:
            self._cartan_type = self._cartan_type_classical.affine()
            self._other_affine_type = self._cartan_type_classical.dual().affine()
        else:
            self._cartan_type = self._cartan_type_classical.dual().affine().dual()
            self._other_affine_type = self._cartan_type

        I = self._cartan_type.index_set()
        cartan_matrix = self._cartan_type.cartan_matrix()
        # Compute the set of doubled nodes for \tilde{X}
        if reduced:
            self._doubled_nodes = tuple([])
        else:
            # uses that the index set starts with 0
            self._doubled_nodes = DoubledNodes(self._cartan_type)

        self._reduced = (len(self._doubled_nodes) == 0)
        self._node_is_doubled = Family(I, lambda x: x in self._doubled_nodes)

        # Make the extended affine Weyl group W_e(\tilde{X})
        from sage.combinat.root_system.extended_affine_weyl_group import ExtendedAffineWeylGroup
        self._We = ExtendedAffineWeylGroup(self._cartan_type, style="PvW0", fundamental="")
        self._F = self._We.realization_of().fundamental_group()
        # Compute whether \tilde{Y} is reduced.
        if dual_reduced:
            self._dual_reduced = True
        else:
            self._dual_reduced = (len(DoubledNodes(self._other_affine_type)) == 0)

        # Specify the subgroup of allowable special affine Dynkin automorphisms `\Pi^X`.
        if self._dual_reduced:
            # Set `\Pi^X = F^X`
            self._special_nodes = tuple(self._We.realization_of().special_nodes())
        else:
            # Set `\Pi^X = \{0\}`
            self._special_nodes = tuple([0])

        # establish the specialization of Hecke parameters by computing
        # W(\tilde{X}) orbits of simple roots and their doubles
        vi = dict()
        v2i = dict()

        I0 = self._cartan_type_classical.index_set()
        # set the v_{\alpha_i} for i nonzero
        if self._cartan_type_classical.is_simply_laced():
            # for one root length we call it short for the purposes of the parameters.
            for i in I0:
                vi[i] = 'short'
        else:
            root_lattice = self._cartan_type_classical.root_system().root_lattice()
            for i in I0:
                vi[i] = 'short' if root_lattice.simple_root(i).is_short_root() else 'long'
        # set v_{\alpha_0}
        if len(self._special_nodes) >= 2:
            # \alpha_0 is in the orbit of another simple root by a Dynkin automorphism in W(\tilde{X})
            vi[0] = vi[self._special_nodes[1]]
        else:
            # check the attachment bond of 0 
            for i in I0:
                a0i = cartan_matrix[0,i]
                if a0i != 0:
                    break
            if a0i * cartan_matrix[i,0] == 1:
                # simple bond, and `\alpha_0` and `\alpha_i` are in the same orbit
                vi[0] = vi[i]
            else:
                # double bond, and `\alpha_0` is not in the orbit of any other simple root
                vi[0] = 'zero'

        # make v_{2\alpha_i}
        for i in I:
            v2i[i] = vi[i]

        # there are at most two doubled nodes and if there are two, one must be 0.
        for i in self._doubled_nodes:
            v2i[i] = 'zero_doubled' if i == 0 else 'doubled'

        # for BC with the nontrivial Dynkin automorphism allowed, 2\alpha_0 is in the orbit of 2\alpha_n.
        if 0 in self._doubled_nodes and self._dual_reduced:
            v2i[0] = 'doubled'

        # dictionaries for the orbits of simple (possibly doubled) roots under W(\tilde{X}).
        self._vi = Family(I, lambda i: vi[i])
        self._v2i = Family(I, lambda i: v2i[i])
        self._orbits = Set([self._vi[i] for i in I]+[self._v2i[i] for i in I])

        if 'null_root' in parameters.keys():
            q = parameters['null_root']
            K = q.parent()
            param_dict = dict({'null_root':q})
            for orbit in self._orbits:
                if orbit not in parameters.keys():
                    raise ValueError, "There is no parameter supplied for the orbit %s"%orbit
                else:
                    param_dict[orbit] = parameters[orbit]
                    if param_dict[orbit] not in K:
                        raise ValueError, "The parameter %s supplied for the orbit %s is not in the parent of %s"%(param_dict[orbit],orbit,q)
                        
            self._parameters = Family(dict([[key, param_dict[key]] for key in param_dict.keys()]))
        else:
            K = QQ['q,v,vl,v0,v2,vz'].fraction_field()
            param_dict = dict({'null_root':K.gen(0),'short':K.gen(1),'long':K.gen(2),'zero':K.gen(3),'doubled':K.gen(4),'zero_doubled':K.gen(5)})
            self._parameters = Family(dict([[root_type, param_dict[root_type]] for root_type in Set(['null_root'])+self._orbits]))
        self._base_ring = K
        self._prefix=prefix

        self._q1 = Family(dict([[i, self._parameters[self._vi[i]]] for i in I]))
        self._q2 = Family(dict([[i, -1/self._q1[i]] for i in I]))
        self._m = len(self.fundamental_group().special_nodes())
        ctc = self._cartan_type_classical
        if ctc.type() == 'C':
            self._m = 1
        elif self._cartan_type.is_untwisted_affine():
            if not self.reduced() or not self.dual_reduced():
                self._m = 1
            elif ctc.type() in ('B','D') and not is_even(ctc.n):
                self._m = 4
        else:
            if self._cartan_type_classical.type() == 'B':
                if self.reduced():
                    if self.dual_reduced() and not is_even(ctc.n):
                        self._m = 4
                elif self.dual_reduced() or is_even(ctc.n):
                    self._m = 1
            elif self._cartan_type_classical.type() == 'F' and self.reduced() and self.dual_reduced():
                self._m = 2

    def __repr__(self):
        def non_string(str, bool):
            if bool:
                return str
            return "non"+str
        return "Double Affine Type %s %s %s"%(self._cartan_type, non_string("reduced", self._reduced), non_string("dual-reduced", self._dual_reduced))

    def untwisted(self):
        return self._untwisted

    def reduced(self):
        r"""
        Is ``self`` reduced?

        EXAMPLES::

            sage: DoubleAffineType(['B',2], untwisted=False, reduced=True, dual_reduced=False).reduced()
            True
            sage: DoubleAffineType(['B',2], untwisted=False, reduced=False, dual_reduced=False).reduced()
            False
            sage: DoubleAffineType(['A',2], untwisted=False, reduced=False, dual_reduced=False).reduced()
            True

        """
        return self._reduced

    def dual_reduced(self):
        r"""
        Is the DAHA dual of ``self`` reduced?

        EXAMPLES::

            sage: DoubleAffineType(['B',2], untwisted=False, reduced=False, dual_reduced=True).dual_reduced()
            True
            sage: DoubleAffineType(['B',2], untwisted=False, reduced=False, dual_reduced=False).dual_reduced()
            False
            sage: DoubleAffineType(['A',2], untwisted=False, reduced=False, dual_reduced=False).dual_reduced()
            True

        """
        return self._dual_reduced

    def properly_extended(self):
        r"""
        Does the group `W(\tilde{X})` have any nontrivial affine Dynkin automorphisms?

        EXAMPLES::

            sage: DoubleAffineType(['A',2]).properly_extended()
            True
            sage: DoubleAffineType(['A',1], dual_reduced=False).properly_extended()
            False
            sage: DoubleAffineType(['B',2], untwisted=False, reduced=False, dual_reduced=True).properly_extended()
            True
            sage: DoubleAffineType(['B',2], untwisted=False, reduced=False, dual_reduced=False).properly_extended()
            False

        """
        return len(self.special_nodes()) > 1

    def base_ring(self):
        return self._base_ring

    def doubled_nodes(self):
        r"""
        The set of doubled nodes of type `X`.

        EXAMPLES::

            sage: DoubleAffineType(['B',2], untwisted=False, reduced=False, dual_reduced=False).doubled_nodes()
            (0, 2)

        """
        return self._doubled_nodes

    def cartan_type(self):
        r"""
        The affine Cartan type of ``self``.

        EXAMPLES::

            sage: DoubleAffineType(['B',2], untwisted=False, reduced=True, dual_reduced=False).cartan_type()
            ['C', 2, 1]^*

        """
        return self._cartan_type

    def cartan_type_classical(self):
        r"""
        The finite Cartan type of ``self``.

        EXAMPLES::

            sage: DoubleAffineType(['B',2], untwisted=False, reduced=True, dual_reduced=False).cartan_type_classical()
            ['B', 2]

        """
        return self._cartan_type_classical

    def special_nodes(self):
        r"""
        Return the set of special nodes indexing length-zero elements of `W(\tilde{X})`.

        EXAMPLES::

            sage: DoubleAffineType(['A',3], untwisted=True, reduced=True, dual_reduced=True).special_nodes()
            (0, 1, 2, 3)
            sage: DoubleAffineType(['B',3], untwisted=True, reduced=True, dual_reduced=True).special_nodes()
            (0, 1)
            sage: DoubleAffineType(['B',3], untwisted=False, reduced=False, dual_reduced=False).special_nodes()
            (0,)
            sage: DoubleAffineType(['B',3], untwisted=False, reduced=False, dual_reduced=True).special_nodes()
            (0, 3)

        """
        return self._special_nodes

    def properly_extended(self):
        r"""
        Is the group `W(\tilde{X})` strictly larger than `W_a(\tilde{X})`?

        EXAMPLES::

            sage: DoubleAffineType(['A',3], untwisted=True, reduced=True, dual_reduced=True).properly_extended()
            True
            sage: DoubleAffineType(['F',4], untwisted=True, reduced=True, dual_reduced=True).properly_extended()
            False
            sage: DoubleAffineType(['B',3], untwisted=False, reduced=True, dual_reduced=False).properly_extended()
            False
        """

        return len(self._special_nodes) >= 2

    def parameter(self, param):
        r"""
        A parameter.

        EXAMPLES::

            sage: DoubleAffineType("B2",False,False,False).parameter('zero')
            v0
            sage: DoubleAffineType("B2",False,False,False).parameter('short')
            v
            sage: DoubleAffineType("B2",False,False,False).parameter('long')
            vl
            sage: DoubleAffineType("B2",False,False,False).parameter('zero_doubled')
            vz
            sage: DoubleAffineType("B2",False,False,False).parameter('doubled')
            v2
            sage: DoubleAffineType("B2",False,False,False).parameter('null_root')
            q
        """
        try:
            return self._parameters[param]
        except KeyError:
            raise ValueError, "No parameter '%s'"%param

    def parameters(self):
        r"""
        The parameters of ``self``.

        EXAMPLES::

            sage: DoubleAffineType("B2",False,False,False).parameters()
            Finite family {'zero_doubled': vz, 'short': v, 'doubled': v2, 'zero': v0, 'long': vl, 'null_root': q}

        """
        return self._parameters

    @cached_method
    def q(self):
        r"""
        The null root parameter.
        """
        return self.parameters()['null_root']

    @cached_method
    def v(self, i):
        r"""
        Family of parameters for nondoubled simple roots.
        """
        return self.parameters()[self._vi[i]]

    @cached_method
    def v2(self, i):
        r"""
        Family of parameters for doubled simple roots.
        """
        return self.parameters()[self._v2i[i]]

    def q1(self, i):
        return self._q1[i]

    def q2(self, i):
        return self._q2[i]

    def extended_affine_weyl_group(self):
        return self._We

    def fundamental_group(self):
        return self._F

    @cached_method
    def doubled_parameters(self):
        r"""
        A family on the set of doubled nodes whose values are the extra factor in the nonreduced Demazure-Lusztig operators.

        EXAMPLES::

            sage: DoubleAffineType("B2",untwisted=False,reduced=False,dual_reduced=False).doubled_parameters()
            Finite family {0: (vz^2 - 1)/vz, 2: (v2^2 - 1)/v2}

        """
        def diff_reciprocal(x):
            return x - 1/x
        return Family(dict([[i, diff_reciprocal(self.parameters()[self._v2i[i]])] for i in self.doubled_nodes()]))

    @cached_method
    def dual(self, prefix=None):
        r"""
        The DAHA dual affine type.

        EXAMPLES::

            sage: dat = DoubleAffineType(['B',2], untwisted=True, reduced=False, dual_reduced=True, prefix="x"); dat
            Double Affine Type ['B', 2, 1] nonreduced dual-reduced
            sage: dat.dual()
            Double Affine Type ['C', 2, 1] reduced nondual-reduced            

        """
        if self._untwisted:
            dual_classical_type = self.cartan_type_classical().dual()
        else:
            dual_classical_type = self.cartan_type_classical()
        # to dualize parameters, the roles of 'doubled' and 'zero' get exchanged
        dual_parameters = dict()
        for x in self._parameters.keys():
            if x == 'doubled':
                dual_parameters['zero'] = self._parameters['doubled']
            elif x == 'zero':
                dual_parameters['doubled'] = self._parameters['zero']
            else:
                dual_parameters[x] = self._parameters[x]
        if prefix is None:
            prefix = ''
        if 'null_root' not in self._parameters.keys():
            dual_parameters['null_root'] = self.q()
        return DoubleAffineType(dual_classical_type, self._untwisted, self._dual_reduced, self._reduced, prefix, **dual_parameters)

class DoubleAffineHeckeAlgebraSansDuality(UniqueRepresentation, Parent):
    r"""
    The double affine Hecke algebra, with all its structure except duality.

    The bases that are supported by this class are:

    - "L_T" -- `X^\mu \pi^X T_w` where `\pi^X` is in the fundamental group `F^X`, `w` is in the affine Weyl group `W_a(\tilde{X})`,
                   and `\mu` is in the lattice `X`
    - "T_L" -- `\pi^X T_w X^\mu` 
    - "L_tv_Lv" -- `X^\mu T_w Y^\nu` where `\mu \in X`, `w` is in the finite Weyl group `W(Y)`, and `\nu \in Y`.

    The first two are supported "natively" and the third by coercion with "L_T".

    There is an input option ``dual_side`` which, if True, essentially applies a form of Macdonald duality:
    The interpretation of the bases become:

    - "L_T" -- `Y^\mu \pi^Y T_w` where `\pi^Y` is in the fundamental group `F^Y`, `w` is in the affine Weyl group `W_a(\tilde{Y})`,
                   and `\mu` is in the lattice `Y`
    - "T_L" -- `\pi^Y T_w Y^\mu` 
    - "L_tv_Lv" -- `Y^\mu T_w X^\nu` where `\mu \in Y`, `w` is in the finite Weyl group `W(X)`, and `\nu \in X`.

    Other differences: 

    - The Demazure-Lusztig operators use the "dominant" convention unless ``dual_side`` is True, whence they use the
    "antidominant" convention
    - The null root parameter `q` is interpreted as the exponential of the null root `\delta^X` unless ``dual_side`` is True,
    in which case `q` is the exponential of `- \delta^Y`.

    By invoking this class with a double affine type and again with the dual double affine type,
    one obtains many realizations of the same DAHA. However the interaction between these two kinds of realizations
    requires additional machinery, which is included in a separate class.

    """

    @staticmethod
    def __classcall_private__(cls, cartan_type, untwisted=True, reduced=True, dual_reduced=True, dual_side=False, **parameters):
        from sage.combinat.root_system.cartan_type import CartanType
        cartan_type = CartanType(cartan_type)
        return super(DoubleAffineHeckeAlgebraSansDuality, cls).__classcall__(cls, cartan_type, untwisted, reduced, dual_reduced, dual_side, **parameters)

    def __init__(self, cartan_type, untwisted, reduced, dual_reduced, dual_side, **parameters):
        self._dat = DoubleAffineType(cartan_type, untwisted, reduced, dual_reduced, **parameters)
        self._base_ring = self._dat._base_ring
        self._dual_dat = self._dat.dual()
        self._m = max(self._dat._m, self._dual_dat._m)
        assert self._dat._base_ring == self._dual_dat._base_ring, "The base ring (%s) of the double affine type does not agree with that (%s) of its dual"%(self._dat._base_ring, self._dual_dat._base_ring)

        Parent.__init__(self, category = AlgebrasWithBasis(self._base_ring).WithRealizations())

        self._dual_side = dual_side
        if dual_side:
            prefixL = "Y"
            prefixLv = "X"
            self._convention = "antidominant"
            self._the_q_unscaled = self._dat.q()**(-1)
            self._the_q = self._dat.q() ** (-self._m)
        else:
            prefixL = "X"
            prefixLv = "Y"
            self._convention = "dominant"
            self._the_q_unscaled = self._dat.q()
            self._the_q = self._dat.q() ** self._m

        self._L = self._dat.cartan_type_classical().root_system().ambient_space()
        self._KL = self._L.algebra(self._base_ring, prefix=prefixL)
        self._W = self._L.weyl_group() # Finite Weyl group of lattice

        self._A = AffineHeckeAlgebra(self._dat.cartan_type(), self._dat._q1, self._dat._q2, extended = self._dat.properly_extended(), dual_side=dual_side)
        self._T = self._A.T() # extended affine Hecke
        self._Ta = self._T.factor(1) # nonextended affine Hecke
        self._Wa = self._Ta.basis().keys() # nonextended affine Weyl group
        self._F = self._T.factor(0).basis().keys() # fundamental group
        self._tv_Lv = self._A.tv_Lv()
        self._tv = self._A.dual_classical_hecke() # classical hecke of "dual" type
        self._Lv = self._A.Lv() # "dual" lattice
        self._KLv = self._A.Lv_algebra() # group algebra of "dual" lattice
        self._Wv = self._Lv.weyl_group() # Finite Weyl group of dual lattice

        cat = ModulesWithBasis(self._base_ring)
        tcat = cat.TensorProducts()
        self._LoT = tensor([self._KL, self._T], category = tcat)
        self._ToL= tensor([self._T, self._KL], category = tcat)

        L_T = self.L_T()
        T_L = self.T_L()
        L_T.register_opposite(T_L)

        SetMorphism(Hom(L_T.factor(0),L_T,category=cat),L_T.factor_embedding(0)).register_as_coercion()
        SetMorphism(Hom(L_T.factor(1),L_T,category=cat),L_T.factor_embedding(1)).register_as_coercion()
        SetMorphism(Hom(T_L.factor(0),T_L,category=cat),T_L.factor_embedding(0)).register_as_coercion()
        SetMorphism(Hom(T_L.factor(1),T_L,category=cat),T_L.factor_embedding(1)).register_as_coercion()

        self._LotvLv = tensor([self._KL, self._tv_Lv], category = tcat)
        self._tvLvoL= tensor([self._tv_Lv, self._KL], category = tcat)

        L_tv_Lv = self.L_tv_Lv()

        SetMorphism(Hom(L_tv_Lv.factor(0),L_tv_Lv,category=cat),L_tv_Lv.factor_embedding(0)).register_as_coercion()
        SetMorphism(Hom(L_tv_Lv.factor(1),L_tv_Lv,category=cat),L_tv_Lv.factor_embedding(1)).register_as_coercion()

        def L_tv_Lv_to_L_T_func((mu, w, nu)):
            return L_T.from_direct_product((self._KL.monomial(mu),self._T(self._tv_Lv.monomial((w,nu)))))

        L_tv_Lv_to_L_T = L_tv_Lv.module_morphism(on_basis=L_tv_Lv_to_L_T_func, codomain=L_T)
        L_tv_Lv_to_L_T.register_as_coercion()

        def L_T_to_L_tv_Lv_func((mu, pi, w)):
            return L_tv_Lv.from_direct_product((self._KL.monomial(mu),self._tv_Lv(self._T.monomial((pi,w)))))

        L_T_to_L_tv_Lv = L_T.module_morphism(on_basis=L_T_to_L_tv_Lv_func, codomain=L_tv_Lv)
        L_T_to_L_tv_Lv.register_as_coercion()

    def double_affine_type(self):
        r"""
        Return the double affine type of ``self``.

        EXAMPLES::

            sage: HH = DoubleAffineHeckeAlgebraSansDuality("B3")
            sage: HH.double_affine_type()
            Double Affine Type ['B', 3, 1] reduced dual-reduced
        """
        return self._dat

    def dual_double_affine_type(self):
        r"""
        Return the dual double affine type of ``self``.

        EXAMPLES::

            sage: HH = DoubleAffineHeckeAlgebraSansDuality("B3")
            sage: HH.dual_double_affine_type()
            Double Affine Type ['C', 3, 1] reduced dual-reduced
        """
        return self._dual_dat

    def cartan_type(self):
        return self.double_affine_type().cartan_type()

    def base_ring(self):
        return self._base_ring

    @cached_method
    def Y_to_X(self):
        r"""
        The morphism from the ambient space of type `Y` to that of type `X`.

        EXAMPLES::

            sage: HH = DoubleAffineHeckeAlgebraSansDuality("B3")
            sage: dct = HH.cartan_type().classical().dual()
            sage: I0 = dct.index_set()
            sage: [(i, HH._Lv.fundamental_weight(i)) for i in I0]
            [(1, (1, 0, 0)), (2, (1, 1, 0)), (3, (1, 1, 1))]
            sage: [(i, HH.Y_to_X()(HH._Lv.fundamental_weight(i))) for i in I0]
            [(1, (1, 0, 0)), (2, (1, 1, 0)), (3, (1, 1, 1))]

            sage: HH = DoubleAffineHeckeAlgebraSansDuality("C3")
            sage: dct = HH.cartan_type().classical().dual()
            sage: I0 = dct.index_set()
            sage: [(i, HH._Lv.fundamental_weight(i)) for i in I0]
            [(1, (1, 0, 0)), (2, (1, 1, 0)), (3, (1/2, 1/2, 1/2))]
            sage: [(i, HH.Y_to_X()(HH._Lv.fundamental_weight(i))) for i in I0]
            [(1, (1, 0, 0)), (2, (1, 1, 0)), (3, (1/2, 1/2, 1/2))]

            sage: HH = DoubleAffineHeckeAlgebraSansDuality("F4")
            sage: dct = HH.cartan_type().classical().dual()
            sage: I0 = dct.index_set()
            sage: [(i, HH._Lv.fundamental_weight(i)) for i in I0]
            [(1, (1, 0, 0, 0)), (2, (3/2, 1/2, 1/2, 1/2)), (3, (2, 1, 1, 0)), (4, (1, 1, 0, 0))]
            sage: [(i, HH.Y_to_X()(HH._Lv.fundamental_weight(i))) for i in I0]
            [(1, (1, 1, 0, 0)), (2, (2, 1, 1, 0)), (3, (3, 1, 1, 1)), (4, (2, 0, 0, 0))]

            sage: HH = DoubleAffineHeckeAlgebraSansDuality("G2")
            sage: dct = HH.cartan_type().classical().dual()
            sage: I0 = dct.index_set()
            sage: [(i, HH._Lv.fundamental_weight(i)) for i in I0]
            [(1, (2, -1, -1)), (2, (1, 0, -1))]
            sage: [(i, HH.Y_to_X()(HH._Lv.fundamental_weight(i))) for i in I0]
            [(1, (1, 0, -1)), (2, (2/3, -1/3, -1/3))]

        TODO: Move to ambient space code?

        """
        if not self.cartan_type().is_untwisted_affine():
            return lambda x: x
        cartan_type = self.cartan_type().classical()
        if cartan_type.is_simply_laced():
            return lambda x: x
        typ = cartan_type.type()
        if typ in ('B','C'):
            return lambda v: self._L.from_vector(v.to_vector())
        dual_weight_space = cartan_type.dual().root_system().weight_space()
        if typ == 'F':
            # F4 and G2 have dual implemented as Dynkin reversals of themselves
            def YXF(mu):
                return self._L.from_vector(vector((mu[0]+mu[1],mu[0]-mu[1],mu[2]+mu[3],mu[2]-mu[3]),QQ))
            return YXF
        if typ == 'G':
            def YXG(mu):
                return self._L.from_vector(vector(((2*mu[0]+mu[1])/3,(mu[0]+2*mu[2])/3,(2*mu[1]+mu[2])/3),QQ))
            return YXG
        raise TypeError, "%s should be an irreducible finite Cartan type"%self.cartan_type()

    @cached_method
    def Y_pair_X(self):
        r"""
        Return the pairing between `Y` and `X`.

        If `Y` equals `X` (dual untwisted case) then the pairing in [Haiman] is the unique Weyl-invariant pairing
        with short roots of square length two. The ambient space pairing agrees with this except in
        types `B_n` and `F_4`, which use half the above pairing.
        If `Y` is the dual of `X` (untwisted case) then the weight lattice of `Y` is identified with the coweight
        lattice of `X` which is then paired with the weight lattice of `X`.

        The ambient lattices for `B_n` and `F_4` have pairing that is one-half times the
        invariant pairing on which the short root roots have square length 2.

        EXAMPLES::

            sage: E = DoubleAffineHeckeAlgebraSansDuality("A1")
            sage: I0 = E.cartan_type().classical().index_set()
            sage: Matrix([[E.Y_pair_X()(E._Lv.simple_root(i), E._L.simple_root(j)) for j in I0] for i in I0])
            [2]
            sage: E.cartan_type().classical().cartan_matrix()
            [2]
            sage: E = DoubleAffineHeckeAlgebraSansDuality("A2")
            sage: I0 = E.cartan_type().classical().index_set()
            sage: Matrix([[E.Y_pair_X()(E._Lv.simple_root(i), E._L.simple_root(j)) for j in I0] for i in I0])
            [ 2 -1]
            [-1  2]
            sage: E.cartan_type().classical().cartan_matrix()
            [ 2 -1]
            [-1  2]
            sage: E = DoubleAffineHeckeAlgebraSansDuality("B2")
            sage: I0 = E.cartan_type().classical().index_set()
            sage: Matrix([[E.Y_pair_X()(E._Lv.simple_root(i), E._L.simple_root(j)) for j in I0] for i in I0])
            [ 2 -1]
            [-2  2]
            sage: E.cartan_type().classical().cartan_matrix()
            [ 2 -1]
            [-2  2]

            sage: E = DoubleAffineHeckeAlgebraSansDuality("C2")
            sage: I0 = E.cartan_type().classical().index_set()
            sage: Matrix([[E.Y_pair_X()(E._Lv.simple_root(i), E._L.simple_root(j)) for j in I0] for i in I0])
            [ 2 -2]
            [-1  2]
            sage: E.cartan_type().classical().cartan_matrix()
            [ 2 -2]
            [-1  2]

            sage: E = DoubleAffineHeckeAlgebraSansDuality("F4")
            sage: I0 = E.cartan_type().classical().index_set()
            sage: Matrix([[E.Y_pair_X()(E._Lv.simple_root(i), E._L.simple_root(j)) for j in I0] for i in I0])
            [ 2 -1  0  0]
            [-1  2 -1  0]
            [ 0 -2  2 -1]
            [ 0  0 -1  2]
            sage: E.cartan_type().classical().cartan_matrix()
            [ 2 -1  0  0]
            [-1  2 -1  0]
            [ 0 -2  2 -1]
            [ 0  0 -1  2]

            sage: E = DoubleAffineHeckeAlgebraSansDuality("G2")
            sage: I0 = E.cartan_type().classical().index_set()
            sage: Matrix([[E.Y_pair_X()(E._Lv.simple_root(i), E._L.simple_root(j)) for j in I0] for i in I0])
            [ 2 -3]
            [-1  2]            
            sage: E.cartan_type().classical().cartan_matrix()
            [ 2 -3]
            [-1  2]

            sage: E = DoubleAffineHeckeAlgebraSansDuality("B2", untwisted=False)
            sage: I0 = E.cartan_type().classical().index_set()
            sage: Matrix([[E.Y_pair_X()(E._Lv.simple_root(i), E._L.simple_root(j)) for j in I0] for i in I0])
            [ 2 -1]
            [-1  1]

            sage: E = DoubleAffineHeckeAlgebraSansDuality("C2", untwisted=False)
            sage: I0 = E.cartan_type().classical().index_set()
            sage: Matrix([[E.Y_pair_X()(E._Lv.simple_root(i), E._L.simple_root(j)) for j in I0] for i in I0])
            [ 2 -2]
            [-2  4]

            sage: E = DoubleAffineHeckeAlgebraSansDuality("F4", untwisted=False)
            sage: I0 = E.cartan_type().classical().index_set()
            sage: Matrix([[E.Y_pair_X()(E._Lv.simple_root(i), E._L.simple_root(j)) for j in I0] for i in I0])
            [   2   -1    0    0]
            [  -1    2   -1    0]
            [   0   -1    1 -1/2]
            [   0    0 -1/2    1]

            sage: E = DoubleAffineHeckeAlgebraSansDuality("G2", untwisted=False)
            sage: I0 = E.cartan_type().classical().index_set()
            sage: Matrix([[E.Y_pair_X()(E._Lv.simple_root(i), E._L.simple_root(j)) for j in I0] for i in I0])
            [ 2 -3]
            [-3  6]

        """
        if not self.cartan_type().is_untwisted_affine():
            return lambda y, x: y.scalar(x)
        cartan_type = self.cartan_type().classical()
        typ = cartan_type.type()
        if typ == 'A':
            h = cartan_type.n + 1
            # this normalization is needed for the type A ambient space
            def type_a_pairing(y, x):
                return y.scalar(x) - (QQ.sum(vector(x))*QQ.sum(vector(y)))/h
            return type_a_pairing
        if cartan_type.is_simply_laced():
            return lambda y,x: y.scalar(x)
        return lambda y, x: x.scalar(self.Y_to_X()(y))

    def Y_pair_X_m(self, y, x):
        r"""
        This is a hack to deal with fractional powers of q.
        """
        return self.Y_pair_X()(y, x) * self._m

    def L(self):
        r"""
        The lattice.
        """
        return self._L

    def Lv(self):
        r"""
        The dual lattice.
        """
        return self._Lv

    def L_algebra(self):
        r"""
        The group algebra of the lattice `L`

        EXAMPLES::

            sage: HH = DoubleAffineHeckeAlgebraSansDuality("B2")
            sage: KL = HH.L_algebra(); KL
            Group algebra of the Ambient space of the Root system of type ['B', 2] over Fraction Field of Multivariate Polynomial Ring in q, v, vl, v0, v2, vz over Rational Field
            sage: KL.an_element()
            X[(2, 2)]

            sage: HH = DoubleAffineHeckeAlgebraSansDuality("B2",dual_side=True)
            sage: KL = HH.L_algebra(); KL
            Group algebra of the Ambient space of the Root system of type ['B', 2] over Fraction Field of Multivariate Polynomial Ring in q, v, vl, v0, v2, vz over Rational Field
            sage: KL.an_element()
            Y[(2, 2)]
        """
        return self._KL

    def Lv_algebra(self):
        r"""
        The group algebra of the dual lattice `Lv`

        EXAMPLES::

            sage: HH = DoubleAffineHeckeAlgebraSansDuality("B2")
            sage: KLv = HH.Lv_algebra(); KLv
            Group algebra of the Ambient space of the Root system of type ['C', 2] over Fraction Field of Multivariate Polynomial Ring in q, v, vl, v0, v2, vz over Rational Field
            sage: KLv.an_element()
            Y[(2, 2)]
        """
        return self._KLv

    def F(self):
        r"""
        The fundamental group.
        """
        return self._F

    @cached_method
    def F_on_L(self, pi):
        r"""
        Returns a function which sends an element `\mu` of `L` to
        its image under the action of the fundamental group element `\pi`.

        The value lies in the group algebra of `L`. If `\pi=\pi_i` then

        ..MATH::

            \pi_i^X = u_i^{-1} t_{-\omega^Y_{i^*}}

        where ` - \omega^Y_{i^*} = w_0(\omega^Y_i) `

        EXAMPLES::

            sage: HH = DoubleAffineHeckeAlgebraSansDuality("A2")
            sage: F = HH.double_affine_type().fundamental_group()
            sage: print "q should be replaced by q**(%s)"%(1/HH._m)
            q should be replaced by q**(1/3)
            sage: for i in F.special_nodes():
            ...       for j in HH.cartan_type().classical().index_set():
            ...           print i, j, HH.F_on_L(F(i))(HH._L.fundamental_weight(j))
            0 1 X[(1, 0, 0)]
            0 2 X[(1, 1, 0)]
            1 1 q*X[(0, 1, 0)]
            1 2 q^2*X[(0, 1, 1)]
            2 1 q^2*X[(0, 0, 1)]
            2 2 q*X[(1, 0, 1)]

            sage: HH = DoubleAffineHeckeAlgebraSansDuality("A2",dual_side=True)
            sage: F = HH.double_affine_type().fundamental_group()
            sage: print "q should be replaced by q**(%s)"%(1/HH._m)
            q should be replaced by q**(1/3)
            sage: for i in F.special_nodes():
            ...       for j in HH.cartan_type().classical().index_set():
            ...           print i, j, HH.F_on_L(F(i))(HH._L.fundamental_weight(j))
            0 1 Y[(1, 0, 0)]
            0 2 Y[(1, 1, 0)]
            1 1 1/q*Y[(0, 1, 0)]
            1 2 1/q^2*Y[(0, 1, 1)]
            2 1 1/q^2*Y[(0, 0, 1)]
            2 2 1/q*Y[(1, 0, 1)]

            sage: HH = DoubleAffineHeckeAlgebraSansDuality("B4",dual_side=True)
            sage: F = HH.double_affine_type().fundamental_group()
            sage: print "q should be replaced by q**(%s)"%(1/HH._m)
            q should be replaced by q**(1/2)
            sage: for i in F.special_nodes():
            ...       for j in HH.cartan_type().classical().index_set():
            ...           print i, j, HH.F_on_L(F(i))(HH._L.fundamental_weight(j))
            0 1 Y[(1, 0, 0, 0)]
            0 2 Y[(1, 1, 0, 0)]
            0 3 Y[(1, 1, 1, 0)]
            0 4 Y[(1/2, 1/2, 1/2, 1/2)]
            1 1 1/q^2*Y[(-1, 0, 0, 0)]
            1 2 1/q^2*Y[(-1, 1, 0, 0)]
            1 3 1/q^2*Y[(-1, 1, 1, 0)]
            1 4 1/q*Y[(-1/2, 1/2, 1/2, 1/2)]

            TODO: Fix the powers of q.

        """
        i = pi.value()
        if i == 0:
            return lambda mu: self.L_algebra().monomial(mu)
        istar = pi.parent().dual_node()[i]
        omi = self._Lv.fundamental_weight(i)
        rwuii = omi.reduced_word(positive=False)
        uii = self._W.from_reduced_word(rwuii)
        return lambda mu: self.L_algebra().term(uii.action(mu), self._the_q_unscaled**(self.Y_pair_X_m(self._Lv.fundamental_weight(istar),mu)))

    @cached_method
    def s0_on_L(self, mu):
        r"""
        Act on the element `\mu` of `L` by `s_0`.

        TODO:: CHECK!!!!

        EXAMPLES::

            sage: HH = DoubleAffineHeckeAlgebraSansDuality("A2")
            sage: print "q should be replaced by q**(1/%s)"%HH._m
            q should be replaced by q**(1/3)
            sage: [(i, HH.s0_on_L(HH._L.fundamental_weight(i))) for i in HH.cartan_type().classical().index_set()]
            [(1, q^3*X[(0, 0, 1)]), (2, q^3*X[(0, 1, 1)])]

            sage: HH = DoubleAffineHeckeAlgebraSansDuality("B2")
            sage: print "q should be replaced by q**(1/%s)"%HH._m
            q should be replaced by q**(1/2)
            sage: [(i, HH.s0_on_L(HH._L.fundamental_weight(i))) for i in HH.cartan_type().classical().index_set()]
            [(1, q^2*X[(0, -1)]), (2, q^2*X[(-1/2, -1/2)])]            

            sage: HH = DoubleAffineHeckeAlgebraSansDuality("B2", dual_side=True)
            sage: print "q should be replaced by q**(1/%s)"%HH._m
            q should be replaced by q**(1/2)
            sage: [(i, HH.s0_on_L(HH._L.fundamental_weight(i))) for i in HH.cartan_type().classical().index_set()]
            [(1, 1/q^2*Y[(0, -1)]), (2, 1/q^2*Y[(-1/2, -1/2)])]

            sage: HH = DoubleAffineHeckeAlgebraSansDuality("C2", dual_side=True)
            sage: print "q should be replaced by q**(1/%s)"%HH._m
            q should be replaced by q**(1/2)
            sage: [(i, HH.s0_on_L(HH._L.fundamental_weight(i))) for i in HH.cartan_type().classical().index_set()]
            [(1, 1/q^2*Y[(-1, 0)]), (2, 1/q^2*Y[(-1, 1)])]

            sage: HH = DoubleAffineHeckeAlgebraSansDuality("B2",untwisted=False)
            sage: print "q should be replaced by q**(1/%s)"%HH._m
            q should be replaced by q**(1/2)
            sage: [(i, HH.s0_on_L(HH._L.fundamental_weight(i))) for i in HH.cartan_type().classical().index_set()]
            [(1, q^4*X[(-1, 0)]), (2, q^2*X[(-1/2, 1/2)])]

            sage: HH = DoubleAffineHeckeAlgebraSansDuality("B2",untwisted=False, dual_side=True)
            sage: print "q should be replaced by q**(1/%s)"%HH._m
            q should be replaced by q**(1/2)
            sage: [(i, HH.s0_on_L(HH._L.fundamental_weight(i))) for i in HH.cartan_type().classical().index_set()]
            [(1, 1/q^4*Y[(-1, 0)]), (2, 1/q^2*Y[(-1/2, 1/2)])]

        """
        dat = self.double_affine_type()
        if dat.cartan_type().is_untwisted_affine():
            phi = dat.cartan_type().classical().root_system().root_space().highest_root().to_ambient()
            phiv = phi.associated_coroot()
        else:
            phiv = dat.cartan_type().classical().root_system().coroot_space().highest_root().to_ambient()
            phi = phiv.associated_coroot()
        sp = mu.scalar(phiv)
        return self._the_q_unscaled**(self._m * sp) * self._KL.monomial(mu - sp * phi)

    @cached_method
    def s0_on_L_algebra(self):
        r"""
        The operator that acts on the group algebra of `L` by `s_0`.

        TODO:: FIX!!!!!!!!!!!!

        EXAMPLES::

            sage: HH = DoubleAffineHeckeAlgebraSansDuality("A2")
            sage: print "q should be replaced by q**(1/%s)"%HH._m
            q should be replaced by q**(1/3)
            sage: [(i, HH.s0_on_L_algebra()(HH._KL.monomial(HH._L.fundamental_weight(i)))) for i in HH.cartan_type().classical().index_set()]
            [(1, q^3*X[(0, 0, 1)]), (2, q^3*X[(0, 1, 1)])]
            sage: [(i, HH.s0_on_L_algebra()(HH.s0_on_L(HH._L.fundamental_weight(i)))) for i in HH.cartan_type().classical().index_set()]
            [(1, X[(1, 0, 0)]), (2, X[(1, 1, 0)])]
            sage: HH = DoubleAffineHeckeAlgebraSansDuality("B2", dual_side=True)
            sage: print "q should be replaced by q**(1/%s)"%HH._m
            q should be replaced by q**(1/2)
            sage: [(i, HH.s0_on_L_algebra()(HH._KL.monomial(HH._L.fundamental_weight(i)))) for i in HH.cartan_type().classical().index_set()]
            [(1, 1/q^2*Y[(0, -1)]), (2, 1/q^2*Y[(-1/2, -1/2)])]
            sage: [(i, HH.s0_on_L_algebra()(HH.s0_on_L(HH._L.fundamental_weight(i)))) for i in HH.cartan_type().classical().index_set()]
            [(1, Y[(1, 0)]), (2, Y[(1/2, 1/2)])]
        """
        KL = self._KL
        return KL.module_morphism(on_basis=self.s0_on_L, codomain=KL, category=ModulesWithBasis(self.base_ring()))

    def T(self):
        r"""
        The extended affine Hecke algebra corresponding to the lattice `L`.

        EXAMPLES::

            sage: DoubleAffineHeckeAlgebraSansDuality("A2").T()
            T basis of The affine Hecke algebra of type ['A', 2, 1]
        """
        return self._T

    @cached_method
    def L_T(self):
        r"""
        The "L_T" basis.

        EXAMPLES::

            sage: DoubleAffineHeckeAlgebraSansDuality("A2").L_T()
            L_T basis of The double affine Hecke algebra of type ['A', 2, 1]

        """
        return self.DoubleAffineHeckeAlgebraSansDualityL_T()

    @cached_method
    def T_L(self):
        r"""
        The "T_L" basis.

        EXAMPLES::

            sage: DoubleAffineHeckeAlgebraSansDuality("A2").T_L()
            T_L basis of The double affine Hecke algebra of type ['A', 2, 1]

        """
        return self.DoubleAffineHeckeAlgebraSansDualityT_L()

    @cached_method
    def L_tv_Lv(self):
        r"""
        The L_tv_Lv basis.

        EXAMPLES::

            sage: DoubleAffineHeckeAlgebraSansDuality("A2").L_tv_Lv()
            L_tv_Lv basis of The double affine Hecke algebra of type ['A', 2, 1]

        """
        return self.DoubleAffineHeckeAlgebraSansDualityL_tv_Lv()

    def tv_Lv(self):
        return self._tv_Lv

    def tv(self):
        return self._tv

    def a_realization(self):
        r"""
        Returns the default realization.

        EXAMPLES::

            sage: DoubleAffineHeckeAlgebraSansDuality("A2").a_realization()
            L_T basis of The double affine Hecke algebra of type ['A', 2, 1]

        """
        return self.L_T()

    def _repr_(self):
        r"""
        EXAMPLES::

            sage: DoubleAffineHeckeAlgebraSansDuality("A2")
            The double affine Hecke algebra of type ['A', 2, 1]

        """
        return "The double affine Hecke algebra of type %s"%self.cartan_type()

    class _BasesCategory(Category_realization_of_parent):
        r"""
        The category of realizations of a double affine Hecke algebra (without duality)
        """
        def __init__(self, basis, prefix=None):
            r"""
            Initialize a basis.

            INPUT:

            - ``basis`` -- a basis
            - ``prefix`` -- a prefix

            TESTS::

                sage: HH = DoubleAffineHeckeAlgebraSansDuality("A2")
                sage: bases = HH._BasesCategory()
                sage: HH.L_T() in bases
                True
            """
            Category_realization_of_parent.__init__(self, basis)
            basis._prefix = prefix

        def super_categories(self):
            r"""
            EXAMPLES::

                sage: DoubleAffineHeckeAlgebraSansDuality("A2")._BasesCategory().super_categories()
                [Category of realizations of The double affine Hecke algebra of type ['A', 2, 1], Category of algebras with basis over Fraction Field of Multivariate Polynomial Ring in q, v, vl, v0, v2, vz over Rational Field, Category of monoids with realizations, Category of additive unital additive magmas with realizations]

            """
            return [Realizations(self.base())] + self.base().category().super_categories()

        def _repr_(self):
            r"""
            Return the representation of ``self``.

            EXAMPLES::

                sage: DoubleAffineHeckeAlgebraSansDuality("A2")._BasesCategory()
                Category of bases of The double affine Hecke algebra of type ['A', 2, 1]
            """
            return "Category of bases of %s" % self.base()

        class ParentMethods:

            def T_generators(self):
                r"""
                The family of elements `T_i` in the given realization.

                It is a family on the affine Dynkin node set `I` with values in ``self``.

                ..warning:: Must be implemented for "L_T".

                EXAMPLES::

                    sage: HH = DoubleAffineHeckeAlgebraSansDuality("A2")
                    sage: HH.L_T().T_generators()
                    Finite family {0: TX[0], 1: TX[1], 2: TX[2]}
                    sage: HH.T_L().T_generators()
                    Finite family {0: TX[0], 1: TX[1], 2: TX[2]}
                    sage: HH.L_tv_Lv().T_generators()
                    Finite family {0: Ty[1,2,1] Y[(-1, 0, 1)] + ((v^2-1)/v), 1: Ty[1], 2: Ty[2]}

                TODO:: other realizations

                """
                HH = self.realization_of()
                return Family(dict([[i, self(HH.L_T().T_generators()[i])] for i in HH.double_affine_type().cartan_type().index_set()]))

            def from_F(self):
                r"""
                The family of elements for the fundamental group in ``self``.

                ..warning:: Must be implemented in "L_T".

                EXAMPLES::

                    sage: HH = DoubleAffineHeckeAlgebraSansDuality("A2")
                    sage: pis = HH.L_T().from_F(); pis
                    Finite family {0: 1, 1: piX[1], 2: piX[2]}
                    sage: pis[0].parent()
                    L_T basis of The double affine Hecke algebra of type ['A', 2, 1]
                    sage: HH.L_tv_Lv().from_F()
                    Finite family {0: 1, 1: Ty[1,2] Y[(-1, -1, 0)], 2: Ty[2,1] Y[(-1, 0, 0)]}
                """
                HH = self.realization_of()
                return Family(dict([[i, self(HH.L_T().from_F()[i])] for i in HH.double_affine_type().special_nodes()]))

            def L_morphism(self, a):
                r"""
                The image of `a` under the morphism from the group algebra of the `L` lattice into ``self``.

                ..warning:: Must be implemented in "L_T".

                EXAMPLES::

                    sage: HH = DoubleAffineHeckeAlgebraSansDuality("A2")
                    sage: L_T = HH.L_T()
                    sage: KL = HH.L_algebra()
                    sage: a = KL.monomial(HH.L().simple_root(1)); a
                    X[(1, -1, 0)]
                    sage: a.parent()
                    Group algebra of the Ambient space of the Root system of type ['A', 2] over Fraction Field of Multivariate Polynomial Ring in q, v, vl, v0, v2, vz over Rational Field
                    sage: aa = L_T.L_morphism(a); aa
                    X[(1, -1, 0)]
                    sage: aa.parent()
                    L_T basis of The double affine Hecke algebra of type ['A', 2, 1]

                """
                HH = self.realization_of()
                return self(HH.L_T().factor_embedding(0)(a))

            def Lv_morphism(self, b):
                r"""
                The image of `b` under the morphism from the group algebra of the `Lv` lattice into ``self``.

                ..warning:: Must be implemented in basis `L_tv_Lv`.

                EXAMPLES::

                    sage: HH = DoubleAffineHeckeAlgebraSansDuality("A2")
                    sage: L_tv_Lv = HH.L_tv_Lv()
                    sage: KLv = HH.Lv_algebra()
                    sage: Lv = HH.Lv()
                    sage: b = KLv.monomial(Lv.simple_root(1)); b
                    Y[(1, -1, 0)]
                    sage: b.parent()
                    Group algebra of the Ambient space of the Root system of type ['A', 2] over Fraction Field of Multivariate Polynomial Ring in q, v, vl, v0, v2, vz over Rational Field
                    sage: bb = L_tv_Lv.Lv_morphism(b); bb
                    Y[(1, -1, 0)]
                    sage: bb.parent()
                    L_tv_Lv basis of The double affine Hecke algebra of type ['A', 2, 1]
                    sage: c = HH.L_T().Lv_morphism(b); c
                    TX[0,2,0,1] + ((-v^2+1)/v)*TX[0,2,1]
                    sage: L_tv_Lv(c) == b
                    True
                    sage: HH = DoubleAffineHeckeAlgebraSansDuality("A2", dual_side=True)
                    sage: L_tv_Lv = HH.L_tv_Lv()
                    sage: KLv = HH.Lv_algebra()
                    sage: Lv = HH.Lv()
                    sage: b = KLv.monomial(Lv.simple_root(1)); b
                    X[(1, -1, 0)]
                    sage: b.parent()
                    Group algebra of the Ambient space of the Root system of type ['A', 2] over Fraction Field of Multivariate Polynomial Ring in q, v, vl, v0, v2, vz over Rational Field
                    sage: c = HH.T_L()(b); c
                    ((v^4-2*v^2+1)/v^2)*TY[2,0] + ((-v^2+1)/v)*TY[2,0,1] + ((-v^2+1)/v)*TY[0,2,0] + ((v^4-2*v^2+1)/v^2) + ((-v^2+1)/v)*TY[1] + TY[0,2,0,1]
                    sage: c.parent()
                    T_L basis of The double affine Hecke algebra of type ['A', 2, 1]

                """
                HH = self.realization_of()
                return self(HH.L_tv_Lv().factor_embedding(1)(HH.tv_Lv().factor_embedding(1)(b)))

            def T_morphism(self, a):
                r"""
                Returns the image of `a` from the extended affine Hecke algebra "T" to ``self``.

                ..warning:: Must be implemented in type "L_T".

                EXAMPLES::

                    sage: HH = DoubleAffineHeckeAlgebraSansDuality("A2")
                    sage: L_T = HH.L_T()
                    sage: T = HH.T()
                    sage: a = T.an_element()
                    sage: b = L_T.T_morphism(a); b
                    2*TX[0] + 3*TX[0,1] + 1 + TX[0,1,2] + 4*piX[1] TX[0] + 6*piX[1] TX[0,1] + 2*piX[1] + 2*piX[1] TX[0,1,2] + 8*piX[2] TX[0] + 12*piX[2] TX[0,1] + 4*piX[2] + 4*piX[2] TX[0,1,2]
                    sage: b == L_T(a)
                    True
                """
                return self(self.realization_of().L_T().T_morphism(a))

            def tv_morphism(self, a):
                r"""
                Returns the image of `a` from the finite Hecke algebra "tv" of dual type, to ``self``.

                ..warning:: Must be implemented in type "L_tv_Lv".

                EXAMPLES::

                    sage: HH = DoubleAffineHeckeAlgebraSansDuality("A2")
                    sage: L_T = HH.L_T()
                    sage: tv_Lv = HH.tv_Lv()
                    sage: tv = HH.tv()
                    sage: a = tv.an_element(); a
                    Ty[1,2,1] + 3*Ty[1,2] + 3*Ty[2,1]
                    sage: b = L_T.tv_morphism(a); b
                    3*TX[2,1] + 3*TX[1,2] + TX[1,2,1]                    
                    sage: b == L_T(a)
                    True
                """
                return self(self.realization_of().L_tv_Lv().tv_morphism(a))

            def from_reduced_word(self, word):
                r"""
                Given a reduced word for an element `w` in the affine Weyl group, return the image of the basis element `T_w`
                in ``self``.

                .. warning::

                    Must be implemented in style "L_T".

                EXAMPLES::

                    sage: DoubleAffineHeckeAlgebraSansDuality("B2").L_T().from_reduced_word([0,2,1])
                    TX[0,2,1]

                    sage: DoubleAffineHeckeAlgebraSansDuality("B2", dual_side=True).L_T().from_reduced_word([0,2,1])
                    TY[0,2,1]
                """
                return self(self.realization_of().L_T().from_reduced_word(word))

            def from_reduced_word_dual(self, word):
                r"""
                Given a reduced word for an element `w` in the finite Weyl group of `Lv`, 
                return the image of the corresponding basis element of `tv` in ``self``.

                .. warning::

                    Must be implemented in basis "L_tv_Lv".

                EXAMPLES::

                    sage: HH = DoubleAffineHeckeAlgebraSansDuality("B2")
                    sage: a = HH.L_tv_Lv().from_reduced_word_dual([2,1]); a
                    Ty[2,1]
                    sage: L_T = HH.L_T()
                    sage: b = L_T.from_reduced_word_dual([2,1]); b
                    TX[2,1]
                    sage: b == L_T(a)
                    True
                    sage: HH = DoubleAffineHeckeAlgebraSansDuality("B2", dual_side=True)
                    sage: a = HH.L_tv_Lv().from_reduced_word_dual([2,1]); a
                    Tx[2,1]
                    sage: L_T = HH.L_T()
                    sage: b = L_T.from_reduced_word_dual([2,1]); b
                    TY[2,1]
                    sage: b == L_T(a)
                    True

                """
                return self(self.realization_of().L_tv_Lv().from_reduced_word(word))

    class _Bases(UniqueRepresentation, BindableClass):
        r"""
        The class of realizations of a double affine Hecke algebra without duality.
        """

        def _repr_(self):
            r"""
            EXAMPLES::

                sage: DoubleAffineHeckeAlgebraSansDuality("A2").L_T() # indirect doctest
                L_T basis of The double affine Hecke algebra of type ['A', 2, 1]

            """
            return "%s basis of the %s"%(self._prefix, self.realization_of())

        def is_parent_of(self, x):
            return x.parent() == self

    class DoubleAffineHeckeAlgebraSansDualityL_T(SmashProductAlgebra, _Bases):
        r"""
        DAHA basis L_T.

        INPUT:

        - `HH` -- DAHA realization parent

        EXAMPLES::

            sage: DoubleAffineHeckeAlgebraSansDuality("A2").L_T()
            L_T basis of The double affine Hecke algebra of type ['A', 2, 1]

        """

        def __init__(self, HH):
            dat = HH.double_affine_type()
            # To define the product on L_T we need the left action of left multiplication by T on KL # T.
            # We start with the left action of the Hecke algebra of the nonextended affine Weyl group of `L`
            # on the group algebra KL.
            from sage.combinat.root_system.hecke_algebra_representation import HeckeAlgebraRepresentation
            HH._KLaf = dat.cartan_type().root_system().ambient_space().algebra(HH.base_ring())
            HH._ML = HH._KLaf.nonreduced_demazure_lusztig_operators_on_classical(HH._the_q, dat._q1, dat._q2, convention=HH._convention, doubled_parameters=dat.doubled_parameters(),domain=HH.L_algebra())
            mcat = ModulesWithBasis(HH.base_ring())
            tmcat = mcat.TensorProducts()
            # Now we define the action of the above nonextended affine Hecke algebra on KL # T
            # This is done by first giving the action of the generators `T_i` for `i \in I`:
            # T_i * (e^\mu # pi T_w) = (T_i(e^\mu) - q1[i] e^{s_i(\mu)}) # pi T_w + e^{s_i(\mu)} # T_i pi T_w
            def Ti_on_LoT_left((mu,pi,w), i):
                if i == 0:
                    smupoly = HH.s0_on_L(mu)
                else:
                    smupoly = HH._KL.monomial(mu.simple_reflection(i))
                return tensor([HH._ML[i](HH._KL.monomial(mu)) - dat._q1[i] * smupoly, HH._T.monomial((pi,w))],category=tmcat) + tensor([smupoly, HH._T.product_by_generator_on_basis((pi,w), i, side='left')],category=tmcat)
            # Use the HeckeAlgebraRepresentation tool to obtain a left action of the nonextended affine Hecke on KL # T.

            HH._MLoT = HeckeAlgebraRepresentation(HH._LoT, Ti_on_LoT_left, dat.cartan_type(), dat._q1, dat._q2, HH._the_q, side='left', doubled_parameters=dat.doubled_parameters)

            # Now define the left action of the fundamental group elements on KL # T.
            def pi_on_LoT_left(pi, (mu,pi0,w)):
                return tensor([HH.F_on_L(pi)(mu), HH._T.product_by_fundamental_group_element_on_basis((pi0,w),pi,side='left')],category=tmcat)

            F = HH._F
            HH._F_on_LoT_left_morphisms = Family(dict([[F(i), HH._LoT.module_morphism(on_basis=functools.partial(pi_on_LoT_left, F(i)),category=mcat,codomain=HH._LoT)] for i in F.special_nodes()]))
            # the left action of the extended affine Hecke algebra on the module LoT.
            def left_LoT_func((ppi,ww),mu,(pi,w)):
                return HH._F_on_LoT_left_morphisms[ppi](HH._MLoT.Tw(ww)(HH._LoT.monomial((mu,pi,w))))

            SmashProductAlgebra.__init__(self, HH._KL, HH._T, left_action=left_LoT_func, category=Category.join((HH._BasesCategory(),AlgebrasWithBasis(HH.base_ring()).TensorProducts())))
            self._style = "L_T"

        def _repr_(self):
            HH = self.realization_of()
            return "%s basis of %s"%(self._style, HH._repr_())

        @cached_method
        def T_generators(self):
            r"""
            A family on the affine Dynkin node set with values given by `T_i`.

            EXAMPLES::

                sage: HH=DoubleAffineHeckeAlgebraSansDuality("A2")
                sage: L_T = HH.L_T()
                sage: L_T.T_generators()
                Finite family {0: TX[0], 1: TX[1], 2: TX[2]}

            """
            return Family(dict([[i, self.factor_embedding(1)(self.factor(1).from_reduced_word([i]))] for i in self.realization_of().double_affine_type().cartan_type().index_set()]))

        @cached_method
        def from_F(self):
            r"""
            Family on the special nodes of the affine Dynkin diagram of `L`, with values in ``self``.

            EXAMPLES::

                sage: DoubleAffineHeckeAlgebraSansDuality("A2").L_T().from_F()
                Finite family {0: 1, 1: piX[1], 2: piX[2]}

            """
            F = self.realization_of().double_affine_type().fundamental_group()
            return Family(dict([[i, self.factor_embedding(1)(self.factor(1).from_fundamental(F(i)))] for i in F.special_nodes()]))

        def L_morphism(self, a):
            r"""
            The image of the element `a` of `KX` in ``self``.

            EXAMPLES::

                sage: HH = DoubleAffineHeckeAlgebraSansDuality("A2")
                sage: L_T = HH.L_T()
                sage: KL = L_T.factor(0)
                sage: a = KL.an_element(); a
                X[(2, 2, 3)]
                sage: b = L_T.L_morphism(a); b
                X[(2, 2, 3)]
                sage: b.parent()
                L_T basis of The double affine Hecke algebra of type ['A', 2, 1]

            """
            return self.factor_embedding(0)(a)

        def T_morphism(self, a):
            r"""
            The image of the element `a` of `T` in ``self``.

            EXAMPLES::

                sage: HH = DoubleAffineHeckeAlgebraSansDuality("A2")
                sage: L_T = HH.L_T()
                sage: T = L_T.factor(1)
                sage: a = T.an_element(); a
                2*TX[0] + 3*TX[0,1] + 1 + TX[0,1,2] + 4*piX[1] TX[0] + 6*piX[1] TX[0,1] + 2*piX[1] + 2*piX[1] TX[0,1,2] + 8*piX[2] TX[0] + 12*piX[2] TX[0,1] + 4*piX[2] + 4*piX[2] TX[0,1,2]
                sage: b = L_T.T_morphism(a); b
                2*TX[0] + 3*TX[0,1] + 1 + TX[0,1,2] + 4*piX[1] TX[0] + 6*piX[1] TX[0,1] + 2*piX[1] + 2*piX[1] TX[0,1,2] + 8*piX[2] TX[0] + 12*piX[2] TX[0,1] + 4*piX[2] + 4*piX[2] TX[0,1,2]
                sage: b.parent()
                L_T basis of The double affine Hecke algebra of type ['A', 2, 1]                

            """
            return self.factor_embedding(1)(a)

        def from_reduced_word(self, word):
            r"""
            Given a reduced word for an element `w` in the affine Weyl group of `L`, return the image of the basis element `T_w`
            in ``self``.

            .. warning::

                Must be implemented in style "L_T".

            EXAMPLES::

                sage: DoubleAffineHeckeAlgebraSansDuality("A2").L_T().from_reduced_word([0,2,1])
                TX[0,2,1]

            """
            return self.T_morphism(self.factor(1).from_reduced_word(word))

    class DoubleAffineHeckeAlgebraSansDualityT_L(SmashProductAlgebra, _Bases):
        r"""
        DAHA basis T_L.

        INPUT:

        - `HH` -- DAHA realization parent

        EXAMPLES::

            sage: DoubleAffineHeckeAlgebraSansDuality("A2").T_L()
            T_L basis of The double affine Hecke algebra of type ['A', 2, 1]

        """

        def __init__(self, HH):
            dat = HH.double_affine_type()
            # Define the left action of the Hecke algebra of the affine Weyl group of `L` on the group algebra KL.
            from sage.combinat.root_system.hecke_algebra_representation import HeckeAlgebraRepresentation
            HH._LM = HH._KLaf.nonreduced_demazure_lusztig_operators_on_classical(HH._the_q, dat._q1, dat._q2, convention=HH._convention,side='right', doubled_parameters=dat.doubled_parameters(),domain=HH._KL)
            mcat = ModulesWithBasis(HH.base_ring())
            tmcat = mcat.TensorProducts()
            # The above nonextended affine Hecke algebra has a right action on T # KL
            # via the action of the generators `T_i` for `i \in I`:
            # (pi T_w # e^\mu) # T_i = pi T_w # (T_i(e^\mu) - q1[i] e^{s_i(\mu)}) + pi T_w T_i # e^{s_i(\mu)}
            def Ti_on_ToL_right((pi,w,mu), i):
                if i == 0:
                    smupoly = HH.s0_on_L(mu)
                else:
                    smupoly = HH._KL.monomial(mu.simple_reflection(i))
                return tensor([HH._T.monomial((pi,w)), HH._LM[i](HH._KL.monomial(mu)) - dat._q1[i] * smupoly],category=tmcat) + tensor([HH._T.product_by_generator_on_basis((pi,w), i, side='right'),smupoly],category=tmcat)

            # Use the HeckeAlgebraRepresentation tool to obtain a right action of the nonextended affine Hecke on T # KL.
            HH._ToLM = HeckeAlgebraRepresentation(HH._ToL, Ti_on_ToL_right, dat.cartan_type(), dat._q1, dat._q2, HH._the_q, side='right', doubled_parameters=dat.doubled_parameters)

            # Now define the right action of the fundamental group elements on T # KL.
            def pi_on_ToL_right(pi, (pi0,w,mu)):
                return tensor([HH._T.product_by_fundamental_group_element_on_basis((pi0,w),pi,side='right'),HH.F_on_L(pi.inverse())(mu)],category=tmcat)

            F = HH._F
            HH._F_on_ToL_right_morphisms = Family(dict([[F(i), HH._ToL.module_morphism(on_basis=functools.partial(pi_on_ToL_right, F(i)),category=mcat,codomain=HH._ToL)] for i in F.special_nodes()]))

            # Finally we obtain the right action of the extended affine Hecke algebra on the module ToL.
            def right_ToL_func((ppi,ww),(pi,w),mu):
                return HH._ToLM.Tw(ww)(HH._F_on_ToL_right_morphisms[ppi](HH._ToL.monomial((pi,w,mu))))

            SmashProductAlgebra.__init__(self, HH._T, HH._KL, right_action=right_ToL_func, category=Category.join((HH._BasesCategory(),AlgebrasWithBasis(HH.base_ring()).TensorProducts())))

            self._style = "T_L"

        def _repr_(self):
            HH = self.realization_of()
            return "%s basis of %s"%(self._style, HH._repr_())

        @cached_method
        def T_generators(self):
            r"""
            A family on the affine Dynkin node set with values given by `T_i`.

            EXAMPLES::

                sage: HH=DoubleAffineHeckeAlgebraSansDuality("A2")
                sage: T_L = HH.T_L()
                sage: T_L.T_generators()
                Finite family {0: TX[0], 1: TX[1], 2: TX[2]}

            """
            return Family(dict([[i, self.factor_embedding(0)(self.factor(0).from_reduced_word([i]))] for i in self.realization_of().double_affine_type().cartan_type().index_set()]))

        @cached_method
        def from_F(self):
            r"""
            Family on the special nodes of the affine Dynkin diagram of `L`, with values in ``self``.

            EXAMPLES::

                sage: DoubleAffineHeckeAlgebraSansDuality("A2").T_L().from_F()
                Finite family {0: 1, 1: piX[1], 2: piX[2]}

            """
            F = self.realization_of().double_affine_type().fundamental_group()
            return Family(dict([[i, self.factor_embedding(0)(self.factor(0).from_fundamental(F(i)))] for i in F.special_nodes()]))

        def L_morphism(self, a):
            r"""
            The image of the element `a` of `KL` in ``self``.

            EXAMPLES::

                sage: HH = DoubleAffineHeckeAlgebraSansDuality("A2")
                sage: T_L = HH.T_L()
                sage: KL = T_L.factor(1)
                sage: a = KL.an_element(); a
                X[(2, 2, 3)]
                sage: b = T_L.L_morphism(a); b
                X[(2, 2, 3)]
                sage: b.parent()
                T_L basis of The double affine Hecke algebra of type ['A', 2, 1]

            """
            return self.factor_embedding(1)(a)

        def T_morphism(self, a):
            r"""
            The image of the element `a` of `T` in ``self``.

            EXAMPLES::

                sage: HH = DoubleAffineHeckeAlgebraSansDuality("A2")
                sage: T_L = HH.T_L()
                sage: T = T_L.factor(0)
                sage: a = T.an_element(); a
                2*TX[0] + 3*TX[0,1] + 1 + TX[0,1,2] + 4*piX[1] TX[0] + 6*piX[1] TX[0,1] + 2*piX[1] + 2*piX[1] TX[0,1,2] + 8*piX[2] TX[0] + 12*piX[2] TX[0,1] + 4*piX[2] + 4*piX[2] TX[0,1,2]
                sage: b = T_L.T_morphism(a); b
                2*TX[0] + 3*TX[0,1] + 1 + TX[0,1,2] + 4*piX[1] TX[0] + 6*piX[1] TX[0,1] + 2*piX[1] + 2*piX[1] TX[0,1,2] + 8*piX[2] TX[0] + 12*piX[2] TX[0,1] + 4*piX[2] + 4*piX[2] TX[0,1,2]
                sage: b.parent()
                T_L basis of The double affine Hecke algebra of type ['A', 2, 1]                

            """
            return self.factor_embedding(0)(a)

        def from_reduced_word(self, word):
            r"""
            Given a reduced word for an element `w` in the affine Weyl group of `L`, return the image of the basis element `T_w`
            in ``self``.

            EXAMPLES::

                sage: DoubleAffineHeckeAlgebraSansDuality("A2").T_L().from_reduced_word([0,2,1])
                TX[0,2,1]

            """
            return self.T_morphism(self.factor(0).from_reduced_word(word))



    class DoubleAffineHeckeAlgebraSansDualityL_tv_Lv(SmashProductAlgebra, _Bases):
        r"""
        DAHA basis L_tv_Lv.

        INPUT:

        - `HH` -- DAHA realization parent

        EXAMPLES::

            sage: DoubleAffineHeckeAlgebraSansDuality("A2").L_tv_Lv()
            L_tv_Lv basis of The double affine Hecke algebra of type ['A', 2, 1]


        """

        def __init__(self, HH):
            dat = HH.double_affine_type()
            # To define the product on L_tv_Lv we just coerce to L_T and back.
            # That is, we define the twist for L_tv_Lv in terms of the twist for L_T.
            mcat = ModulesWithBasis(HH.base_ring())
            tmcat = mcat.TensorProducts()
            KL = HH._KL
            coerceoid = tensor([HH.T().coerce_map_from(HH.tv_Lv()), KL._identity_map()], category=tmcat)
            idocoerce = tensor([KL._identity_map(), HH.tv_Lv().coerce_map_from(HH.T())], category=tmcat)

            HH._twist_L_tv_Lv = SetMorphism(Hom(HH._tvLvoL,HH._LotvLv,mcat),idocoerce * HH.L_T().twist() * coerceoid)

            SmashProductAlgebra.__init__(self, HH._KL, HH.tv_Lv(), twist_morphism=HH._twist_L_tv_Lv, category=Category.join((HH._BasesCategory(),AlgebrasWithBasis(HH.base_ring()).TensorProducts())))
            self._style = "L_tv_Lv"

        def _repr_(self):
            HH = self.realization_of()
            return "%s basis of %s"%(self._style, HH._repr_())

        def L_morphism(self, a):
            r"""
            The image of the element `a` of `KL` in ``self``.

            EXAMPLES::

                sage: HH = DoubleAffineHeckeAlgebraSansDuality("A2")
                sage: L_tv_Lv = HH.L_tv_Lv()
                sage: KL = HH.L_algebra()
                sage: a = KL.an_element(); a
                X[(2, 2, 3)]
                sage: b = L_tv_Lv.L_morphism(a); b
                X[(2, 2, 3)]
                sage: b.parent()
                L_tv_Lv basis of The double affine Hecke algebra of type ['A', 2, 1]
            """
            return self.factor_embedding(0)(a)


        def Lv_morphism(self, a):
            r"""
            The embedding of the group algebra of `Lv` into ``self``.

            EXAMPLES::

                sage: HH=DoubleAffineHeckeAlgebraSansDuality("A2")
                sage: KLv = HH.Lv_algebra()
                sage: a = KLv.an_element(); a
                Y[(2, 2, 3)]
                sage: a.parent()
                Group algebra of the Ambient space of the Root system of type ['A', 2] over Fraction Field of Multivariate Polynomial Ring in q, v, vl, v0, v2, vz over Rational Field
                sage: L_tv_Lv = HH.L_tv_Lv()
                sage: b = L_tv_Lv.Lv_morphism(a); b
                Y[(2, 2, 3)]
                sage: b.parent()
                L_tv_Lv basis of The double affine Hecke algebra of type ['A', 2, 1]

            """
            return self.factor_embedding(1)(self.factor(1).factor_embedding(1)(a))

        def tv_morphism(self, a):
            r"""
            Returns the image of `a` from the finite Hecke algebra "tv" of dual type, to ``self``.

            EXAMPLES::

                sage: HH = DoubleAffineHeckeAlgebraSansDuality("A2")
                sage: tv_Lv = HH.tv_Lv()
                sage: tv = HH.tv()
                sage: a = tv.an_element(); a
                Ty[1,2,1] + 3*Ty[1,2] + 3*Ty[2,1]
                sage: L_tv_Lv = HH.L_tv_Lv()
                sage: b = L_tv_Lv.tv_morphism(a); b
                Ty[1,2,1] + 3*Ty[1,2] + 3*Ty[2,1]
                sage: b == L_tv_Lv(a)
                True
            """
            return self.factor_embedding(1)(self.factor(1).factor_embedding(0)(a))

        def from_reduced_word_dual(self, word):
            r"""
            Given a reduced word for an element `w` in the classical Weyl group of `Lv`, return the image of the basis element `T_w`
            in ``self``.

            EXAMPLES::

                sage: DoubleAffineHeckeAlgebraSansDuality("A2").T_L().from_reduced_word_dual([2,1])
                TX[2,1]
            """
            return self.factor_embedding(1)(self.factor(1).from_reduced_word(word))

