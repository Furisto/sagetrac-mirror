#*****************************************************************************
#       Copyright (C) 2014 Mark Shimozono <mshimo at vt.edu>
#
#  Distributed under the terms of the GNU General Public License (GPL)
#                  http://www.gnu.org/licenses/
#*****************************************************************************
#
# Double affine Hecke algebras
#
################################

import functools

from sage.structure.parent import Parent
from sage.structure.unique_representation import UniqueRepresentation
from sage.misc.abstract_method import abstract_method
from sage.misc.bindable_class import BindableClass
from sage.misc.cachefunc import cached_method
from sage.misc.functional import is_even
from sage.categories.algebras_with_basis import AlgebrasWithBasis
from sage.categories.category import Category
from sage.categories.homset import Hom
from sage.categories.modules_with_basis import ModulesWithBasis
from sage.categories.morphism import SetMorphism
from sage.categories.realizations import Category_realization_of_parent, Realizations
from sage.categories.tensor import tensor
from sage.sets.family import Family, FiniteFamily
from sage.sets.set import Set
from sage.rings.rational_field import QQ
from sage.rings.integer_ring import ZZ
from sage.algebras.multiparameter_hecke_algebra import MultiParameterHeckeAlgebra, ParameterFamilies
from sage.algebras.smash_product_algebra import SmashProductAlgebra
from sage.algebras.affine_hecke_algebra import ExtendedAffineHeckeAlgebra
from sage.modules.free_module_element import vector
from sage.structure.sage_object import SageObject

class DoubleAffineType(SageObject):
    r"""
    Class which specifies a double affine Hecke algebra
    of not-necessarily-reduced possibly-extended affine type.

    INPUT:

        - ``cartan_type`` -- An irreducible finite Cartan type
        - ``untwisted`` -- True or False (default: True); whether to use the untwisted or twisted affinization
        - ``reduced`` -- True or False (default: True); whether the affine root system is reduced
        - ``dual_reduced`` -- True or False (default: True); whether the "dual" affine root system is reduced
        - ``general_linear`` -- True or False (default: None, meaning False); if the root system is untwisted affine type A, \
          use the weight lattice of the general linear group
        - ``parameters`` -- keyword arguments for parameters

    EXAMPLES::

        sage: DoubleAffineType("A1")
        Double Affine Type ['A', 1, 1] reduced dual-reduced
        sage: DoubleAffineType(['C',3], untwisted=True, reduced=False, dual_reduced=True)
        Double Affine Type ['C', 3, 1] reduced dual-reduced
        sage: DoubleAffineType(['F',4], untwisted=False, reduced=True, dual_reduced=False)
        Double Affine Type ['F', 4, 1]^* relabelled by {0: 0, 1: 4, 2: 3, 3: 2, 4: 1} reduced dual-reduced
        sage: K = QQ['q,v,vl,v0,v2,vz'].fraction_field()
        sage: q,v,vl,v0,v2,vz = K.gens()
        sage: DoubleAffineType(['B',2], untwisted=False, reduced=False, dual_reduced=False, null_root=q,short=v,long=vl,zero=v0,doubled=v2,zero_doubled=vz)
        Double Affine Type ['C', 2, 1]^* nonreduced nondual-reduced
        sage: DoubleAffineType(['A',2], general_linear=True)
        Double Affine Type GL(3) reduced dual-reduced

    ..RUBRIC:: Untwisted, dual untwisted, and mixed.

    There is a trichotomy of irreducible affine Cartan types: untwisted, dual untwisted (meaning the dual of an
    untwisted affine type) and mixed. The mixed types, `A_{2n}^{(2)}` and its dual, are the ones with three root lengths.

    ..RUBRIC:: Pair of affine Cartan types `\tilde{X}` and `\tilde{Y}`

    The inputs ``cartan_type`` and ``untwisted`` determine a pair of affine Cartan types `\tilde{X}` and `\tilde{Y}`
    which are both untwisted or both dual untwisted. Define

        - `X` -- The irreducible reduced finite Cartan type given by ``cartan_type``

        - `\tilde{X} -- if ``untwisted``, the untwisted affinization of `X`; otherwise, obtained from `X` by taking the dual, then the untwisted affinization, then the affine dual.

        - `W_a(\tilde{X})` -- The nonextended affine Weyl group of type `\tilde{X}`. It is generated by the simple reflections `s_i` for `i` in the affine Dynkin node set `I^X`.

        - `R_{red}(\tilde{X})` -- The set of affine real roots for the reduced affine root system. It is the set of affine root lattice elements of the form `u \alpha_i` where `u \in W_a(\tilde{X})` and `\alpha_i` is a simple root for `i \in I^X`.

        - `Y` -- Equal to `X` if not ``untwisted``; otherwise the dual of `X`

        - `\tilde{Y}` -- Equal to `\tilde{X}` if not ``untwisted``; otherwise the untwisted affinization of `Y`
        
    `W_a(\tilde{Y})` and `R_{red}(\tilde{Y})` are analogously defined.

    Since `X` and `Y` are either equal or dual, there is a natural bijection between their classical
    Dynkin node sets `I^X_0 = I^X \setminus \{0^X\}` and `I^Y_0`. This induces an isomorphism `W(X)\cong W(Y)` of
    the finite Weyl groups.

    ..RUBRIC:: Extended affine Weyl groups

    See :meth:`sage.combinat.root_system.ExtendedAffineWeylGroup` for definitions for extended affine Weyl groups.
    Define

        - `W_e(\tilde{X})` -- The extended affine Weyl group of type `\tilde{X}`.

        - `F^X` -- The fundamental group of `W_e(\tilde{X})` of length zero elements.

    Using the notation `W` for either of the isomorphic groups `W(X)` or `W(Y)` and letting
    `Q^Y` and `P^Y` be the root and weight lattices of type `Y`, there are isomorphisms

    ..MATH::

        W_a(\tilde{X}) \cong W \ltimes Q^Y \\
        W_e(\tilde{X}) \cong W \ltimes P^Y \cong F^X \ltimes W_a(\tilde{X})

    Note: The usual convention in the untwisted case is to use the coroot and coweight lattices of type `X`.

    The group `F^X` acts on `W_a(\tilde{X})` by the group automorphisms

    ..MATH::

        \pi^X s^X_i (\pi^X)^{-1} = s^X_{\pi^X(i)}

    for all `\pi^X \in F^X` and `i \in I^X` where the affine Dynkin automorphism `\pi^X` is regarded as a
    permutation of `I^X`. Similarly we have

    ..MATH::

        W_a(\tilde{Y}) \cong W \ltimes Q^X \\
        W_e(\tilde{Y}) \cong W \ltimes P^X \cong F^Y \ltimes W_a(\tilde{Y})

    ..RUBRIC:: Affine Hecke algebra `H(W_a(\tilde{X}))`

    Let `K` be a commutative ring. For `i \in I^X` let `v_{\alpha_i^X} \in K` be an invertible element.
    They must satisfy `v_{\alpha_i^X} = v_{\alpha_j^X}` if `\alpha_i^X` and `\alpha_j^X` are in the
    same `W_a(\tilde{X})`-orbit. The mnemonic for these parameters is `v^X`.

    The Hecke algebra `H(W_a(\tilde{X});v^X)` is the `K`-algebra with algebra generators
    `T^X_i` for `i \in I^X` with the `T^X_i` satisfying the same braid relations as the
    `s^X_i` do in `W_a(\tilde{X})`, together with the quadratic relations

    ..MATH::

        (T^X_i - v_{\alpha_i^X})(T^X_i + v_{\alpha_i^X}^{-1}) = 0

    for all `i \in I^X`.

    For `w \in W_a(\tilde{X})` let `w=s^X_{i_1}\dotsm s^X_{i_l}` be a reduced expression
    (one with `l` minimal) where `i_1,\dotsc,i_l \in I^X`. There is a well-defined element

    ..MATH::

        T^X_w = T^X_{i_1} \dotsm T^X_{i_l}.

    These form a `K`-basis of `H(W_a(\tilde{X}))`.

    ..RUBRIC:: Extended affine Hecke algebra of `W_e(\tilde{X})`

    Let `K` and `v_{\alpha_i^X}` be as for `H(W_a(\tilde{X}))` except that we impose the additional
    condition that `v_{\alpha_i^X} = v_{\alpha_j^X}` if `\alpha_i^X` and `\alpha_j^X` are in the
    same `W_e(\tilde{X})`-orbit (as opposed to the same `W_a(\tilde{X})`-orbit).
    Recalling that `W_e(\tilde{X}) \cong F^X \ltimes W_a(\tilde{X})`,
    the extended affine Hecke algebra `H(W_e(\tilde{X}),v^X)` is linearly the tensor product

    ..MATH::

        K[F^X] \otimes H(W_a(\tilde{X}),v^X)

    where `K[F^X]` is the group algebra, and `K[F^X]` acts on `H(W_a(\tilde{X}),v^X)` by

    ..MATH::

        \pi^X T^X_i (\pi^X)^{-1} = T^X_{\pi^X(i)}.

    for all `\pi^X \in F^X` and `i \in I^X`.

    Let `v \in W_e(\tilde{X})` be written `v = \pi^X w` with `\pi^X \in F^X` and `w \in W_a(\tilde{X})`.
    `H(W_e(\tilde{X}))` has a basis given by the elements

    ..MATH::

        T^X_v = \pi^X T^X_w.

    ..RUBRIC:: Not-necessarily-reduced affine root systems

    The pair of boolean inputs ``reduced`` and ``dual_reduced`` affects the choice of root versus weight lattices,
    nonextended and extended affine Weyl groups, and nonreduced versus reduced root systems.

    A node `i \in I^X` is *doubleable* if the evaluation `\alpha_i^\vee(\alpha_j)`
    of the `i`-th simple coroot `\alpha_i^\vee` on the `j`-th simple root, is even for all `j \in I^X`.

    Here are some examples of affine cartan types and their sets of doubleable nodes::

        sage: CartanType(['A',1,1]).doubled_nodes()
        (0, 1)
        sage: CartanType(['A',2,1]).doubled_nodes()
        ()
        sage: CartanType(['B',3,1]).doubled_nodes()
        (3,)
        sage: CartanType(['D',4,2]).doubled_nodes()
        (0, 3)
        sage: CartanType(['C',2,1]).doubled_nodes()
        (1,)
        sage: CartanType(['C',3,1]).doubled_nodes()
        ()

    Fact: The only untwisted or dual untwisted affine root systems
    with doubleable nodes, are `A_1^{(1)}` nodes `0,1`; `C_2^{(1)}` node `1`; `B_n^{(1)}` node `n`;
    and `D_{n+1}^{(2)}`, nodes `0,n`.

    ..RUBRIC: Notation

        - `S^X` -- if the input ``reduced`` is False, the set of doubleable nodes in `I^X`;
        otherwise, the empty set. We call this is the set of doubled nodes.
        - `R(\tilde{X})` -- the union of `R_{red}(\tilde{X})` with the elements `u (2\alpha_i)` 
        for `u \in W_a(\tilde{X})` and `i \in S^X`. This is the not-necessarily reduced
        affine root system.

    We say that `R(\tilde{X})` is reduced if it equals `R_{red}(\tilde{X})` (that is, `S^X` is empty)
    and is nonreduced otherwise. Even if ``reduced`` is set to False, if there are no
    doubleable nodes then `R(\tilde{X})` is still reduced.
     
    `S^Y` and `R(\tilde{Y})` are defined analogously, using `\tilde{Y}` instead of `\tilde{X}` and the input boolean
    ``dual_reduced`` instead of ``reduced``.

    ..RUBRIC:: Lattices `X` and `Y` and possibly extended affine Weyl groups `W(\tilde{X})` and `W(\tilde{Y})`

        - `X` -- By abuse of notation this symbol stands for the weight lattice `P^X` if `R(\tilde{Y})` is reduced (no typo with
          the Y here); otherwise, for the root lattice `Q^X`.

        - `\tilde{X}` -- This stands for the direct sum of the lattice `X` with the integer multiples of the affine null root
          `\delta^X`. It is a sublattice of the level-zero part of the affine weight lattice.

        - `W(\tilde{X})` -- If `R(\tilde{Y})` is reduced, this is the extended affine Weyl group `W_e(\tilde{X})`, and otherwise it is the nonextended affine Weyl group `W_a(\tilde{X})`.

        - `Y`, `\tilde{Y}`, `W(\tilde{Y})` -- Defined analogously with the roles of `X` and `Y` interchanged.

    Observe that the lattice `Y` (resp. `X`) provides the translation elements for the "other" affine Weyl group
    `W(\tilde{X})` (resp. `W(\tilde{Y})`):

    ..MATH::

        W(\tilde{X}) \cong W(Y) \ltimes Y
        W(\tilde{Y}) \cong W(X) \ltimes X

    Let `\Pi^X \subset F^X` be the trivial subgroup if `R(\tilde{Y})` is nonreduced and otherwise let `\Pi^X=F^X`.
    Make similar definitions for `\Pi^Y \subset F^Y`. Then

    ..MATH::

        W(\tilde{X}) \cong \Pi^X \ltimes W_a(\tilde{X})
        W(\tilde{Y}) \cong \Pi^Y \ltimes W_a(\tilde{Y})

    ..RUBRIC:: The base ring `K` of the DAHA and parameters

    We assume `K` is a commutative ring and `QQ`-algebra.

    For every `i \in I^X` there is an invertible element `v_{\alpha_i^X}\in K` and
    for every `i \in S^X` an invertible element `v_{2\alpha_i^X} \in K`.
    For convenience we define `v_{2\alpha_i^X}=v_{\alpha_i^X}` for `i \in I^X \setminus S^X`.
    They must satisfy the compatibility that `v_\alpha=v_\beta` if `\alpha` and `\beta` are in the
    same `W(\tilde{X})`-orbit in `R(\tilde{X})`.

    Finally, there is an invertible element `q \in K`. It represents the exponential of the null root
    `\delta^X` and also the exponential of `-\delta^Y`.
    Under this identification there are group homomorphisms
    `\tilde{X} \to K[X]` and `\tilde{Y} \to K[Y]`. We assume `q` is transcendental over `QQ` so that these maps are injective.
    In particular it makes sense to refer to `X^{\alpha_0^X} \in K[X]`.
    
    There is also an action of `W(\tilde{X})` on `K[X]` by `K`-algebra automorphisms:

    ..MATH::

        \begin{align*}
            s^X_i \cdot X^\lambda &= X^{s^X_i(\lambda)} \\
            \pi^X \cdot X^{\alpha_i^X} &= X^{\alpha_{\pi^X(i)}}
        \end{align*}

    where `i \in I^X`, `\lambda \in \tilde{X}`, and `\pi^X \in F^X`. 
    The action of `s^X_0` involves `q` since `\alpha^X_0` does.
    The action of `\Pi^X` has only been defined on the affine root lattice,
    which is only a sublattice of `\tilde{X}`, but this sublattice spans over
    the rationals. The action of `\Pi^X` can also involve `q`.

    ..RUBRIC:: The possibly-extended affine Hecke algebra `H(W(\tilde{X}))`.

    Define the possibly extended affine Hecke algebra `H(W(\tilde{X}))` to be `H(W_e(\tilde{X}))` or
    `H(W_a(\tilde{X}))` according as `W(\tilde{X})` equals `W_e(\tilde{X})` or `W_a(\tilde{X})`.

    ..RUBRIC:: The DAHA, at last!

    Linearly it is the tensor product

    ..MATH::

        H(X,Y;v^X) = H(W(\tilde{X}),v^X) \otimes K[X]

    To define the product it is enough to specify the commutation of the `T^X_i` with `X^\lambda`
    for `i \in I^X` and `\lambda \in X`. This is achieved using the very interesting Demazure-Lusztig operators.

    For nondoubled nodes `i \in I^X \setminus S^X` we have

    ..MATH::

        T^X_i X^\lambda - X^{s_i^X(\lambda)} T^X_i = (v_{\alpha_i^X} - v_{\alpha_i^X}^{-1})
            \dfrac{X^\lambda - X^{s_i^X(\lambda)}}{1 - X^{\alpha_i^X}}

    For doubled nodes `i \in S^X` we have

    ..MATH::

        T^X_i X^\lambda - X^{s_i^X(\lambda)} T^X_i =
            (v_{\alpha_i^X} - v_{\alpha_i^X}^{-1} + (v_{2\alpha_i^X} - v_{2\alpha_i^X}^{-1})X^{\alpha_i^X}
            \dfrac{X^\lambda - X^{s_i^X(\lambda)}}{1 - X^{2 \alpha_i^X}}

    In particular it follows that the DAHA `H(X,Y;v^X)` has bases of the form

    ..MATH::

        T_v X^\lambda \qquad\text{ and }\qquad X^\lambda T_v

    where `v \in W(\tilde{X})` and `\lambda \in X`. We call these bases the "TX_X" and "X_TX" bases respectively.

    ..RUBRIC:: Dual Hecke parameters

    Recall the parameters `v_{\alpha_i^X}` and `v_{2\alpha_i^X}`. 
    Recall that `v_{2\alpha_i^X} = v_{\alpha_i^X}` if `i \in I^X \setminus S^X`.

    The "dual Hecke parameters" are the following relabelling of the Hecke
    parameters::

        - `v_{\alpha_i^Y} = v_{\alpha_i^X}` -- for `i\ne 0`, 
        - `v_{\alpha_0^Y} = v_{2\alpha_r^X}` -- for `r \in I^X \setminus\{0\}` with `\alpha_r^X` short
        - `v_{2\alpha_i^Y} = v_{\alpha_0^X}` -- if `i \in S^Y\setminus \{0\}`
        - `v_{2\alpha_0^Y} = v_{2\alpha_0^X}` -- if `0 \in S^Y`

    where `v_{2\alpha_i^Y} = v_{\alpha_i^Y}` if `i \in I^Y \setminus S^Y`.
    The parameters `v_{\alpha_i^Y}` and `v_{2\alpha_i^Y}` are collectively labeled `v^Y`.

    ..RUBRIC:: Dual presentation of the DAHA

    The DAHA `H(X,Y;v^X)` has a `K`-algebra isomorphism

    ..MATH::

        H(X,Y;v^X) \cong H(W(\tilde{Y});v^Y) \otimes K[Y]

    We first give the commutation between `T^Y_i` and `Y^\lambda` to define the multiplication on
    the right hand side, and then describe the preimages of the right hand side's generators.

    For `i \in I^Y \setminus S^Y` and `\lambda \in Y` we have

    ..MATH::

        T^Y_i Y^\lambda - Y^{s_i^Y(\lambda)} T^Y_i = (v_{\alpha_i^Y} - v_{\alpha_i^Y}^{-1})
            \dfrac{Y^\lambda - X^{s_i^Y(\lambda)}}{1 - Y^{-\alpha_i^Y}}

    which looks like the `X`-analogue except for the `-\alpha_i^Y`.
    For doubled nodes `i \in S^Y` we have

    ..MATH::

        T^Y_i Y^\lambda - Y^{s_i^Y(\lambda)} T^Y_i =
            (v_{\alpha_i^Y} - v_{\alpha_i^Y}^{-1} + (v_{2\alpha_i^Y} - v_{2\alpha_i^Y}^{-1})Y^{-\alpha_i^Y}
            \dfrac{Y^\lambda - Y^{s_i^Y(\lambda)}}{1 - Y^{- 2 \alpha_i^Y}}

    For nonzero `i` we have `T^Y_i = T^X_i`. We have

    ..MATH::

        T^Y_0 = (X^\varphi T_{s_{\varphi}})^{-1}

    where `\varphi \in X` is the dominant short root (its associated coroot is the highest coroot).
    
    For `\pi_i^Y \in \Pi^Y` where `i` is a special node in `I^Y`, if `i=0^Y` then `\pi_i^Y` is the identity.
    For `i \ne 0^Y` let `\omega_i^X` be the `i`-th fundamental weight and `u_i \in W(X)` the shortest element
    such that `u_i(\omega_i)` is antidominant. Then

    ..MATH::

        \pi^Y_i = X^{\omega_i^X} T_{u_i^{-1}}.

    In particular it follows that the DAHA `H(X,Y;v^X)` has bases of the form

    ..MATH::

        T_v Y^\lambda \qquad\text{ and }\qquad Y^\lambda T_v

    where `v \in W(\tilde{Y})` and `\lambda \in Y`. We call these bases the "TY_Y" and "Y_TY" bases respectively.

    ..RUBRIC:: Bases

    Using the isomorphism `K[X] \otimes H(W) \cong H(W(\tilde{Y}))`
    of the type `\tilde{Y}` affine Hecke algebra, we have
    the following presentations of the DAHA.

        - "XT" -- `K[X] \otimes H(W(\tilde{X}))`
        - "XtyY" -- `K[X] \otimes H(W(X)) \otimes K[Y]`
        - "XtxY" -- `K[X] \otimes H(W(Y)) \otimes K[Y]`
        - "TY" -- `H(W(\tilde{Y})) \otimes K[Y]`

    Note that the classical Weyl groups `W(X)` and `W(Y)` are isomorphic.
    The DAHA has a basis corresponding to each of the permutations of the tensor factors
    of these forms. The various bases of the DAHA are implemented by smash product algebras.

    ..RUBRIC:: Implementation of Hecke parameters

    The default base ring is the field `K` given by

    ::

        sage: K = QQ['q,v,vl,v0,v2,vz'].fraction_field()
        sage: q,v,vl,v0,v2,vz = K.gens()

    This can be customized using the ``parameters`` option. Every parameter must be an invertible element of the
    base ring. The default parameters have the following names.

        - `q`  -- 'null_root'. Recall that `q=X^{\delta^X}= Y^{-\delta^Y}`)
        - `v`  -- 'short' (orbit of short `\alpha_i^X` for some nonzero `i`)
        - `vl` -- 'long' (orbit of long `\alpha_i^X` for some nonzero `i` if not simply-laced)
        - `v0` -- 'zero' (orbit of `\alpha_0^X`)
        - `v2` -- 'doubled' (orbit of `2\alpha_i^X` for nonzero doubled node `i`)
        - `vz` -- 'zero_doubled' (orbit of `2\alpha_0^X`)

    In any given case only some of these parameters are used and often they may have the same value.

    EXAMPLES::

        sage: K = QQ['q,v'].fraction_field()
        sage: q,v=K.gens()
        sage: dat = DoubleAffineType(['A',2], untwisted=True, reduced=True, dual_reduced=True, null_root=q, short=v)
        sage: dat.parameter('short')
        v
        sage: dat.parameter('long')
        Traceback (most recent call last):
        ...
        ValueError: No parameter 'long'
        sage: K = QQ['q,v,vl,v0,v2,vz'].fraction_field()
        sage: q,v,vl,v0,v2,vz=K.gens()
        sage: dat = DoubleAffineType(['B',2], untwisted=False, reduced=False, dual_reduced=False, null_root=q,short=v,long=vl,zero=v0,doubled=v2,zero_doubled=vz)
        sage: dat.parameter('null_root')
        q
        sage: dat.parameter('doubled')
        v2
        sage: dat.parameter('zero')
        v0
        sage: dat.parameter('zero_doubled')
        vz

    REFERENCES:

    .. [Haiman_ICM] M. Haiman, Cherednik algebras, Macdonald polynomials and combinatorics,
       Proceedings of the International Congress of Mathematicians,
       Madrid 2006, Vol. III, 843-872.
    """
    
    def __init__(self, cartan_type, untwisted=True, reduced=True, dual_reduced=True, general_linear=False, **parameters):
        from sage.combinat.root_system.cartan_type import CartanType
        self._cartan_type_classical = CartanType(cartan_type)
        if not self._cartan_type_classical.is_finite():
            raise ValueError, "Cartan type is not finite"
        if self._cartan_type_classical.rank() == 1:
            self._cartan_type_classical = CartanType(['A',1])
        # check that parameters are invertible
        for par_name in parameters.keys():
            try:
                (parameters[par_name])**(-1)
            except ZeroDivisionError:
                raise ValueError, "Parameters must be invertible"
        if self._cartan_type_classical.is_simply_laced():
            # in simply-laced type, override `untwisted`
            self._untwisted = True
        else:
            self._untwisted = untwisted
        if untwisted:
            self._cartan_type = self._cartan_type_classical.affine()
            self._other_affine_type = self._cartan_type_classical.dual().affine()
        else:
            self._cartan_type = self._cartan_type_classical.dual().affine().dual()
            self._other_affine_type = self._cartan_type

        I = self._cartan_type.index_set()
        cartan_matrix = self._cartan_type.cartan_matrix()
        # Compute the set of doubled nodes for \tilde{X}
        if reduced:
            self._doubled_nodes = tuple([])
        else:
            # uses that the index set starts with 0
            self._doubled_nodes = self._cartan_type.doubled_nodes()

        self._reduced = (len(self._doubled_nodes) == 0)
        self._node_is_doubled = Family(I, lambda x: x in self._doubled_nodes)

        # Compute whether \tilde{Y} is reduced.
        if dual_reduced:
            self._dual_reduced = True
        else:
            self._dual_reduced = (len(self._other_affine_type.doubled_nodes()) == 0)

        # general linear root data
        if general_linear:
            if untwisted and self._cartan_type.type() == 'A' and self._reduced and self._dual_reduced:
                self._general_linear = True
                self._n = self._cartan_type.n + 1
            else:
                raise ValueError, "General linear double affine data should be untwisted type A, reduced, and dual-reduced"
        else:
            self._general_linear = False

        # Make the extended affine Weyl group W_e(\tilde{X})
        from sage.combinat.root_system.extended_affine_weyl_group import ExtendedAffineWeylGroup
        self._E = ExtendedAffineWeylGroup(self._cartan_type, general_linear = self._general_linear, fundamental="")
        # Specify the subgroup of allowable special affine Dynkin automorphisms `\Pi^X`.
        if self._dual_reduced:
            # Set `\Pi^X = F^X`
            self._special_nodes = self._E.special_nodes()
        else:
            # Set `\Pi^X = \{0\}`
            self._special_nodes = tuple([0])

        # establish the specialization of Hecke parameters by computing
        # W(\tilde{X}) orbits of simple roots and their doubles
        vi = dict()
        v2i = dict()

        I0 = self._cartan_type_classical.index_set()
        # set the v_{\alpha_i} for i nonzero
        if self._cartan_type_classical.is_simply_laced():
            # for one root length we call it short for the purposes of the parameters.
            for i in I0:
                vi[i] = 'short'
        else:
            root_lattice = self._cartan_type_classical.root_system().root_lattice()
            for i in I0:
                vi[i] = 'short' if root_lattice.simple_root(i).is_short_root() else 'long'
        # set v_{\alpha_0}
        if self._general_linear:
            vi[0] = vi[1]
        elif len(self._special_nodes) >= 2:
            # \alpha_0 is in the orbit of another simple root by a Dynkin automorphism in W(\tilde{X})
            vi[0] = vi[self._special_nodes[1]]
        else:
            # check the attachment bond of 0 
            for i in I0:
                a0i = cartan_matrix[0,i]
                if a0i != 0:
                    break
            if a0i * cartan_matrix[i,0] == 1:
                # simple bond, and `\alpha_0` and `\alpha_i` are in the same orbit
                vi[0] = vi[i]
            else:
                # double bond, and `\alpha_0` is not in the orbit of any other simple root
                vi[0] = 'zero'

        # make v_{2\alpha_i}
        for i in I:
            v2i[i] = vi[i]

        # there are at most two doubled nodes and if there are two, one must be 0.
        for i in self._doubled_nodes:
            v2i[i] = 'zero_doubled' if i == 0 else 'doubled'

        # for BC with the nontrivial Dynkin automorphism allowed, 2\alpha_0 is in the orbit of 2\alpha_n.
        if 0 in self._doubled_nodes and self._dual_reduced:
            v2i[0] = 'doubled'

        # dictionaries for the orbits of simple (possibly doubled) roots under W(\tilde{X}).
        self._vi = Family(I, lambda i: vi[i])
        self._v2i = Family(I, lambda i: v2i[i])
        self._orbits = Set([self._vi[i] for i in I]+[self._v2i[i] for i in I])

        if 'null_root' in parameters.keys():
            q = parameters['null_root']
            K = q.parent()
            param_dict = dict({'null_root':q})
            for orbit in self._orbits:
                if orbit not in parameters.keys():
                    raise ValueError, "There is no parameter supplied for the orbit %s"%orbit
                else:
                    param_dict[orbit] = parameters[orbit]
                    if param_dict[orbit] not in K:
                        raise ValueError, "The parameter %s supplied for the orbit %s is not in the parent of %s"%(param_dict[orbit],orbit,q)
                        
            self._parameters = Family(dict([[key, param_dict[key]] for key in param_dict.keys()]))
        else:
            K = QQ['q,v,vl,v0,v2,vz'].fraction_field()
            param_dict = dict({'null_root':K.gen(0),'short':K.gen(1),'long':K.gen(2),'zero':K.gen(3),'doubled':K.gen(4),'zero_doubled':K.gen(5)})
            self._parameters = Family(dict([[root_type, param_dict[root_type]] for root_type in Set(['null_root'])+self._orbits]))
        self._base_ring = K

        self._q1 = Family(dict([[i, self._parameters[self._vi[i]]] for i in I]))
        self._q2 = Family(dict([[i, -1/self._q1[i]] for i in I]))
        if self._general_linear:
            self._m = self._n
        else:
            self._m = len(self._special_nodes)

    def __repr__(self):
        def non_string(str, bool):
            if bool:
                return str
            return "non"+str
        return "Double Affine Type %s %s %s"%(self._cartan_type if not self._general_linear else "GL(%s)"%self._n, non_string("reduced", self._reduced), non_string("dual-reduced", self._dual_reduced))

    def untwisted(self):
        return self._untwisted

    def reduced(self):
        r"""
        Is ``self`` reduced?

        EXAMPLES::

            sage: DoubleAffineType(['B',2], untwisted=False, reduced=True, dual_reduced=False).reduced()
            True
            sage: DoubleAffineType(['B',2], untwisted=False, reduced=False, dual_reduced=False).reduced()
            False
            sage: DoubleAffineType(['A',2], untwisted=False, reduced=False, dual_reduced=False).reduced()
            True

        """
        return self._reduced

    def dual_reduced(self):
        r"""
        Is the DAHA dual of ``self`` reduced?

        EXAMPLES::

            sage: DoubleAffineType(['B',2], untwisted=False, reduced=False, dual_reduced=True).dual_reduced()
            True
            sage: DoubleAffineType(['B',2], untwisted=False, reduced=False, dual_reduced=False).dual_reduced()
            False
            sage: DoubleAffineType(['A',2], untwisted=False, reduced=False, dual_reduced=False).dual_reduced()
            True

        """
        return self._dual_reduced

    def properly_extended(self):
        r"""
        Does the group `W(\tilde{X})` have any nontrivial affine Dynkin automorphisms?

        EXAMPLES::

            sage: DoubleAffineType(['A',2]).properly_extended()
            True
            sage: DoubleAffineType(['A',1], dual_reduced=False).properly_extended()
            False
            sage: DoubleAffineType(['B',2], untwisted=False, reduced=False, dual_reduced=True).properly_extended()
            True
            sage: DoubleAffineType(['B',2], untwisted=False, reduced=False, dual_reduced=False).properly_extended()
            False

        """
        return len(self.special_nodes()) > 1

    def base_ring(self):
        return self._base_ring

    def doubled_nodes(self):
        r"""
        The set of doubled nodes of type `X`.

        EXAMPLES::

            sage: DoubleAffineType(['B',2], untwisted=False, reduced=False, dual_reduced=False).doubled_nodes()
            (0, 2)

        """
        return self._doubled_nodes

    def cartan_type(self):
        r"""
        The affine Cartan type of ``self``.

        EXAMPLES::

            sage: DoubleAffineType(['B',2], untwisted=False, reduced=True, dual_reduced=False).cartan_type()
            ['C', 2, 1]^*

        """
        return self._cartan_type

    def cartan_type_classical(self):
        r"""
        The finite Cartan type of ``self``.

        EXAMPLES::

            sage: DoubleAffineType(['B',2], untwisted=False, reduced=True, dual_reduced=False).cartan_type_classical()
            ['B', 2]

        """
        return self._cartan_type_classical

    def special_nodes(self):
        r"""
        Return the set of special nodes indexing length-zero elements of `W(\tilde{X})`.

        EXAMPLES::

            sage: DoubleAffineType(['A',3], untwisted=True, reduced=True, dual_reduced=True).special_nodes()
            (0, 1, 2, 3)
            sage: DoubleAffineType(['B',3], untwisted=True, reduced=True, dual_reduced=True).special_nodes()
            (0, 1)
            sage: DoubleAffineType(['B',3], untwisted=False, reduced=False, dual_reduced=False).special_nodes()
            (0,)
            sage: DoubleAffineType(['B',3], untwisted=False, reduced=False, dual_reduced=True).special_nodes()
            (0, 3)

        """
        return self._special_nodes

    def properly_extended(self):
        r"""
        Is the group `W(\tilde{X})` strictly larger than `W_a(\tilde{X})`?

        EXAMPLES::

            sage: DoubleAffineType(['A',3], untwisted=True, reduced=True, dual_reduced=True).properly_extended()
            True
            sage: DoubleAffineType(['F',4], untwisted=True, reduced=True, dual_reduced=True).properly_extended()
            False
            sage: DoubleAffineType(['B',3], untwisted=False, reduced=True, dual_reduced=False).properly_extended()
            False
            sage: DoubleAffineType(['A',3], general_linear=True).properly_extended()
            True
        """

        return self._general_linear or len(self._special_nodes) >= 2

    def parameter(self, param):
        r"""
        A parameter.

        EXAMPLES::

            sage: DoubleAffineType("B2",False,False,False).parameter('zero')
            v0
            sage: DoubleAffineType("B2",False,False,False).parameter('short')
            v
            sage: DoubleAffineType("B2",False,False,False).parameter('long')
            vl
            sage: DoubleAffineType("B2",False,False,False).parameter('zero_doubled')
            vz
            sage: DoubleAffineType("B2",False,False,False).parameter('doubled')
            v2
            sage: DoubleAffineType("B2",False,False,False).parameter('null_root')
            q
        """
        try:
            return self._parameters[param]
        except KeyError:
            raise ValueError, "No parameter '%s'"%param

    def parameters(self):
        r"""
        The parameters of ``self``.

        EXAMPLES::

            sage: DoubleAffineType("B2",False,False,False).parameters()
            Finite family {'zero_doubled': vz, 'short': v, 'doubled': v2, 'zero': v0, 'long': vl, 'null_root': q}

        """
        return self._parameters

    @cached_method
    def q(self):
        r"""
        The null root parameter.
        """
        return self.parameters()['null_root']

    @cached_method
    def v(self, i):
        r"""
        Family of parameters for nondoubled simple roots.
        """
        return self.parameters()[self._vi[i]]

    @cached_method
    def v2(self, i):
        r"""
        Family of parameters for doubled simple roots.
        """
        return self.parameters()[self._v2i[i]]

    def q1(self, i):
        return self._q1[i]

    def q2(self, i):
        return self._q2[i]

    def extended_affine_weyl(self):
        return self._E

    @cached_method
    def doubled_parameters(self):
        r"""
        A family on the set of doubled nodes whose values are the extra factor in the nonreduced Demazure-Lusztig operators.

        EXAMPLES::

            sage: DoubleAffineType("B2",untwisted=False,reduced=False,dual_reduced=False).doubled_parameters()
            Finite family {0: (vz^2 - 1)/vz, 2: (v2^2 - 1)/v2}

        """
        def diff_reciprocal(x):
            return x - 1/x
        return Family(dict([[i, diff_reciprocal(self.parameters()[self._v2i[i]])] for i in self.doubled_nodes()]))

    def dual(self):
        r"""
        The DAHA dual affine type.

        EXAMPLES::

            sage: dat = DoubleAffineType(['B',2], untwisted=True, reduced=False, dual_reduced=True); dat
            Double Affine Type ['B', 2, 1] nonreduced dual-reduced
            sage: dat.dual()
            Double Affine Type ['C', 2, 1] reduced nondual-reduced            

        """
        if self._untwisted:
            dual_classical_type = self.cartan_type_classical().dual()
        else:
            dual_classical_type = self.cartan_type_classical()
        # to dualize parameters, the roles of 'doubled' and 'zero' get exchanged
        dual_parameters = dict()
        for x in self._parameters.keys():
            if x == 'doubled':
                dual_parameters['zero'] = self._parameters['doubled']
            elif x == 'zero':
                dual_parameters['doubled'] = self._parameters['zero']
            else:
                dual_parameters[x] = self._parameters[x]
        if 'null_root' not in self._parameters.keys():
            dual_parameters['null_root'] = self.q()
        return DoubleAffineType(dual_classical_type, self._untwisted, self._dual_reduced, self._reduced, general_linear=self._general_linear, **dual_parameters)

class DoubleAffineHeckeAlgebraSansDuality(UniqueRepresentation, Parent):
    r"""
    The double affine Hecke algebra, with all its structure except duality.

    The bases that are supported by this class are:

    - "LT" -- `X^\mu \pi^X T_w` where `\pi^X` is in the fundamental group `F^X`, `w` is in the affine Weyl group `W_a(\tilde{X})`,
                   and `\mu` is in the lattice `X`
    - "TL" -- `\pi^X T_w X^\mu` 
    - "LtvLv" -- `X^\mu T_w Y^\nu` where `\mu \in X`, `w` is in the finite Weyl group `W(Y)`, and `\nu \in Y`.

    EXAMPLES::

        sage: HH = DoubleAffineHeckeAlgebraSansDuality(['A',2])
        sage: LT = HH.LT(); LT
        LT basis of The double affine Hecke algebra of type ['A', 2, 1]
        sage: m = LT.a_monomial(); m
        X[(2, 2, 3)] piX[2] TX[0,1,2]
        sage: TL = HH.TL(); TL
        TL basis of The double affine Hecke algebra of type ['A', 2, 1]
        sage: TL(m)
        ((q*v^2-q)/v)*piX[2] TX[0,1] X[(2, 2, 3)] + ((v^6-3*v^4+3*v^2-1)/(q^2*v^3))*piX[2] X[(2, 2, 3)] + ((-v^4+2*v^2-1)/(q^2*v^2))*piX[2] TX[2] X[(2, 2, 3)] + ((-v^4+2*v^2-1)/(q^2*v^2))*piX[2] TX[1] X[(2, 2, 3)] + ((v^2-1)/(q^2*v))*piX[2] TX[1,2] X[(2, 2, 3)] + q*piX[2] TX[0,1,2] X[(2, 3, 2)]
        sage: LtvLv = HH.LtvLv(); LtvLv
        LtvLv basis of The double affine Hecke algebra of type ['A', 2, 1]
        sage: LtvLv(m)
        X[(2, 2, 3)] Ty[2] Y[(0, 0, -1)]

    The first two have "native" product; the third has product via coercion with "LT".

    There is an input option ``dual_side`` which, if True, essentially applies a form of Macdonald duality:
    The interpretation of the bases become:

    - "LT" -- `Y^\mu \pi^Y T_w` where `\pi^Y` is in the fundamental group `F^Y`, `w` is in the affine Weyl group `W_a(\tilde{Y})`,
                   and `\mu` is in the lattice `Y`
    - "TL" -- `\pi^Y T_w Y^\mu` 
    - "LtvLv" -- `Y^\mu T_w X^\nu` where `\mu \in Y`, `w` is in the finite Weyl group `W(X)`, and `\nu \in X`.

    Other differences: 

    - The Demazure-Lusztig operators use the "dominant" convention unless ``dual_side`` is True, whence they use the
    "antidominant" convention
    - The null root parameter `q` is interpreted as the exponential of the null root `\delta^X` unless ``dual_side`` is True,
    in which case `q` is the exponential of `- \delta^Y`.

    By invoking this class with a double affine type and again with the dual double affine type,
    one obtains many realizations of the same DAHA. However the interaction between these two kinds of realizations
    requires additional machinery, which is included in a separate class.

    ..RUBRIC:: General Linear case

    Here the usual extended affine Hecke algebra of `SL_n` is replaced by that for `GL_n` and the
    group algebra of the weight lattice of `SL_n` is replaced by that of `GL_n`.

    """

    @staticmethod
    def __classcall_private__(cls, cartan_type, untwisted=True, reduced=True, dual_reduced=True, dual_side=False, general_linear=False, **parameters):
        from sage.combinat.root_system.cartan_type import CartanType
        cartan_type = CartanType(cartan_type)
        return super(DoubleAffineHeckeAlgebraSansDuality, cls).__classcall__(cls, cartan_type, untwisted, reduced, dual_reduced, dual_side, general_linear, **parameters)

    def __init__(self, cartan_type, untwisted, reduced, dual_reduced, dual_side, general_linear, **parameters):
        self._dat = DoubleAffineType(cartan_type, untwisted, reduced, dual_reduced, general_linear, **parameters)
        self._base_ring = self._dat._base_ring
        self._dual_dat = self._dat.dual()
        self._m = max(self._dat._m, self._dual_dat._m)
        assert self._dat._base_ring == self._dual_dat._base_ring, "The base ring (%s) of the double affine type does not agree with that (%s) of its dual"%(self._dat._base_ring, self._dual_dat._base_ring)

        self._general_linear = False
        if general_linear:
            ct = self._dat.cartan_type()
            if ct.is_untwisted_affine() and ct.type() == 'A' and self._dat.dual_reduced():
                self._general_linear = True
                self._n = ct.n + 1

        Parent.__init__(self, category = AlgebrasWithBasis(self._base_ring).WithRealizations())

        self._dual_side = dual_side
        if dual_side:
            prefixL = "Y"
            prefixLv = "X"
            self._convention = "antidominant"
            self._the_q_unscaled = self._dat.q()**(-1)
            self._the_q = self._dat.q() ** (-self._m)
        else:
            prefixL = "X"
            prefixLv = "Y"
            self._convention = "dominant"
            self._the_q_unscaled = self._dat.q()
            self._the_q = self._dat.q() ** self._m

        self._L = self._dat.cartan_type_classical().root_system().ambient_space()
        self._KL = self._L.algebra(self._base_ring, prefix=prefixL)
        self._W = self._L.weyl_group()

        self._H = ExtendedAffineHeckeAlgebra(self._dat.cartan_type(), self._dat._q1, self._dat._q2, extended = self._dat.properly_extended(), dual_side=dual_side, general_linear=self._general_linear)

        self._Lv = self._H.dual_lattice()
        self._KLv = self._Lv.algebra(self._base_ring, prefix=prefixLv)
        self._Wv = self._H.dual_classical_weyl()

        self._T = self._H.T() # T-basis of extended affine Hecke algebra
        self._E = self._H.extended_affine_weyl()
        self._W0Pv = self._E.W0Pv()
        self._F = self._H.fundamental_group()
        self._tvLv = self._H.tvLv()
        self._tv = self._H.dual_classical_hecke()

        cat = ModulesWithBasis(self._base_ring)
        tcat = cat.TensorProducts()
        self._LTmod = tensor([self._KL, self._T], category = tcat)
        self._TLmod= tensor([self._T, self._KL], category = tcat)

        # working here
        LT = self.LT()
        TL = self.TL()
        LT.register_opposite(TL)

        SetMorphism(Hom(LT.factor(0),LT,category=cat),LT.factor_embedding(0)).register_as_coercion()
        SetMorphism(Hom(LT.factor(1),LT,category=cat),LT.factor_embedding(1)).register_as_coercion()
        SetMorphism(Hom(TL.factor(0),TL,category=cat),TL.factor_embedding(0)).register_as_coercion()
        SetMorphism(Hom(TL.factor(1),TL,category=cat),TL.factor_embedding(1)).register_as_coercion()

        self._LtvLvmod = tensor([self._KL, self._tvLv], category = tcat)
        self._tvLvLmod= tensor([self._tvLv, self._KL], category = tcat)

        LtvLv = self.LtvLv()

        SetMorphism(Hom(LtvLv.factor(0),LtvLv,category=cat),LtvLv.factor_embedding(0)).register_as_coercion()
        SetMorphism(Hom(LtvLv.factor(1),LtvLv,category=cat),LtvLv.factor_embedding(1)).register_as_coercion()

        def LtvLv_to_LT_on_basis((mu, w, nu)):
            return LT.from_direct_product((self._KL.monomial(mu),self._T(self._tvLv.monomial((w,nu)))))

        LtvLv_to_LT = LtvLv.module_morphism(on_basis=LtvLv_to_LT_on_basis, codomain=LT)
        LtvLv_to_LT.register_as_coercion()

        def LT_to_LtvLv_on_basis((mu, pi, w)):
            return LtvLv.from_direct_product((self._KL.monomial(mu),self._tvLv(self._T.monomial((pi,w)))))

        LT_to_LtvLv = LT.module_morphism(on_basis=LT_to_LtvLv_on_basis, codomain=LtvLv)
        LT_to_LtvLv.register_as_coercion()

    def double_affine_type(self):
        r"""
        Return the double affine type of ``self``.

        EXAMPLES::

            sage: HH = DoubleAffineHeckeAlgebraSansDuality("B3")
            sage: HH.double_affine_type()
            Double Affine Type ['B', 3, 1] reduced dual-reduced
        """
        return self._dat

    def dual_double_affine_type(self):
        r"""
        Return the dual double affine type of ``self``.

        EXAMPLES::

            sage: HH = DoubleAffineHeckeAlgebraSansDuality("B3")
            sage: HH.dual_double_affine_type()
            Double Affine Type ['C', 3, 1] reduced dual-reduced
        """
        return self._dual_dat

    def cartan_type(self):
        return self.double_affine_type().cartan_type()

    def base_ring(self):
        return self._base_ring

    @cached_method
    def Y_to_X(self):
        r"""
        The morphism from the ambient space of type `Y` to that of type `X`.

        EXAMPLES::

            sage: HH = DoubleAffineHeckeAlgebraSansDuality("B3")
            sage: dct = HH.cartan_type().classical().dual()
            sage: I0 = dct.index_set()
            sage: [(i, HH._Lv.fundamental_weight(i)) for i in I0]
            [(1, (1, 0, 0)), (2, (1, 1, 0)), (3, (1, 1, 1))]
            sage: [(i, HH.Y_to_X()(HH._Lv.fundamental_weight(i))) for i in I0]
            [(1, (1, 0, 0)), (2, (1, 1, 0)), (3, (1, 1, 1))]

            sage: HH = DoubleAffineHeckeAlgebraSansDuality("C3")
            sage: dct = HH.cartan_type().classical().dual()
            sage: I0 = dct.index_set()
            sage: [(i, HH._Lv.fundamental_weight(i)) for i in I0]
            [(1, (1, 0, 0)), (2, (1, 1, 0)), (3, (1/2, 1/2, 1/2))]
            sage: [(i, HH.Y_to_X()(HH._Lv.fundamental_weight(i))) for i in I0]
            [(1, (1, 0, 0)), (2, (1, 1, 0)), (3, (1/2, 1/2, 1/2))]

            sage: HH = DoubleAffineHeckeAlgebraSansDuality("F4")
            sage: dct = HH.cartan_type().classical().dual()
            sage: I0 = dct.index_set()
            sage: [(i, HH._Lv.fundamental_weight(i)) for i in I0]
            [(1, (1, 0, 0, 0)), (2, (3/2, 1/2, 1/2, 1/2)), (3, (2, 1, 1, 0)), (4, (1, 1, 0, 0))]
            sage: [(i, HH.Y_to_X()(HH._Lv.fundamental_weight(i))) for i in I0]
            [(1, (1, 1, 0, 0)), (2, (2, 1, 1, 0)), (3, (3, 1, 1, 1)), (4, (2, 0, 0, 0))]

            sage: HH = DoubleAffineHeckeAlgebraSansDuality("G2")
            sage: dct = HH.cartan_type().classical().dual()
            sage: I0 = dct.index_set()
            sage: [(i, HH._Lv.fundamental_weight(i)) for i in I0]
            [(1, (2, -1, -1)), (2, (1, 0, -1))]
            sage: [(i, HH.Y_to_X()(HH._Lv.fundamental_weight(i))) for i in I0]
            [(1, (1, 0, -1)), (2, (2/3, -1/3, -1/3))]

        TODO: Move to ambient space code?

        """
        if not self.cartan_type().is_untwisted_affine() or self._dat._general_linear:
            return lambda x: x
        cartan_type = self.cartan_type().classical()
        if cartan_type.is_simply_laced():
            return lambda x: x
        typ = cartan_type.type()
        if typ in ('B','C'):
            return lambda v: self._L.from_vector(v.to_vector())
        if typ == 'F':
            # F4 and G2 have dual implemented as Dynkin reversals of themselves
            def YXF(mu):
                return self._L.from_vector(vector((mu[0]+mu[1],mu[0]-mu[1],mu[2]+mu[3],mu[2]-mu[3]),QQ))
            return YXF
        if typ == 'G':
            def YXG(mu):
                return self._L.from_vector(vector(((2*mu[0]+mu[1])/3,(mu[0]+2*mu[2])/3,(2*mu[1]+mu[2])/3),QQ))
            return YXG
        raise TypeError, "%s should be an irreducible finite Cartan type"%self.cartan_type()

    @cached_method
    def Y_pair_X(self):
        r"""
        Return the pairing between `Y` and `X`.

        This computes the pairing in [Haiman_ICM]_.

        If `Y` equals `X` (dual untwisted case), the pairing is the unique Weyl-invariant one
        with short roots of square length two. This is given by the ambient space pairing except in
        types `B_n` and `F_4`, in which case the ambient space pairing must be doubled.
        If `Y` is the dual of `X` (untwisted case) then the weight lattice of `Y` is identified with the coweight
        lattice of `X` which is then paired with the weight lattice of `X`.

        EXAMPLES::

            sage: E = DoubleAffineHeckeAlgebraSansDuality("A1")
            sage: I0 = E.cartan_type().classical().index_set()
            sage: Matrix([[E.Y_pair_X()(E._Lv.simple_root(i), E._L.simple_root(j)) for j in I0] for i in I0])
            [2]
            sage: E.cartan_type().classical().cartan_matrix()
            [2]
            sage: E = DoubleAffineHeckeAlgebraSansDuality("A2")
            sage: I0 = E.cartan_type().classical().index_set()
            sage: Matrix([[E.Y_pair_X()(E._Lv.simple_root(i), E._L.simple_root(j)) for j in I0] for i in I0])
            [ 2 -1]
            [-1  2]
            sage: E.cartan_type().classical().cartan_matrix()
            [ 2 -1]
            [-1  2]
            sage: E = DoubleAffineHeckeAlgebraSansDuality("B2")
            sage: I0 = E.cartan_type().classical().index_set()
            sage: Matrix([[E.Y_pair_X()(E._Lv.simple_root(i), E._L.simple_root(j)) for j in I0] for i in I0])
            [ 2 -1]
            [-2  2]
            sage: E.cartan_type().classical().cartan_matrix()
            [ 2 -1]
            [-2  2]

            sage: E = DoubleAffineHeckeAlgebraSansDuality("C2")
            sage: I0 = E.cartan_type().classical().index_set()
            sage: Matrix([[E.Y_pair_X()(E._Lv.simple_root(i), E._L.simple_root(j)) for j in I0] for i in I0])
            [ 2 -2]
            [-1  2]
            sage: E.cartan_type().classical().cartan_matrix()
            [ 2 -2]
            [-1  2]

            sage: E = DoubleAffineHeckeAlgebraSansDuality("F4")
            sage: I0 = E.cartan_type().classical().index_set()
            sage: Matrix([[E.Y_pair_X()(E._Lv.simple_root(i), E._L.simple_root(j)) for j in I0] for i in I0])
            [ 2 -1  0  0]
            [-1  2 -1  0]
            [ 0 -2  2 -1]
            [ 0  0 -1  2]
            sage: E.cartan_type().classical().cartan_matrix()
            [ 2 -1  0  0]
            [-1  2 -1  0]
            [ 0 -2  2 -1]
            [ 0  0 -1  2]

            sage: E = DoubleAffineHeckeAlgebraSansDuality("G2")
            sage: I0 = E.cartan_type().classical().index_set()
            sage: Matrix([[E.Y_pair_X()(E._Lv.simple_root(i), E._L.simple_root(j)) for j in I0] for i in I0])
            [ 2 -3]
            [-1  2]            
            sage: E.cartan_type().classical().cartan_matrix()
            [ 2 -3]
            [-1  2]

            sage: E = DoubleAffineHeckeAlgebraSansDuality("B2", untwisted=False)
            sage: I0 = E.cartan_type().classical().index_set()
            sage: Matrix([[E.Y_pair_X()(E._Lv.simple_root(i), E._L.simple_root(j)) for j in I0] for i in I0])
            [ 4 -2]
            [-2  2]

            sage: E = DoubleAffineHeckeAlgebraSansDuality("C2", untwisted=False)
            sage: I0 = E.cartan_type().classical().index_set()
            sage: Matrix([[E.Y_pair_X()(E._Lv.simple_root(i), E._L.simple_root(j)) for j in I0] for i in I0])
            [ 2 -2]
            [-2  4]

            sage: E = DoubleAffineHeckeAlgebraSansDuality("F4", untwisted=False)
            sage: I0 = E.cartan_type().classical().index_set()
            sage: Matrix([[E.Y_pair_X()(E._Lv.simple_root(i), E._L.simple_root(j)) for j in I0] for i in I0])
            [ 4 -2  0  0]
            [-2  4 -2  0]
            [ 0 -2  2 -1]
            [ 0  0 -1  2]

            sage: E = DoubleAffineHeckeAlgebraSansDuality("G2", untwisted=False)
            sage: I0 = E.cartan_type().classical().index_set()
            sage: Matrix([[E.Y_pair_X()(E._Lv.simple_root(i), E._L.simple_root(j)) for j in I0] for i in I0])
            [ 2 -3]
            [-3  6]

        """
        cartan_type = self.cartan_type().classical()
        typ = cartan_type.type()
        if typ == 'A' and not self._general_linear:
            h = cartan_type.n + 1
            # this normalization is needed for the type A ambient space
            def type_a_pairing(y, x):
                return y.scalar(x) - (QQ.sum(vector(x))*QQ.sum(vector(y)))/h
            return type_a_pairing
        if cartan_type.is_simply_laced():
            return lambda y,x: y.scalar(x)
        if self.cartan_type().is_untwisted_affine():
            return lambda y, x: x.scalar(self.Y_to_X()(y))
        if typ in ('B','F'):
            return lambda y, x: 2 * y.scalar(x)
        return lambda y, x: y.scalar(x)

    def Y_pair_X_m(self, y, x):
        r"""
        This is a hack to deal with fractional powers of q.
        """
        return self.Y_pair_X()(y, x) * self._m

    def lattice(self):
        r"""
        The lattice.
        """
        return self._L

    def dual_lattice(self):
        r"""
        The dual lattice.
        """
        return self._Lv

    def lattice_algebra(self):
        r"""
        The group algebra of the lattice `L`

        EXAMPLES::

            sage: HH = DoubleAffineHeckeAlgebraSansDuality("B2")
            sage: KL = HH.lattice_algebra(); KL
            Group algebra of the Ambient space of the Root system of type ['B', 2] over Fraction Field of Multivariate Polynomial Ring in q, v, vl, v0, v2, vz over Rational Field
            sage: KL.an_element()
            X[(2, 2)]

            sage: HH = DoubleAffineHeckeAlgebraSansDuality("B2",dual_side=True)
            sage: KL = HH.lattice_algebra(); KL
            Group algebra of the Ambient space of the Root system of type ['B', 2] over Fraction Field of Multivariate Polynomial Ring in q, v, vl, v0, v2, vz over Rational Field
            sage: KL.an_element()
            Y[(2, 2)]
        """
        return self._KL

    def dual_lattice_algebra(self):
        r"""
        The group algebra of the dual lattice.

        EXAMPLES::

            sage: HH = DoubleAffineHeckeAlgebraSansDuality("B2")
            sage: KLv = HH.dual_lattice_algebra(); KLv
            Group algebra of the Ambient space of the Root system of type ['C', 2] over Fraction Field of Multivariate Polynomial Ring in q, v, vl, v0, v2, vz over Rational Field
            sage: KLv.an_element()
            Y[(2, 2)]
        """
        return self._KLv

    def F(self):
        r"""
        The fundamental group.
        """
        return self._F

    @cached_method
    def _F_to_W0Pv(self, pi):
        r"""
        Given an element `\pi` of the fundamental group, returns `(u, \mu)` where `u` is an element of the
        classical Weyl group and `\mu` is in the ambient space of the dual lattice.
        """
        x = self._W0Pv(pi)
        return (self._W.from_reduced_word(x.to_dual_classical_weyl().reduced_word()), x.to_dual_translation_right().to_ambient())

    @cached_method
    def _F_on_L(self, pi):
        r"""
        Returns a function which sends an element `\mu` of the weight lattice
        to its image under the action of the fundamental group element `\pi`.

        The value lies in the group algebra of the weight lattice. If `\pi=\pi_i` then

        ..MATH::

            \pi_i^X = u_i^{-1} t_{-\omega^Y_{i^*}}

        where ` - \omega^Y_{i^*} = w_0(\omega^Y_i) `

        EXAMPLES::

            sage: HH = DoubleAffineHeckeAlgebraSansDuality("A2")
            sage: F = HH.double_affine_type().extended_affine_weyl().fundamental_group()
            sage: print "q should be replaced by q**(%s)"%(1/HH._m)
            q should be replaced by q**(1/3)
            sage: for i in F.special_nodes():
            ...       for j in HH.cartan_type().classical().index_set():
            ...           print i, j, HH._F_on_L(F(i))(HH._L.fundamental_weight(j))
            0 1 X[(1, 0, 0)]
            0 2 X[(1, 1, 0)]
            1 1 q*X[(0, 1, 0)]
            1 2 q^2*X[(0, 1, 1)]
            2 1 q^2*X[(0, 0, 1)]
            2 2 q*X[(1, 0, 1)]

            sage: HH = DoubleAffineHeckeAlgebraSansDuality("A2",dual_side=True)
            sage: F = HH.double_affine_type().extended_affine_weyl().fundamental_group()
            sage: print "q should be replaced by q**(%s)"%(1/HH._m)
            q should be replaced by q**(1/3)
            sage: for i in F.special_nodes():
            ...       for j in HH.cartan_type().classical().index_set():
            ...           print i, j, HH._F_on_L(F(i))(HH._L.fundamental_weight(j))
            0 1 Y[(1, 0, 0)]
            0 2 Y[(1, 1, 0)]
            1 1 q*Y[(0, 1, 0)]
            1 2 q^2*Y[(0, 1, 1)]
            2 1 q^2*Y[(0, 0, 1)]
            2 2 q*Y[(1, 0, 1)]

            sage: HH = DoubleAffineHeckeAlgebraSansDuality("B4",dual_side=True)
            sage: F = HH.double_affine_type().extended_affine_weyl().fundamental_group()
            sage: print "q should be replaced by q**(%s)"%(1/HH._m)
            q should be replaced by q**(1/2)
            sage: for i in F.special_nodes():
            ...       for j in HH.cartan_type().classical().index_set():
            ...           print i, j, HH._F_on_L(F(i))(HH._L.fundamental_weight(j))
            0 1 Y[(1, 0, 0, 0)]
            0 2 Y[(1, 1, 0, 0)]
            0 3 Y[(1, 1, 1, 0)]
            0 4 Y[(1/2, 1/2, 1/2, 1/2)]
            1 1 q^2*Y[(-1, 0, 0, 0)]
            1 2 q^2*Y[(-1, 1, 0, 0)]
            1 3 q^2*Y[(-1, 1, 1, 0)]
            1 4 q*Y[(-1/2, 1/2, 1/2, 1/2)]

            sage: HH = DoubleAffineHeckeAlgebraSansDuality("A2", general_linear=True)
            sage: F = HH.double_affine_type().extended_affine_weyl().fundamental_group()
            sage: print "q should be replaced by q**(%s)"%(1/HH._m)
            q should be replaced by q**(1/3)
            sage: for i in range(5):
            ...       for j in HH.cartan_type().classical().index_set():
            ...           print i, j, HH._F_on_L(F(i))(HH._L.fundamental_weight(j))
            0 1 X[(1, 0, 0)]
            0 2 X[(1, 1, 0)]
            1 1 X[(0, 1, 0)]
            1 2 X[(0, 1, 1)]
            2 1 X[(0, 0, 1)]
            2 2 1/q^3*X[(1, 0, 1)]
            3 1 1/q^3*X[(1, 0, 0)]
            3 2 1/q^6*X[(1, 1, 0)]
            4 1 1/q^3*X[(0, 1, 0)]
            4 2 1/q^6*X[(0, 1, 1)]

            TODO: Fix the powers of q.

        """
        u, nu = self._F_to_W0Pv(pi)
        if not self._dual_side:
            nu = - nu
        if self._general_linear:
            return lambda mu: self.lattice_algebra().term(pi.act_on_classical_ambient(mu), self._the_q_unscaled**(self.Y_pair_X_m(nu,mu)))
        else:
            return lambda mu: self.lattice_algebra().term(u.action(mu), self._the_q_unscaled**(self.Y_pair_X_m(nu, mu)))

    @cached_method
    def s0_on_L(self, mu):
        r"""
        Act on the element `\mu` of `L` by `s_0`.

        TODO:: CHECK!!!!

        EXAMPLES::

            sage: HH = DoubleAffineHeckeAlgebraSansDuality("A2")
            sage: print "q should be replaced by q**(1/%s)"%HH._m
            q should be replaced by q**(1/3)
            sage: [(i, HH.s0_on_L(HH._L.fundamental_weight(i))) for i in HH.cartan_type().classical().index_set()]
            [(1, q^3*X[(0, 0, 1)]), (2, q^3*X[(0, 1, 1)])]

            sage: HH = DoubleAffineHeckeAlgebraSansDuality("B2")
            sage: print "q should be replaced by q**(1/%s)"%HH._m
            q should be replaced by q**(1/2)
            sage: [(i, HH.s0_on_L(HH._L.fundamental_weight(i))) for i in HH.cartan_type().classical().index_set()]
            [(1, q^2*X[(0, -1)]), (2, q^2*X[(-1/2, -1/2)])]            

            sage: HH = DoubleAffineHeckeAlgebraSansDuality("B2", dual_side=True)
            sage: print "q should be replaced by q**(1/%s)"%HH._m
            q should be replaced by q**(1/2)
            sage: [(i, HH.s0_on_L(HH._L.fundamental_weight(i))) for i in HH.cartan_type().classical().index_set()]
            [(1, 1/q^2*Y[(0, -1)]), (2, 1/q^2*Y[(-1/2, -1/2)])]

            sage: HH = DoubleAffineHeckeAlgebraSansDuality("C2", dual_side=True)
            sage: print "q should be replaced by q**(1/%s)"%HH._m
            q should be replaced by q**(1/2)
            sage: [(i, HH.s0_on_L(HH._L.fundamental_weight(i))) for i in HH.cartan_type().classical().index_set()]
            [(1, 1/q^2*Y[(-1, 0)]), (2, 1/q^2*Y[(-1, 1)])]

            sage: HH = DoubleAffineHeckeAlgebraSansDuality("B2",untwisted=False)
            sage: print "q should be replaced by q**(1/%s)"%HH._m
            q should be replaced by q**(1/2)
            sage: [(i, HH.s0_on_L(HH._L.fundamental_weight(i))) for i in HH.cartan_type().classical().index_set()]
            [(1, q^4*X[(-1, 0)]), (2, q^2*X[(-1/2, 1/2)])]

            sage: HH = DoubleAffineHeckeAlgebraSansDuality("B2",untwisted=False, dual_side=True)
            sage: print "q should be replaced by q**(1/%s)"%HH._m
            q should be replaced by q**(1/2)
            sage: [(i, HH.s0_on_L(HH._L.fundamental_weight(i))) for i in HH.cartan_type().classical().index_set()]
            [(1, 1/q^4*Y[(-1, 0)]), (2, 1/q^2*Y[(-1/2, 1/2)])]

        """
        dat = self.double_affine_type()
        if dat.cartan_type().is_untwisted_affine():
            phi = dat.cartan_type().classical().root_system().root_space().highest_root().to_ambient()
            phiv = phi.associated_coroot()
        else:
            phiv = dat.cartan_type().classical().root_system().coroot_space().highest_root().to_ambient()
            phi = phiv.associated_coroot()
        sp = mu.scalar(phiv)
        return self._the_q_unscaled**(self._m * sp) * self._KL.monomial(mu - sp * phi)

    @cached_method
    def s0_on_lattice_algebra(self):
        r"""
        The operator that acts on the group algebra of `L` by `s_0`.

        TODO:: FIX!!!!!!!!!!!!

        EXAMPLES::

            sage: HH = DoubleAffineHeckeAlgebraSansDuality("A2")
            sage: print "q should be replaced by q**(1/%s)"%HH._m
            q should be replaced by q**(1/3)
            sage: [(i, HH.s0_on_lattice_algebra()(HH._KL.monomial(HH._L.fundamental_weight(i)))) for i in HH.cartan_type().classical().index_set()]
            [(1, q^3*X[(0, 0, 1)]), (2, q^3*X[(0, 1, 1)])]
            sage: [(i, HH.s0_on_lattice_algebra()(HH.s0_on_L(HH._L.fundamental_weight(i)))) for i in HH.cartan_type().classical().index_set()]
            [(1, X[(1, 0, 0)]), (2, X[(1, 1, 0)])]
            sage: HH = DoubleAffineHeckeAlgebraSansDuality("B2", dual_side=True)
            sage: print "q should be replaced by q**(1/%s)"%HH._m
            q should be replaced by q**(1/2)
            sage: [(i, HH.s0_on_lattice_algebra()(HH._KL.monomial(HH._L.fundamental_weight(i)))) for i in HH.cartan_type().classical().index_set()]
            [(1, 1/q^2*Y[(0, -1)]), (2, 1/q^2*Y[(-1/2, -1/2)])]
            sage: [(i, HH.s0_on_lattice_algebra()(HH.s0_on_L(HH._L.fundamental_weight(i)))) for i in HH.cartan_type().classical().index_set()]
            [(1, Y[(1, 0)]), (2, Y[(1/2, 1/2)])]
        """
        return self._KL.module_morphism(on_basis=self.s0_on_L, codomain=self._KL, category=ModulesWithBasis(self.base_ring()))

    def T(self):
        r"""
        The extended affine Hecke algebra corresponding to the lattice `L`.

        EXAMPLES::

            sage: DoubleAffineHeckeAlgebraSansDuality("A2").T()
            T basis of The affine Hecke algebra of type ['A', 2, 1]
        """
        return self._T

    def LT(self):
        r"""
        The "LT" basis.

        EXAMPLES::

            sage: DoubleAffineHeckeAlgebraSansDuality("A2").LT()
            LT basis of The double affine Hecke algebra of type ['A', 2, 1]

        """
        return self.DoubleAffineHeckeAlgebraSansDualityLT()

    def TL(self):
        r"""
        The "TL" basis.

        EXAMPLES::

            sage: DoubleAffineHeckeAlgebraSansDuality("A2").TL()
            TL basis of The double affine Hecke algebra of type ['A', 2, 1]

        """
        return self.DoubleAffineHeckeAlgebraSansDualityTL()

    def LtvLv(self):
        r"""
        The LtvLv basis.

        EXAMPLES::

            sage: DoubleAffineHeckeAlgebraSansDuality("A2").LtvLv()
            LtvLv basis of The double affine Hecke algebra of type ['A', 2, 1]

        """
        return self.DoubleAffineHeckeAlgebraSansDualityLtvLv()

    def tv_Lv(self):
        return self._tvLv

    def tv(self):
        return self._tv

    @cached_method
    def _F_on_LTmod_left_morphism(self, pi):
        r"""
        Returns the morphism that gives the action of the fundamental group element `pi` on the product form of the "LT" basis.
        """
        cat = ModulesWithBasis(self.base_ring())
        on_basis = lambda (mu,pi0,w): tensor([self._F_on_L(pi)(mu), self._T.product_by_fundamental_group_element_on_basis((pi0,w),pi,side='left')],category=cat.TensorProducts())
        return self._LTmod.module_morphism(on_basis=on_basis, category=cat, codomain = self._LTmod)

    @cached_method
    def _F_on_TLmod_right_morphism(self, pi):
        r"""
        Returns the morphism that gives the right action of the fundamental group element `pi` on the product form of the "TL" basis.
        """
        cat = ModulesWithBasis(self.base_ring())
        on_basis = lambda (pi0,w,mu): tensor([self._T.product_by_fundamental_group_element_on_basis((pi0,w),pi,side='right'),self._F_on_L(pi.inverse())(mu)],category=cat.TensorProducts())
        return self._TLmod.module_morphism(on_basis=on_basis, category=cat, codomain = self._TLmod)

    def a_realization(self):
        r"""
        Returns the default realization.

        EXAMPLES::

            sage: DoubleAffineHeckeAlgebraSansDuality("A2").a_realization()
            LT basis of The double affine Hecke algebra of type ['A', 2, 1]

        """
        return self.LT()

    def _repr_(self):
        r"""
        EXAMPLES::

            sage: DoubleAffineHeckeAlgebraSansDuality("A2")
            The double affine Hecke algebra of type ['A', 2, 1]

        """
        return "The double affine Hecke algebra of type %s"%self.cartan_type()

    class _DAHABasesCategory(Category_realization_of_parent):
        r"""
        The category of realizations of a double affine Hecke algebra (without duality)
        """
        def __init__(self, basis, prefix=None):
            r"""
            Initialize a basis.

            INPUT:

            - ``basis`` -- a basis
            - ``prefix`` -- a prefix

            TESTS::

                sage: HH = DoubleAffineHeckeAlgebraSansDuality("A2")
                sage: bases = HH._DAHABasesCategory()
                sage: HH.LT() in bases
                True
            """
            Category_realization_of_parent.__init__(self, basis)
            basis._prefix = prefix

        def super_categories(self):
            r"""
            EXAMPLES::

                sage: DoubleAffineHeckeAlgebraSansDuality("A2")._DAHABasesCategory().super_categories()
                [Category of realizations of The double affine Hecke algebra of type ['A', 2, 1], Category of algebras with basis over Fraction Field of Multivariate Polynomial Ring in q, v, vl, v0, v2, vz over Rational Field, Category of monoids with realizations, Category of additive unital additive magmas with realizations]

            """
            return [Realizations(self.base())] + self.base().category().super_categories()

        def _repr_(self):
            r"""
            Return the representation of ``self``.

            EXAMPLES::

                sage: DoubleAffineHeckeAlgebraSansDuality("A2")._DAHABasesCategory()
                Category of bases of The double affine Hecke algebra of type ['A', 2, 1]
            """
            return "Category of bases of %s" % self.base()

        class ParentMethods:

            def T_generators(self):
                r"""
                The family of elements `T_i` in the given realization.

                It is a family on the affine Dynkin node set `I` with values in ``self``.

                ..warning:: Must be implemented for "LT".

                EXAMPLES::

                    sage: HH = DoubleAffineHeckeAlgebraSansDuality("A2")
                    sage: HH.LT().T_generators()
                    Finite family {0: TX[0], 1: TX[1], 2: TX[2]}
                    sage: HH.TL().T_generators()
                    Finite family {0: TX[0], 1: TX[1], 2: TX[2]}
                    sage: HH.LtvLv().T_generators()
                    Finite family {0: Ty[1,2,1] Y[(-1, 0, 1)] + ((v^2-1)/v), 1: Ty[1], 2: Ty[2]}

                TODO:: other realizations

                """
                HH = self.realization_of()
                return Family(dict([[i, self(HH.LT().T_generators()[i])] for i in HH.double_affine_type().cartan_type().index_set()]))

            def from_fundamental(self, i):
                r"""
                The image of the fundamental group element of `L` indexed by the special node `i`, in ``self``.

                ..warning:: Must be implemented in "LT".

                EXAMPLES::

                    sage: HH = DoubleAffineHeckeAlgebraSansDuality("A2")
                    sage: F = HH._F
                    sage: [(i, HH.LT().from_fundamental(i)) for i in F.special_nodes()]
                    [(0, 1), (1, piX[1]), (2, piX[2])]
                    sage: HH.LT().from_fundamental(1).parent()
                    LT basis of The double affine Hecke algebra of type ['A', 2, 1]
                    sage: [(i, HH.LtvLv().from_fundamental(i)) for i in F.special_nodes()]
                    [(0, 1), (1, Ty[1,2] Y[(-1, -1, 0)]), (2, Ty[2,1] Y[(-1, 0, 0)])]
                """
                return self(self.realization_of().LT().from_fundamental(i))

            def from_lattice_algebra(self, a):
                r"""
                The image of `a` under the morphism from the group algebra of the `L` lattice into ``self``.

                ..warning:: Must be implemented in "LT".

                EXAMPLES::

                    sage: HH = DoubleAffineHeckeAlgebraSansDuality("A2")
                    sage: LT = HH.LT()
                    sage: KL = HH.lattice_algebra()
                    sage: a = KL.monomial(HH.lattice().simple_root(1)); a
                    X[(1, -1, 0)]
                    sage: a.parent()
                    Group algebra of the Ambient space of the Root system of type ['A', 2] over Fraction Field of Multivariate Polynomial Ring in q, v, vl, v0, v2, vz over Rational Field
                    sage: aa = LT.from_lattice_algebra(a); aa
                    X[(1, -1, 0)]
                    sage: aa.parent()
                    LT basis of The double affine Hecke algebra of type ['A', 2, 1]

                """
                HH = self.realization_of()
                return self(HH.LT().factor_embedding(0)(a))

            def from_dual_lattice_algebra(self, b):
                r"""
                The image of `b` under the morphism from the group algebra of the `Lv` lattice into ``self``.

                ..warning:: Must be implemented in basis `LtvLv`.

                EXAMPLES::

                    sage: HH = DoubleAffineHeckeAlgebraSansDuality("A2")
                    sage: LtvLv = HH.LtvLv()
                    sage: KLv = HH.dual_lattice_algebra()
                    sage: Lv = HH.dual_lattice()
                    sage: b = KLv.monomial(Lv.simple_root(1)); b
                    Y[(1, -1, 0)]
                    sage: b.parent()
                    Group algebra of the Ambient space of the Root system of type ['A', 2] over Fraction Field of Multivariate Polynomial Ring in q, v, vl, v0, v2, vz over Rational Field
                    sage: bb = LtvLv.from_dual_lattice_algebra(b); bb
                    Y[(1, -1, 0)]
                    sage: bb.parent()
                    LtvLv basis of The double affine Hecke algebra of type ['A', 2, 1]
                    sage: c = HH.LT().from_dual_lattice_algebra(b); c
                    TX[0,2,0,1] + ((-v^2+1)/v)*TX[0,2,1]
                    sage: LtvLv(c) == b
                    True
                    sage: HH = DoubleAffineHeckeAlgebraSansDuality("A2", dual_side=True)
                    sage: LtvLv = HH.LtvLv()
                    sage: KLv = HH.dual_lattice_algebra()
                    sage: Lv = HH.dual_lattice()
                    sage: b = KLv.monomial(Lv.simple_root(1)); b
                    X[(1, -1, 0)]
                    sage: b.parent()
                    Group algebra of the Ambient space of the Root system of type ['A', 2] over Fraction Field of Multivariate Polynomial Ring in q, v, vl, v0, v2, vz over Rational Field
                    sage: c = HH.TL()(b); c
                    ((v^4-2*v^2+1)/v^2)*TY[2,0] + ((-v^2+1)/v)*TY[2,0,1] + ((-v^2+1)/v)*TY[0,2,0] + ((v^4-2*v^2+1)/v^2) + ((-v^2+1)/v)*TY[1] + TY[0,2,0,1]
                    sage: c.parent()
                    TL basis of The double affine Hecke algebra of type ['A', 2, 1]

                """
                HH = self.realization_of()
                return self(HH.LtvLv().factor_embedding(1)(HH.tv_Lv().factor_embedding(1)(b)))

            def from_extended_affine_hecke(self, a):
                r"""
                Returns the image of `a` from the extended affine Hecke algebra "T" to ``self``.

                ..warning:: Must be implemented in type "LT".

                EXAMPLES::

                    sage: HH = DoubleAffineHeckeAlgebraSansDuality("A2")
                    sage: LT = HH.LT()
                    sage: T = HH.T()
                    sage: a = T.an_element()
                    sage: b = LT.from_extended_affine_hecke(a); b
                    2*TX[0] + 3*TX[0,1] + 1 + TX[0,1,2] + 4*piX[1] TX[0] + 6*piX[1] TX[0,1] + 2*piX[1] + 2*piX[1] TX[0,1,2] + 8*piX[2] TX[0] + 12*piX[2] TX[0,1] + 4*piX[2] + 4*piX[2] TX[0,1,2]
                    sage: b == LT(a)
                    True
                """
                return self(self.realization_of().LT().from_extended_affine_hecke(a))

            def from_dual_classical_hecke(self, a):
                r"""
                Returns the image of `a` from the finite Hecke algebra "tv" of dual type, to ``self``.

                ..warning:: Must be implemented in type "LtvLv".

                EXAMPLES::

                    sage: HH = DoubleAffineHeckeAlgebraSansDuality("A2")
                    sage: LT = HH.LT()
                    sage: tv_Lv = HH.tv_Lv()
                    sage: tv = HH.tv()
                    sage: a = tv.an_element(); a
                    2*Ty[1,2,1] + 4*Ty[1,2] + 1
                    sage: b = LT.from_dual_classical_hecke(a); b
                    1 + 4*TX[1,2] + 2*TX[1,2,1]
                    sage: b == LT(a)
                    True
                """
                return self(self.realization_of().LtvLv().from_dual_classical_hecke(a))

            def from_reduced_word(self, word):
                r"""
                Given a reduced word for an element `w` in the affine Weyl group, return the image of the basis element `T_w`
                in ``self``.

                .. warning::

                    Must be implemented in style "LT".

                EXAMPLES::

                    sage: DoubleAffineHeckeAlgebraSansDuality("B2").LT().from_reduced_word([0,2,1])
                    TX[0,2,1]

                    sage: DoubleAffineHeckeAlgebraSansDuality("B2", dual_side=True).LT().from_reduced_word([0,2,1])
                    TY[0,2,1]
                """
                return self(self.realization_of().LT().from_reduced_word(word))

            def from_reduced_word_dual(self, word):
                r"""
                Given a reduced word for an element `w` in the dual classical Weyl group,
                return the image of the corresponding basis element of the dual classical Hecke algebra in ``self``.

                .. warning::

                    Must be implemented in basis "LtvLv".

                EXAMPLES::

                    sage: HH = DoubleAffineHeckeAlgebraSansDuality("B2")
                    sage: a = HH.LtvLv().from_reduced_word_dual([2,1]); a
                    Ty[2,1]
                    sage: LT = HH.LT()
                    sage: b = LT.from_reduced_word_dual([2,1]); b
                    TX[2,1]
                    sage: b == LT(a)
                    True
                    sage: HH = DoubleAffineHeckeAlgebraSansDuality("B2", dual_side=True)
                    sage: a = HH.LtvLv().from_reduced_word_dual([2,1]); a
                    Tx[2,1]
                    sage: LT = HH.LT()
                    sage: b = LT.from_reduced_word_dual([2,1]); b
                    TY[2,1]
                    sage: b == LT(a)
                    True

                """
                return self(self.realization_of().LtvLv().from_reduced_word(word))

    class _DAHABases(UniqueRepresentation, BindableClass):
        r"""
        The class of realizations of a double affine Hecke algebra without duality.
        """

        def _repr_(self):
            r"""
            EXAMPLES::

                sage: DoubleAffineHeckeAlgebraSansDuality("A2").LT() # indirect doctest
                LT basis of The double affine Hecke algebra of type ['A', 2, 1]

            """
            return "%s basis of the %s"%(self._prefix, self.realization_of())

        def is_parent_of(self, x):
            return x.parent() == self

    class DoubleAffineHeckeAlgebraSansDualityLT(SmashProductAlgebra, _DAHABases):
        r"""
        DAHA basis LT.

        INPUT:

        - `HH` -- DAHA realization parent

        EXAMPLES::

            sage: DoubleAffineHeckeAlgebraSansDuality("A2").LT()
            LT basis of The double affine Hecke algebra of type ['A', 2, 1]

        """

        def __init__(self, HH):
            dat = HH.double_affine_type()
            # To define the product on LT we need the left action of left multiplication by T on KL # T.
            # We start with the left action of the Hecke algebra of the nonextended affine Weyl group of `L`
            # on the group algebra KL.
            from sage.combinat.root_system.hecke_algebra_representation import HeckeAlgebraRepresentation
            HH._KLaf = dat.cartan_type().root_system().ambient_space().algebra(HH.base_ring())
            HH._ML = HH._KLaf.nonreduced_demazure_lusztig_operators_on_classical(HH._the_q, dat._q1, dat._q2, convention=HH._convention, doubled_parameters=dat.doubled_parameters(),domain=HH.lattice_algebra())
            mcat = ModulesWithBasis(HH.base_ring())
            tmcat = mcat.TensorProducts()
            # Now we define the action of the above nonextended affine Hecke algebra on KL # T
            # This is done by first giving the action of the generators `T_i` for `i \in I`:
            # T_i * (e^\mu # pi T_w) = (T_i(e^\mu) - q1[i] e^{s_i(\mu)}) # pi T_w + e^{s_i(\mu)} # T_i pi T_w
            def Ti_on_LTmod_left((mu,pi,w), i):
                if i == 0:
                    smupoly = HH.s0_on_L(mu)
                else:
                    smupoly = HH._KL.monomial(mu.simple_reflection(i))
                return tensor([HH._ML[i](HH._KL.monomial(mu)) - dat._q1[i] * smupoly, HH._T.monomial((pi,w))],category=tmcat) + tensor([smupoly, HH._T.product_by_generator_on_basis((pi,w), i, side='left')],category=tmcat)
            # Use the HeckeAlgebraRepresentation tool to obtain a left action of the nonextended affine Hecke on KL # T.

            HH._MLTmod = HeckeAlgebraRepresentation(HH._LTmod, Ti_on_LTmod_left, dat.cartan_type(), dat._q1, dat._q2, HH._the_q, side='left', doubled_parameters=dat.doubled_parameters)

            # The left action of the extended affine Hecke algebra on the module LTmod.
            def left_LTmod_on_basis((ppi,ww),mu,(pi,w)):
                return HH._F_on_LTmod_left_morphism(ppi)(HH._MLTmod.Tw(ww)(HH._LTmod.monomial((mu,pi,w))))

            SmashProductAlgebra.__init__(self, HH._KL, HH._T, left_action=left_LTmod_on_basis, category=Category.join((HH._DAHABasesCategory(),AlgebrasWithBasis(HH.base_ring()).TensorProducts())))
            self._style = "LT"

        def _repr_(self):
            HH = self.realization_of()
            return "%s basis of %s"%(self._style, HH._repr_())

        @cached_method
        def T_generators(self):
            r"""
            A family on the affine Dynkin node set with values given by `T_i`.

            EXAMPLES::

                sage: HH=DoubleAffineHeckeAlgebraSansDuality("A2")
                sage: LT = HH.LT()
                sage: LT.T_generators()
                Finite family {0: TX[0], 1: TX[1], 2: TX[2]}

            """
            return Family(dict([[i, self.factor_embedding(1)(self.factor(1).from_reduced_word([i]))] for i in self.realization_of().double_affine_type().cartan_type().index_set()]))

        @cached_method
        def from_fundamental(self, i):
            r"""
            The image of the fundamental group element of `L` indexed by the special node `i`, in ``self``.

            EXAMPLES::

                sage: HH = DoubleAffineHeckeAlgebraSansDuality("A2")
                sage: [(i, HH.LT().from_fundamental(i)) for i in HH._F.special_nodes()]
                [(0, 1), (1, piX[1]), (2, piX[2])]

                sage: HH = DoubleAffineHeckeAlgebraSansDuality("A2",general_linear=True)
                sage: [(i, HH.LT().from_fundamental(i)) for i in range(5)]
                [(0, 1), (1, piX[1]), (2, piX[2]), (3, piX[3]), (4, piX[4])]

            """
            return self.factor_embedding(1)(self.factor(1).from_fundamental(self.realization_of()._F(i)))

        def from_lattice_algebra(self, a):
            r"""
            The image of the element `a` of `KX` in ``self``.

            EXAMPLES::

                sage: HH = DoubleAffineHeckeAlgebraSansDuality("A2")
                sage: LT = HH.LT()
                sage: KL = LT.factor(0)
                sage: a = KL.an_element(); a
                X[(2, 2, 3)]
                sage: b = LT.from_lattice_algebra(a); b
                X[(2, 2, 3)]
                sage: b.parent()
                LT basis of The double affine Hecke algebra of type ['A', 2, 1]

            """
            return self.factor_embedding(0)(a)

        def from_extended_affine_hecke(self, a):
            r"""
            The image of the element `a` of `T` in ``self``.

            EXAMPLES::

                sage: HH = DoubleAffineHeckeAlgebraSansDuality("A2")
                sage: LT = HH.LT()
                sage: T = LT.factor(1)
                sage: a = T.an_element(); a
                2*TX[0] + 3*TX[0,1] + 1 + TX[0,1,2] + 4*piX[1] TX[0] + 6*piX[1] TX[0,1] + 2*piX[1] + 2*piX[1] TX[0,1,2] + 8*piX[2] TX[0] + 12*piX[2] TX[0,1] + 4*piX[2] + 4*piX[2] TX[0,1,2]
                sage: b = LT.from_extended_affine_hecke(a); b
                2*TX[0] + 3*TX[0,1] + 1 + TX[0,1,2] + 4*piX[1] TX[0] + 6*piX[1] TX[0,1] + 2*piX[1] + 2*piX[1] TX[0,1,2] + 8*piX[2] TX[0] + 12*piX[2] TX[0,1] + 4*piX[2] + 4*piX[2] TX[0,1,2]
                sage: b.parent()
                LT basis of The double affine Hecke algebra of type ['A', 2, 1]                

            """
            return self.factor_embedding(1)(a)

        def from_reduced_word(self, word):
            r"""
            Given a reduced word for an element `w` in the affine Weyl group of `L`, return the image of the basis element `T_w`
            in ``self``.

            .. warning::

                Must be implemented in style "LT".

            EXAMPLES::

                sage: DoubleAffineHeckeAlgebraSansDuality("A2").LT().from_reduced_word([0,2,1])
                TX[0,2,1]

            """
            return self.from_extended_affine_hecke(self.factor(1).from_reduced_word(word))

    class DoubleAffineHeckeAlgebraSansDualityTL(SmashProductAlgebra, _DAHABases):
        r"""
        DAHA basis TL.

        INPUT:

        - `HH` -- DAHA realization parent

        EXAMPLES::

            sage: DoubleAffineHeckeAlgebraSansDuality("A2").TL()
            TL basis of The double affine Hecke algebra of type ['A', 2, 1]

        """

        def __init__(self, HH):
            dat = HH.double_affine_type()
            # Define the left action of the Hecke algebra of the affine Weyl group of `L` on the group algebra KL.
            from sage.combinat.root_system.hecke_algebra_representation import HeckeAlgebraRepresentation
            HH._LM = HH._KLaf.nonreduced_demazure_lusztig_operators_on_classical(HH._the_q, dat._q1, dat._q2, convention=HH._convention,side='right', doubled_parameters=dat.doubled_parameters(),domain=HH._KL)
            mcat = ModulesWithBasis(HH.base_ring())
            tmcat = mcat.TensorProducts()
            # The above nonextended affine Hecke algebra has a right action on T # KL
            # via the action of the generators `T_i` for `i \in I`:
            # (pi T_w # e^\mu) # T_i = pi T_w # (T_i(e^\mu) - q1[i] e^{s_i(\mu)}) + pi T_w T_i # e^{s_i(\mu)}
            def Ti_on_TLmod_right((pi,w,mu), i):
                if i == 0:
                    smupoly = HH.s0_on_L(mu)
                else:
                    smupoly = HH._KL.monomial(mu.simple_reflection(i))
                return tensor([HH._T.monomial((pi,w)), HH._LM[i](HH._KL.monomial(mu)) - dat._q1[i] * smupoly],category=tmcat) + tensor([HH._T.product_by_generator_on_basis((pi,w), i, side='right'),smupoly],category=tmcat)

            # Use the HeckeAlgebraRepresentation tool to obtain a right action of the nonextended affine Hecke on T # KL.
            HH._TLmodM = HeckeAlgebraRepresentation(HH._TLmod, Ti_on_TLmod_right, dat.cartan_type(), dat._q1, dat._q2, HH._the_q, side='right', doubled_parameters=dat.doubled_parameters)

            # Finally we obtain the right action of the extended affine Hecke algebra on the module TLmod.
            def right_TLmod_on_basis((ppi,ww),(pi,w),mu):
                return HH._TLmodM.Tw(ww)(HH._F_on_TLmod_right_morphism(ppi)(HH._TLmod.monomial((pi,w,mu))))

            SmashProductAlgebra.__init__(self, HH._T, HH._KL, right_action=right_TLmod_on_basis, category=Category.join((HH._DAHABasesCategory(),AlgebrasWithBasis(HH.base_ring()).TensorProducts())))

            self._style = "TL"

        def _repr_(self):
            HH = self.realization_of()
            return "%s basis of %s"%(self._style, HH._repr_())

        @cached_method
        def T_generators(self):
            r"""
            A family on the affine Dynkin node set with values given by `T_i`.

            EXAMPLES::

                sage: HH=DoubleAffineHeckeAlgebraSansDuality("A2")
                sage: TL = HH.TL()
                sage: TL.T_generators()
                Finite family {0: TX[0], 1: TX[1], 2: TX[2]}

            """
            return Family(dict([[i, self.factor_embedding(0)(self.factor(0).from_reduced_word([i]))] for i in self.realization_of().double_affine_type().cartan_type().index_set()]))

        @cached_method
        def from_fundamental(self, i):
            r"""
            The image of the fundamental group element of `L` indexed by the special node `i`, in ``self``.

            EXAMPLES::

                sage: HH = DoubleAffineHeckeAlgebraSansDuality("A2")
                sage: [(i, HH.TL().from_fundamental(i)) for i in HH._F.special_nodes()]
                [(0, 1), (1, piX[1]), (2, piX[2])]
            """
            return self.factor_embedding(0)(self.factor(0).from_fundamental(self.realization_of()._F(i)))

        def from_lattice_algebra(self, a):
            r"""
            The image of the element `a` of `KL` in ``self``.

            EXAMPLES::

                sage: HH = DoubleAffineHeckeAlgebraSansDuality("A2")
                sage: TL = HH.TL()
                sage: KL = TL.factor(1)
                sage: a = KL.an_element(); a
                X[(2, 2, 3)]
                sage: b = TL.from_lattice_algebra(a); b
                X[(2, 2, 3)]
                sage: b.parent()
                TL basis of The double affine Hecke algebra of type ['A', 2, 1]

            """
            return self.factor_embedding(1)(a)

        def from_extended_affine_hecke(self, a):
            r"""
            The image of the element `a` of `T` in ``self``.

            EXAMPLES::

                sage: HH = DoubleAffineHeckeAlgebraSansDuality("A2")
                sage: TL = HH.TL()
                sage: T = TL.factor(0)
                sage: a = T.an_element(); a
                2*TX[0] + 3*TX[0,1] + 1 + TX[0,1,2] + 4*piX[1] TX[0] + 6*piX[1] TX[0,1] + 2*piX[1] + 2*piX[1] TX[0,1,2] + 8*piX[2] TX[0] + 12*piX[2] TX[0,1] + 4*piX[2] + 4*piX[2] TX[0,1,2]
                sage: b = TL.from_extended_affine_hecke(a); b
                2*TX[0] + 3*TX[0,1] + 1 + TX[0,1,2] + 4*piX[1] TX[0] + 6*piX[1] TX[0,1] + 2*piX[1] + 2*piX[1] TX[0,1,2] + 8*piX[2] TX[0] + 12*piX[2] TX[0,1] + 4*piX[2] + 4*piX[2] TX[0,1,2]
                sage: b.parent()
                TL basis of The double affine Hecke algebra of type ['A', 2, 1]                

            """
            return self.factor_embedding(0)(a)

        def from_reduced_word(self, word):
            r"""
            Given a reduced word for an element `w` in the affine Weyl group of `L`, return the image of the basis element `T_w`
            in ``self``.

            EXAMPLES::

                sage: DoubleAffineHeckeAlgebraSansDuality("A2").TL().from_reduced_word([0,2,1])
                TX[0,2,1]

            """
            return self.from_extended_affine_hecke(self.factor(0).from_reduced_word(word))



    class DoubleAffineHeckeAlgebraSansDualityLtvLv(SmashProductAlgebra, _DAHABases):
        r"""
        DAHA basis LtvLv.

        INPUT:

        - `HH` -- DAHA realization parent

        EXAMPLES::

            sage: DoubleAffineHeckeAlgebraSansDuality("A2").LtvLv()
            LtvLv basis of The double affine Hecke algebra of type ['A', 2, 1]


        """

        def __init__(self, HH):
            dat = HH.double_affine_type()
            # To define the product on LtvLv we just coerce to LT and back.
            # That is, we define the twist for LtvLv in terms of the twist for LT.
            mcat = ModulesWithBasis(HH.base_ring())
            tmcat = mcat.TensorProducts()
            KL = HH._KL
            coerceoid = tensor([HH.T().coerce_map_from(HH.tv_Lv()), KL._identity_map()], category=tmcat)
            idocoerce = tensor([KL._identity_map(), HH.tv_Lv().coerce_map_from(HH.T())], category=tmcat)

            HH._twist_LtvLv = SetMorphism(Hom(HH._tvLvLmod,HH._LtvLvmod,mcat),idocoerce * HH.LT().twist() * coerceoid)

            SmashProductAlgebra.__init__(self, HH._KL, HH.tv_Lv(), twist_morphism=HH._twist_LtvLv, category=Category.join((HH._DAHABasesCategory(),AlgebrasWithBasis(HH.base_ring()).TensorProducts())))
            self._style = "LtvLv"

        def _repr_(self):
            HH = self.realization_of()
            return "%s basis of %s"%(self._style, HH._repr_())

        def from_lattice_algebra(self, a):
            r"""
            The image of the element `a` of `KL` in ``self``.

            EXAMPLES::

                sage: HH = DoubleAffineHeckeAlgebraSansDuality("A2")
                sage: LtvLv = HH.LtvLv()
                sage: KL = HH.lattice_algebra()
                sage: a = KL.an_element(); a
                X[(2, 2, 3)]
                sage: b = LtvLv.from_lattice_algebra(a); b
                X[(2, 2, 3)]
                sage: b.parent()
                LtvLv basis of The double affine Hecke algebra of type ['A', 2, 1]
            """
            return self.factor_embedding(0)(a)


        def from_dual_lattice_algebra(self, a):
            r"""
            The embedding of the group algebra of `Lv` into ``self``.

            EXAMPLES::

                sage: HH=DoubleAffineHeckeAlgebraSansDuality("A2")
                sage: KLv = HH.dual_lattice_algebra()
                sage: a = KLv.an_element(); a
                Y[(2, 2, 3)]
                sage: a.parent()
                Group algebra of the Ambient space of the Root system of type ['A', 2] over Fraction Field of Multivariate Polynomial Ring in q, v, vl, v0, v2, vz over Rational Field
                sage: LtvLv = HH.LtvLv()
                sage: b = LtvLv.from_dual_lattice_algebra(a); b
                Y[(2, 2, 3)]
                sage: b.parent()
                LtvLv basis of The double affine Hecke algebra of type ['A', 2, 1]

            """
            return self.factor_embedding(1)(self.factor(1).factor_embedding(1)(a))

        def from_dual_classical_hecke(self, a):
            r"""
            Returns the image of `a` from the finite Hecke algebra "tv" of dual type, to ``self``.

            EXAMPLES::

                sage: HH = DoubleAffineHeckeAlgebraSansDuality("A2")
                sage: tv_Lv = HH.tv_Lv()
                sage: tv = HH.tv()
                sage: a = tv.an_element(); a
                2*Ty[1,2,1] + 4*Ty[1,2] + 1
                sage: LtvLv = HH.LtvLv()
                sage: b = LtvLv.from_dual_classical_hecke(a); b
                2*Ty[1,2,1] + 4*Ty[1,2] + 1
                sage: b == LtvLv(a)
                True
            """
            return self.factor_embedding(1)(self.factor(1).factor_embedding(0)(a))

        def from_reduced_word_dual(self, word):
            r"""
            Given a reduced word for an element `w` in the classical Weyl group of `Lv`, return the image of the basis element `T_w`
            in ``self``.

            EXAMPLES::

                sage: DoubleAffineHeckeAlgebraSansDuality("A2").TL().from_reduced_word_dual([2,1])
                TX[2,1]
            """
            return self.factor_embedding(1)(self.factor(1).from_reduced_word(word))

