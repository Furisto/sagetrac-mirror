#*****************************************************************************
#       Copyright (C) 2014 Mark Shimozono <mshimo at vt.edu>
#
#  Distributed under the terms of the GNU General Public License (GPL)
#                  http://www.gnu.org/licenses/
#*****************************************************************************
#
# Double affine Hecke algebras
#
################################

import functools
from sage.misc.cachefunc import cached_method
from sage.misc.functional import is_even
from sage.sets.set import Set
from sage.sets.family import Family
from sage.structure.unique_representation import UniqueRepresentation
from sage.categories.tensor import tensor
from sage.categories.modules_with_basis import ModulesWithBasis
from sage.rings.all import QQ
from sage.algebras.multiparameter_hecke_algebra import MultiParameterHeckeAlgebra
from sage.algebras.smash_product_algebra import SmashProductAlgebra

class DoubleAffineHeckeAlgebra(UniqueRepresentation):
    r"""
    Class which specifies a double affine Hecke algebra
    of not-necessarily-reduced possibly-extended affine type.

    INPUT:

        - ``cartan_type`` -- An irreducible finite Cartan type
        - ``untwisted`` -- True or False (default: True); whether to use the untwisted or twisted affinization
        - ``reduced`` -- True or False (default: True); whether the affine root system is reduced
        - ``dual_reduced`` -- True or False (default: True); whether the "dual" affine root system is reduced
        - ``prefix`` -- (default: None)
        - ``parameters`` -- keyword arguments for parameters

    EXAMPLES::

        sage: DoubleAffineHeckeAlgebra(['A',1], untwisted=True, reduced=True, dual_reduced=True)
        Double Affine Type ['A', 1, 1] reduced dual-reduced
        sage: DoubleAffineHeckeAlgebra(['C',3], untwisted=True, reduced=False, dual_reduced=True)
        Double Affine Type ['C', 3, 1] reduced dual-reduced
        sage: DoubleAffineHeckeAlgebra(['F',4], untwisted=False, reduced=True, dual_reduced=False)
        Double Affine Type ['F', 4, 1]^* relabelled by {0: 0, 1: 4, 2: 3, 3: 2, 4: 1} reduced dual-reduced
        sage: K = QQ['q,v,vl,v0,v2,vz'].fraction_field()
        sage: q,v,vl,v0,v2,vz = K.gens()
        sage: DoubleAffineHeckeAlgebra(['B',2], untwisted=False, reduced=False, dual_reduced=False, null_root=q,short=v,long=vl,zero=v0,doubled=v2,zero_doubled=vz)
        Double Affine Type ['C', 2, 1]^* nonreduced nondual-reduced

    ..RUBRIC:: Untwisted, dual untwisted, and mixed.

    There is a trichotomy of irreducible affine Cartan types: untwisted, dual untwisted (meaning the dual of an
    untwisted affine type) and mixed. The mixed types, `A_{2n}^{(2)}` and its dual, are the ones with three root lengths.

    ..RUBRIC:: Pair of affine Cartan types `\tilde{X}` and `\tilde{Y}`

    The inputs ``cartan_type`` and ``untwisted`` determine a pair of affine Cartan types `\tilde{X}` and `\tilde{Y}`
    which are both untwisted or both dual untwisted. Define

        - `X` -- The irreducible reduced finite Cartan type given by ``cartan_type``

        - `\tilde{X} -- if ``untwisted``, the untwisted affinization of `X`; otherwise, obtained from `X` by taking the dual, then the untwisted affinization, then the affine dual.

        - `W_a(\tilde{X})` -- The nonextended affine Weyl group of type `\tilde{X}`. It is generated by the simple reflections `s_i` for `i` in the affine Dynkin node set `I^X`.

        - `R_{red}(\tilde{X})` -- The set of affine real roots for the reduced affine root system. It is the set of affine root lattice elements of the form `u \alpha_i` where `u \in W_a(\tilde{X})` and `\alpha_i` is a simple root for `i \in I^X`.

        - `Y` -- Equal to `X` if not ``untwisted``; otherwise the dual of `X`

        - `\tilde{Y}` -- Equal to `\tilde{X}` if not ``untwisted``; otherwise the untwisted affinization of `Y`
        
    `W_a(\tilde{Y})` and `R_{red}(\tilde{Y})` are analogously defined.

    Since `X` and `Y` are either equal or dual, there is a natural bijection between their classical
    Dynkin node sets `I^X_0 = I^X \setminus \{0^X\}` and `I^Y_0`. This induces an isomorphism `W(X)\cong W(Y)` of
    the finite Weyl groups.

    ..RUBRIC:: Extended affine Weyl groups

    See :meth:`sage.combinat.root_system.ExtendedAffineWeylGroup` for definitions for extended affine Weyl groups.
    Define

        - `W_e(\tilde{X})` -- The extended affine Weyl group of type `\tilde{X}`.

        - `F^X` -- The fundamental group of `W_e(\tilde{X})` of length zero elements.

    Using the notation `W` for either of the isomorphic groups `W(X)` or `W(Y)` and letting
    `Q^Y` and `P^Y` be the root and weight lattices of type `Y`, there are isomorphisms

    ..MATH::

        W_a(\tilde{X}) \cong W \ltimes Q^Y \\
        W_e(\tilde{X}) \cong W \ltimes P^Y \cong F^X \ltimes W_a(\tilde{X})

    Note: The usual convention in the untwisted case is to use the coroot and coweight lattices of type `X`.

    The group `F^X` acts on `W_a(\tilde{X})` by the group automorphisms

    ..MATH::

        \pi^X s^X_i (\pi^X)^{-1} = s^X_{\pi^X(i)}

    for all `\pi^X \in F^X` and `i \in I^X` where the affine Dynkin automorphism `\pi^X` is regarded as a
    permutation of `I^X`. Similarly we have

    ..MATH::

        W_a(\tilde{Y}) \cong W \ltimes Q^X \\
        W_e(\tilde{Y}) \cong W \ltimes P^X \cong F^Y \ltimes W_a(\tilde{Y})

    ..RUBRIC:: Affine Hecke algebra `H(W_a(\tilde{X}))`

    Let `K` be a commutative ring. For `i \in I^X` let `v_{\alpha_i^X} \in K` be an invertible element.
    They must satisfy `v_{\alpha_i^X} = v_{\alpha_j^X}` if `\alpha_i^X` and `\alpha_j^X` are in the
    same `W_a(\tilde{X})`-orbit. The mnemonic for these parameters is `v^X`.

    The Hecke algebra `H(W_a(\tilde{X});v^X)` is the `K`-algebra with algebra generators
    `T^X_i` for `i \in I^X` with the `T^X_i` satisfying the same braid relations as the
    `s^X_i` do in `W_a(\tilde{X})`, together with the quadratic relations

    ..MATH::

        (T^X_i - v_{\alpha_i^X})(T^X_i + v_{\alpha_i^X}^{-1}) = 0

    for all `i \in I^X`.

    For `w \in W_a(\tilde{X})` let `w=s^X_{i_1}\dotsm s^X_{i_l}` be a reduced expression
    (one with `l` minimal) where `i_1,\dotsc,i_l \in I^X`. There is a well-defined element

    ..MATH::

        T^X_w = T^X_{i_1} \dotsm T^X_{i_l}.

    These form a `K`-basis of `H(W_a(\tilde{X}))`.

    ..RUBRIC:: Extended affine Hecke algebra of `W_e(\tilde{X})`

    Let `K` and `v_{\alpha_i^X}` be as for `H(W_a(\tilde{X}))` except that we impose the additional
    condition that `v_{\alpha_i^X} = v_{\alpha_j^X}` if `\alpha_i^X` and `\alpha_j^X` are in the
    same `W_e(\tilde{X})`-orbit (as opposed to the same `W_a(\tilde{X})`-orbit).
    Recalling that `W_e(\tilde{X}) \cong F^X \ltimes W_a(\tilde{X})`,
    the extended affine Hecke algebra `H(W_e(\tilde{X}),v^X)` is linearly the tensor product

    ..MATH::

        K[F^X] \otimes H(W_a(\tilde{X}),v^X)

    where `K[F^X]` is the group algebra, and `K[F^X]` acts on `H(W_a(\tilde{X}),v^X)` by

    ..MATH::

        \pi^X T^X_i (\pi^X)^{-1} = T^X_{\pi^X(i)}.

    for all `\pi^X \in F^X` and `i \in I^X`.

    Let `v \in W_e(\tilde{X})` be written `v = \pi^X w` with `\pi^X \in F^X` and `w \in W_a(\tilde{X})`.
    `H(W_e(\tilde{X}))` has a basis given by the elements

    ..MATH::

        T^X_v = \pi^X T^X_w.

    ..RUBRIC:: Not-necessarily-reduced affine root systems

    The pair of boolean inputs ``reduced`` and ``dual_reduced`` affects the choice of root versus weight lattices,
    nonextended and extended affine Weyl groups, and nonreduced versus reduced root systems.

    A node `i \in I^X` is *doubleable* if the evaluation `\alpha_i^\vee(\alpha_j)`
    of the `i`-th simple coroot `\alpha_i^\vee` on the `j`-th simple root, is even for all `j \in I^X`.

    Here are some examples of affine cartan types and their sets of doubleable nodes.

    - ['A',1,1] -- 0, 1
    - ['A',2,1] -- None
    - ['B',3,1] -- 3
    - ['D',4,2] -- 0, 3
    - ['C',2,1] -- 1
    - ['C',3,1] -- None

    Fact: The only untwisted or dual untwisted affine root systems
    with doubleable nodes, are `A_1^{(1)}` nodes `0,1`; `C_2^{(1)}` node `1`; `B_n^{(1)}` node `n`;
    and `D_{n+1}^{(2)}`, nodes `0,n`.

    ..RUBRIC: Notation

        - `S^X` -- if the input ``reduced`` is False, the set of doubleable nodes in `I^X`;
        otherwise, the empty set. We call this is the set of doubled nodes.
        - `R(\tilde{X})` -- the union of `R_{red}(\tilde{X})` with the elements `u (2\alpha_i)` 
        for `u \in W_a(\tilde{X})` and `i \in S^X`. This is the not-necessarily reduced
        affine root system.

    We say that `R(\tilde{X})` is reduced if it equals `R_{red}(\tilde{X})` (that is, `S^X` is empty)
    and is nonreduced otherwise. Even if ``reduced`` is set to False, if there are no
    doubleable nodes then `R(\tilde{X})` is still reduced.
     
    `S^Y` and `R(\tilde{Y})` are defined analogously, using `\tilde{Y}` instead of `\tilde{X}` and the input boolean
    ``dual_reduced`` instead of ``reduced``.

    ..RUBRIC:: Lattices `X` and `Y` and possibly extended affine Weyl groups `W(\tilde{X})` and `W(\tilde{Y})`

        - `X` -- By abuse of notation this symbol stands for the weight lattice `P^X` if `R(\tilde{Y})` is reduced (no typo with
          the Y here); otherwise, for the root lattice `Q^X`.

        - `\tilde{X}` -- This stands for the direct sum of the lattice `X` with the integer multiples of the affine null root
          `\delta^X`. It is a sublattice of the level-zero part of the affine weight lattice.

        - `W(\tilde{X})` -- If `R(\tilde{Y})` is reduced, this is the extended affine Weyl group `W_e(\tilde{X})`, and otherwise it is the nonextended affine Weyl group `W_a(\tilde{X})`.

        - `Y`, `\tilde{Y}`, `W(\tilde{Y})` -- Defined analogously with the roles of `X` and `Y` interchanged.

    Observe that the lattice `Y` (resp. `X`) provides the translation elements for the "other" affine Weyl group
    `W(\tilde{X})` (resp. `W(\tilde{Y})`):

    ..MATH::

        W(\tilde{X}) \cong W(Y) \ltimes Y
        W(\tilde{Y}) \cong W(X) \ltimes X

    Let `\Pi^X \subset F^X` be the trivial subgroup if `R(\tilde{Y})` is nonreduced and otherwise let `\Pi^X=F^X`.
    Make similar definitions for `\Pi^Y \subset F^Y`. Then

    ..MATH::

        W(\tilde{X}) \cong \Pi^X \ltimes W_a(\tilde{X})
        W(\tilde{Y}) \cong \Pi^Y \ltimes W_a(\tilde{Y})

    ..RUBRIC:: The base ring `K` of the DAHA and parameters

    We assume `K` is a commutative ring and `QQ`-algebra.

    For every `i \in I^X` there is an invertible element `v_{\alpha_i^X}\in K` and
    for every `i \in S^X` an invertible element `v_{2\alpha_i^X} \in K`.
    For convenience we define `v_{2\alpha_i^X}=v_{\alpha_i^X}` for `i \in I^X \setminus S^X`.
    They must satisfy the compatibility that `v_\alpha=v_\beta` if `\alpha` and `\beta` are in the
    same `W(\tilde{X})`-orbit in `R(\tilde{X})`.

    Finally, there is an invertible element `q \in K`. It represents the exponential of the null root
    `\delta^X` and also the exponential of `-\delta^Y`.
    Under this identification there are group homomorphisms
    `\tilde{X} \to K[X]` and `\tilde{Y} \to K[Y]`. We assume `q` is transcendental over `QQ` so that these maps are injective.
    In particular it makes sense to refer to `X^{\alpha_0^X} \in K[X]`.
    
    There is also an action of `W(\tilde{X})` on `K[X]` by `K`-algebra automorphisms:

    ..MATH::

        \begin{align*}
            s^X_i \cdot X^\lambda &= X^{s^X_i(\lambda)} \\
            \pi^X \cdot X^{\alpha_i^X} &= X^{\alpha_{\pi^X(i)}}
        \end{align*}

    where `i \in I^X`, `\lambda \in \tilde{X}`, and `\pi^X \in F^X`. 
    The action of `s^X_0` involves `q` since `\alpha^X_0` does.
    The action of `\Pi^X` has only been defined on the affine root lattice,
    which is only a sublattice of `\tilde{X}`, but this sublattice spans over
    the rationals. The action of `\Pi^X` can also involve `q`.

    ..RUBRIC:: The possibly-extended affine Hecke algebra `H(W(\tilde{X}))`.

    Define the possibly extended affine Hecke algebra `H(W(\tilde{X}))` to be `H(W_e(\tilde{X}))` or
    `H(W_a(\tilde{X}))` according as `W(\tilde{X})` equals `W_e(\tilde{X})` or `W_a(\tilde{X})`.

    ..RUBRIC:: The DAHA, at last!

    Linearly it is the tensor product

    ..MATH::

        H(X,Y;v^X) = H(W(\tilde{X}),v^X) \otimes K[X]

    To define the product it is enough to specify the commutation of the `T^X_i` with `X^\lambda`
    for `i \in I^X` and `\lambda \in X`. This is achieved using the very interesting Demazure-Lusztig operators.

    For nondoubled nodes `i \in I^X \setminus S^X` we have

    ..MATH::

        T^X_i X^\lambda - X^{s_i^X(\lambda)} T^X_i = (v_{\alpha_i^X} - v_{\alpha_i^X}^{-1})
            \dfrac{X^\lambda - X^{s_i^X(\lambda)}}{1 - X^{\alpha_i^X}}

    For doubled nodes `i \in S^X` we have

    ..MATH::

        T^X_i X^\lambda - X^{s_i^X(\lambda)} T^X_i =
            (v_{\alpha_i^X} - v_{\alpha_i^X}^{-1} + (v_{2\alpha_i^X} - v_{2\alpha_i^X}^{-1})X^{\alpha_i^X}
            \dfrac{X^\lambda - X^{s_i^X(\lambda)}}{1 - X^{2 \alpha_i^X}}

    In particular it follows that the DAHA `H(X,Y;v^X)` has bases of the form

    ..MATH::

        T_v X^\lambda \qquad\text{ and }\qquad X^\lambda T_v

    where `v \in W(\tilde{X})` and `\lambda \in X`. We call these bases the "TX_X" and "X_TX" bases respectively.

    ..RUBRIC:: Dual Hecke parameters

    Recall the parameters `v_{\alpha_i^X}` and `v_{2\alpha_i^X}`. 
    Recall that `v_{2\alpha_i^X} = v_{\alpha_i^X}` if `i \in I^X \setminus S^X`.

    The "dual Hecke parameters" are the following relabelling of the Hecke
    parameters::

        - `v_{\alpha_i^Y} = v_{\alpha_i^X}` -- for `i\ne 0`, 
        - `v_{\alpha_0^Y} = v_{2\alpha_r^X}` -- for `r \in I^X \setminus\{0\}` with `\alpha_r^X` short
        - `v_{2\alpha_i^Y} = v_{\alpha_0^X}` -- if `i \in S^Y\setminus \{0\}`
        - `v_{2\alpha_0^Y} = v_{2\alpha_0^X}` -- if `0 \in S^Y`

    where `v_{2\alpha_i^Y} = v_{\alpha_i^Y}` if `i \in I^Y \setminus S^Y`.
    The parameters `v_{\alpha_i^Y}` and `v_{2\alpha_i^Y}` are collectively labeled `v^Y`.

    ..RUBRIC:: Dual presentation of the DAHA

    The DAHA `H(X,Y;v^X)` has a `K`-algebra isomorphism

    ..MATH::

        H(X,Y;v^X) \cong H(W(\tilde{Y});v^Y) \otimes K[Y]

    We first give the commutation between `T^Y_i` and `Y^\lambda` to define the multiplication on
    the right hand side, and then describe the preimages of the right hand side's generators.

    For `i \in I^Y \setminus S^Y` and `\lambda \in Y` we have

    ..MATH::

        T^Y_i Y^\lambda - Y^{s_i^Y(\lambda)} T^Y_i = (v_{\alpha_i^Y} - v_{\alpha_i^Y}^{-1})
            \dfrac{Y^\lambda - X^{s_i^Y(\lambda)}}{1 - Y^{-\alpha_i^Y}}

    which looks like the `X`-analogue except for the `-\alpha_i^Y`.
    For doubled nodes `i \in S^Y` we have

    ..MATH::

        T^Y_i Y^\lambda - Y^{s_i^Y(\lambda)} T^Y_i =
            (v_{\alpha_i^Y} - v_{\alpha_i^Y}^{-1} + (v_{2\alpha_i^Y} - v_{2\alpha_i^Y}^{-1})Y^{-\alpha_i^Y}
            \dfrac{Y^\lambda - Y^{s_i^Y(\lambda)}}{1 - Y^{- 2 \alpha_i^Y}}

    For nonzero `i` we have `T^Y_i = T^X_i`. We have

    ..MATH::

        T^Y_0 = (X^\varphi T_{s_{\varphi}})^{-1}

    where `\varphi \in X` is the dominant short root (its associated coroot is the highest coroot).
    
    For `\pi_i^Y \in \Pi^Y` where `i` is a special node in `I^Y`, if `i=0^Y` then `\pi_i^Y` is the identity.
    For `i \ne 0^Y` let `\omega_i^X` be the `i`-th fundamental weight and `u_i \in W(X)` the shortest element
    such that `u_i(\omega_i)` is antidominant. Then

    ..MATH::

        \pi^Y_i = X^{\omega_i^X} T_{u_i^{-1}}.

    In particular it follows that the DAHA `H(X,Y;v^X)` has bases of the form

    ..MATH::

        T_v Y^\lambda \qquad\text{ and }\qquad Y^\lambda T_v

    where `v \in W(\tilde{Y})` and `\lambda \in Y`. We call these bases the "TY_Y" and "Y_TY" bases respectively.

    ..RUBRIC:: Bases

    Using the isomorphism `K[X] \otimes H(W) \cong H(W(\tilde{Y}))`
    of the type `\tilde{Y}` affine Hecke algebra, we have
    the following presentations of the DAHA.

        - "X_TX" -- `K[X] \otimes H(W(\tilde{X}))`
        - "X_T_Y" -- `K[X] \otimes H(W) \otimes K[Y]`
        - "TY_Y" -- `H(W(\tilde{Y})) \otimes K[Y]`

    The DAHA has a basis corresponding to each of the permutations of the tensor factors
    of these forms. The various bases of the DAHA are implemented by smash product algebras.

    ..RUBRIC:: Implementation of Hecke parameters

    The default base ring is the field `K` given by

    ::

        sage: K = QQ['q,v,vl,v0,v2,vz'].fraction_field()
        sage: q,v,vl,v0,v2,vz = K.gens()

    This can be customized using the ``parameters`` option. Every parameter must be an invertible element of the
    base ring. The default parameters have the following names.

        - `q`  -- 'null_root'. Recall that `q=X^{\delta^X}= Y^{-\delta^Y}`)
        - `v`  -- 'short' (orbit of short `\alpha_i^X` for some nonzero `i`)
        - `vl` -- 'long' (orbit of long `\alpha_i^X` for some nonzero `i` if not simply-laced)
        - `v0` -- 'zero' (orbit of `\alpha_0^X`)
        - `v2` -- 'doubled' (orbit of `2\alpha_i^X` for nonzero doubled node `i`)
        - `vz` -- 'zero_doubled' (orbit of `2\alpha_0^X`)

    In any given case only some of these parameters are used and often they may have the same value.

    EXAMPLES::

        sage: K = QQ['q,v'].fraction_field()
        sage: q,v=K.gens()
        sage: dat = DoubleAffineHeckeAlgebra(['A',2], untwisted=True, reduced=True, dual_reduced=True, null_root=q, short=v)
        sage: dat.parameter('short')
        v
        sage: dat.parameter('long')
        Traceback (most recent call last):
        ...
        ValueError: No parameter 'long'
        sage: K = QQ['q,v,vl,v0,v2,vz'].fraction_field()
        sage: q,v,vl,v0,v2,vz=K.gens()
        sage: dat = DoubleAffineHeckeAlgebra(['B',2], untwisted=False, reduced=False, dual_reduced=False, null_root=q,short=v,long=vl,zero=v0,doubled=v2,zero_doubled=vz)
        sage: dat.parameter('null_root')
        q
        sage: dat.parameter('doubled')
        v2
        sage: dat.parameter('zero')
        v0
        sage: dat.parameter('zero_doubled')
        vz

    REFERENCES:

    .. [Haiman_ICM] M. Haiman, Cherednik algebras, Macdonald polynomials and combinatorics,
       Proceedings of the International Congress of Mathematicians,
       Madrid 2006, Vol. III, 843-872.


    """

    @staticmethod
    def __classcall_private__(cls, cartan_type, untwisted=True, reduced=True, dual_reduced=True, prefix=None, **parameters):
        from sage.combinat.root_system.cartan_type import CartanType
        cartan_type = CartanType(cartan_type)
        if not cartan_type.is_finite():
            raise ValueError, "Cartan type is not finite"
        if cartan_type.rank() == 1:
            cartan_type = CartanType(['A',1])
        if not prefix:
            prefix = ''
        # check that parameters are invertible
        for par_name in parameters.keys():
            try:
                (parameters[par_name])**(-1)
            except ZeroDivisionError:
                raise ValueError, "Parameters must be invertible"
        return super(DoubleAffineHeckeAlgebra, cls).__classcall__(cls, cartan_type, untwisted, reduced, dual_reduced, prefix, **parameters)

    def __init__(self, cartan_type, untwisted, reduced, dual_reduced, prefix, **parameters):
        self._cartan_type_classical = cartan_type
        if cartan_type.is_simply_laced():
            # in simply-laced type, override `untwisted`
            self._untwisted = True
        else:
            self._untwisted = untwisted
        if untwisted:
            self._cartan_type = cartan_type.affine()
            self._other_affine_type = cartan_type.dual().affine()
        else:
            self._cartan_type = cartan_type.dual().affine().dual()
            self._other_affine_type = self._cartan_type

        I = self._cartan_type.index_set()
        cartan_matrix = self._cartan_type.cartan_matrix()
        # Compute the set of doubled nodes for \tilde{X}
        if reduced:
            self._doubled_nodes = tuple([])
        else:
            # uses that the index set starts with 0
            self._doubled_nodes = tuple([i for i in I if all(is_even(cartan_matrix[i,j]) for j in I)])

        self._reduced = (len(self._doubled_nodes) == 0)
        self._node_is_doubled = Family(I, lambda x: x in self._doubled_nodes)

        # Make the extended affine Weyl group W_e(\tilde{X})
        from sage.combinat.root_system.extended_affine_weyl_group import ExtendedAffineWeylGroup
        self._W = ExtendedAffineWeylGroup(self._cartan_type, style="PvW0", affine="S"+prefix,classical="s"+prefix,translation="t"+prefix,fundamental="pi"+prefix)
        # Compute whether \tilde{Y} is reduced.
        if dual_reduced:
            self._dual_reduced = True
        else:
            other_cartan_matrix = self._other_affine_type.cartan_matrix()
            # only set self._dual_reduced to False if the other affine root system has doubleable nodes
            self._dual_reduced = not any(i for i in I if all(is_even(other_cartan_matrix[i,j]) for j in I))

        # Specify the subgroup of allowable special affine Dynkin automorphisms `\Pi^X`.
        if self._dual_reduced:
            # Set `\Pi^X = F^X`
            self._special_nodes = tuple(self._W.realization_of().special_nodes())
        else:
            # Set `\Pi^X = \{0\}`
            self._special_nodes = tuple([0])

        # establish the specialization of Hecke parameters by computing
        # W(\tilde{X}) orbits of simple roots and their doubles
        vi = dict()
        v2i = dict()

        I0 = self._cartan_type_classical.index_set()
        # set the v_{\alpha_i} for i nonzero
        if self._cartan_type_classical.is_simply_laced():
            # for one root length we call it short for the purposes of the parameters.
            for i in I0:
                vi[i] = 'short'
        else:
            root_lattice = self._cartan_type_classical.root_system().root_lattice()
            for i in I0:
                vi[i] = 'short' if root_lattice.simple_root(i).is_short_root() else 'long'
        # set v_{\alpha_0}
        if len(self._special_nodes) >= 2:
            # \alpha_0 is in the orbit of another simple root by a Dynkin automorphism in W(\tilde{X})
            vi[0] = vi[self._special_nodes[1]]
        else:
            # check the attachment bond of 0 
            for i in I0:
                a0i = cartan_matrix[0,i]
                if a0i != 0:
                    break
            if a0i * cartan_matrix[i,0] == 1:
                # simple bond, and `\alpha_0` and `\alpha_i` are in the same orbit
                vi[0] = vi[i]
            else:
                # double bond, and `\alpha_0` is not in the orbit of any other simple root
                vi[0] = 'zero'

        # make v_{2\alpha_i}
        for i in I:
            v2i[i] = vi[i]

        # there are at most two doubled nodes and if there are two, one must be 0.
        for i in self._doubled_nodes:
            v2i[i] = 'zero_doubled' if i == 0 else 'doubled'

        # for BC with the nontrivial Dynkin automorphism allowed, 2\alpha_0 is in the orbit of 2\alpha_n.
        if 0 in self._doubled_nodes and self._dual_reduced:
            v2i[0] = 'doubled'

        # dictionaries for the orbits of simple (possibly doubled) roots under W(\tilde{X}).
        self._vi = Family(I, lambda i: vi[i])
        self._v2i = Family(I, lambda i: v2i[i])

        self._orbits = Set([self._vi[i] for i in I]+[self._v2i[i] for i in I])

        if 'null_root' in parameters.keys():
            q = parameters['null_root']
            K = q.parent()
            param_dict = dict({'null_root':q})
            for orbit in self._orbits:
                if orbit not in parameters.keys():
                    raise ValueError, "There is no parameter supplied for the orbit %s"%orbit
                else:
                    param_dict[orbit] = parameters[orbit]
                    if param_dict[orbit] not in K:
                        raise ValueError, "The parameter %s supplied for the orbit %s is not in the parent of %s"%(param_dict[orbit],orbit,q)
                        
            self._parameters = Family(dict([[key, param_dict[key]] for key in param_dict.keys()]))
        else:
            K = QQ['q,v,vl,v0,v2,vz'].fraction_field()
            param_dict = dict({'null_root':K.gen(0),'short':K.gen(1),'long':K.gen(2),'zero':K.gen(3),'doubled':K.gen(4),'zero_doubled':K.gen(5)})
            self._parameters = Family(dict([[root_type, param_dict[root_type]] for root_type in Set(['null_root'])+self._orbits]))
        self._base_ring = K
        self._prefix=prefix
        
    def __repr__(self):
        def non_string(str, bool):
            if bool:
                return str
            return "non"+str
        return "Double Affine Type %s %s %s"%(self._cartan_type, non_string("reduced", self._reduced), non_string("dual-reduced", self._dual_reduced))

    def untwisted(self):
        return self._untwisted

    def reduced(self):
        r"""
        Is ``self`` reduced?

        EXAMPLES::

            sage: DoubleAffineHeckeAlgebra(['B',2], untwisted=False, reduced=True, dual_reduced=False).reduced()
            True
            sage: DoubleAffineHeckeAlgebra(['B',2], untwisted=False, reduced=False, dual_reduced=False).reduced()
            False
            sage: DoubleAffineHeckeAlgebra(['A',2], untwisted=False, reduced=False, dual_reduced=False).reduced()
            True

        """
        return self._reduced

    def dual_reduced(self):
        r"""
        Is the DAHA dual of ``self`` reduced?

        EXAMPLES::

            sage: DoubleAffineHeckeAlgebra(['B',2], untwisted=False, reduced=False, dual_reduced=True).dual_reduced()
            True
            sage: DoubleAffineHeckeAlgebra(['B',2], untwisted=False, reduced=False, dual_reduced=False).dual_reduced()
            False
            sage: DoubleAffineHeckeAlgebra(['A',2], untwisted=False, reduced=False, dual_reduced=False).dual_reduced()
            True

        """
        return self._dual_reduced

    # this will need to get fixed later
    def base_ring(self):
        return self._base_ring

    def doubled_nodes(self):
        r"""
        The set of doubled nodes.

        EXAMPLES::

            sage: DoubleAffineHeckeAlgebra(['B',2], untwisted=False, reduced=False, dual_reduced=False).doubled_nodes()
            (0, 2)

        """
        return self._doubled_nodes

    def extended_affine_weyl_group(self):
        r"""
        The extended affine Weyl group.

        EXAMPLES::

            sage: DoubleAffineHeckeAlgebra(['C',2], untwisted=True, reduced=True, dual_reduced=False).extended_affine_weyl_group()
            Extended affine Weyl group of type ['C', 2, 1] realized by Semidirect product of Multiplicative form of Weight lattice of the Root system of type ['B', 2] acted upon by Weyl Group of type ['B', 2] (as a matrix group acting on the weight lattice)

        """
        return self._W

    @cached_method
    def affine_weyl_group(self):
        r"""
        The affine Weyl group `W_a(\tilde{X})`.

        EXAMPLES::

            sage: DoubleAffineHeckeAlgebra(['C',2], untwisted=True, reduced=True, dual_reduced=False).affine_weyl_group()
            Weyl Group of type ['C', 2, 1] (as a matrix group acting on the root lattice)
        """
        return self.extended_affine_weyl_group().realization_of().affine_weyl()

    @cached_method
    def classical_weyl_group(self):
        r"""
        The classical Weyl group `W(X)`.

        EXAMPLES::

            sage: DoubleAffineHeckeAlgebra(['C',2], untwisted=True, reduced=True, dual_reduced=False).classical_weyl_group()
            Weyl Group of type ['B', 2] (as a matrix group acting on the coweight lattice)
            
        """
        return self.extended_affine_weyl_group().realization_of().classical_weyl()

    @cached_method
    def dual_classical_weyl_group(self):
        r"""
        The classical Weyl group `W(Y)`.

        EXAMPLES::

            sage: DoubleAffineHeckeAlgebra(['C',2], untwisted=True, reduced=True, dual_reduced=False).dual_classical_weyl_group()
            Weyl Group of type ['B', 2] (as a matrix group acting on the weight lattice)

        """
        return self.extended_affine_weyl_group().realization_of().dual_classical_weyl()

    def cartan_type(self):
        r"""
        The affine Cartan type of ``self``.

        EXAMPLES::

            sage: DoubleAffineHeckeAlgebra(['B',2], untwisted=False, reduced=True, dual_reduced=False).cartan_type()
            ['C', 2, 1]^*

        """
        return self._cartan_type

    def cartan_type_classical(self):
        r"""
        The finite Cartan type of ``self``.

        EXAMPLES::

            sage: DoubleAffineHeckeAlgebra(['B',2], untwisted=False, reduced=True, dual_reduced=False).cartan_type_classical()
            ['B', 2]

        """
        return self._cartan_type_classical

    def special_nodes(self):
        r"""
        Return the set of special nodes indexing length-zero elements of `W(\tilde{X})`.

        EXAMPLES::

            sage: DoubleAffineHeckeAlgebra(['A',3], untwisted=True, reduced=True, dual_reduced=True).special_nodes()
            (0, 1, 2, 3)
            sage: DoubleAffineHeckeAlgebra(['B',3], untwisted=True, reduced=True, dual_reduced=True).special_nodes()
            (0, 1)
            sage: DoubleAffineHeckeAlgebra(['B',3], untwisted=False, reduced=False, dual_reduced=False).special_nodes()
            (0,)
            sage: DoubleAffineHeckeAlgebra(['B',3], untwisted=False, reduced=False, dual_reduced=True).special_nodes()
            (0, 3)

        """

        return self._special_nodes

    def properly_extended(self):
        r"""
        Is the group `W(\tilde{X})` strictly larger than `W_a(\tilde{X})`?

        EXAMPLES::

            sage: DoubleAffineHeckeAlgebra(['A',3], untwisted=True, reduced=True, dual_reduced=True).properly_extended()
            True
            sage: DoubleAffineHeckeAlgebra(['F',4], untwisted=True, reduced=True, dual_reduced=True).properly_extended()
            False
            sage: DoubleAffineHeckeAlgebra(['B',3], untwisted=False, reduced=True, dual_reduced=False).properly_extended()
            False
        """

        return len(self._special_nodes) >= 2

    def parameter(self, param):
        r"""
        A parameter.

        EXAMPLES::

            sage: DoubleAffineHeckeAlgebra("B2",False,False,False).parameter('zero')
            v0
            sage: DoubleAffineHeckeAlgebra("B2",False,False,False).parameter('short')
            v
            sage: DoubleAffineHeckeAlgebra("B2",False,False,False).parameter('long')
            vl
            sage: DoubleAffineHeckeAlgebra("B2",False,False,False).parameter('zero_doubled')
            vz
            sage: DoubleAffineHeckeAlgebra("B2",False,False,False).parameter('doubled')
            v2
            sage: DoubleAffineHeckeAlgebra("B2",False,False,False).parameter('null_root')
            q
        """
        try:
            return self._parameters[param]
        except KeyError:
            raise ValueError, "No parameter '%s'"%param

    def parameters(self):
        r"""
        The parameters of ``self``.

        EXAMPLES::

            sage: DoubleAffineHeckeAlgebra("B2",False,False,False).parameters()
            Finite family {'zero_doubled': vz, 'short': v, 'doubled': v2, 'zero': v0, 'long': vl, 'null_root': q}

        """
        return self._parameters

    @cached_method
    def q(self):
        return self.parameters()['null_root']

    @cached_method
    def v(self, i):
        r"""
        Family of parameters for nondoubled simple roots.
        """
        return self.parameters()[self._vi[i]]

    @cached_method
    def v2(self, i):
        r"""
        Family of parameters for doubled simple roots.
        """
        return self.parameters()[self._v2i[i]]

    @cached_method
    def dual(self, prefix=None):
        r"""
        The DAHA dual affine type.

        EXAMPLES::

            sage: dat = DoubleAffineHeckeAlgebra(['B',2], untwisted=True, reduced=False, dual_reduced=True, prefix="x"); dat
            Double Affine Type ['B', 2, 1] nonreduced dual-reduced
            sage: dat.dual()
            Double Affine Type ['C', 2, 1] reduced nondual-reduced            

        """
        if self._untwisted:
            dual_classical_type = self.cartan_type_classical().dual()
        else:
            dual_classical_type = self.cartan_type_classical()
        # to dualize parameters, the roles of 'doubled' and 'zero' get exchanged
        dual_parameters = dict()
        for x in self._parameters.keys():
            if x == 'doubled':
                dual_parameters['zero'] = self._parameters['doubled']
            elif x == 'zero':
                dual_parameters['doubled'] = self._parameters['zero']
            else:
                dual_parameters[x] = self._parameters[x]
        if prefix is None:
            prefix = ''
        return DoubleAffineHeckeAlgebra(dual_classical_type, self._untwisted, self._dual_reduced, self._reduced, prefix, **dual_parameters)

    @cached_method
    def classical_hecke_algebra(self, prefix=None):
        r"""
        The Hecke algebra of `W(X)`.

            sage: dat = DoubleAffineHeckeAlgebra(['B',2], untwisted=True, reduced=False, dual_reduced=True, prefix="x")
            sage: HX = dat.classical_hecke_algebra(); HX
            Hecke algebra of type ['C', 2]
            sage: HX.an_element()
            3*tx[2,1,2,1] + tx[1,2,1] + 3*tx[1,2]

        """
        ctc = self.cartan_type_classical()
        I0 = ctc.index_set()
        q1 = Family(dict([[i,self.v(i)] for i in I0]))
        q2 = Family(dict([[i,-1/self.v(i)] for i in I0]))
        if prefix is None:
            prefix = "t"+self._prefix
        return MultiParameterHeckeAlgebra(self.classical_weyl_group(), q1=q1, q2=q2, prefix=prefix)

    @cached_method
    def dual_classical_hecke_algebra(self, prefix=None):
        r"""
        The Hecke algebra of `W(Y)`.

            sage: dat = DoubleAffineHeckeAlgebra(['B',2], untwisted=True, reduced=False, dual_reduced=True, prefix="x")
            sage: HY = dat.dual_classical_hecke_algebra(prefix="ty"); HY
            Hecke algebra of type ['C', 2]
            sage: HY.an_element()
            3*ty[2,1,2,1] + ty[1,2,1] + 3*ty[1,2]

        """
        ctc = self.cartan_type_classical()
        I0 = ctc.index_set()
        q1 = Family(dict([[i,self.v(i)] for i in I0]))
        q2 = Family(dict([[i,-1/self.v(i)] for i in I0]))
        if prefix is None:
            prefix = "t"+self._prefix
        return MultiParameterHeckeAlgebra(self.dual_classical_weyl_group(), q1=q1, q2=q2, prefix=prefix)

    @cached_method
    def affine_hecke_algebra(self, prefix=None):
        r"""
        The Hecke algebra of `W_a(\tilde{X})`.

            sage: dat = DoubleAffineHeckeAlgebra(['B',2], untwisted=True, reduced=False, dual_reduced=True, prefix="X")
            sage: HaX = dat.affine_hecke_algebra(prefix="TX"); HaX
            Hecke algebra of type ['B', 2, 1]
            sage: HaX.an_element()
            TX[1,0,2] + 3*TX[0,2] + 2*TX[0] + 1

        """
        I = self.cartan_type().index_set()
        q1 = Family(dict([[i,self.v(i)] for i in I]))
        q2 = Family(dict([[i,-1/self.v(i)] for i in I]))
        if prefix is None:
            prefix = "T"+self._prefix
        return MultiParameterHeckeAlgebra(self.affine_weyl_group(), q1=q1, q2=q2, prefix=prefix)

    @cached_method
    def fundamental_group_algebra(self, prefix=None):
        r"""
        The group algebra of `\Pi^X`.

            sage: dat = DoubleAffineHeckeAlgebra(['B',2], untwisted=True, reduced=False, dual_reduced=True, prefix="x")
            sage: FX = dat.fundamental_group_algebra("FX"); FX
            Group algebra of Fundamental group of type ['B', 2, 1] over Fraction Field of Multivariate Polynomial Ring in q, v, vl, v0, v2, vz over Rational Field
            sage: FX.an_element()
            FX[pix[1]]

        """
        if prefix is None:
            prefix = "F"+self._prefix
        return self._W.realization_of().fundamental_group().algebra(self._base_ring, prefix=prefix)

    @cached_method
    def representation_ring(self, prefix=None):
        r"""
        The group algebra of `P^X`. We will only use the group algebra of the subgroup `X`.

            sage: dat = DoubleAffineHeckeAlgebra(['B',2], untwisted=True, reduced=False, dual_reduced=True, prefix="x")
            sage: KX = dat.representation_ring("X"); KX
            Group algebra of the Ambient space of the Root system of type ['B', 2] over Fraction Field of Multivariate Polynomial Ring in q, v, vl, v0, v2, vz over Rational Field
            sage: KX.an_element()
            X[(2, 2)]

        """
        if not prefix:
            prefix = self._prefix
        X = self.cartan_type().classical().root_system().ambient_space()
        return X.algebra(self._base_ring, prefix = prefix)

    @cached_method
    def dual_representation_ring(self, prefix=None):
        r"""
        The group algebra of `P^Y`. We will only use the group algebra of the subgroup `Y`.

            sage: dat = DoubleAffineHeckeAlgebra(['B',2], untwisted=True, reduced=False, dual_reduced=True, prefix="x")
            sage: KY = dat.dual_representation_ring("Y"); KY
            Group algebra of the Ambient space of the Root system of type ['C', 2] over Fraction Field of Multivariate Polynomial Ring in q, v, vl, v0, v2, vz over Rational Field
            sage: KY.an_element()
            Y[(2, 2)]
        """
        if not prefix:
            prefix = "Y"
        Y = self.cartan_type().classical().dual().root_system().ambient_space()
        return Y.algebra(self._base_ring, prefix = prefix)

    @cached_method
    def extended_affine_hecke_algebra_F_TX(self):
        r"""
        The Hecke algebra of the extended affine Weyl group `W_e(\tilde{X})`,
        realized as the smash product `K F^X \otimes H` of the group algebra
        `K F^X` of the fundamental group `F^X` of `\tilde{X}`, with the
        Hecke algebra `H` of `W_a(\tilde{X})`, where `K` is the base ring.

        EXAMPLES::

            sage: dat = DoubleAffineHeckeAlgebra("A2")
            sage: E = dat.extended_affine_hecke_algebra_F_TX(); E
            Smash product of Group algebra of Fundamental group of type ['A', 2, 1] over Fraction Field of Multivariate Polynomial Ring in q, v, vl, v0, v2, vz over Rational Field and Hecke algebra of type ['A', 2, 1]
            sage: x = E.an_element(); x
            2*F[pi[2]] # T[0] + 3*F[pi[2]] # T[0,1] + F[pi[2]] # 1 + F[pi[2]] # T[0,1,2]
        """
        H = self.affine_hecke_algebra()
        KF = self.fundamental_group_algebra()
        HF = tensor([H,KF],category=ModulesWithBasis(self.base_ring()))
        FH = tensor([KF,H],category=ModulesWithBasis(self.base_ring()))
        twist = HF.module_morphism(on_basis = lambda (w,pi): FH.monomial((pi,pi.inverse().act_on_affine_weyl(w))), codomain=FH, category=ModulesWithBasis(self.base_ring()))
        FSH = SmashProductAlgebra(KF, H, twist)
        untwist = FH.module_morphism(on_basis = lambda (pi,w): HF.monomial((pi.act_on_affine_weyl(w),pi)), codomain=HF, category=ModulesWithBasis(self.base_ring()))
        HSF = SmashProductAlgebra(H, KF, untwist)
        FSH.register_opposite(HSF)
        return FSH

    @cached_method
    def extended_affine_hecke_algebra_TX_F(self):
        r"""
        The algebra `H \otimes K F^X`; see :meth:`.extended_affine_hecke_algebra_F_TX`.
        """
        return self.extended_affine_hecke_algebra_F_TX().opposite()

    @cached_method
    def extended_affine_hecke_algebra_TY_Y(self):
        r"""
        The algebra `K[Y] \otimes H(W(Y))`. 

        The Hecke algebra of the finite Weyl group acts on `K[Y]` by the Demazure-Lusztig
        operators.
        """
        pass

    @cached_method
    def extended_affine_hecke_algebra_Y_TY(self):
        r"""
        The algebra `H(W(Y)) \otimes K[Y]`.

        """
        pass
