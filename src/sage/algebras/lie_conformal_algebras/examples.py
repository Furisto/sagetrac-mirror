r"""
Examples of Lie Conformal Algebras

- Abelian Lie Conformal Algebra

  For a commutative ring `R` and a free `R`-module `M`. The *Abelian Lie
  conformal algebra* generated by `M` is the free `R[T]` module
  generated by `M` with vanishing `\lambda`-brackets.

- Affine Lie Conformal Algebra

  The affine Kac-Moody Lie conformal algebra associated to the
  finite dimensional simple Lie algebra `\mathfrak{g}`. For a commutative
  ring `R`, it is the `R[T]`-module freely generated by `\mathfrak{g}`
  plus a central element `K` satisfying `TK = 0`. The non-vanishing
  `\lambda`-brackets are given by

  .. MATH::

      [a_\lambda b] = [a,b] + \lambda (a,b)K,

  where `a,b \in \mathfrak{g}` and `(a,b)` is the normalized
  form of `\mathfrak{g}` so that its longest root has square-norm
  `2`.

- Bosonic Ghosts Lie Conformal Algebra

  The *Bosonic-ghosts* or `\beta-\gamma`-system Lie conformal algebra
  with `2n` generators is the H-graded Lie conformal algebra generated
  by `\beta_i, \gamma_i, i = 1,\ldots,n` and a central element `K`, with
  non-vanishing `\lambda`-brackets:

  .. MATH::

      [{\beta_i}_\lambda \gamma_j] = \delta_{ij} K.

  The generators `\beta_i` have degree `1` while the generators `\gamma_i`
  have degree `0`.

- Fermionic Ghosts Super Lie Conformal Algebra

  The *Fermionic-ghosts* or b--c system super Lie conformal algebra
  with `2n` generators is the H-graded super Lie conformal algebra
  generated by odd vectors `b_i, c_i, i = 1,\ldots,n` and a central
  element `K`, with non-vanishing `\lambda`-brackets:

  .. MATH::

      [{b_i}_\lambda c_j] = \delta_{ij} K.

  The generators `b_i` have degree `1` while the generators `c_i`
  have degree `0`.

- Free Bosons Lie Conformal Algebra

  Given an `R`-module `M` with a symmetric, bilinear pairing
  `(\cdot, \cdot): M\otimes_R M \rightarrow R`. The *Free Bosons*
  Lie conformal algebra associated to this datum is the free
  `R[T]`-module generated by `M` plus a central vector `K` satisfying
  `TK=0`. The remaining `\lambda`-brackets are given by:

  .. MATH::

      [v_\lambda w] = \lambda (v,w)K,

  where `v,w \in M`.

  This is an H-graded Lie conformal algebra where every generator
  `v \in M` has degree 1.

- Free Fermions Super Lie Conformal Algebra.

  Given an `R`-module `M` with a skew-symmetric, bilinear pairing
  `\langle\cdot, \cdot\rangle: M\otimes_R M \rightarrow R`. The
  *Free Fermions* super Lie conformal algebra associated to this datum is
  the free `R[T]`-super module generated by `\Pi M` (a purely odd copy
  of `M`) plus a central vector `K` satisfying `TK=0`. The remaining
  `\lambda`-brackets are given by:

  .. MATH::

      [v_\lambda w] = \langle v,w \rangle K,

  where `v,w \in M`.

  This is an H-graded Lie conformal algebra where every generator
  `v \in M` has degree `1/2`.

- Virasoro Lie Conformal Algebra

  The Virasoro Lie conformal algebra is generated by `L` and a central
  element `C`. The `\lambda`-brackets are given by:

  .. MATH::

      [L_\lambda L] = T L + 2 \lambda L + \frac{\lambda^3}{12} C.

  It is an H-graded Lie conformal algebra with `L` of degree `2`.

- Neveu-Schwarz Super Lie Conformal Algebra

  The `N=1` or *Neveu-Schwarz* super Lie conformal algebra is a super
  extension of the Virasoro Lie conformal algebra with generators `L`
  and `C` by an odd primary generator `G` of conformal weight `3/2`. The
  remaining `\lambda`-bracket is given by:

  .. MATH::

      [G_\lambda G] = 2L + \frac{\lambda^2}{3} C.

- N=2 Super Lie Conformal Algebra

  The `N=2` super Lie conformal algebra is an extension of the Virasoro
  Lie conformal algebra (with generators `L,C`) by an even generator `J`
  which is primary of conformal weight `1` and two odd generators
  `G_1,G_2` which are primary of conformal weight `3/2`. The remaining
  `\lambda`-brackets are given by:

  .. MATH::

      [J_\lambda J] &= \frac{\lambda}{3} C, \\
      [J_\lambda G_1] &= G_1, \\
      [J_\lambda G_2] &= -G_2, \\
      [{G_1}_\lambda G_1] &= [{G_2}_\lambda G_2 ] = 0, \\
      [{G_1}_\lambda G_2] &= L + \frac{1}{2} TJ + \lambda J + \frac{\lambda^2}{6}C.

- Weyl Lie Conformal Algebra

  Given a commutative ring `R`, a free `R`-module `M` and a
  non-degenerate, skew-symmetric, bilinear pairing
  `\langle \cdot,\cdot\rangle: M \otimes_R M \rightarrow R`. The *Weyl*
  Lie conformal algebra associated to this datum is the free
  `R[T]`-module generated by `M` plus a central vector `K`. The
  non-vanishing `\lambda`-brackets are given by:

  .. MATH::

      [v_\lambda w] = \langle v, w\rangle K.

  This is not an H-graded Lie conformal algebra. The choice of a
  Lagrangian decomposition `M = L \oplus L^*` determines an H-graded
  structure. For this H-graded Lie conformal algebra see:

  :class:`BosonicGhostsLieConformalAlgebra`.

AUTHORS:

- Reimundo Heluani (2020-06-15): Initial implementation.
"""

#******************************************************************************
#       Copyright (C) 2020 Reimundo Heluani <heluani@potuz.net>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# (at your option) any later version.
#                  http://www.gnu.org/licenses/
#*****************************************************************************

from .graded_lie_conformal_algebra import GradedLieConformalAlgebra
from sage.rings.integer import Integer
from sage.algebras.lie_algebras.lie_algebra import LieAlgebra
from sage.matrix.special import identity_matrix
from sage.structure.indexed_generators import standardize_names_index_set
from .lie_conformal_algebra_with_structure_coefs import \
                                LieConformalAlgebraWithStructureCoefficients

class AbelianLieConformalAlgebra(GradedLieConformalAlgebra):
    def __init__(self, R, ngens=1, weights=None,
                 parity=None, names=None, index_set=None):
        r"""
        The Abelian Lie conformal algebra.

        INPUT:

        - ``R`` -- a commutative ring; the base ring of this Lie
          conformal algebra
        - ``ngens`` -- a positive integer (default: ``1``); the number
          of generators of this Lie conformal algebra
        - ``weights`` -- a list of positive rational numbers (default:
          ``1`` for each
          generator); the weights of the generators. The resulting
          Lie conformal algebra is `H`-graded.
        - ``parity`` -- ``None`` or a list of ``0`` or ``1`` (default:
          ``None``); The parity of the generators. If not ``None`` the
          resulting Lie Conformal algebra is a Super Lie conformal
          algebra
        - ``names`` -- a tuple of ``str`` or ``None`` (default: ``None``
          ); the list of names of the generators of this algebra.
        - ``index_set`` -- an enumerated set or ``None`` (default:
          ``None``); A set indexing the generators of this Lie
          conformal algebra.

        OUTPUT:

        The Abelian Lie conformal algebra with generators `a_i`,
        `i=1,...,n` and vanishing `\lambda`-brackets, where `n` is
        ``ngens``.

        EXAMPLES::

            sage: R = AbelianLieConformalAlgebra(QQ,2); R
            The Abelian Lie conformal algebra with generators (a0, a1) over Rational Field
            sage: R.inject_variables()
            Defining a0, a1
            sage: a0.bracket(a1.T(2))
            {}

        TESTS::

            sage: R.central_elements()
            ()
            sage: R.structure_coefficients()
            Finite family {}

        .. TODO::

            implement its own class to speed up arithmetics in this
            case.
        """
        if (names is None) and (index_set is None):
            names = 'a'
            self._latex_names = tuple(r'a_{%d}' % i for i in range(ngens))

        names,index_set = standardize_names_index_set(names=names,
                                                      index_set=index_set,
                                                      ngens=ngens)
        abeliandict = {}

        GradedLieConformalAlgebra.__init__(self, R, abeliandict, names=names,
                                           index_set=index_set, weights=weights,
                                           parity=parity)

    def _repr_(self):
        """
        String representation.
        """
        return "The Abelian Lie conformal algebra with generators {} over {}"\
                .format(self.gens(), self.base_ring())

class AffineLieConformalAlgebra(GradedLieConformalAlgebra):
    def __init__(self, R, ct, names=None, prefix=None, bracket=None):
        r"""
        The current or affine Kac-Moody Lie conformal algebra.

        INPUT:

        - ``R`` -- a commutative Ring; the base ring for this Lie
          conformal algebra.
        - ``ct`` -- a ``str`` or a :mod:`CartanType<sage.combinat.\
          root_system.cartan_type>`; the Cartan Type for
          the corresponding finite dimensional Lie algebra. It must
          correspond to a simple finite dimensional Lie algebra.
        - ``names`` -- a list of ``str`` or ``None`` (default: ``None``)
          ; alternative names for the generators. If ``None`` the
          generators are labeled by the corresponding root and coroot
          vectors.
        - ``prefix`` -- a ``str``; parameter passed to
          :class:`IndexedGenerators<\
          sage.structure.indexed_generators.IndexedGenerators>`
        - ``bracket`` -- a ``str``; parameter passed to
          :class:`IndexedGenerators<\
          sage.structure.indexed_generators.IndexedGenerators>`.

        EXAMPLES::

            sage: R = AffineLieConformalAlgebra(QQ, 'A1')
            sage: R
            The affine Lie conformal algebra of type ['A', 1] over Rational Field
            sage: R.an_element()
            B[alpha[1]] + B[alphacheck[1]] + B[-alpha[1]] + B['K']

            sage: R = AffineLieConformalAlgebra(QQ, 'A1', names = ('e', 'h','f'))
            sage: R.inject_variables()
            Defining e, h, f, K
            sage: Family(e.bracket(f.T(3)))
            Finite family {0: 6*T^(3)h, 1: 6*T^(2)h, 2: 6*Th, 3: 6*h, 4: 24*K}

            sage: V = AffineLieConformalAlgebra(QQ, CartanType(["A",2,1]))
            Traceback (most recent call last):
            ...
            ValueError: Only affine algebras of simple finite dimensionalLie algebras are implemented

        OUTPUT:

        The Affine Lie conformal algebra associated with the finite
        dimensional simple Lie algebra of Cartan type ``ct``.
        """
        if type(ct) is str:
            from sage.combinat.root_system.cartan_type import CartanType
            try:
                ct = CartanType(ct)
            except IndexError:
                raise ValueError("ct must be a valid Cartan Type")
        if not (ct.is_finite() and ct.is_irreducible ):
            raise ValueError("Only affine algebras of simple finite dimensional"
                "Lie algebras are implemented")
        hv = Integer(ct.dual_coxeter_number())
        g = LieAlgebra(R, cartan_type=ct)
        B = g.basis()
        S = B.keys()
        gdict = {}
        for k1 in S:
            for k2 in S:
                if S.rank(k2) <= S.rank(k1):
                    myb = B[k1].bracket(B[k2]).monomial_coefficients()
                    myf = R(2).inverse_of_unit()*R(hv).inverse_of_unit()\
                          *g.killing_form(B[k1],B[k2])
                    if myb or myf:
                        gdict[(k1,k2)] = {}
                        if myb:
                            gdict[(k1,k2)][0] = {(nk,0):v for nk,v in \
                                                                    myb.items()}
                        if myf:
                            gdict[(k1,k2)][1] = {('K',0):myf}

        weights = (1,)*B.cardinality()
        self._ct = ct
        if prefix is None and names is None:
            prefix = 'B'

        GradedLieConformalAlgebra.__init__(self,
                    R, gdict, index_set=S,
                    central_elements=('K',), weights=weights,
                    names=names, prefix=prefix,bracket=bracket)

    def cartan_type(self):
        """
        The Cartan type of this Lie conformal algbera.

        EXAMPLES::

            sage: R = AffineLieConformalAlgebra(QQ, 'B3')
            sage: R
            The affine Lie conformal algebra of type ['B', 3] over Rational Field
            sage: R.cartan_type()
            ['B', 3]
        """
        return self._ct

    def _repr_(self):
        """
        The name of this Lie conformal algebra.
        """
        return "The affine Lie conformal algebra of type {} over {}".format(
                                                    self._ct,self.base_ring())

class BosonicGhostsLieConformalAlgebra(GradedLieConformalAlgebra):

    def __init__(self, R, ngens=2, names=None, index_set=None):
        r"""
        The Bosonic ghosts or `\beta-\gamma`-system Lie conformal
        algebra.

        INPUT:

        - ``R`` -- a commutative ring.
        - ``ngens`` -- an even positive Integer (default: ``2``); the
          number of non-central generators of this Lie conformal
          algebra.
        - ``names`` -- a list of ``str``; alternative names for the
          generators
        - ``index_set`` -- an enumerated set; An indexing set for the
          generators.

        OUTPUT:

        The Bosonic Ghosts Lie conformal algebra with generators
        `\beta_i,\gamma_i, i=1,\ldots,n` and `K`, where `2n` is
        ``ngens``.

        EXAMPLES::

            sage: R = BosonicGhostsLieConformalAlgebra(QQ); R
            The Bosonic ghosts Lie conformal algebra with generators (beta, gamma, K) over Rational Field
            sage: R.inject_variables(); beta.bracket(gamma)
            Defining beta, gamma, K
            {0: K}
            sage: beta.degree()
            1
            sage: gamma.degree()
            0

            sage: R = BosonicGhostsLieConformalAlgebra(QQbar, ngens = 4, names = 'abcd'); R
            The Bosonic ghosts Lie conformal algebra with generators (a, b, c, d, K) over Algebraic Field
            sage: R.structure_coefficients()
            Finite family {('a', 'c'): ((0, K),),  ('b', 'd'): ((0, K),),  ('c', 'a'): ((0, -K),),  ('d', 'b'): ((0, -K),)}

        TESTS::

            sage: BosonicGhostsLieConformalAlgebra(AA).category()
            Category of finitely generated H-graded Lie conformal algebras with basis over Algebraic Real Field
        """
        from sage.rings.all import ZZ
        try:
            assert (ngens in ZZ and ngens > 0 and ngens % 2 == 0)
        except AssertionError:
            raise ValueError("ngens should be an even positive integer, " +
                             "got {}".format(ngens))
        latex_names = None
        if (names is None) and (index_set is None):
            from sage.misc.defaults import variable_names as varnames
            from sage.misc.defaults import latex_variable_names as laxnames
            names = varnames(ngens/2,'beta') + varnames(ngens/2,'gamma')
            latex_names =  tuple(laxnames(ngens/2,r'\beta') +\
                                          laxnames(ngens/2,r'\gamma')) + ('K',)

        names,index_set = standardize_names_index_set(names=names,
                                                      index_set=index_set,
                                                      ngens=ngens)
        A = identity_matrix(R,ngens/2)
        from sage.matrix.special import block_matrix
        gram_matrix = block_matrix([[R.zero(),A],[-A,R.zero()]])
        ghostsdict = { (i,j): {0: {('K',0): gram_matrix[index_set.rank(i),
                    index_set.rank(j)]}} for i in index_set for j in index_set}
        weights = (1,)*(ngens//2) + (0,)*(ngens//2)
        super(BosonicGhostsLieConformalAlgebra,self).__init__(R,
                                           ghostsdict,names=names,
                                           latex_names=latex_names,
                                           index_set=index_set,
                                           weights=weights,
                                           central_elements=('K',))

    def _repr_(self):
        """
        String representation.

        EXAMPLES::

            sage: BosonicGhostsLieConformalAlgebra(QQbar)
            The Bosonic ghosts Lie conformal algebra with generators (beta, gamma, K) over Algebraic Field
        """
        return "The Bosonic ghosts Lie conformal algebra with generators {} "\
               "over {}".format(self.gens(),self.base_ring())

class FermionicGhostsLieConformalAlgebra(GradedLieConformalAlgebra):

    def __init__(self,R,ngens=2,names=None,index_set=None):
        r"""
        The Fermionic ghosts or `bc`-system super Lie conformal algebra.

        INPUT:

        - ``R`` --  a commutative ring; the base ring of this Lie
          conformal algebra
        - ``ngens`` -- an even positive Integer (default: ``2``); The
          number of non-central generators of this Lie conformal
          algebra.
        - ``names`` -- a tuple of ``str``; alternative names for the
          generators
        - ``index_set`` -- an enumerated set; alternative indexing
          set for the generators.

        OUTPUT:

        The Fermionic Ghosts super Lie conformal algebra with generators
        `b_i,c_i, i=1,\ldots,n` and `K` where `2n` is ``ngens``.

        EXAMPLES::

            sage: R = FermionicGhostsLieConformalAlgebra(QQ); R
            The Fermionic ghosts Lie conformal algebra with generators (b, c, K) over Rational Field
            sage: R.inject_variables()
            Defining b, c, K
            sage: b.bracket(c) == c.bracket(b)
            True
            sage: b.degree()
            1
            sage: c.degree()
            0
            sage: R.category()
            Category of finitely generated super H-graded Lie conformal algebras with basis over Rational Field

            sage: R = FermionicGhostsLieConformalAlgebra(QQbar, ngens=4, names = 'abcd');R
            The Fermionic ghosts Lie conformal algebra with generators (a, b, c, d, K) over Algebraic Field
            sage: R.structure_coefficients()
            Finite family {('a', 'c'): ((0, K),),  ('b', 'd'): ((0, K),),  ('c', 'a'): ((0, K),),  ('d', 'b'): ((0, K),)}
        """
        try:
            assert (ngens > 0 and ngens % 2 == 0)
        except AssertionError:
            raise ValueError("ngens should be an even positive integer, " +
                             "got {}".format(ngens))
        latex_names = None
        if (names is None) and (index_set is None):
            from sage.misc.defaults import variable_names as varnames
            from sage.misc.defaults import latex_variable_names as laxnames
            names = varnames(ngens/2,'b') + varnames(ngens/2,'c')
            latex_names =  tuple(laxnames(ngens/2,'b') +\
                                          laxnames(ngens/2,'c')) + ('K',)

        from sage.structure.indexed_generators import \
                                                standardize_names_index_set
        names,index_set = standardize_names_index_set(names=names,
                                                      index_set=index_set,
                                                      ngens=ngens)
        from sage.matrix.special import identity_matrix
        A = identity_matrix(R,ngens/2)
        from sage.matrix.special import block_matrix
        gram_matrix = block_matrix([[R.zero(),A],[A,R.zero()]])
        ghostsdict = { (i,j): {0: {('K',0): gram_matrix[index_set.rank(i),
                    index_set.rank(j)]}} for i in index_set for j in index_set}
        weights = (1,)*(ngens//2) + (0,)*(ngens//2)
        parity = (1,)*ngens
        super(FermionicGhostsLieConformalAlgebra,self).__init__(R,
                                           ghostsdict,names=names,
                                           latex_names=latex_names,
                                           index_set=index_set,
                                           weights=weights,
                                           parity=parity,
                                           central_elements=('K',))

    def _repr_(self):
        """
        String representation.

        EXAMPLES::

            sage: FermionicGhostsLieConformalAlgebra(QQ)
            The Fermionic ghosts Lie conformal algebra with generators (b, c, K) over Rational Field
        """
        return "The Fermionic ghosts Lie conformal algebra with generators {} "\
               "over {}".format(self.gens(),self.base_ring())

class FreeBosonsLieConformalAlgebra(GradedLieConformalAlgebra):
    def __init__(self, R, ngens=None, gram_matrix=None, names=None,
                 index_set=None):
        r"""
        The Free Bosons Lie conformal algebra.

        INPUT:

        - ``R`` -- a commutative ring.
        - ``ngens`` -- a positive Integer (default ``1``); the number of
          non-central generators of this Lie conformal algebra.
        - ``gram_matrix``: a symmetric square matrix with coefficients
          in ``R`` (default: ``identity_matrix(ngens)``); the Gram
          matrix of the inner product
        - ``names`` -- a tuple of ``str``; alternative names for the
          generators
        - ``index_set`` -- an enumerated set; alternative indexing set
          for the generators.

        OUTPUT:

        The Free Bosons Lie conformal algebra with generators
         `\alpha_i`, `i=1,...,n` and `\lambda`-brackets

         .. MATH::

            [{\alpha_i}_{\lambda} \alpha_j] = \lambda M_{ij} K,

        where `n` is the number of generators ``ngens`` and `M` is
        the ``gram_matrix``. This Lie conformal
        algebra is `H`-graded where every generator has conformal weight
        `1`.

        EXAMPLES::

            sage: R = FreeBosonsLieConformalAlgebra(AA); R
            The free Bosons Lie conformal algebra with generators (alpha, K) over Algebraic Real Field
            sage: R.inject_variables()
            Defining alpha, K
            sage: alpha.bracket(alpha)
            {1: K}
            sage: M = identity_matrix(QQ,2); R = FreeBosonsLieConformalAlgebra(QQ,gram_matrix=M, names='alpha,beta'); R
            The free Bosons Lie conformal algebra with generators (alpha, beta, K) over Rational Field
            sage: R.inject_variables(); alpha.bracket(beta)
            Defining alpha, beta, K
            {}
            sage: alpha.bracket(alpha)
            {1: K}
            sage: R = FreeBosonsLieConformalAlgebra(QQbar, ngens=3); R
            The free Bosons Lie conformal algebra with generators (alpha0, alpha1, alpha2, K) over Algebraic Field

        TESTS::
            sage: R = FreeBosonsLieConformalAlgebra(QQ); R.0.degree()
            1
            sage: R = FreeBosonsLieConformalAlgebra(QQbar, ngens=2, gram_matrix=identity_matrix(QQ,1,1))
            Traceback (most recent call last):
            ...
            ValueError: The gram_matrix should be a symmetric 2 x 2 matrix, got [1]
            sage: R = FreeBosonsLieConformalAlgebra(QQbar, ngens=2, gram_matrix=Matrix(QQ,[[0,1],[-1,0]]))
            Traceback (most recent call last):
            ...
            ValueError: The gram_matrix should be a symmetric 2 x 2 matrix, got [ 0  1]
            [-1  0]
        """
        from sage.matrix.matrix_space import MatrixSpace
        if (gram_matrix is not None):
            if ngens is None:
                ngens = gram_matrix.dimensions()[0]
            try:
                assert (gram_matrix in MatrixSpace(R,ngens,ngens))
            except AssertionError:
                raise ValueError("The gram_matrix should be a symmetric " +
                    "{0} x {0} matrix, got {1}".format(ngens,gram_matrix))
            if not gram_matrix.is_symmetric():
                raise ValueError("The gram_matrix should be a symmetric " +
                    "{0} x {0} matrix, got {1}".format(ngens,gram_matrix))
        else:
            if ngens is None:
                ngens = 1;
            gram_matrix = identity_matrix(R,ngens,ngens)

        latex_names = None
        if (names is None) and (index_set is None):
            names = 'alpha'
            latex_names = tuple(r'\alpha_{%d}' % i \
                                      for i in range (ngens)) + ('K',)
        names,index_set = standardize_names_index_set(names=names,
                                                      index_set=index_set,
                                                      ngens=ngens)
        bosondict = { (i,j): {1: {('K',0): gram_matrix[index_set.rank(i),
                    index_set.rank(j)]}} for i in index_set for j in index_set}

        GradedLieConformalAlgebra.__init__(self,R,bosondict,names=names,
                                           latex_names=latex_names,
                                           index_set=index_set,
                                           central_elements=('K',))

        self._gram_matrix = gram_matrix

    def _repr_(self):
        """
        String representation.

        EXAMPLES::

            sage: FreeBosonsLieConformalAlgebra(AA)
            The free Bosons Lie conformal algebra with generators (alpha, K) over Algebraic Real Field
        """
        return "The free Bosons Lie conformal algebra with generators {}"\
                " over {}".format(self.gens(),self.base_ring())

    def gram_matrix(self):
        r"""
        The Gram matrix that specifies the `\lambda`-brackets of the
        generators.

        EXAMPLES::

            sage: R = FreeBosonsLieConformalAlgebra(QQ,ngens=2);
            sage: R.gram_matrix()
            [1 0]
            [0 1]
        """
        return self._gram_matrix

class FreeFermionsLieConformalAlgebra(GradedLieConformalAlgebra):

    def __init__(self, R, ngens=None, gram_matrix=None, names=None,
                 index_set=None):
        r"""
        The Free Fermions Super Lie conformal algebra.

        INPUT:

        - ``R``: a commutative ring.
        - ``ngens``: a positive Integer (default ``1``); the number of
          non-central generators of this Lie conformal algebra.
        - ``gram_matrix``: a symmetric square matrix with coefficients
          in ``R`` (default: ``identity_matrix(ngens)``); the Gram
          matrix of the inner product

        OUTPUT:

        The Free Fermions Lie conformal algebra with generators
         `\psi_i`, `i=1,...,n` and `\lambda`-brackets

         .. MATH::

            [{\psi_i}_{\lambda} \psi_j] = M_{ij} K,

        where `n` is the number of generators ``ngens`` and `M` is the
        ``gram_matrix``. This super Lie conformal
        algebra is `H`-graded where every generator has degree `1/2`.

        EXAMPLES::

            sage: R = FreeFermionsLieConformalAlgebra(QQbar); R
            The free Fermions super Lie conformal algebra with generators (psi, K) over Algebraic Field.
            sage: R.inject_variables()
            Defining psi, K
            sage: psi.bracket(psi)
            {0: K}

            sage: R = FreeFermionsLieConformalAlgebra(QQbar,gram_matrix=Matrix([[0,1],[1,0]])); R
            The free Fermions super Lie conformal algebra with generators (psi_0, psi_1, K) over Algebraic Field.
            sage: R.inject_variables()
            Defining psi_0, psi_1, K
            sage: psi_0.bracket(psi_1)
            {0: K}
            sage: psi_0.degree()
            1/2
            sage: R.category()
            Category of finitely generated super H-graded Lie conformal algebras with basis over Algebraic Field
        """
        from sage.matrix.matrix_space import MatrixSpace
        from sage.matrix.special import identity_matrix
        if (gram_matrix is not None):
            if ngens is None:
                ngens = gram_matrix.dimensions()[0]
            try:
                assert (gram_matrix in MatrixSpace(R,ngens,ngens))
            except AssertionError:
                raise ValueError("The gram_matrix should be a symmetric " +
                    "{0} x {0} matrix, got {1}".format(ngens,gram_matrix))
            if not gram_matrix.is_symmetric():
                raise ValueError("The gram_matrix should be a symmetric " +
                    "{0} x {0} matrix, got {1}".format(ngens,gram_matrix))
        else:
            if ngens is None:
                ngens = 1;
            gram_matrix = identity_matrix(R,ngens,ngens)

        latex_names=None

        if (names is None) and (index_set is None):
            if ngens==1:
                names = 'psi'
            else:
                names = 'psi_'
            latex_names = tuple(r"\psi_{%d}" % i \
                                      for i in range (ngens)) + ('K',)

        from sage.structure.indexed_generators import \
                                                standardize_names_index_set
        names,index_set = standardize_names_index_set(names=names,
                                                      index_set=index_set,
                                                      ngens=ngens)
        fermiondict = { (i,j): {0: {('K',0): gram_matrix[index_set.rank(i),
                    index_set.rank(j)]}} for i in index_set for j in index_set}

        from sage.rings.rational_field import QQ
        weights = (QQ(1/2),)*ngens
        parity = (1,)*ngens
        GradedLieConformalAlgebra.__init__(self,R,fermiondict,names=names,
                                           latex_names=latex_names,
                                           index_set=index_set,weights=weights,
                                           parity=parity,
                                           central_elements=('K',))

        self._gram_matrix = gram_matrix

    def _repr_(self):
        return "The free Fermions super Lie conformal algebra "\
                    "with generators {} over {}.".format(self.gens(),
                                                         self.base_ring())

    def gram_matrix(self):
        r"""
        The Gram matrix that specifies the `\lambda`-brackets of the
        generators.

        EXAMPLES::

            sage: R = FreeFermionsLieConformalAlgebra(QQ,ngens=2);
            sage: R.gram_matrix()
            [1 0]
            [0 1]
        """
        return self._gram_matrix




class N2LieConformalAlgebra(GradedLieConformalAlgebra):
    def __init__(self,R):
        """
        The N=2 super Lie conformal algebra.

        INPUT:

        - ``R`` -- a commutative ring; the base ring of this super
          Lie conformal algebra.

        EXAMPLES::

            sage: F.<x> = NumberField(x^2 -2)
            sage: R = N2LieConformalAlgebra(F); R
            The N=2 super Lie conformal algebra over Number Field in x with defining polynomial x^2 - 2
            sage: R.inject_variables()
            Defining L, J, G1, G2, C
            sage: G1.bracket(G2)
            {0: L + 1/2*TJ, 1: J, 2: 1/3*C}
            sage: G2.bracket(G1)
            {0: L - 1/2*TJ, 1: -J, 2: 1/3*C}
            sage: G1.degree()
            3/2
            sage: J.degree()
            1

        The topological twist is a Virasoro vector with central
        charge 0::

            sage: L2 = L - 1/2*J.T()
            sage: L2.bracket(L2) == {0: L2.T(), 1: 2*L2}
            True

        The sum of the fermions is a generator of the Neveu-Schwarz
        Lie conformal algebra::

            sage: G = (G1 + G2)
            sage: G.bracket(G)
            {0: 2*L, 2: 2/3*C}
        """
        n2dict =\
        {('L','L'):{0:{('L',1):1}, 1:{('L',0): 2},
        3:{('C', 0):R(2).inverse_of_unit()}},
        ('L','G1'):{0:{('G1',1):1}, 1:{('G1',0):3*R(2).\
        inverse_of_unit()}},
        ('L','G2'):{0:{('G2',1):1}, 1:{('G2',0):3*R(2).\
        inverse_of_unit()}},
        ('G1','G2'): {0:{('L',0):1,('J',1):R(2).inverse_of_unit()},
                   1:{('J',0):1}, 2:{('C',0):R(3).inverse_of_unit()}},
        ('L','J'): {0:{('J',1):1},1:{('J',0):1}},
        ('J','J'): {1:{('C',0):R(3).inverse_of_unit()}},
        ('J','G1'): {0:{('G1',0):1}},
        ('J','G2'): {0:{('G2',0):-1}}}
        from sage.rings.rational_field import QQ
        weights = (2,1,QQ(3/2),QQ(3/2))
        parity = (0,0,1,1)
        GradedLieConformalAlgebra.__init__(self,R,n2dict,
                                           names=('L', 'J','G1','G2'),
                                           central_elements=('C',),
                                           weights=weights, parity=parity)

    def _repr_(self):
        """
        The name of this Lie conformal algebra.

        EXAMPLES::

            sage: R = N2LieConformalAlgebra(QQbar); R
            The N=2 super Lie conformal algebra over Algebraic Field

        """
        return "The N=2 super Lie conformal algebra over {}".\
                format(self.base_ring())


class NeveuSchwarzLieConformalAlgebra(GradedLieConformalAlgebra):

    def __init__(self, R):
        """
        The Neveu-Schwarz super Lie conformal algebra.

        INPUT:

        - ``R`` -- a commutative Ring; the base ring of this Lie
          conformal algebra.

        EXAMPLES::

            sage: R = NeveuSchwarzLieConformalAlgebra(AA); R
            The Neveu-Schwarz super Lie conformal algebra over Algebraic Real Field
            sage: R.structure_coefficients()
            Finite family {('G', 'G'): ((0, 2*L), (2, 2/3*C)),  ('G', 'L'): ((0, 1/2*TG), (1, 3/2*G)),  ('L', 'G'): ((0, TG), (1, 3/2*G)),  ('L', 'L'): ((0, TL), (1, 2*L), (3, 1/2*C))}
            sage: R.inject_variables()
            Defining L, G, C
            sage: G.nproduct(G,0)
            2*L
            sage: G.degree()
            3/2
        """
        nsdict =  {('L','L'):{0:{('L',1):1}, 1:{('L',0): 2},
                    3:{('C', 0):R(2).inverse_of_unit()}},
                   ('L','G'):{0:{('G',1):1}, 1:{('G',0):R(3)*R(2).\
                    inverse_of_unit()}}, ('G','G'): {0:{('L',0):2},
                    2:{('C',0):R(2)*R(3).inverse_of_unit()}}}
        from sage.rings.rational_field import QQ
        weights = (2,QQ(3/2))
        parity = (0,1)
        GradedLieConformalAlgebra.__init__(self, R, nsdict, names=('L','G'),
                    central_elements=('C',), weights=weights, parity=parity)

    def _repr_(self):
        """
        The name of this Lie Conformal algebra.

        EXAMPLES::

            sage: R = NeveuSchwarzLieConformalAlgebra(GF(5)); R
            The Neveu-Schwarz super Lie conformal algebra over Finite Field of size 5
        """
        return "The Neveu-Schwarz super Lie conformal algebra over {}".\
                format(self.base_ring())



class VirasoroLieConformalAlgebra(GradedLieConformalAlgebra):
    def __init__(self, R):
        """
        The Virasoro Lie Conformal algebra over `R`.

        INPUT:

        - ``R`` -- a commutative ring; behaviour is undefined if `R` is
          not a Field of characteristic zero.

        EXAMPLES::

            sage: Vir = VirasoroLieConformalAlgebra(QQ)
            sage: Vir.category()
            Category of finitely generated H-graded Lie conformal algebras with basis over Rational Field
            sage: Vir.inject_variables()
            Defining L, C
            sage: L.bracket(L)
            {0: TL, 1: 2*L, 3: 1/2*C}

        TESTS::

            sage: Vir.gens()
            (L, C)
        """
        virdict =  {('L','L'):{0:{('L',1):1}, 1:{('L',0): 2},
                    3:{('C', 0):R(2).inverse_of_unit()}}}
        GradedLieConformalAlgebra.__init__(self,R, virdict,
            names = ('L',), central_elements = ('C',), weights = (2,))

    def _repr_(self):
        """
        The name of this Lie conformal algebra.

        EXAMPLES::

            sage: VirasoroLieConformalAlgebra(QQbar)
            The Virasoro Lie conformal algebra over Algebraic Field
        """
        return "The Virasoro Lie conformal algebra over {}".format(
                                                            self.base_ring())


class WeylLieConformalAlgebra(LieConformalAlgebraWithStructureCoefficients):
    def __init__(self,R,ngens=None, gram_matrix=None, names=None,
                 index_set=None):
        r"""
        The Weyl Lie conformal algebra.

        INPUT:

        - ``R`` -- a commutative ring; the base ring of this Lie
          conformal algebra.
        - ``ngens``: an even positive Integer (default `2`); The number
          of non-central generators of this Lie conformal algebra.
        - ``gram_matrix``: a matrix (default: ``None``); A non-singular
          skew-symmetric square matrix with coefficients in `R`.
        - ``names`` -- a list or tuple of ``str``; alternative names
          for the generators
        - ``index_set`` -- an enumerated set; alternative indexing set
          for the generators


        OUTPUT:

        The Weyl Lie conformal algebra with generators
         `\alpha_i`, `i=1,...,ngens` and `\lambda`-brackets

         .. MATH::

            [{\alpha_i}_{\lambda} \alpha_j] = M_{ij} K,

        where `M` is the ``gram_matrix`` above.

        .. NOTE::

            The returned Lie conformal algebra is not `H`-graded. For
            a related `H`-graded Lie conformal algebra see
            :class:`BosonicGhostsLieConformalAlgebra<sage.algebras.\
            lie_conformal_algebras.bosonic_ghosts_lie_conformal_algebra\
            .BosonicGhostsLieConformalAlgebra>`.

        EXAMPLES::

            sage: WeylLieConformalAlgebra(QQ)
            The Weyl Lie conformal algebra with generators (alpha0, alpha1, K) over Rational Field
            sage: R = WeylLieConformalAlgebra(QQbar, gram_matrix=Matrix(QQ,[[0,1],[-1,0]]), names = ('a','b'))
            sage: R.inject_variables()
            Defining a, b, K
            sage: a.bracket(b)
            {0: K}
            sage: b.bracket(a)
            {0: -K}

            sage: R = WeylLieConformalAlgebra(QQbar, ngens=4)
            sage: R.gram_matrix()
            [ 0  0| 1  0]
            [ 0  0| 0  1]
            [-----+-----]
            [-1  0| 0  0]
            [ 0 -1| 0  0]
            sage: R.inject_variables()
            Defining alpha0, alpha1, alpha2, alpha3, K
            sage: alpha0.bracket(alpha2)
            {0: K}

            sage: R = WeylLieConformalAlgebra(QQ); R.category()
            Category of finitely generated Lie conformal algebras with basis over Rational Field
            sage: R.is_graded()
            False
            sage: R.inject_variables()
            Defining alpha0, alpha1, K
            sage: alpha0.degree()
            Traceback (most recent call last):
            ...
            AttributeError: 'WeylLieConformalAlgebra_with_category.element_class' object has no attribute 'degree'

        TESTS::

            sage: WeylLieConformalAlgebra(ZZ, gram_matrix=identity_matrix(ZZ,3))
            Traceback (most recent call last):
            ...
            ValueError: The gram_matrix should be a non degenerate skew-symmetric 3 x 3 matrix, got [1 0 0]
            [0 1 0]
            [0 0 1]
        """
        from sage.matrix.matrix_space import MatrixSpace
        if ngens:
            try:
                from sage.rings.all import NN
                assert ngens in NN and ngens % 2 == 0
            except AssertionError:
                raise ValueError("ngens needs to be an even positive "+
                                 "Integer, got {}".format(ngens))
        if (gram_matrix is not None):
            if ngens is None:
                ngens = gram_matrix.dimensions()[0]
            try:
                assert (gram_matrix in MatrixSpace(R,ngens,ngens))
            except AssertionError:
                raise ValueError("The gram_matrix should be a skew-symmetric "+
                    "{0} x {0} matrix, got {1}".format(ngens,gram_matrix))
            if (not gram_matrix.is_skew_symmetric()) or \
                                                (gram_matrix.is_singular()):
                raise ValueError("The gram_matrix should be a non degenerate " +
                                 "skew-symmetric {0} x {0} matrix, got {1}"\
                                 .format(ngens,gram_matrix))
        elif (gram_matrix is None):
            if ngens is None:
                ngens = 2;
            A = identity_matrix(R,ngens/2)
            from sage.matrix.special import block_matrix
            gram_matrix = block_matrix([[R.zero(),A],[-A,R.zero()]])

        latex_names = None
        if (names is None) and (index_set is None):
            names = 'alpha'
            latex_names = tuple(r'\alpha_{%d}' % i \
                                      for i in range (ngens)) + ('K',)
        names,index_set = standardize_names_index_set(names=names,
                                                      index_set=index_set,
                                                      ngens=ngens)
        weyldict = { (i,j): {0: {('K',0): gram_matrix[index_set.rank(i),
                    index_set.rank(j)]}} for i in index_set for j in index_set}

        super(WeylLieConformalAlgebra,self).__init__(R,weyldict,names=names,
                                           latex_names=latex_names,
                                           index_set=index_set,
                                           central_elements=('K',))
        self._gram_matrix = gram_matrix

    def _repr_(self):
        """
        The name of this Lie conformal algebra.

        EXAMPLES::

            sage: R = WeylLieConformalAlgebra(ZZ); R
            The Weyl Lie conformal algebra with generators (alpha0, alpha1, K) over Integer Ring
        """
        return "The Weyl Lie conformal algebra with generators {} over {}"\
                .format(self.gens(),self.base_ring())

    def gram_matrix(self):
        r"""
        The Gram matrix that specifies the `\lambda`-brackets of the
        generators.

        EXAMPLES::

            sage: R = WeylLieConformalAlgebra(QQbar, ngens=4)
            sage: R.gram_matrix()
            [ 0  0| 1  0]
            [ 0  0| 0  1]
            [-----+-----]
            [-1  0| 0  0]
            [ 0 -1| 0  0]
        """
        return self._gram_matrix


