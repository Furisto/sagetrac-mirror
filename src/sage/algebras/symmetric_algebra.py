from sage.structure.unique_representation import UniqueRepresentation
from sage.sets.family import Family, FiniteFamily
from sage.misc.cachefunc import cached_method
from sage.categories.rings import Rings
from sage.categories.fields import Fields
from sage.categories.modules_with_basis import ModulesWithBasis
from sage.categories.integral_domains import IntegralDomains
from sage.rings.polynomial.multi_polynomial_ring import MPolynomialRing_polydict_domain
from sage.rings.fraction_field import FractionField_generic
from sage.rings.polynomial.polynomial_ring_constructor import PolynomialRing
from sage.rings.fraction_field import FractionField_generic
from sage.categories.morphism import SetMorphism
from sage.categories.homset import Hom
from sage.categories.sets_cat import Sets

class SymmetricAlgebra(MPolynomialRing_polydict_domain, UniqueRepresentation):
    r"""
    The symmetric algebra of a module.

    This is a polynomial ring whose generators correspond to the basis of ``module``.

    INPUT:

    - ``module`` -- A finite-dimensional free module with distinguished basis, over a
    commutative ring.

    Optional keyword arguments are:

    - ``prefix`` -- optional string used for the variable names of the polynomial ring

    - ``variable_names`` -- optional dictionary from the basis keys to strings which will
    be used as names of the polynomial generators.

    EXAMPLES::

        sage: M = CombinatorialFreeModule(QQ, [1,2])
        sage: from sage.algebras.symmetric_algebra import SymmetricAlgebra
        sage: S = SymmetricAlgebra(M); S
        Symmetric Algebra of Free module generated by {1, 2} over Rational Field
        sage: S.an_element()**2
        B1^2
        sage: SymmetricAlgebra(M,prefix="x").an_element() ** 2
        x1^2
        sage: SymmetricAlgebra(M,variable_names=Family(dict({1:"q",2:"t"}))).an_element() ** 2
        q^2
        sage: S = SymmetricAlgebra(M, prefix="x")
        sage: S.from_items([((2,0),2),((1,1),-1)])
        2*x1^2 - x1*x2
        sage: S.from_items([((2,0),2),((2,0),-1)])
        -x1^2
    """

    def __init__(self, module, **keywords):
        r"""
        TESTS::

            sage: from sage.algebras.symmetric_algebra import SymmetricAlgebra
            sage: S = SymmetricAlgebra(CombinatorialFreeModule(QQ,[1,2]))
            sage: TestSuite(S).run()
        """
        if not hasattr(module, "base_ring"):
            raise TypeError("The operand of the symmetric algebra functor should be a module")
        base_ring = module.base_ring()
        if not base_ring in IntegralDomains():
            raise TypeError("The module should afford the action of an integral domain")
        if not module in ModulesWithBasis(base_ring).FiniteDimensional():
            raise TypeError("The module must be a finite-dimensional module with basis")
        self._module = module
        self._keys = [k for k in module.basis().keys()]
        variable_names = keywords.get('variable_names', None)
        if variable_names:
            if not isinstance(variable_names, FiniteFamily) or variable_names.keys() != self._keys:
                raise TypeError("variable names are not given by a Family on the keys of the basis of the module")
        else:
            prefix = keywords.get('prefix',None)
            if not prefix:
                prefix = module.prefix()
            variable_names = Family(self._keys, lambda k: prefix+str(k))
        MPolynomialRing_polydict_domain.__init__(self, base_ring, variable_names.cardinality(), [variable_names[k] for k in self._keys], "lex")
        # the actual variables of the polynomial ring
        self._variables = Family(self._keys, lambda k: self.gen(self._keys.index(k)))
        # map from base module to polynomial ring
        self._module_to_symmetric_algebra_map = module.module_morphism(on_basis = lambda i: self._variables[i], codomain=self)
        self._module_to_symmetric_algebra_map.register_as_coercion()

        self._poly_ring = PolynomialRing(base_ring, [x for x in variable_names])
        self._poly_ring_fraction_field = self._poly_ring.fraction_field()
        #self.to_poly = SetMorphism(Hom(self, self._poly_ring, category=Sets()), self.to_poly)
        #self.to_poly.register_as_coercion()
        self.from_poly = SetMorphism(Hom(self._poly_ring, self, category=Sets()), self.from_poly)
        self.from_poly.register_as_coercion()

    def to_poly(self, f):
        return self._poly_ring(f)

    def from_poly(self, f):
        return self(f)

    def _repr_(self):
        """
        EXAMPLES::

            sage: from sage.algebras.symmetric_algebra import SymmetricAlgebra
            sage: SymmetricAlgebra(CombinatorialFreeModule(QQ, [1,2]))
            Symmetric Algebra of Free module generated by {1, 2} over Rational Field
        """
        return "Symmetric Algebra of %s"%self.base_module()

    def base_module(self):
        r"""
        The module of which ``self`` is the symmetric algebra.

        EXAMPLES::

            sage: from sage.algebras.symmetric_algebra import SymmetricAlgebra
            sage: SymmetricAlgebra(CombinatorialFreeModule(QQ, [1,2])).base_module()
            Free module generated by {1, 2} over Rational Field
        """
        return self._module

    def keys(self):
        r"""
        A list of keys of the basis of the base module of ``self``.

        EXAMPLES::

            sage: from sage.algebras.symmetric_algebra import SymmetricAlgebra
            sage: SymmetricAlgebra(CombinatorialFreeModule(QQ, [1,2])).keys()
            [1, 2]
        """
        return self._keys

    @cached_method
    def algebra_generators(self):
        r"""
        The family of generators.

        EXAMPLES::

            sage: from sage.algebras.symmetric_algebra import SymmetricAlgebra
            sage: gens = SymmetricAlgebra(CombinatorialFreeModule(QQ, [1,2]),prefix="x").algebra_generators()
            sage: gens
            Finite family {1: x1, 2: x2}
            sage: gens[1].parent()
            Symmetric Algebra of Free module generated by {1, 2} over Rational Field
        """
        return Family(self.keys(), lambda i: self.from_module_map()(self.base_module().basis()[i]))

    def algebra_generator(self, i):
        r"""
        The `i`-th generator of ``self``.

        EXAMPLES::

            sage: from sage.algebras.symmetric_algebra import SymmetricAlgebra
            sage: SymmetricAlgebra(CombinatorialFreeModule(QQ, [1,2]),variable_names=Family(dict([[1,"x"],[2,"y"]]))).algebra_generator(2)
            y
        """
        return self.algebra_generators()[i]

    def from_module_map(self):
        r"""
        The map from the base module of ``self``, to ``self``.

        EXAMPLES::

            sage: M = CombinatorialFreeModule(QQ, [1,2])
            sage: from sage.algebras.symmetric_algebra import SymmetricAlgebra
            sage: S = SymmetricAlgebra(M,prefix="x")
            sage: S.from_module_map()(M.monomial(1) + 3 * M.monomial(2))
            x1 + 3*x2
        """
        return self._module_to_symmetric_algebra_map

    def monomial(self, exp, coefficient=None):
        r"""
        A monomial.

        INPUT:

        - ``exp`` -- A tuple of nonnegative integers
        - ``coefficient`` -- coefficient (default: None, which is replaced by 1)

        EXAMPLES::

            sage: M = CombinatorialFreeModule(QQ, [1,2])
            sage: from sage.algebras.symmetric_algebra import SymmetricAlgebra
            sage: S = SymmetricAlgebra(M,prefix="x")
            sage: b = S.base_module().basis()
            sage: S.monomial((1,3))
            x1*x2^3
        """
        if not coefficient:
            coefficient = self.base_ring().one()
        return self.from_items([(exp, coefficient)])

    def from_items(self, pairs):
        r"""
        Convert a list of items to a polynomial.

        Here an item is a pair consisting of a tuple of exponents (representing a monomial)
        and a coefficient.

        EXAMPLES::

            sage: M = CombinatorialFreeModule(QQ, [1,2])
            sage: from sage.algebras.symmetric_algebra import SymmetricAlgebra
            sage: S = SymmetricAlgebra(M,prefix="x")
            sage: b = S.base_module().basis()
            sage: S.from_items([((3,2),-2),((0,2),1)])
            -2*x1^3*x2^2 + x2^2
        """
        return self(dict(pairs))

    def algebra_morphism(self, images):
        r"""
        The algebra map from ``self`` to another algebra, specified by the images
        of the polynomial generators.

        INPUT:

        - ``images`` -- A list, tuple or family giving the images of the polynomial generators.
        For a list or tuple, the correspondence with the generators is given by the order of
        ``self.keys()`. For a family, the keys of the family must match ``self.keys()``.

        EXAMPLES::

            sage: M = CombinatorialFreeModule(QQ, [1,2])
            sage: from sage.algebras.symmetric_algebra import SymmetricAlgebra
            sage: S = SymmetricAlgebra(M,prefix="x")
            sage: T = PolynomialRing(QQ,'t')
            sage: f = S.algebra_morphism((T.gen(0),T.gen(0)))
            sage: m = M.monomial(1)+3*M.monomial(2)
            sage: f((1 + S(m))**2)
            16*t^2 + 8*t + 1
        """
        if not isinstance(images, (list, tuple)):
            if not isinstance(images, FiniteFamily) or images.keys() != self.keys():
                raise TypeError("images are not properly specified {} {}".format(images.keys(),self.keys()))
            images = [images[k] for k in self.keys()]
        return self.hom(images)

    def induced_algebra_endomorphism(self, images):
        r"""
        Like :meth:`algebra_morphism` except that the elements of images 
        are in the base module of ``self``.

        EXAMPLES::

            sage: M = CombinatorialFreeModule(QQ, [1,2])
            sage: from sage.algebras.symmetric_algebra import SymmetricAlgebra
            sage: S = SymmetricAlgebra(M,prefix="x")
            sage: f = S.induced_algebra_endomorphism([M.monomial(2),M.monomial(1)])
            sage: m = M.monomial(1)+3*M.monomial(2)
            sage: f((1 + S(m))**2)
            9*x1^2 + 6*x1*x2 + 6*x1 + x2^2 + 2*x2 + 1
        """
        if not isinstance(images, (list, tuple)):
            if not isinstance(images, FiniteFamily) or images.keys() != self.keys():
                raise TypeError("images are not properly specified")
            images = [self.from_module_map()(images[k]) for k in self.keys()]
        else:
            images = [self.from_module_map()(x) for x in images]
        return self.hom(images,codomain=self)

    def divide_elements(self, numerator, denominator):
        r"""
        Divide a polynomial by another, provided that the answer is a polynomial.

        EXAMPLES::

            sage: from sage.algebras.symmetric_algebra import SymmetricAlgebra
            sage: M = CombinatorialFreeModule(QQ,[1,2])
            sage: S = SymmetricAlgebra(M,prefix="x")
            sage: p = S.an_element(); p
            x1
            sage: p/p
            x1/x1
            sage: S.divide_elements(p,p)
            1
        """
        return self(self._poly_ring(self._poly_ring_fraction_field(numerator/denominator)))
