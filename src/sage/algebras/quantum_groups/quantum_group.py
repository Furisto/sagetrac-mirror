"""
Quantum Groups

AUTHORS:

- Travis Scrimshaw (2013-05-03): Initial version
"""

#*****************************************************************************
#  Copyright (C) 2013 Travis Scrimshaw <tscrim@ucdavis.edu>
#
#  Distributed under the terms of the GNU General Public License (GPL)
#
#    This code is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty
#    of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
#
#  See the GNU General Public License for more details; the full text
#  is available at:
#
#                  http://www.gnu.org/licenses/
#*****************************************************************************

from sage.structure.unique_representation import UniqueRepresentation
from sage.categories.algebras_with_basis import AlgebrasWithBasis
from sage.categories.cartesian_product import cartesian_product
from sage.misc.cachefunc import cached_method
from sage.misc.lazy_attribute import lazy_attribute
from sage.misc.misc_c import prod
from sage.misc.misc import repr_lincomb

from sage.algebras.algebra import Algebra
from sage.algebras.free_algebra import FreeAlgebra
from sage.algebras.quantum_groups.q_numbers import q_factorial, q_binomial
from sage.monoids.free_monoid import FreeMonoid
from sage.combinat.free_module import CombinatorialFreeModule
from sage.combinat.root_system.cartan_matrix import CartanMatrix
from sage.combinat.root_system.cartan_type import CartanType
from sage.combinat.root_system.root_system import RootSystem
from sage.rings.polynomial.polynomial_ring_constructor import PolynomialRing
from sage.rings.fraction_field import FractionField
from sage.rings.all import QQ
from sage.sets.family import Family

class QuantumGroup(Algebra, UniqueRepresentation):
    r"""
    A quantum group.

    A quantum group is a deformation of the universal enveloping algebra of
    a Kac--Moody algebra `\mathfrak{g}` over a ring `R`. We denote a quantum
    group as `U_q(\mathfrak{g})`. Let `A` denote the Cartan matrix of
    the Kac--Moody algerba with Cartan subalgebra `\mathfrak{h}`.
    The quantum group `U_q(\mathfrak{g}` is generated by `e_i, f_i`, and
    `k_{\lambda}` where `\lambda` is in the weight lattice `P` which
    satisfy the following relations:

    .. MATH::

        \begin{aligned}
        k_0 & = 1,
        \\ k_{\lambda} k_{\mu} & = k_{\lambda + \mu}
        \\ k_{\lambda} e_i k_{\lambda}^{-1} & = q^{(\alpha_i, \lambda)} e_i
        \\ k_{\lambda} f_i k_{\lambda}^{-1} & = q^{-(\alpha_i, \lambda)} f_i
        \\ [e_i, f_j] & = \delta_{ij} \frac{k_i - k_i^{-1}}{q_i - q_i^{-1}}
        \end{aligned}

    and for all `i \neq j`:

    .. MATH::

        \begin{aligned}
        \sum_{n=0}^{1-a_{ij}} (-1)^n \frac{[1 - a_{ij}]_{q_i}!}
        {[1 - a_{ij} - n]_{q_i}! [n]_{q_i}!} e_i^n e_j e_i^{1-a_{ij}-n} & = 0,
        \\ \sum_{n=0}^{1-a_{ij}} (-1)^n \frac{[1 - a_{ij}]_{q_i}!}
        {[1 - a_{ij} - n]_{q_i}! [n]_{q_i}!} f_i^n f_j f_i^{1-a_{ij}-n} & = 0.
        \end{aligned}

    where

    - `k_i = k_{\alpha_i}`,
    - `q_i = q^{\frac{1}{2} (\alpha_i, \alpha_i)}`,
    - `[n]_{q_i} = \frac{q_i^n - q_i^{-n}}{q_i - q_i^{-1}}`,
    - `[n]_{q_i}! = [n]_{q_i} [n-1]_{q_i} \cdots [1]_{q_i}`,
    - `[0]_{q_i}! = 1`.

    Now as we take `q \to 1`, this is what is known as the classical limit,
    we get `k_{\lambda} \to 1` and
    `\frac{k_{\lambda} - k_{-\lambda}}{q - q^{-1}} \to 1`, and so we recover
    `U(\mathfrak{g})`, the universal enveloping algebra of `\mathfrak{g}`.

    Quantum groups also admit a Hopf algebra structure given with
    comultiplication `\Delta`, counit `\varepsilon`, and antipode `S`
    defined by:

    .. MATH::

        \begin{aligned}
        \Delta(q^h) & = q^h \otimes q^h,
        \\ \Delta(e_i) = e_i \otimes K_i^{-1} + 1 \otimes e_i,
        \Delta(f_i) = f_i \otimes 1 + K_i \otimes f_i,
        \\ \varepsilon(q^h) = 1, \quad \varepsilon(e_i) = \varepsilon(f_i) = 0,
        \\ S(q^h) = q^{h}, \quad S(e_i) = -e_i K_i, \quad S(f_i) = -K_i^{-1}f_i

    for `h \in P^{\vee}` and `i \in I` and extending to algebra
    (anti)homomorphisms.

    Quantum groups also have a triangular decompostion:

    .. MATH::

        U_q(\mathfrak{g}) \cong U_q^- \otimes U_q^0 \otimes U_q^+

    where `U_q^-`, `U_q^0`, and `U_q^+` are the subalgebras generated by all
    `\{ f_i \}`,\ `\{ q^h \}`, and `\{ e_i \}` respectively.

    INPUT:

    - ``cm`` -- a Cartan matrix
    - ``q`` -- the deformation parameter
    - ``index_set`` -- (optional) an index set
    - ``base_ring`` -- (optional) the base ring which must contain ``q``; if
      not specified, the base ring is the parent of ``q``
    """
    @staticmethod
    def __classcall__(cls, cm, q=None, index_set=None, base_ring=None, **kwds):
        """
        Normalize arguments to ensure a unique representation.
        """
        if base_ring is None:
            if q is None:
                base_ring = PolynomialRing(QQ, 'q')
                q = base_ring.gen(0)
            else:
                base_ring = q.parent()
        cm = CartanMatrix(cm, index_set=index_set) # index_set not currently supported
        base_ring = FractionField(base_ring)
        q = base_ring(q)
        return super(QuantumGroup, cls).__classcall__(cls, cm, q, base_ring)

    @staticmethod
    def construct_yamane(R, q, n):
        r"""
        Construct the quantum group `U_q(\mathfrak{sl}_n)` following Yamane.

        We have `U^+` over `\CC(t)` generated by `\{ e_{ij} \mid 1 \leq i <
        j \leq n \}` with the following relations:

        .. MATH::

            e_{ij} e_{rs} = \begin{cases}
            t^2 e_{rs} e_{ij} & i = r < j < s \text{ or } i < r < j = s, \\
            e_{rs} e_{ij} & i < r < s < j \text{ or } i < j < r < s, \\
            e_{rs} e_{ij} + (t^2 - t^{-2}) e_{is} e_{rj} & i < r < j < s, \\
            e_{rs} e_{ij} + t e_{is} & i < j = r < s.
            \end{cases}
        """
        n += 1 # +1 for simplicity with indexing
        gens  = ['e%s%s'%(i,j) for i in range(1, n) for j in range(i+1, n)]
        gens += ['f%s%s'%(j,i) for i in range(1, n) for j in range(i+1, n)]
        gens += ['h%s'%i for i in range(1, n-1)] # Up to n-1
        n -= 1 # Shift the indexing back

        # Construct a dictionary of the gens for simplicity
        F = FreeAlgebra(R, len(gens), gens)
        k = 0
        pos = {}
        for i in range(n):
            for j in range(i+1, n):
                pos[(i,j)] = F.gen(k)
                k += 1
        neg = {}
        for i in range(n):
            for j in range(i+1, n):
                neg[(j,i)] = F.gen(k)
                k += 1
        h = [F.gen(k + i) for i in range(n-1)]

        # NOTE: Here we take q to be the t (in Ringel)
        # Case 1 i = r < j < s E_{ij} E_{rs} = t^2 E_{rs} * E_{ij}
        # Case 2 i < r < s < j E_{ij} E_{rs} = E_{rs} * E_{ij}
        # Case 3 i < r < j = s E_{ij} E_{rs} = t^2 E_{rs} * E_{ij}
        # Case 4 i < r < j < s E_{ij} E_{rs} = E_{rs} * E_{ij} + (t^2 - t^{-2}) E_{is} E_{rj}
        # Case 5 i < j = r < s E_{ij} E_{rs} = E_{rs} * E_{ij} + t E_{is}
        # Case 6 i < j < r < s E_{ij} E_{rs} = E_{rs} * E_{ij}
        rels = {}
        def add_relation(i, j, r, s):
            x = pos[(i, j)]
            y = pos[(r, s)]
            a = neg[(j, i)]
            b = neg[(s, r)]
            if j == s: # Case 3
                if i == r or r >= j: # By construction, we take i <= r
                    return
                rels[x*y] = q**2 * y * x
                rels[a*b] = q**2 * b * a
            elif s < j: # Case 4
                if i == r:
                    return
                rels[x*y] = y * x
                rels[a*b] = b * a
            elif i == r: # Case 1 (at this point j < s)
                rels[x*y] = q**2 * y * x
                rels[a*b] = q**2 * b * a
            elif j < r: # Case 6 (at this point i < r)
                rels[x*y] = y * x
                rels[a*b] = b * a
            elif j == r: # Case 5
                rels[x*y] = y * x + q * pos[(i, s)]
                rels[a*b] = b * a + q * neg[(s, i)]
            else: # Case 2
                rels[x*y] = y * x
                rels[a*b] = b * a

        for i in range(n):
            for j in range(i+1, n):
                if i > 0:
                    rels[h[j-1]*h[i-1]] = h[i-1]*h[j-1]
                for r in range(i, n):
                    for s in range(r+1, n):
                        add_relation(i, j, r, s)

        print rels
        if len(rels) == 0: # No relations, so it's a free algebra
            # More importantly, there is a bug:
            # sage: F = FreeAlgebra(QQ['t'], 2, 'a,b')
            # sage: F.g_algebra({}) # BOOM
            # sage: F = FreeAlgebra(QQ, 2, 'a,b')
            # sage: F.g_algebra({}) # This works however...
            return F
        return F.g_algebra(rels) # Need to be careful about the ordering

    def __init__(self, cm, q, base_ring):
        """
        Initialize ``self``.

        TESTS::

            sage: R.<q> = LaurentPolynomialRing(QQ)
            sage: TestSuite(QuantumGroup(['A', 2], q)).run()
        """
        self._q = q
        index_set = cm.index_set()
        n = len(index_set)
        self._n = n
        self._cartan_matrix = cm
        #p_roots = list(cm.root_system().root_lattice().positive_roots())
        from sage.misc.flatten import flatten
        names = flatten(list( ['e%s'%i, 'f%s'%i, 'h%s'%i] for i in range(n) ))#len(p_roots)) ))
        names += ['d%i'%i for i in range(n - super(CartanMatrix, cm).rank())]
        #short_root_name = lambda root: '(' + repr(root).replace('*', '').replace(' + ', '') + ')'
        #names = tuple(map( lambda x: "X" + x,
        #              map(short_root_name, cm.root_system().root_lattice().positive_roots()) ))
        #names += tuple(map( lambda x: "Y" + x,
        #               map(short_root_name, cm.root_system().root_lattice().positive_roots()) ))
        self.__ngens = len(names)
        #names = ['e%s'%i for i in index_set]
        #names += ['f%s'%i for i in index_set]
        #names += ['h%s'%i for i in index_set]
        #names += ['d%s'%i for i in range(n-cm.rank())]
        Algebra.__init__(self, base_ring, names, category=AlgebrasWithBasis(base_ring))

    def _repr_(self):
        """
        Return a string representation of ``self``.

        EXAMPLES::

            sage: R.<q> = LaurentPolynomialRing(QQ)
            sage: QuantumGroup(['A', 2], q)
            Quantum group of Cartan type ['A', 2] over Univariate Polynomial Ring in q over Rational Field
            sage: QuantumGroup([[2, -3], [-4, 2]], q) # todo: currently only for finite types
        """
        ct = self.cartan_type()
        if ct == self._cartan_matrix:
            return "Quantum group over {0} with Cartan matrix:\n{1}".format(
                    self.base_ring(), self._cartan_matrix)
        return "Quantum group of Cartan type {0} over {1}".format(ct, self.base_ring())

    def one(self):
        """
        PLACEHOLDER!!!!
        """
        return self.base_ring().one()

    def _element_cosntructor_(self, x):
        """
        PLACEHOLDER!!!!
        """
        return self.base_ring()(x)

    def ngens(self):
        """
        Return the number of generators of ``self``.

        EXAMPLES::

            sage: R.<q> = QQ[]
            sage: QuantumGroup(['A', 2], q).ngens()
        """
        return self.__ngens

    def cartan_type(self):
        """
        Return the Cartan type of ``self``.

        EXAMPLES::

            sage: R.<q> = LaurentPolynomialRing(QQ)
            sage: QuantumGroup(['A', 2], q).cartan_type()
            ['A', 2]
        """
        return self._cartan_matrix.cartan_type()

    def cartan_matrix(self):
        """
        Return the defining Cartan matrix of ``self``.

        EXAMPLES::

            sage: R.<q> = LaurentPolynomialRing(QQ)
            sage: QuantumGroup(q, ['A', 2]).cartan_matrix()
            [ 2 -1]
            [-1  2]
        """
        return self._cartan_matrix

    def e(self, i=None):
        r"""
        Return the generator `e_i`.
        """
        if i is None:
            return tuple(self._e)
        return self._e[i]

    def f(self, i):
        r"""
        Return the generator `f_i`.
        """
        if i is None:
            return tuple(self._f)
        return self._f[i]

    def h(self, i):
        """
        Return the generator `h_i`.
        """
        if i is None:
            return tuple(self._h)
        return self._h[i]

    @cached_method
    def q(self, i):
        """
        Return the `q_i = q^{s_i}`.
        """
        s = self.cartan_type().symmetrizer()
        return self._q**s[i]

class QuantumGroupMonomialBasis(CombinatorialFreeModule):
    """
    The monomial basis of the quantum group
    `U_q(\mathfrak{g})`.
    """
    @staticmethod
    def __classcall__(cls, ct, q=None, base_ring=None, **kwds):
        """
        Normalize arguments to ensure a unique representation.
        """
        ct = CartanType(ct)
        if not ct.is_finite():
            raise NotImplementedError("only implemented for finite types")

        if base_ring is None:
            if q is None:
                base_ring = PolynomialRing(QQ, 'q')
                q = base_ring.gen(0)
            else:
                base_ring = q.parent()
        base_ring = FractionField(base_ring)
        q = base_ring(q)
        return super(QuantumGroupMonomialBasis, cls).__classcall__(cls, ct, q, base_ring)

    def __init__(self, ct, q, base_ring):
        """
        Initialize ``self``.
        """
        self._q = q
        self._cartan_type = ct
        n = ct.rank()
        names  = ['e{}'.format(i) for i in range(1, n+1)]
        names += ['f{}'.format(i) for i in range(1, n+1)]
        names += ['h{}'.format(i) for i in range(1, n+1)]
        self._e_monoid = FreeMonoid(n, names[:n])
        self._P_check = RootSystem(ct).coweight_lattice()
        self._f_monoid = FreeMonoid(n, names[n:2*n])
        indices = cartesian_product([self._e_monoid, self._P_check, self._f_monoid])
        CombinatorialFreeModule.__init__(self, base_ring, indices,
                                         prefix="", bracket=False,
                                         category=AlgebrasWithBasis(base_ring))

    def _repr_(self):
        """
        Return a string representation of ``self``.
        """
        return "Quantum group of {} in the monomial basis".format(self._cartan_type)

    def _repr_term(self, m):
        """
        Return a string representation of the term indexed by ``m``.
        """
        ret = ''
        if len(m[0]) > 0:
            ret += repr(m[0])
        if not m[1].is_zero():
            if len(ret) != 0:
                ret = ret + '*'
            lin_comb = repr_lincomb(m[1]._sorted_items_for_printing(), scalar_mult='*',
                                    repr_monomial=lambda a: 'h[{}]'.format(a), strip_one=True)
            ret += 'q^({})'.format(lin_comb)
        if len(m[2]) > 0:
            if len(ret) != 0:
                ret = ret + '*'
            ret += repr(m[0])
        if len(ret) == 0:
            ret = '1'
        return ret

    @cached_method
    def one_basis(self):
        """
        Return the index of the basis element `1`.
        """
        return self._group.one()

    @cached_method
    def e(self, i=None):
        """
        Return the generator `e_i` of ``self``.
        """
        n = self._cartan_type.rank()
        if i is None:
            return Family({i:self.e(i) for i in self._cartan_type.index_set()})
        i = self._cartan_type.index_set().index(i)
        index = (self._e_monoid.gen(i), self._P_check.zero(), self._f_monoid.one())
        C = self.basis().keys()
        return self.monomial(C(index))

    @cached_method
    def f(self, i=None):
        """
        Return the generator `e_i` of ``self``.
        """
        n = self._cartan_type.rank()
        if i is None:
            return Family({i:self.f(i) for i in self._cartan_type.index_set()})
        i = self._cartan_type.index_set().index(i)
        index = (self._e_monoid.one(), self._P_check.zero(), self._f_monoid.gen(i))
        C = self.basis().keys()
        return self.monomial(C(index))

    @cached_method
    def K(self, i=None):
        """
        Return the scaled generator `K_i = q^{\epsilon_i h_i}` of ``self``
        where `\epsilon_i` is the `i`-th symmetrizing factor.
        """
        n = self._cartan_type.rank()
        if i is None:
            return Family({i:self.K(i) for i in self._cartan_type.index_set()})
        s = self._cartan_type.symmetrizer()
        index = (self._e_monoid.one(), s[i] * self._P_check.basis()[i], self._f_monoid.one())
        C = self.basis().keys()
        return self.monomial(C(index))

    @cached_method
    def q(self, i):
        """
        Return the `q_i = q^{s_i}`.
        """
        s = self._cartan_type.symmetrizer()
        return self._q**s[i]

    def _generator_type(self, x):
        """
        Return the type of generator corresponding to the index ``x`` or
        ``None`` if ``x`` is not a generator.
        """
        ret = None

        # Check e
        if len(x[0]) > 1:
            return None
        if len(x[0]) == 1:
            ret = ('e', self._e_monoid.gens().index(x[0]))

        # Check q^h
        if not x[1].is_zero():
            if ret is not None:
                return None
            ret = ('h', x[1])

        # Check f
        if len(x[2]) > 1:
            return None
        if len(x[2]) == 1:
            if ret is not None:
                return None
            ret = ('f', self._f_monoid.gens().index(x[2]))
        return ret

    def _list_of_generators(self, m):
        """
        Return a list of generators whose product equals ``m``.
        """
        e,h,f = m
        h_basis = self._P_check.basis()
        e_id, h_id, f_id = self._e_monoid.one(), self._P_check.zero(), self._f_monoid.one()
        C = self.basis().keys()
        ret = [self.monomial(C( (e_gen, h_id, f_id) )) for e_gen in e]
        ret.append(self.monomial( C((e_id, h, f_id)) ))
        ret += [self.monomial(C( (e_id, h_id, f_gen) )) for f_gen in f]

    def product_on_basis(self, a, b):
        """
        Return the product of basis elements indexed by ``a`` and ``b``.
        """
        C = self.basis().keys()
        ret = self.one()
        ga = self._generator_type(a)
        if ga is not None: # If the lhs is a generator
            if ga[0] == 'e':
                return self.monomial(C((a[0]*b[0], b[1], b[2])))
            elif ga[0] == 'h':
                p = 0
                i_set = self._cartan_type.index_Set()
                for syl in b[0]:
                    j = self._e_monoid.gens().index(syl[0])
                    p += sum(c * syl[1] * cm[j,i_set.index(i)] for i,c in a[1])
                return self.term(C((b[0], a[1] + b[1], b[2])), self._q**p)
            elif ga[0] == 'f':
                comm = None
                for k,syl in enumerate(b[0]):
                    lot = self.zero() # Lower order terms
                    if ga[0] == self._f_monoid.gens().index(syl[0]):
                        if comm is None:
                            temp = self._cartan_type.index_set()[ga[1]]
                            comm = (self.K(temp)**-1 - self.K(temp)) / (self.q(temp) - self.q(temp)**-1)
                        # a[1] == self._P_check.zero()
                        lot += self.monomial( C((b[0][:k], a[1], self._f_monoid.one())) ) \
                                * comm * self.monomial(C((b[0][k+1:], b[1], b[2])))
                return self.monomial( C((b[0], a[1], a[2])) ) + lot
        return self.prod(self.product_on_basis(gen_a, b)
                         for gen_a in self._list_of_generators(a))

    def T_on_generator(self, i, x):
        r"""
        Return the image of `T_i` on the generator indexed by `x`.

        The automorphism `T_i` is defined as follows:

        .. MATH::

            \begin{aligned}
            T_i(e_j) & = \begin{cases} -f_i K_i & i = j, \\
            \sum_{k=0}^{-a_{ij}} (-1)^{-a_{ij}-k} q_i^{a_{ij}+k}
            e^{(k)}_i e_j e^{(-a_{ij}-k)}_i & i \neq j, \end{cases}
            \\ T_i(f_j) & = \begin{cases} -K_i^{-1} e_i & i = j, \\
            \sum_{k=0}^{-a_{ij}} (-1)^{-a_{ij}-k} q_i^{-a_{ij}-k}
            f^{(-a_{ij}-k)}_i f_j f^{(k)}_i & i \neq j, \end{cases}
            \\ T_i(K_j) & = K_j K_i^{-a_{ij}}.
            \end{aligned}

        INPUT:

        - ``i`` -- the index of `T_i`
        - ``x`` -- a generator
        """
        q = self.q(i)
        n = self._cartan_type.rank()
        e = self._e_monoid.gens()
        h = self._P_check.basis()
        f = self._f_monoid.gens()
        C = self.basis().keys()
        s = self._cartan_type.symmetrizer()[i]
        i = self._cartan_type.index(i)

        if x in e:
            j = e.index(x)
            if i == j:
                return self.term(C((self._e_monoid.one(), s*h[i], f[i])), -1)
            aij = self._cartan_type.cartan_matrix()[i,j]
            if aij == 0:
                return self.one()
            return self.sum_of_terms([(C((e[i]**k * e[j] * e[i]**(-aij-k),
                                          self._P_check.zero(), self._f_monoid.one())),
                                       (-1)**(-aij-k) * q**(aij+k)
                                       / q_factorial(k, self._q) / q_factorial(-aij-k, self._q))
                                      for k in range(-aij+1)]) # +1 for non-inclusive

        if x in f:
            j = f.index(x)
            if i == j:
                return self.term(C((e[i], -s*h[i], self._f_monoid.one())), -1)
            aij = self._cartan_type.cartan_matrix()[i,j]
            if aij == 0:
                return self.one()
            return self.sum_of_terms([(C((self._e_monoid.one(), self._P_check.zero(),
                                          f[i]**(-aij-k) * f[j] * f[i]**k)),
                                       (-1)**(-aij-k) * q**(-aij-k) # +1 for indexing
                                       / q_factorial(-aij-k, self._q) / q_factorial(k, self._q))
                                      for k in range(-aij+1)]) # +1 for non-inclusive

        # it is a q^{h} element
        s = self._cartan_type.symmetrizer()
        i_set = self._cartan_type.index_set()
        si = s[i_set[i]]
        ret_h = self._P_check.zero()
        for j, p in enumerate(x):
            aij = self._cartan_type.cartan_matrix()[i,j]
            ret_h += p * (s[i_set[j]] // si * h[j] + -aij // si * h[i])
        return self.monomial( C((self._e_monoid.one(), ret_h, self._f_monoid.one())) )

    class Element(CombinatorialFreeModule.Element):
        """
        An element of the monomial basis.
        """
        def __invert__(self):
            """
            Return the inverse of ``self``.
            """
            supp = self.support()
            if len(supp) != 1:
                raise ValueError("can only invert monomials")
            m, c = list(self)[0]
            if not m[0] != self._e_monoid.one() or m[2] != self._f_monoid.one():
                raise ValueError("can only invert monomials in h")
            m = (m[0], -m[1], m[2])
            return self.term(m, ~c)

        def T(self, i):
            """
            Return the action of `T_i` on ``self``.

            See :meth:`T_on_generator()` for a definition of the
            automorphism `T_i`.
            """
            P = self.parent()
            h = self._P_check.basis()
            return sum([c * P.prod(P.T_on_generator(i, x)**p for x,p in m[0])
                          * P.T_on_generator(i, m[1])
                          * P.prod(P.T_on_generator(i, x)**p for x,p in m[2])
                        for m,c in self], P.zero())

class QuantumGroupPBWBasis(CombinatorialFreeModule):
    """
    The Poincare-Birkhoff-Witt (PBW) basis of the quantum group
    `U_q(\mathfrak{g})`.
    """
    @staticmethod
    def __classcall__(cls, ct, q=None, base_ring=None, **kwds):
        """
        Normalize arguments to ensure a unique representation.
        """
        ct = CartanType(ct)
        if not ct.is_finite():
            raise NotImplementedError("only implemented for finite types")

        if base_ring is None:
            if q is None:
                base_ring = PolynomialRing(QQ, 'q')
                q = base_ring.gen(0)
            else:
                base_ring = q.parent()
        base_ring = FractionField(base_ring)
        q = base_ring(q)
        return super(QuantumGroupPBWBasis, cls).__classcall__(cls, ct, q, base_ring)

    def __init__(self, ct, q, base_ring):
        """
        Initialize ``self``.
        """
        self._q = q
        self._cartan_type = ct
        from sage.combinat.root_system.weyl_group import WeylGroup
        from sage.combinat.cartesian_product import CartesianProduct
        from sage.rings.semirings.non_negative_integer_semiring import NN
        self._weyl = WeylGroup(ct)
        self._long_word = self._weyl.long_element().reduced_word()
        cp = CartesianProduct( *[NN]*(3*len(self._long_word)) )
        CombinatorialFreeModule.__init__(self, base_ring, cp, prefix="PBW",
                                         category=AlgebrasWithBasis(base_ring))

    def _repr_(self):
        """
        Return a string representation of ``self``.
        """
        return "Quantum group of {} in the PBW basis".format(self._cartan_type)

    @cached_method
    def one_basis(self):
        """
        Return the index of the basis element `1`.
        """
        return self._group.one()

    def expand_on_basis(self, m):
        """
        Expand the basis element index by ``m`` in the monomial basis.
        """
        monomials = QuantumGroupMonomialBasis(self._cartan_type, self._q, self.base_ring())
        n = self._cartan_type.rank()
        ret  = monomials.prod(reduce(lambda x,i: x.T(i), self._long_word[:j-1], monomials.e(j))
                              for j,p in enumerate(m[:n]))
        ret *= prod(monomials.h(i)**p for i,p in enumerate(m[n:2*n]))
        ret *= monomials.prod(reduce(lambda x,i: x.T(i), self._long_word[:j-1], monomials.f(j))
                              for j,p in enumerate(m[2*n:]))

    class Element(CombinatorialFreeModule.Element):
        """
        An element of the PBW basis.
        """
        def expand(self):
            """
            Expand ``self`` into monomials using `e_i`, `f_i`, and `h_i`.
            """
            P = self.parent()
            return sum([c*P.expand_on_basis(m) for m,c in self], P.zero())

