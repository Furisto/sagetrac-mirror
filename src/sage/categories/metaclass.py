"""
Metaclass for Categories

This module defines machinery to support defining subcategories as
inner classes.
"""


from sage.misc.classcall_metaclass import ClasscallMetaclass
from sage.structure.dynamic_class import DynamicMetaclass, DynamicClasscallMetaclass
from sage.categories.axioms.axiom import Axiom
from sage.categories.axioms.model import category_axiom_model
from sage.categories.inner_category_utils import InnerCategory, CategoryWithAxiomsPlaceholder


def separate_axiom_classes(class_list):
    """
    Helper to split a list of classes into categories and axioms

    Also, enforce that axioms are at the end of ``class_list``.

    EXAMPLES::

        sage: from sage.categories.metaclass import separate_axiom_classes
        sage: class_list = [Category, int, axioms.Finite, axioms.Commutative]
        sage: cats, axioms = separate_axiom_classes(class_list)
        sage: cats
        [<class 'sage.categories.category.Category'>, <type 'int'>]
        sage: sorted(axioms)
        [<class 'sage.categories.axioms.commutative.Commutative'>, 
         <class 'sage.categories.axioms.finite.Finite'>]
    """
    remainder = []
    axioms = []
    for cls in class_list:
        if issubclass(cls, Axiom):
            axioms.append(cls)
        else:
            if len(axioms) > 0:
                raise TypeError('Axioms must be at the end of {0}'.format(class_list))
            remainder.append(cls)        
    return remainder, axioms


def replace_InnerCategory(classes_list, replacement):
    """
    Helper to replace :class:`InnerCategory` in a list
    
    EXAMPLES::

        sage: from sage.categories.metaclass import replace_InnerCategory, InnerCategory
        sage: class_list = ['A', InnerCategory, 'B']
        sage: replace_InnerCategory(class_list, ['Replaced'])
        ('A', 'Replaced', 'B')
    """
    result = []
    for cls in classes_list:
        if cls is InnerCategory:
            result.extend(replacement)
        else:
            result.append(cls)
    return tuple(result)


def subcategory_with_axiom_factory(name, *axiom_classes):
    def self_with_axioms(self):
        """
        Return the category with added axioms.

        Calls ``self.with_axioms(...)``
        """
        axiom_list = [axiom() for axiom in axiom_classes]
        return self.with_axioms(*axiom_list)
    self_with_axioms.__name__ = name
    return self_with_axioms


def add_generated_attributes(category, base_category, axiom_classes):
    """
    Add the autogenerated attributes to the category class
    """
    category.__class_without_category__ = category
    category.__base_category_class__ = base_category
    category.__axiom_classes__ = axiom_classes


def read_off_axioms(bases, dictionary):
    """
    Figure out the axioms for a class
    
    INPUT:

    - ``bases`` -- tuple of base classes.

    - ``dictionary`` -- the class dictionary.

    OUTPUT:

    A list of axioms. A ``TypeError`` is raised if both inheritance
    and the ``__axiom_classes__`` attribute is used to specify the
    axioms.

    EXAMPLES::

        sage: from sage.categories.metaclass import read_off_axioms
        sage: read_off_axioms((Category,), 
        ....:                 dict(__axiom_classes__=frozenset([axioms.Finite])))
        frozenset([<class 'sage.categories.axioms.finite.Finite'>])

        sage: read_off_axioms((Category, axioms.Finite), dict())
        frozenset([<class 'sage.categories.axioms.finite.Finite'>])

        sage: read_off_axioms((Category, axioms.Finite), 
        ....:                 dict(__axiom_classes__=frozenset([axioms.Finite])))
        Traceback (most recent call last):
        ...
        TypeError: must not both inherit from Axiom and set the __axiom_classes__ attribute
    """
    base_remainder, base_axioms = separate_axiom_classes(bases)
    attr_axioms = list(dictionary.get('__axiom_classes__', []))
    if len(attr_axioms) > 0 and len(base_axioms) > 0:
        raise TypeError('must not both inherit from Axiom and '
                        'set the __axiom_classes__ attribute')
    return frozenset(base_axioms + attr_axioms)


class CategoryMetaclass(ClasscallMetaclass): 
    """
    Metaclass to define subcategories by inner classes
    
    This is the solution to the following chicken-and-egg problem:
    While the inner class is constructed, the containing class does
    not yet exist.
    """
    
    @classmethod
    def __new_dynamic__(cls, base_category, axioms):
        """
        Construct a dynamic category-with-axiom class

        EXAMPLES::

            sage: from sage.categories.category_with_axioms import Test1, CategoryWithAxioms
            sage: cls = CategoryWithAxioms.__metaclass__.__new_dynamic__(Test1(), [axioms.WithBasis()])
            sage: cls().explain()
            Category sage.categories.metaclass.dynamic.Test1.WithBasis_with_category
            Set by meta class:
                __class_without_category__ = dynamic.Test1.WithBasis
                __base_category_class__ = Test1
                __axiom_classes__ = frozenset([WithBasis])
            Set by the category axiom manager:
                _base_category = Category of test1
            MRO = (dynamic.Test1.WithBasis_with_category, dynamic.Test1.WithBasis, CategoryWithAxioms, NewCategory, Category, UniqueRepresentation, CachedRepresentation, WithEqualityById, SageObject, dynamic.Test1.WithBasis.subcategory_class, object)
        """
        # print('Meta {0} {1} {2}'.format(cls, base_category, axioms))
        base_category_class = base_category.__base_category_class__
        axiom_classes = frozenset(ax.__class__ for ax in axioms)
        name = 'dynamic.{0}.{1}'.format(
            base_category_class.__name__, 
            ''.join(map(str, axioms)))
        from sage.categories.category_with_axioms import CategoryWithAxioms
        bases = (CategoryWithAxioms,)
        dictionary = {
            '__base_category_class__': base_category_class,
            '__axiom_classes__': axiom_classes,
        }
        category = super(CategoryMetaclass, cls).__new__(
            cls, name, bases, dictionary)
        add_generated_attributes(category, base_category_class, axiom_classes)
        category_axiom_model.register_category_class(category)
        return category

    def __new__(cls, name, bases, dictionary):
        """
        Construct a new Category subclass

        .. NOTE::

            The metacategory works on classes only, it never sees
            instances of the categories. So in the implementation of
            the metaclass, note that ``category`` really always refers
            to the class (type) of the category. However, in the
            interest of breverity, we do not add ``_class`` to every
            variable name.
        """
        # don't do it twice for the top-most dynamic class
        # TODO: we need some proper hook there
        #       shoud generate the dynamic _with_category in the metaclass 
        #       as well and only set its attributes in Category.__init__
        if issubclass(cls, DynamicMetaclass):
            return super(CategoryMetaclass, cls).__new__(
                cls, name, bases, dictionary)

        # print('Meta {0} {1} {2} {3}'.format(cls, name, bases, dictionary))
        base_category = dictionary.pop('__base_category_class__', None)
        axioms = read_off_axioms(bases, dictionary)
        
        # Scan through the dictionary of the class we are going to construct
        inner_categories = []
        for key, attr in dictionary.items():
            if isinstance(attr, CategoryWithAxiomsPlaceholder):
                # Turn "SomeName = subcategory_with_axioms(axioms.Foo)" 
                # into a factory method for category-with-Foo 
                dictionary[key] = subcategory_with_axiom_factory(key, *attr.axiom_classes)
            elif isinstance(attr, type) and issubclass(attr, InnerCategory):
                # Turn inner class into a factory method for new category-with-axioms
                attr_remainder, attr_axioms = separate_axiom_classes(attr.__bases__)
                inner_categories.append([key, attr])
                if attr.__bases__[0] is not InnerCategory:
                    raise TypeError('InnerCategory must be the first parent class for '
                                    'for subcategory {0}'.format(key))
                dictionary[key] = subcategory_with_axiom_factory(key, *attr_axioms)
            elif isinstance(attr, type) and isinstance(attr, CategoryMetaclass):
                raise TypeError('subcategory {0} defined by inner class must derive '
                                'from InnerCategory and axioms only'.format(key))
            else:
                pass

        # Generate the category class
        category = super(CategoryMetaclass, cls).__new__(
            cls, name, bases, dictionary)
        if base_category is None:
            base_category = category
        add_generated_attributes(category, base_category, axioms)
        category_axiom_model.register_category_class(category)

        # Generate the subcategory classes
        for key, subcategory in inner_categories:
            from sage.categories.category_with_axioms import CategoryWithAxioms
        
            # Base classes for the category defined by the inner class
            sub_bases = replace_InnerCategory(subcategory.__bases__, [CategoryWithAxioms])

            sub_dictionary = dict(subcategory.__dict__)
            if '__base_category_class__' in sub_dictionary:
                raise ValueError('InnerCategory must not set __base_category_class__, '
                                 'it wil automatically be set to the outermost class')
            sub_dictionary['__base_category_class__'] = base_category

            sub_axioms = read_off_axioms(sub_bases, sub_dictionary)
            if axioms.intersection(sub_axioms) != set():
                raise ValueError('subcategory from inner class {0} adds axiom that is '
                                     'already in the containing class'.format(key))
            sub_dictionary['__axiom_classes__'] = axioms.union(sub_axioms)

            # strip out the axioms from the oop base classes
            sub_bases, _ = separate_axiom_classes(sub_bases)
            sub_bases = tuple(sub_bases)

            # Generate the subcategory class with a recursive call to __new__
            subcategory = cls.__new__(cls, name + '.' + key, sub_bases, sub_dictionary)

        return category

    def __init__(cls, name, bases, dictionary):
        #print '-----------------------------------'
        #print "Initializing class", name, cls
        #print cls
        #print bases
        #print dictionary
        super(CategoryMetaclass, cls).__init__(name, bases, dictionary)
        #print '__init__', name, bases, dictionary
        #cls._base_category


class DynamicCategoryMetaclass(DynamicMetaclass, CategoryMetaclass):
    """
    Workaround for having two metaclasses for categories
    """
    pass
