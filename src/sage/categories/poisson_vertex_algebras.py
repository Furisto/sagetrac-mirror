r"""
Poisson vertex algebras
AUTHORS

- Reimundo Heluani (10-09-2019): Initial implementation

Let `R` be a ring. A *Poisson vertex algebra* over `R` is a tuple `(P, T,
\mathbb{1}, \{\cdot_\lambda \cdot\}, \cdot)` such that:

    - `(P,\mathbb{1}, \cdot)` is a unital commutative and associative algebra
      over `R`. 
    - `(P, T, \{ \cdot_\lambda \cdot \})` is a 
      :mod:`Lie conformal algebra<sage.categories.lie_conformal_algebra>` 
      over `R`.
    - `T` is a derivation of the commutative product `\cdot`.
    - The following *Leibniz* identity holds in `P[\lambda]`:

        .. MATH::

            \{a_\lambda b\cdot c\} = c \cdot \{a_\lambda b\}  + b \cdot
            \{a_\lambda c\}, \qquad a,b,c \in P

Given a :mod:`vertex algebra<sage.categories.vertex_algebras>` `V` the
associated graded `P = gr^F V` with respect to the 
:meth:`Li
filtration<sage.algebras.vertex_algebras.UniversalEnvelopingVertexAlgebra.li_filtration>`
is canonically a Poisson vertex algebra. The operations are defined by:

    .. MATH::

        \sigma_p(a) \cdot \sigma_q(b) = \sigma_{p+q} (a_{(-1)} b), \qquad
        [\sigma_p(a)_\lambda \sigma_q(b)] = \sum_{j \geq 0}
        \frac{\lambda^j}{j!} \sigma_{p+q-j} \bigl( a_{(j)} b \bigr), \qquad 
        T \sigma_p a = \sigma_{p+1} Ta

where `\sigma_p` is the principal symbol map. This algebra is graded: the
multiplication and `\lambda` bracket are of degree `0`.  When `V` is also 
:meth:`H-Graded<sage.categories.vertex_algebras.HGraded>` its classical limit is
bigraded. We call this extra grading the *conformal weight* grading. With
respect to the conformal weight grading, the multiplication is of degree `0`
while the `\lambda` bracket is of degree `-1`. This
Poisson vertex algebra is also called the *quasiclassical limit* or simply the
*classical limit* of `V`. 

EXAMPLES:

    - The classical limit of the universal Virasoro vertex algebra is the
      polynomial algebra in infinitely many generators. `R[L_{-2},L_{-3},\ldots]`
      The generator `L_{-n}` is in Li filtration degree `n-2` and conformal
      weight degree `n`. As an `R[T]` module it is freely generated by `L_{-2}`.
      The `\lambda` bracket vanishes on `P`. 

    - The classical limit of the universal affine vertex algebra
      `V^k(\mathfrak{g})` associated to a finite dimensional Lie algebra
      `\mathfrak{g}` is also a commutative algebra with infinitely many
      generators: `P = Sym^* t^{-1}\mathfrak{g}[t^{-1}]`. The generators
      `t^{-n-1}a` for `n \geq 0` and `a \in \mathfrak{g}` are in bidegree
      `(n,n)`.  As an `R[T]`-module it
      is finitely generated by `t^{-1} \mathfrak{g}`, the action of `T` is given
      by `\frac{d}{d t}`. The `\lambda` bracket among generators is given by

      .. MATH::

        \left\{t^{-1}a_\lambda t^{-1}b \right\} = t^{-1}[a,b] 
      
    - The classical limit of other vertex algebras may have quite a complicated
      structure. This happens even in very simple cases. Consider for example the
      classical limit of the Virasoro *ising* model::

        sage: V = VirasoroVertexAlgebra(QQ,1/2); L = V.0
        sage: v =  L*(L*L) + 93/64*L.T()*L.T() - 33/16*L.T(2)*L - 9/128*L.T(4)
        sage: Q = V.quotient(V.ideal(v))
        sage: Q(L)*Q(L)*Q(L)
        65/8*L_-4L_-2|0>+35/16*L_-6|0>+35/64*L_-3L_-3|0>
        sage: P = PoissonVertexAlgebra(QQ,Q)
        sage: P(L)*P(L)*P(L) == P.zero()
        True

      The multiplication in `P` is computationally expensive. We represent elements of
      `P` by a dictionary with both gradings as keys, we check here an identity in
      bidegree `(3,9)`::

        sage: P(L)
        {2: {0: B[0]}}
        sage: a = P(L)*P(L)*P(L.T(3)); a
        {9: {3: -3*B[0]}}
        sage: b = P(L)*P(L.T())*P(L.T(2)); b
        {9: {3: 1/6*B[0]}}
        sage: 18* b + a == P.zero()
        True

.. SEEALSO:: :mod:`sage.algebras.vertex_algebras.poisson_vertex_algebra`

"""

#******************************************************************************
#       Copyright (C) 2019 Reimundo Heluani <heluani@potuz.net>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# (at your option) any later version.
#                  http://www.gnu.org/licenses/
#*****************************************************************************
from sage.categories.category_with_axiom import all_axioms as all_axioms
from sage.categories.category_types import Category_over_base_ring
from sage.categories.category_with_axiom import CategoryWithAxiom_over_base_ring
from sage.misc.abstract_method import abstract_method
from sage.misc.cachefunc import cached_method
from lie_conformal_algebras import LieConformalAlgebras
from sage.categories.commutative_algebras import CommutativeAlgebras
all_axioms += ("HGraded",)


class PoissonVertexAlgebras(Category_over_base_ring):

    @cached_method
    def super_categories(self):
        """
        The super categories of this category

        EXAMPLES::

            sage: C = PoissonVertexAlgebras(QQ); C
            Category of Poisson vertex algebras over Rational Field
            sage: C.super_categories()
            [Category of commutative algebras over Rational Field,
             Category of Lie conformal algebras over Rational Field]
            sage: C.HGraded()
            Category of H-graded poisson vertex algebra over Rational Field
            sage: C.HGraded().super_categories()
            [Category of graded algebras over Rational Field,
             Category of Poisson vertex algebras over Rational Field,
             Category of H-graded Lie conformal algebra over Rational Field]

        """
        return [CommutativeAlgebras(self.base_ring()), 
                LieConformalAlgebras(self.base_ring())]

    def _repr_object_names(self):
        """
        The names of objects of this category
        """
        return "Poisson vertex algebras over {}".format(self.base_ring())

    class SubcategoryMethods:
        def Graded(self):
            """
            The subcategory of H-Graded Poisson vertex algebras

            These are graded by *conformal weight*
            """
            return self.HGraded()

        def HGraded(self):
            """
            The subcategory of H-Graded Poisson vertex algebras

            These are graded by *conformal weight*
            """
            return self._with_axiom('HGraded')

        def FinitelyGenerated(self):
            """
            The subcategory of finitely generated Poisson vertex algebras

            This returns ``self.FinitelyGeneratedAsMagma()`` implicitly using 
            only the algebra structure over `R[T]`.
            """
            return self.FinitelyGeneratedAsMagma()

        def WithBasis(self):
            """
            The subcategory of Poisson vertex algebras with a preferred basis
            """
            return self._with_axiom('WithBasis')

    class WithBasis(CategoryWithAxiom_over_base_ring):
        def _repr_object_names(self):
            """
            The names of objects of this category
            """
            return "poisson vertex algebra with basis over {}".format(
                                                            self.base_ring())

        class ParentMethods:
            @abstract_method
            def basis(self):
                """
                Return a basis of this Poisson vertex algebra
                """
                raise NotImplementedError("Not implemented")

    class FinitelyGeneratedAsMagma(CategoryWithAxiom_over_base_ring):
        def _repr_object_names(self):
            """
            The names of objects of this category
            """
            return "finitely generated poisson vertex algebras over {}"\
                        .format(self.base_ring())

        class ParentMethods:
            @abstract_method
            def gens(self):
                """
                The list of generators of this Poisson vertex algebra

                EXAMPLES::

                    sage: V = VirasoroVertexAlgebra(QQ,1/2);
                    sage: P = PoissonVertexAlgebra(QQ,V)
                    sage: P.gens()
                    (L_-2|0>,)
                    sage: P.0 in P
                    True
                    sage: P.inject_variables()
                    Defining L
                    sage: L*L*L
                    L_-2L_-2L_-2|0>
                    sage: L*L*L == L*(L*L)
                    True
                    sage: L in V
                    False

                    sage: L = V.0
                    sage: v =  L*(L*L) + 93/64*L.T()*L.T() - 33/16*L.T(2)*L - 9/128*L.T(4)
                    sage: Q = V.quotient(V.ideal(v))
                    sage: P = PoissonVertexAlgebra(QQ,Q)
                    sage: P.gens()
                    ({2: {0: B[0]}},)
                    sage: P.inject_variables()
                    Defining L
                    sage: L in P
                    True
                    sage: (L*L*L).is_zero()
                    True

                """
                raise NotImplementedError("Not implemented")

            def ngens(self):
                """
                The number of generators of this Poisson vertex algebra
                
                EXAMPLES::

                    sage: V = VirasoroVertexAlgebra(QQ,1/2);
                    sage: P = PoissonVertexAlgebra(QQ,V)
                    sage: P.ngens()
                    1

                 """
                return len(self.gens())
        
        class ElementMethods:
            def monomials(self):
                """
                The monomials in this element

                EXAMPLES::

                    sage: V = VirasoroVertexAlgebra(QQ,1/2); L = V.0
                    sage: v =  L*(L*L) + 93/64*L.T()*L.T() - 33/16*L.T(2)*L - 9/128*L.T(4)
                    sage: Q = V.quotient(V.ideal(v))
                    sage: P = PoissonVertexAlgebra(QQ,Q)
                    sage: Q.inject_variables()
                    Defining L
                    sage: mon = P(L*L*L).monomials(); mon
                    [{6: {2: 65/8*B[0]}}, {6: {2: 35/64*B[1]}}, {6: {4: 35/16*B[0]}}]
                    sage: [m.lift() for m in mon]
                    [65/8*L_-4L_-2|0>, 35/64*L_-3L_-3|0>, 35/16*L_-6|0>]

                """
                return tuple(v[1]*v[0] for v in 
                             self.monomial_coefficients().items())

    class HGraded(CategoryWithAxiom_over_base_ring):
        def extra_super_categories(self):
            """
            The extra super categories of this category

            Every H-Graded Poisson vertex algebra is a graded commutative
            algebra
            """
            return [CommutativeAlgebras(self.base_ring()).Graded(),]

        def _repr_object_names(self):
            """
            The names of objects of this category
            """
            return "H-graded poisson vertex algebra over {}"\
                    .format(self.base_ring())

        class FinitelyGeneratedAsMagma(CategoryWithAxiom_over_base_ring):
            def _repr_object_names(self):
                """
                The names of objects of this category
                """
                return "Finitely generated H-graded poisson vertex algebra "\
                        "over {}".format(self.base_ring())

        class ElementMethods:
            @abstract_method
            def weight(self):
                """
                The conformal weight of this element

                EXAMPLES::

                    sage: V = VirasoroVertexAlgebra(QQ,1/2)
                    sage: P = PoissonVertexAlgebra(QQ,V)
                    sage: P.0.weight()
                    2
                    sage: L = V.0; v =  L*(L*L) + 93/64*L.T()*L.T() - 33/16*L.T(2)*L - 9/128*L.T(4)
                    sage: Q = V.quotient(V.ideal(v))
                    sage: P = PoissonVertexAlgebra(QQ,Q)
                    sage: P.0.weight()
                    2

                """
                raise NotImplementedError("Not implemented")
