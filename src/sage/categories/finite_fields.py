r"""
Finite Fields
"""
#*****************************************************************************
#  Copyright (C) 2005      David Kohel <kohel@maths.usyd.edu>
#                          William Stein <wstein@math.ucsd.edu>
#                2008      Teresa Gomez-Diaz (CNRS) <Teresa.Gomez-Diaz@univ-mlv.fr>
#                2008-2009 Nicolas M. Thiery <nthiery at users.sf.net>
#
#  Distributed under the terms of the GNU General Public License (GPL)
#                  http://www.gnu.org/licenses/
#******************************************************************************

from sage.categories.category_with_axiom import CategoryWithAxiom
from sage.categories.enumerated_sets import EnumeratedSets

class FiniteFields(CategoryWithAxiom):
    """
    The category of finite fields.

    EXAMPLES::

        sage: K = FiniteFields(); K
        Category of finite enumerated fields

    A finite field is a finite monoid with the structure of a field;
    it is currently assumed to be enumerated::

        sage: K.super_categories()
        [Category of fields,
         Category of finite commutative rings,
         Category of finite enumerated sets]

    Some examples of membership testing and coercion::

        sage: FiniteField(17) in K
        True
        sage: RationalField() in K
        False
        sage: K(RationalField())
        Traceback (most recent call last):
        ...
        TypeError: unable to canonically associate a finite field to Rational Field

    TESTS::

        sage: K is Fields().Finite()
        True
        sage: TestSuite(K).run()
    """

    def extra_super_categories(self):
        r"""
        Any finite field is assumed to be endowed with an enumeration.

        TESTS::

            sage: Fields().Finite().extra_super_categories()
            [Category of finite enumerated sets]
            sage: FiniteFields().is_subcategory(FiniteEnumeratedSets())
            True
        """
        return [EnumeratedSets().Finite()]

    def __contains__(self, x):
        """
        EXAMPLES::

            sage: GF(4, "a") in FiniteFields()
            True
            sage: QQ in FiniteFields()
            False
            sage: IntegerModRing(4) in FiniteFields()
            False
        """
        from sage.categories.fields import Fields
        return x in Fields() and x.is_finite()

    # As is, this does no more than the usual __call__ of Category, but for the error message
    def _call_(self, x):
        """
        EXAMPLES::

            sage: FiniteFields()(GF(4, "a"))
            Finite Field in a of size 2^2
            sage: FiniteFields()(RationalField())   # indirect doctest
            Traceback (most recent call last):
            ...
            TypeError: unable to canonically associate a finite field to Rational Field
        """
        raise TypeError("unable to canonically associate a finite field to %s"%x)
        # TODO: local dvr ring?

    class ParentMethods:
        def absolute_field(self):
            r"""
            Return a finite field which is isomorphic to this field together
            with its isomorphisms.

            The field returned is the standard ``GF(p^n)`` of Sage which might
            be better suited for some computations.

            OUTPUT:

            A triple ``(k, f, t)`` where ``k`` is a finite field, ``f`` is an
            isomorphism from ``k`` to this field, and ``t`` is an inverse of
            ``f``.

            EXAMPLES:

            A trivial case::

                sage: GF(2^2).absolute_field()

            Rewriting a non-standard extension::

                sage: k = GF(2)
                sage: R.<a> = k[]
                sage: l.<a> = k.extension(a^3 + a^2 + 1)
                sage: l.absolute_field()

            Rewriting a tower of finite fields::

                sage: R.<b> = l[]
                sage: m.<b> = l.extension(b^2 + b + a)
                sage: m.absolute_field()

            """
            from sage.all import GF, matrix
            ret = GF(self.cardinality())
            if self is ret:
                return ret, ret.hom(ret), ret.hom(ret)
            
            generators = self.gens()
            if len(generators) != 1:
                raise NotImplementedError("finite field extension generated by more than one element in a single step; we don't know how to consistently pick the roots of these generators in the image")
            generator = generators[0]

            minpoly = generator.minpoly()
            base_map, standard_base_to_base, base_to_standard_base = self.base_ring().absolute_field()
            # Note that this is probably the place where this implementation is
            # really specific to finite fields: There is a consistent choice of
            # embeddings of the fields that come out of GF(p^n) and this makes
            # the .hom(ret) work.
            base_embedding = base_to_standard_base.hom(ret)
            image_of_generator = minpoly.map_coefficients(base_embedding).any_root()
            to_ret = self.hom([image_of_generator], base_morphism=base_embedding)            

            # Construct the inverse of to_ret by solving the corrspoding system
            # of linear equations; we could also factor the minpoly and pick
            # the right root but linear algebra is probably faster than that.
            A = matrix([(image_of_generator**i)._vector_() for i in range(ret.degree())])
            x = A.solve_right([i == 1 for i in range(ret.degree())])
            from_ret = ret.hom([sum([c*generator**i for i,c in enumerate(x)])])
            return ret, to_ret, from_ret

    class ElementMethods:
        pass
