"""
Categories with Axioms



"""

import importlib
import re
from sage.misc.cachefunc import cached_method, cached_function
from sage.misc.lazy_attribute import lazy_class_attribute
from sage.misc.lazy_import import LazyImport
from sage.misc.misc import call_method, uniq
from sage.categories.axioms.factory import axioms






#################################################################3
#  New category class

from sage.categories.metaclass import CategoryMetaclass, DynamicCategoryMetaclass

from sage.categories.category import Category
from sage.categories.category_singleton import Category_singleton
from sage.categories.category_types import Category_over_base_ring
from sage.categories.axioms.model import category_axiom_model
from sage.structure.dynamic_class import dynamic_class

DEBUG = True

class NewCategory(Category):
    r"""
    This class is only for demonstration purposes, it should
    be merged with Category.
    """
    __metaclass__ = CategoryMetaclass

    # The class of the base category, auto-generated by the CategoryMetaclass
    # __base_category_class__ = NewCategory

    # Frozenset of axiom classes, auto-generated by the CategoryMetaclass
    # __axiom_classes__ = frozenset()
    
    @staticmethod
    def __classcall__(cls, *args, **kwds):
        """
        Intercept all classclass and redirect to the category axiom manager

        EXAMPLES::

            sage: FiniteGroups()
            Category of finite groups
            sage: ModulesWithBasis(ZZ)
            Category of modules with basis over Integer Ring
            sage: AlgebrasWithBasis(QQ)
            Category of algebras with basis over Rational Field

        This is relevant when e.g. ``Foos(**)`` does some non trivial
        transformations::

            sage: Modules(QQ) is VectorSpaces(QQ)
            True
            sage: type(Modules(QQ))
            <class 'sage.categories.vector_spaces.VectorSpaces_with_category'>

            sage: ModulesWithBasis(QQ) is VectorSpaces(QQ).WithBasis()
            True
            sage: type(ModulesWithBasis(QQ))
            <class 'sage.categories.vector_spaces.VectorSpaces.WithBasis_with_category'>
        """
        #print('{2}__classcall__({0}, {1})__'.format(args, kwds, cls))
        return category_axiom_model.construct_classcall(cls, args, kwds)
        # return super(NewCategory, cls).__classcall__(cls, *args, **kwds)


    def __init__(self, base_category=None):
        """
        Initializes this category.

        EXAMPLES::

            sage: class SemiprimitiveRings(Category):
            ....:     def super_categories(self):
            ....:         return [Rings()]
            ....:
            ....:     class ParentMethods:
            ....:         def jacobson_radical(self):
            ....:             return self.ideal(0)
            ....:
            sage: C = SemiprimitiveRings()
            sage: C
            Category of semiprimitive rings
            sage: C.__class__
            <class '__main__.SemiprimitiveRings_with_category'>

        TESTS::

            sage: C = Sets.Finite(); C
            Category of finite sets
            sage: type(C)
            <class 'sage.categories.finite_sets.FiniteSets_with_category'>
            sage: type(C).__base__.__base__
            <class 'sage.categories.category_with_axiom.CategoryWithAxiom_singleton'>

            sage: TestSuite(C).run()
        """
        cls = self.__class__
        self.__class__ = dynamic_class('{0}_with_category'.format(cls.__name__),
                                       (cls, self.subcategory_class),
                                       cache=False, reduction=None,
                                       doccls=cls, 
                                       metaclass=DynamicCategoryMetaclass)
        self._base_category = self if base_category is None else base_category
        if DEBUG:
            self._init_debug()

    def _init_debug(self):
        """
        Perform additional checks on instances
        """
        assert issubclass(self.__base_category_class__, Category)
        assert isinstance(self._base_category, self.__base_category_class__)
        assert isinstance(self.__axiom_classes__, frozenset)
        assert self.__class__.__base__ is self.__class_without_category__

    def _test_category_with_axioms(self, **options):
        r"""
        Run generic tests on this category with axioms.

        .. SEEALSO:: :class:`TestSuite`.

        This check that an axiom category of a
        :class:`Category_singleton` is a singleton category, and
        similarwise for :class`Category_over_base_ring`.

        EXAMPLES::

            sage: Sets().Finite()._test_category_with_axiom()
            sage: Modules(ZZ).FiniteDimensional()._test_category_with_axiom()
        """
        tester = self._tester(**options)
        base = self.base_category()
        if isinstance(base, Category_singleton):
            tester.assertIsInstance(self, NewCategory_singleton)
        if isinstance(base, Category_over_base_ring):
            tester.assertIsInstance(self, NewCategory_over_base_ring)

    @staticmethod
    def _repr_object_names_static(category, axiom_list):
        r"""
        INPUT:

        - ``base_category`` -- a category
        - ``axioms`` -- a list or iterable of strings

        EXAMPLES::

            sage: from sage.categories.category_with_axiom import CategoryWithAxiom
            sage: CategoryWithAxiom._repr_object_names_static(Semigroups(), [axioms.Flying(), axioms.Blue()])
            'flying blue semigroups'
            sage: CategoryWithAxiom._repr_object_names_static(Algebras(QQ), 
            ....:     [axioms.Flying(), axioms.WithBasis(), axioms.Blue()])
            'flying blue algebras with basis over Rational Field'
            sage: CategoryWithAxiom._repr_object_names_static(Algebras(QQ), [axioms.WithBasis()])
            'algebras with basis over Rational Field'
            sage: CategoryWithAxiom._repr_object_names_static(
            ....:     Sets().Finite().Subquotients(), [axioms.Finite()])
            'subquotients of finite sets'
            sage: CategoryWithAxiom._repr_object_names_static(Monoids(), [axioms.Unital()])
            'monoids'
            sage: CategoryWithAxiom._repr_object_names_static(Algebras(QQ['x']['y']), 
            ....:     [axioms.Flying(), axioms.WithBasis(), axioms.Blue()])
            'flying blue algebras with basis over Univariate Polynomial Ring in y over Univariate Polynomial Ring in x over Rational Field'

        If the axioms is a set or frozen set, then they are first
        sorted using :func:`canonicalize_axioms`::

            sage: CategoryWithAxiom._repr_object_names_static(Semigroups(), 
            ....:     set([axioms.Finite(), axioms.Commutative(), axioms.Facade()]))
            'facade finite commutative semigroups'

        .. SEEALSO:: :meth:`_repr_object_names`

        .. NOTE:: The logic here is shared between :meth:`_repr_object_names`
            and :meth:`.category.JoinCategory._repr_object_names`
        """
        base_category = category._without_axioms(named=True)
        if isinstance(base_category, NewCategory): # Smelly runtime type checking
            result = super(NewCategory, base_category)._repr_object_names()
        else:
            result = base_category._repr_object_names()
        for axiom in reversed(sorted(set(axiom_list))):
            # TODO: find a more generic way to handle the special cases below
            if axiom in base_category.axioms():
                # If the base category already has this axiom, we
                # need not repeat it here. See the example with
                # Sets().Finite().Subquotients() or Monoids()
                continue
            if axiom == axioms.WithBasis():
                result = result.replace(" over ", " with basis over ", 1)
            elif axiom == axioms.Connected() and "graded " in result:
                result = result.replace("graded ", "graded connected ", 1)
            else:
                result = ' '.join([str(ax).lower() for ax in self.axioms()]) + " " + result
        return result

    def _repr_object_names(self):
        r"""
        The names of the objects of this category, as used by `_repr_`

        .. SEEALSO:: :meth:`Category._repr_object_names`

        EXAMPLES::

            sage: FiniteSets()._repr_object_names()
            'finite sets'
            sage: AlgebrasWithBasis(QQ).FiniteDimensional()._repr_object_names()
            'finite dimensional algebras with basis over Rational Field'
            sage: Monoids()._repr_object_names()
            'monoids'
            sage: Semigroups().Unital().Finite()._repr_object_names()
            'finite monoids'
            sage: Algebras(QQ).Commutative()._repr_object_names()
            'commutative algebras over Rational Field'

        .. NOTE::

            This is implemented by taking _repr_object_names from
            self._without_axioms(named=True), and adding the names
            of the relevant axioms in appropriate order.
        """
        return NewCategory._repr_object_names_static(self, self.axioms())

    def base_category(self):
        r"""
        Return the base category of ``self``.

        EXAMPLES::

            sage: C = Sets.Finite(); C
            Category of finite sets
            sage: C.base_category()
            Category of sets
            sage: C._without_axioms()
            Category of sets

        TESTS::

            sage: from sage.categories.category_with_axiom import TestObjects, CategoryWithAxiom
            sage: C = TestObjects().Commutative().Facade()
            sage: assert isinstance(C, CategoryWithAxiom)
            sage: C._without_axioms()
            Category of test objects
        """
        return self._base_category

    def __reduce__(self):
        r"""
        Implement the pickle protocol.

        This overides the implementation in
        :meth:`UniqueRepresentation.__reduce__` in order to not
        exposes the implementation detail that, for example, the
        category of magmas which distribute over an associative
        additive magma is implemented as
        ``DistributiveMagmasAndAdditiveMagmas.AdditiveAssociative.AdditiveCommutative``
        and not
        ``DistributiveMagmasAndAdditiveMagmas.AdditiveCommutative.AdditiveAssociative``::
        """
        return (call_method, (self.base_category(), "_with_axioms", self.defining_axioms()))

    def with_axioms(self, *axioms_list):
        base_category = self._base_category
        axioms = tuple(uniq(self.axioms() + tuple(axioms_list)))
        if len(axioms) == 0:
            return base_category
        if len(axioms) == 1:
            return category_axiom_model.construct_with_one_axiom(base_category, axioms[0])
        category = category_axiom_model.construct_with_axioms(base_category, axioms)
        if isinstance(category, tuple):
            return Category.join(category)
        else:
            return category
        

    @cached_method
    def axioms(self):
        r"""
        Return the axioms known to be satisfied by all the objects of ``self``.

        .. SEEALSO:: :meth:`Category.axioms`
        """
        return tuple(sorted(axiom() for axiom in self.__axiom_classes__))

    def explain(self):
        """
        Print information about the category

        #EXAMPLES::

        #    sage: from sage.categories.category_with_axioms import Test1
        #    sage: Test1().explain()
        #    sage: Test1().with_axioms(axioms.Finite(), axioms.Commutative()).explain()
        """
        cls = self.__class__
        print('Category {0}.{1}'.format(cls.__module__, cls.__name__))
        print('Set by meta class:')
        print('    __class_without_category__ = {0}'.format(
            self.__class_without_category__.__name__))
        print('    __base_category_class__ = {0}'.format(
            self.__base_category_class__.__name__))
        print('    __axiom_classes__ = frozenset([{0}])'.format(
            ', '.join(map(str, self.axioms()))))
        print('Set by the category axiom manager:')
        print('    _base_category = {0}'.format(self._base_category))
        print('MRO = ({0})'.format(
            ', '.join([parent.__name__ for parent in cls.mro()])))





class CategoryWithAxioms(NewCategory):

    @cached_method
    def super_categories(self):
        """
        Return a list of the (immediate) super categories of
        ``self``, as per :meth:`Category.super_categories`.

        This implements the property that if ``As`` is a subcategory
        of ``Bs``, then the intersection of As with ``FiniteSets()``
        is a subcategory of ``As`` and of the intersection of ``Bs``
        with ``FiniteSets()``.

        EXAMPLES::

            sage: FiniteSets().super_categories()
            [Category of sets]

            sage: FiniteSemigroups().super_categories()
            [Category of semigroups, Category of finite enumerated sets]

        EXAMPLES:

        A finite magma is both a magma and a finite set::

            sage: Magmas().Finite().super_categories()
            [Category of magmas, Category of finite sets]

        TESTS::

            sage: from sage.categories.category_with_axiom import TestObjects
            sage: C = TestObjects().FiniteDimensional().Unital().Commutative().Finite()
            sage: sorted(C.super_categories(), key=str)
            [Category of finite commutative test objects,
             Category of finite dimensional commutative unital test objects,
             Category of finite finite dimensional test objects]
        """
        return []


##############################################################################
# Utilities and tests tools

from sage.categories.inner_category_utils import subcategory_with_axioms, InnerCategory



# manual construction

class Test1(NewCategory):
    """
    EXAMPLES::

        sage: from sage.categories.category_with_axioms import Test1
        sage: Test1().__class__.__base__
        <class 'sage.categories.category_with_axioms.Test1'>
        sage: Test1().FiniteCommutative1().__class__.__base__
        <class 'sage.categories.category_with_axioms.FiniteCommutativeTest1'>
    """

    def super_categories(self):
        return []

    Infinite1 = subcategory_with_axioms(axioms.Infinite)  # parsed by the metaclass
        
    FiniteCommutative1 = subcategory_with_axioms(axioms.Finite, axioms.Commutative)

    

class FiniteCommutativeTest1(CategoryWithAxioms):
    
    __base_category_class__ = Test1

    __axiom_classes__ = frozenset([axioms.Commutative, axioms.Finite])

    def is_finite_commutative_1(self):
        """ Example of extra code """
        pass


# Inner class syntactic sugar

class Test2(NewCategory):
    """
    EXAMPLES::
    
        sage: from sage.categories.category_with_axioms import Test2
        sage: Test2().FiniteCommutative2()
        Category of finite commutative2

        sage: Test2().FiniteCommutative2().explain()
        Category sage.categories.category_with_axioms.Test2.FiniteCommutative2_with_category
        Set by meta class:
            __class_without_category__ = Test2.FiniteCommutative2
            __base_category_class__ = Test2
            __axiom_classes__ = frozenset([Finite, Commutative])
        Set by the category axiom manager:
            _base_category = Category of test2
        MRO = (Test2.FiniteCommutative2_with_category, Test2.FiniteCommutative2, 
               CategoryWithAxioms, NewCategory, Category, UniqueRepresentation, 
               CachedRepresentation, WithEqualityById, SageObject,  
               Test2.FiniteCommutative2.subcategory_class, object)
    """

    def super_categories(self):
        return []

    Infinite2 = axioms.Infinite
        
    class Finite2(InnerCategory, axioms.Finite):
        def is_finite_2(self):
            """ Example of extra code """
            return True

        class Associative2(InnerCategory, axioms.Associative):
            def is_finite_associative_2(self):
                """ Example of extra code """
                return True

    class FiniteCommutative2(InnerCategory, axioms.Finite, axioms.Commutative):
        def is_finite_commutative_2(self):
            """ Example of extra code """
            return True




# class Blahs(Category):

#     def super_categories(self):
#         """
#         TESTS::

#              sage: from sage.categories.category_with_axioms import Blahs
#              sage: Blahs().super_categories()
#              [Category of sets]
#             sage: TestSuite(Blahs()).run()
#         """
#         from sage.categories.sets_cat import Sets
#         return [Sets()]

#     class SubcategoryMethods:
#         FiniteDimensional = with_axioms(axioms.FiniteDimensional())
#         Commutative       = with_axioms(axioms.Commutative())
#         Unital            = with_axioms(axioms.Unital())
#         Connected         = with_axioms(axioms.Connected())
#         Flying            = with_axioms(axioms.Flying())
#         Blue              = with_axioms(axioms.Blue())

#     class FiniteDimensional(NewCategory):
#         pass
#     class Commutative(NewCategory):
#         pass
#     class Connected(NewCategory):
#         pass
#     class Unital(NewCategory):
#         class Blue(NewCategory):
#             pass
#     class Flying(NewCategory):
#         def extra_super_categories(self):
#             """
#             This illustrates a way to have an axiom imply another one.

#             Here, we want ``Flying`` to imply ``Unital``, and to put
#             the class for the category of unital flying blahs in
#             ``Blahs.Flying`` rather than ``Blahs.Unital.Flying``.

#             TESTS::

#                 sage: from sage.categories.category_with_axiom import Blahs, TestObjects, Bars
#                 sage: Blahs().Flying().extra_super_categories()
#                 [Category of unital blahs]
#                 sage: Blahs().Flying()
#                 Category of flying unital blahs
#             """
#             return [Blahs().Unital()]
