r"""
Lie Algebras With Basis

AUTHORS:

- Travis Scrimshaw (07-15-2013): Initial implementation
"""
#*****************************************************************************
#  Copyright (C) 2013 Travis Scrimshaw <tscrim at ucdavis.edu>
#
#  Distributed under the terms of the GNU General Public License (GPL)
#                  http://www.gnu.org/licenses/
#******************************************************************************

from sage.misc.abstract_method import abstract_method
from sage.misc.cachefunc import cached_method
from sage.categories.category_with_axiom import CategoryWithAxiom_over_base_ring
from sage.categories.lie_algebras import LieAlgebras
from sage.algebras.lie_algebras.lie_algebra_element import LieBracket

class LieAlgebrasWithBasis(CategoryWithAxiom_over_base_ring):
    """
    Category of Lie algebras with a basis.
    """
    _base_category_class_and_axiom = [LieAlgebras, "WithBasis"]

    class ParentMethods:
        def _basis_cmp(self, x, y):
            """
            Compare two basis element indices. The default is to call ``cmp``.
            """
            return cmp(x, y)

        @abstract_method(optional=True)
        def bracket_on_basis(self, x, y):
            """
            Return the bracket of basis elements indexed by ``x`` and ``y``
            where ``x < y``. If this is not implemented, then the method
            ``_bracket_()`` for the elements must be overwritten.
            """

        # Generalize to a general operation (on [co]algebras for example)
        def lie_subalgebra(self, gens, names=None):
            """
            Return the Lie subalgebra of ``self`` generated by ``gens``.

            INPUT:

            - ``gens`` -- a set of generators for the Lie subalgebra a linear
              combination of basis elements of ``self``
            - ``names`` -- (optional) a list of names for the generators

            EXAMPLES::

                sage: L.<x,y> = LieAlgebra(QQ, {('x','y'):{'x':1}})
                sage: L.lie_subalgebra([x, y+3*x]).structure_coefficients()
                Finite family {[x0, x1]: ((x0, 1),)}
                sage: L.lie_subalgebra([2*x+3*y, y+3*x], ['a','b']).structure_coefficients()
                Finite family {[a, b]: ((a, 1), (b, -3))}

                sage: L.<x,y,z> = LieAlgebra(QQ, {('x','y'):{'z':1}, ('y','z'):{'x':1}, ('z','x'):{'y':1}})
                sage: L.lie_subalgebra([x, y], ['a', 'b']).structure_coefficients()
                Finite family {[a, b]: ((ab, 1),), [a, ab]: ((b, -1),), [ab, b]: ((a, -1),)}
            """
            # Start by echonizing the basis and taking a linearly independent set (?)
            #if echelonize:
            #    m = matrix(map(lambda x: x.to_vector(), gens))
            #    m.echelonize()
            #    v_names = self.variable_names()
            #    basis = [self.element_class(self,
            #        {v_names[i]:v for i,v in enumerate(row) if v != 0})
            #        for row in m.rows()[:m.rank()]]
            basis = gens[:]

            # Setup the basic names for the generators
            from sage.algebras.lie_algebras.lie_algebra_element import LieGenerator
            if names is None:
                basis_names = [LieGenerator('x%s'%i) for i in range(len(basis))]
            else:
                basis_names = map(LieGenerator, names[:len(basis)])

            # Only need to determine the structure coefficients from gens
            # In the process, we will also determine a basis as well
            coeffs = {}
            R = self.base_ring()
            i = 0
            # TODO: Find a way to condense the vectors to finite dimensions
            b_vecs = map(lambda x: x.to_vector(), basis)
            M = self._dense_free_module()
            while i < len(basis):
                j = i + 1
                while j < len(basis):
                    b = self.bracket(basis[i], basis[j])
                    if not b: # If b == 0, nothing to do
                        continue

                    v = b.to_vector()
                    dep = M.linear_dependence(b_vecs + [v]) # b_vecs are linearly indep
                    if len(dep) != 0:
                        dep = dep[0]
                        # If there is a dependency, rewrite as a linear combination of basis
                        s = -dep[-1]
                        d = {basis_names[k]:R(c/s) for k,c in enumerate(dep[:-1]) if c != 0}
                        coeffs[LieBracket(basis_names[i], basis_names[j])] = d
                    else:
                        # We need to add a new basis vector
                        if names is not None and len(names) > len(basis):
                            basis_names.append(LieGenerator( names[len(basis)] ))
                        else:
                            comb_name = basis_names[i]._name + basis_names[j]._name
                            basis_names.append(LieGenerator(comb_name))
                        coeffs[LieBracket(basis_names[i], basis_names[j])] = {basis_names[-1]:1}
                        basis.append(b)
                        b_vecs.append(v)
                    j += 1
                i += 1
            from sage.algebras.lie_algebras.lie_algebra import LieAlgebraWithStructureCoefficients
            return LieAlgebraWithStructureCoefficients(R, basis_names, coeffs)

        @cached_method
        def derived_subalgebra(self):
            """
            Return the derived subalgebra of ``self``.

            EXAMPLES::
            """
            basis = self.basis()
            # We only need to do [a, b] when a < b (on some total order of the basis elements)
            # We echelonize the matrix here
            b_mat = matrix(self.base_ring(), [self.bracket(a, b).to_vector()
                             for i,a in enumerate(basis) for b in basis[i+1:]])
            b_mat.echelonize()
            r = b_mat.rank()
            names = self.variable_names()
            elt = lambda row: {names[i]: v for i, v in enumerate(row) if v != 0}
            gens = [self.element_class(self, elt(row)) for row in b_mat.rows()[:r]]
            return self.lie_subalgebra(gens)

        @cached_method
        def derived_series(self):
            """
            Return the derived series `(\mathfrak{g}_i)_i` of ``self`` where
            the rightmost `\mathfrak{g}_k = \mathfrak{g}_{k+1} = \cdots`.

            EXAMPLES::
            """
            L = [self]
            while L[-1].dimension() > 0:
                p = L[-1].derived_subalgebra()
                if L[-1].is_isomorphic(p):
                    break
                L.append(p)
            return L

        @cached_method
        def lower_central_series(self):
            """
            Return the lower central series `(\mathfrak{g}_i)_i` of ``self``
            where the rightmost `\mathfrak{g}_k = \mathfrak{g}_{k+1} = \cdots`.

            EXAMPLES::
            """
            L = [self]
            R = self.base_ring()
            basis = self.basis()
            gens = basis
            names = self.variable_names()
            elt = lambda row: {names[i]: v for i, v in enumerate(row) if v != 0}
            while L[-1].dimension() > 0:
                b_mat = matrix(R, [self.bracket(b, a).to_vector()
                                 for b in gens for a in basis])
                b_mat.echelonize()
                r = b_mat.rank()
                gens = [self.element_class(self, elt(row)) for row in b_mat.rows()[:r]]
                s = self.lie_subalgebra(gens)
                if L[-1].is_isomorphic(s):
                    break
                L.append(s)
            return L

        def is_abelian(self):
            """
            Return if ``self`` is an abelian Lie algebra.

            EXAMPLES::
            """
            return len(self.structure_coefficients()) == 0

        def is_solvable(self):
            r"""
            A Lie algebra `\mathfrak{g}` is said to be solvable if the derived
            series

            .. MATH::

                \mathfrak{g} \subseteq [\mathfrak{g}, \mathfrak{g}] \subseteq
                \bigl[ [\mathfrak{g}, \mathfrak{g}], [\mathfrak{g},
                \mathfrak{g}] \bigr] \subseteq
                \biggl[ \bigl[ [\mathfrak{g}, \mathfrak{g}], [\mathfrak{g},
                \mathfrak{g}] \bigr], \bigl[ [\mathfrak{g}, \mathfrak{g}],
                [\mathfrak{g}, \mathfrak{g}] \bigr] \biggr] \subseteq \cdots

            eventually becomes 0.
            """
            # We don't use the derived_series() method here because we can take
            #   advantage of the fact we only need to keep track of 2 Lie algebras
            old = self
            g = self.derived_subalgebra()
            while g.dimension() > 0 and not g.is_isomorphic(old):
                old = g
                g = g.derived_subalgebra()
            return g.dimension() == 0

        def is_nilpotent(self):
            r"""
            Return if ``self`` is a nilpotent Lie algebra.

            A Lie algebra `\mathfrak{g}` is said to be nilpotent if the lower
            central series

            .. MATH::

                \mathfrak{g} \subseteq [\mathfrak{g}, \mathfrak{g}] \subseteq
                \bigl[ [\mathfrak{g}, \mathfrak{g}], \mathfrak{g} \bigr]
                \subseteq\biggl[\bigl[ [\mathfrak{g}, \mathfrak{g}],
                \mathfrak{g} \bigr], \mathfrak{g}\biggr] \subseteq \cdots

            eventually becomes 0.
            """
            # We don't use the local_central_series() method here because we can take
            #   advantage of the fact we only need to keep track of 2 Lie algebras
            old = self
            g = self.derived_subalgebra()
            while not g.is_isomorphic(old):
                old = g
                g = g.derived_subalgebra()
            return g.dimension() != 0

        @abstract_method(optional=True)
        def is_isomorphic(self, g):
            """
            Check to see if ``self`` is isomorphic to ``g`` (as Lie algebras).

            It is clear that `\mathfrak{g}` and `\mathfrak{g}^{\prime}` are
            isomorphic only if the structure graphs in are isomorphic.
            Since we strip all singletons for simplicity, we also need to check
            that the dimensions agree.

            .. SEEALSO::

                :meth:`structure_graph()` for a definition/construction of the
                structure graph of a Lie algebra.
            """

        def pbw_basis(self, basis_indices=None, basis_cmp=None, **kwds):
            """
            Return the Poincare-Birkhoff-Witt basis corresponding to ``self``.

            .. TODO::

                Currently only works for finite dimensional Lie algebras.
            """
            if basis_cmp is None:
                basis_cmp = self._basis_cmp
            from sage.algebras.lie_algebras.poincare_birkhoff_witt \
                import PoincareBirkhoffWittBasis
            return PoincareBirkhoffWittBasis(self, basis_indices, basis_cmp, **kwds)

        poincare_birkhoff_witt_basis = pbw_basis

        _construct_UEA = pbw_basis

    class ElementMethods:
        def _bracket_(self, y):
            """
            Return the Lie bracket of ``[self, y]``.
            """
            P = self.parent()
            def term(ml,mr):
                comp = P._basis_cmp(ml,mr)
                if comp == 0:
                    return P.zero()
                if comp < 0:
                    return P.bracket_on_basis(ml, mr)
                return -P.bracket_on_basis(mr, ml)
            return P.sum(cl*cr * term(ml,mr)
                         for ml,cl in self for mr,cr in y)

