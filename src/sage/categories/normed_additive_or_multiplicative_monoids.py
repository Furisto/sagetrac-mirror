r"""
Normed Additive Or Multiplicative Monoids
"""
#*****************************************************************************
#  Copyright (C) 2020 Travis Scrimshaw <tcscrims at gmail.com>
#                2020 Matthias Koeppe
#
#  Distributed under the terms of the GNU General Public License (GPL)
#                  http://www.gnu.org/licenses/
#******************************************************************************

from sage.misc.cachefunc import cached_method
from sage.categories.category import Category
from sage.categories.sets_cat import Sets
from sage.categories.category_singleton import Category_singleton
from sage.categories.covariant_functorial_construction import RegressiveCovariantConstructionCategory

class NormedMonoidsCategory(RegressiveCovariantConstructionCategory):
    """
    Functorial construction for normed (additive) monoids.
    """
    _functor_category = "Normed"

    @classmethod
    def default_super_categories(cls, category):
        """
        Return the default super categories of ``category.Normed()``.

        Mathematical meaning: if `A` is a normed monoid in the
        category `C`, then `A` is also a metric space.

        INPUT:

        - ``cls`` -- a subclass of ``NormedMonoidsCategory``
        - ``category`` -- a category `C`

        OUTPUT:

        A (join) category

        In practice, this returns ``category.Normed()``, joined
        together with the result of the method
        :meth:`RegressiveCovariantConstructionCategory.default_super_categories()
        <sage.categories.covariant_functorial_construction.RegressiveCovariantConstructionCategory.default_super_categories>`
        (that is the join of ``category`` and ``cat.Normed()`` for
        each ``cat`` in the super categories of ``category``).

        EXAMPLES:

        Consider ``category=VectorSpaces(QQ).Filtered``. Then, a filtered
        vector space `V` with a norm is simultaneously a filtered vector space
        with a metric by itself, and a normed monoid::

        This resulted from the following call::

            sage: from sage.categories.normed_additive_or_multiplicative_monoids import NormedMonoidsCategory
            sage: NormedMonoidsCategory.default_super_categories(VectorSpaces(QQ).Filtered())
            Join of Category of normed modules over Rational Field
             and Category of filtered vector spaces over Rational Field
        """
        return Category.join([category.Metric(),
                              super(NormedMonoidsCategory, cls).default_super_categories(category)])

    # We currently don't have a use for this, but we probably will
    def _repr_object_names(self):
        """
        EXAMPLES::

            sage: Modules(ZZ).Normed()  # indirect doctest
            Category of normed modules over Integer Ring
        """
        return "normed {}".format(self.base_category()._repr_object_names())

class NormedAdditiveOrMultiplicativeMonoids(Category_singleton):
    r"""
    The category of normed additive or multiplicative monoids.

    A norm on a monoid `V` is a function `\|\cdot\| : V \to \RR` such that:

    - `\|x\| \geq 0`,
    - `\|x\| = 0` if and only if `x = 0`,
    - `\|x * y\| \leq \|x\| + \|y\|`, where `*` denotes either multiplication
      or addition.

    .. NOTE::

        This is an abstract category that is designated as a common base
        point for normed additive or mulitplicative monoids to reduce code
        duplication. This is not meant to be used directly.
    """
    def super_categories(self):
        """
        Return the super categories of ``self``.

        TESTS::

            sage: from sage.categories.normed_additive_or_multiplicative_monoids \
            ....:       import NormedAdditiveOrMultiplicativeMonoids
            sage: NormedAdditiveOrMultiplicativeMonoids().super_categories()
            [Category of sets]
        """
        return [Sets()]

    class ParentMethods:
        def norm_function(self):
            r"""
            Return the norm function of ``self``.

            EXAMPLES::

                sage: F = CombinatorialFreeModule(QQ, ['a','b','c'], category=VectorSpaces(QQ).Normed().WithBasis()); F
                Free module generated by {'a', 'b', 'c'} over Rational Field
                sage: F.norm_function()
            """
            return self.norm

        def norm(self, x):
            """
            Return the norm of ``x`` in ``self``.
            """
            return x.abs()

    class ElementMethods:
        def abs_squared(self):
            """
            Return the square of the norm of ``self``.

            Classes implementing a norm should implement one of the methods
            ``abs_squared`` and ``abs``.  The other method is supplied
            automatically.

            """
            return self.norm() ** 2

        def abs(self):
            """
            Return the norm of ``self``.

            Classes implementing a norm should implement one of the methods
            ``abs_squared`` and ``abs``.  The other method is supplied
            automatically.
            """
            return sqrt(self.abs_squared())

