r"""
Proto Poisson Vertex Algebras

AUTHORS:

- Reimundo Heluani (2020-08-26): Initial implementation.
"""
#******************************************************************************
#       Copyright (C) 2020 Reimundo Heluani <heluani@potuz.net>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# (at your option) any later version.
#                  http://www.gnu.org/licenses/
#*****************************************************************************
from .category_types import Category_over_base_ring
from .category_with_axiom import CategoryWithAxiom_over_base_ring
from .commutative_algebras import CommutativeAlgebras
from .quotients import QuotientsCategory
from .lambda_bracket_algebras import LambdaBracketAlgebras
from sage.misc.abstract_method import abstract_method
from sage.misc.cachefunc import cached_method
from sage.categories.commutative_rings import CommutativeRings
from sage.rings.all import QQ
from sage.categories.graded_modules import GradedModulesCategory
_CommutativeRings = CommutativeRings()

class ProtoPoissonVertexAlgebras(Category_over_base_ring):
    r"""
    The category of proto Poisson vertex algebras.

    This is an abstract base category for Poisson vertex algebras and
    super Poisson vertex algebras.
    """
    @staticmethod
    def __classcall_private__(cls, R, check=True):
        r"""
        INPUT:

        - `R` -- a commutative ring
        - ``check`` -- a boolean (default: ``True``); whether to check
          that `R` is a commutative ring

        EXAMPLES::

            sage: PoissonVertexAlgebras(QuaternionAlgebra(2))
            Traceback (most recent call last):
            ValueError: base must be a commutative ring got Quaternion Algebra (-1, -1) with base ring Rational Field
            sage: PoissonVertexAlgebras(ZZ)
            Category of Poisson vertex algebras over Integer Ring
        """
        if check:
            if not (R in _CommutativeRings):
                    raise ValueError("base must be a commutative ring got {}".format(R))
        return super(ProtoPoissonVertexAlgebras, cls).__classcall__(cls, R)

    @cached_method
    def super_categories(self):
        """
        The list of super categories of this category.

        EXAMPLES::

            sage: from sage.categories.proto_vertex_algebras import ProtoVertexAlgebras
            sage: ProtoVertexAlgebras(QQ).super_categories()
            [Category of Lambda bracket algebras over Rational Field]
        """
        return [LambdaBracketAlgebras(self.base_ring()),
                CommutativeAlgebras(self.base_ring())]

    def _repr_object_names(self):
        """
        The name of the objects of this category.

        EXAMPLES::

            sage: from sage.categories.proto_poisson_vertex_algebras import ProtoPoissonVertexAlgebras
            sage: ProtoPoissonVertexAlgebras(QQ)
            Category of proto Poisson vertex algebras over Rational Field
        """
        return "proto Poisson vertex algebras over {}".format(self.base_ring())

    class ParentMethods:

        @abstract_method
        def ideal(self, *gens, check=True):
            r"""
            The ideal of this Poisson vertex algebra generated by ``gens``.

            INPUT:

            - ``gens`` a tuple of homogeneous elements of this Poisson
              vertex algebra; the generators. We only support ideals such
              that the `R`-submodule `M` generated by ``gens``
              satisfies the following two conditions for every generator
              `g` of `V`:

              1. `g_{(n)} M = 0` for `n>0`,
              2. `g_{(0)} M \subset M`.

            - ``check`` -- a boolean (default: ``True``); whether to check
              that the generators satisfy the condition above.

            EXAMPLES::

                sage: V = vertex_algebras.NeveuSchwarz(QQ, 1)
                sage: P = V.classical_limit()
                sage: P.inject_variables()
                Defining L, G
                sage: I = P.ideal(L**2); I
                ideal of The classical limit of The Neveu-Schwarz super vertex algebra of central charge 1 over Rational Field generated by (L_2^2,)
            """
            raise NotImplementedError()

        @abstract_method
        def quotient(self, I, names=None):
            """
            The quotient of this Poisson vertex algebra by its ideal ``I``.

            INPUT:

            - ``I`` -- a :class:`PoissonVertexAlgebraIdeal`
            - ``names`` a list of ``str`` or ``None`` (default: ``None``);
              alternative names for the generators

            EXAMPLES::

                sage: V = vertex_algebras.NeveuSchwarz(QQ, 1)
                sage: P = V.classical_limit()
                sage: P.inject_variables()
                Defining L, G
                sage: I = P.ideal(L**2);
                sage: Q = P.quotient(I); Q
                Quotient of The classical limit of The Neveu-Schwarz super vertex algebra of central charge 1 over Rational Field by the ideal generated by (L_2^2,)
            """
            raise NotImplementedError("Quotients are not implemented for {}".\
                                       format(self))

    class Quotients(QuotientsCategory):
        """
        The category of quotients of Poisson vertex algebras.
        """
        class ParentMethods:
            #Most of these methods are not being picked by __mro__
            #Why is this?

            @abstract_method
            def defining_ideal(self):
                """
                The defining ideal of this quotient.

                EXAMPLES::

                    sage: V = vertex_algebras.Virasoro(QQ,1/2);
                    sage: Q = V.quotient(V.ideal(V.find_singular(6)))
                    sage: A = Q.arc_algebra()
                    sage: A.defining_ideal()
                    ideal of The classical limit of The Virasoro vertex algebra of central charge 1/2 over Rational Field generated by (L_2^3,)
                """
            
            def ideal(self):
                """
                The defining ideal of this quotient.

                EXAMPLES::

                    sage: V = vertex_algebras.Virasoro(QQ,1/2);
                    sage: Q = V.quotient(V.ideal(V.find_singular(6)))
                    sage: A = Q.arc_algebra()
                    sage: A.defining_ideal()
                    ideal of The classical limit of The Virasoro vertex algebra of central charge 1/2 over Rational Field generated by (L_2^3,)
                """
                return self.defining_ideal()

            @abstract_method
            def lift(self, x):
                """
                A preimage of this element in the cover Poisson vertex algebra.

                EXAMPLES::

                    sage: V = vertex_algebras.Virasoro(QQ,1/2);
                    sage: Q = V.quotient(V.ideal(V.find_singular(6)))
                    sage: A = Q.arc_algebra()
                    sage: v = A.an_element().lift(); v
                    1 + 2*L_2 + 3*L_3 + L_3*L_2
                    sage: v.parent()
                    The classical limit of The Virasoro vertex algebra of central charge 1/2 over Rational Field
                """
                raise NotImplementedError()

            @abstract_method
            def cover_algebra(self):
                """
                The covering vertex algebra of this quotient.

                EXAMPLES::

                    sage: V = vertex_algebras.Virasoro(QQ,1/2)
                    sage: P = V.classical_limit()
                    sage: P.inject_variables()
                    Defining L
                    sage: R = P.quotient(P.ideal(L**3))
                    sage: R.cover_algebra()
                    The classical limit of The Virasoro vertex algebra of central charge 1/2 over Rational Field
                """

            def ambient(self):
                """
                The covering vertex algebra of this quotient.

                EXAMPLES::

                    sage: V = vertex_algebras.Virasoro(QQ,1/2)
                    sage: P = V.classical_limit()
                    sage: P.inject_variables()
                    Defining L
                    sage: R = P.quotient(P.ideal(L**3))
                    sage: R.cover_algebra()
                    The classical limit of The Virasoro vertex algebra of central charge 1/2 over Rational Field
                """
                return self.cover_algebra()

            def _repr_(self):
                """
                The name of this quotient.

                EXAMPLES::

                    sage: V = vertex_algebras.Virasoro(QQ, 1/2)
                    sage: P = V.classical_limit()
                    sage: P.inject_variables()
                    Defining L
                    sage: R = P.quotient(P.ideal(L**3))
                    sage: R
                    Quotient of The classical limit of The Virasoro vertex algebra of central charge 1/2 over Rational Field by the ideal generated by (L_2^3,)
                """
                return "Quotient of {} by {}".format(self.cover_algebra(),
                                                     self.defining_ideal())

            def _an_element_(self):
                """
                An element of this quotient.

                EXAMPLES::

                    sage: V = vertex_algebras.Virasoro(QQ,1/2);
                    sage: Q = V.quotient(V.ideal(V.find_singular(6)))
                    sage: A = Q.arc_algebra()
                    sage: A.an_element()
                    1 + 2*L_2 + 3*L_3 + L_3*L_2
                """
                return self.retract(self.cover_algebra()._an_element_())

        class ElementMethods:

            @abstract_method
            def lift(self):
                """
                A preimage of this element in the cover Poisson vertex
                algebra.

                EXAMPLES::

                    sage: V = vertex_algebras.Virasoro(QQ,1/2);
                    sage: Q = V.quotient(V.ideal(V.find_singular(6)))
                    sage: A = Q.arc_algebra()
                    sage: v = A.an_element(); v
                    1 + 2*L_2 + 3*L_3 + L_3*L_2
                    sage: v.lift()
                    1 + 2*L_2 + 3*L_3 + L_3*L_2
                    sage: v.lift().parent() == V.classical_limit()
                    True
                """
                raise NotImplementedError()

            def is_even_odd(self):
                """
                Return ``0`` if this element is even and ``1`` if it is
                odd.

                EXAMPLES::

                    sage: V = vertex_algebras.NeveuSchwarz(QQ, 7/10)
                    sage: Q = V.quotient(V.ideal(V.find_singular(4)))
                    sage: A = Q.arc_algebra()
                    sage: A.inject_variables()
                    Defining L, G
                    sage: G.is_even_odd()
                    1
                """
                return self.lift().is_even_odd()

    class SubcategoryMethods:
        def FinitelyGeneratedAsDifferentialAlgebra(self):
            """
            The subcategory of finitely generated Poisson vertex
            algebras.

            EXAMPLES::

                sage: PoissonVertexAlgebras(AA).FinitelyGenerated()
                Category of finitely generated Poisson vertex algebras over Algebraic Real Field
            """
            return self._with_axiom('FinitelyGeneratedAsDifferentialAlgebra')

        def FinitelyGenerated(self):
            """
            The subcategory of finitely generated proto Poisson vertex
            algebras.

            EXAMPLES::

                sage: PoissonVertexAlgebras(AA).FinitelyGenerated()
                Category of finitely generated Poisson vertex algebras over Algebraic Real Field
            """
            return self._with_axiom('FinitelyGeneratedAsDifferentialAlgebra')

    class FinitelyGeneratedAsDifferentialAlgebra(CategoryWithAxiom_over_base_ring):
        """
        The class of finitely generated proto Poisson vertex algebras.
        """
        class WithBasis(CategoryWithAxiom_over_base_ring):
            """
            The category of finitely generated Poisson vertex algebras
            with basis.

            EXAMPLES::

                sage: PoissonVertexAlgebras(AA).WithBasis().FinitelyGenerated()
                Category of finitely generated Poisson vertex algebras with basis over Algebraic Real Field
            """
            pass

        class ParentMethods:
            @abstract_method
            def gens(self):
                """
                The generators of this Poisson vertex algebra.

                EXAMPLES::

                    sage: V = vertex_algebras.NeveuSchwarz(QQ, 1)
                    sage: P = V.classical_limit()
                    sage: P.gens()
                    (L_2, G_3/2)
                """
                raise NotImplementedError("Not implemented")

            def ngens(self):
                """
                The number of generators of this Poisson vertex algebra.

                EXAMPLES::

                    sage: V = vertex_algebras.Affine(QQ, 'A1',1)
                    sage: P = V.classical_limit()
                    sage: P.ngens()
                    3
                """
                return len(self.gens())

            def gen(self,i):
                """
                The ``i``-th generator of this Poisson vertex algebra.

                EXAMPLES::

                    sage: V = vertex_algebras.NeveuSchwarz(QQ, 7/10)
                    sage: P = V.classical_limit()
                    sage: P.gen(1)
                    G_3/2
                """
                return self.gens()[i]

            def some_elements(self):
                """
                A list of elements of this Poisson vertex algebra.

                EXAMPLES::

                    sage: V = vertex_algebras.NeveuSchwarz(QQ, 1)
                    sage: P = V.classical_limit()
                    sage: P.some_elements()
                    (L_2, G_3/2)
                """
                return self.gens()

        class Quotients(QuotientsCategory):
            """
            The category of quotients of Poisson vertex algebras.
            """

            class ParentMethods:

                def gens(self):
                    """
                    The generators of this quotient.

                    EXAMPLES::

                        sage: V = vertex_algebras.NeveuSchwarz(QQ, 7/10)
                        sage: Q = V.quotient(V.ideal(V.find_singular(4)))
                        sage: A = Q.arc_algebra()
                        sage: A.gens()
                        (L_2, G_3/2)
                    """
                    return tuple(self.retract(g) for g in\
                                 self.cover_algebra().gens()\
                                 if not self.retract(g).is_zero())

    class Graded(GradedModulesCategory):
        """
        The subcategory of H-graded proto Poisson vertex algebras.

        EXAMPLES::

            sage: PoissonVertexAlgebras(QQbar).Graded()
            Category of H-graded Poisson vertex algebras over Algebraic Field
        """
        def _repr_object_names(self):
            """
            The names of objects in this category.

            EXAMPLES::

                sage: PoissonVertexAlgebras(QQbar).Graded()
                Category of H-graded Poisson vertex algebras over Algebraic Field
            """
            return "H-graded {}".format(self.base_category().\
                                        _repr_object_names())

        class ElementMethods:

            @abstract_method
            def weight(self):
                """
                The conformal weight of this element.

                EXAMPLES::

                    sage: V = vertex_algebras.NeveuSchwarz(QQ, 1)
                    sage: P = V.classical_limit()
                    sage: v = P([[3,2],[1]]); v
                    L_4*L_3*G_3/2
                    sage: v.weight()
                    17/2
                """
                raise NotImplementedError("Not Implemented")

            def homogeneous_terms(self):
                """
                The homogeneous terms in this element with respect to
                conformal weight.

                EXAMPLES::

                    sage: V = vertex_algebras.NeveuSchwarz(QQ, 7/10)
                    sage: P = V.classical_limit()
                    sage: P.inject_variables()
                    Defining L, G
                    sage: v = L*L.T() + 3*G.T(2)*G + 2*G*L + L.T(); v
                    L_3 + 2*L_2*G_3/2 + L_3*L_2 + 6*G_7/2*G_3/2
                    sage: v.homogeneous_terms()
                    (L_3*L_2 + 6*G_7/2*G_3/2, 2*L_2*G_3/2, L_3)
                """
                if self.is_zero():
                    return tuple([self])
                S = {}
                p = self.parent()
                for m in self.terms():
                    w = m.weight()
                    S[w] = S.get(w,p.zero()) + m
                return tuple(S.values())

        class WithBasis(CategoryWithAxiom_over_base_ring):
            """
            The subcategory of H-graded proto Poisson vertex algebras with
            basis.
            """
            class ElementMethods:

                def degree(self):
                    """
                    The degree of this element.

                    This is the maximum conformal weight amongst all
                    monomials in this element.

                    EXAMPLES::

                        sage: V = vertex_algebras.Virasoro(QQ,1)
                        sage: P = V.classical_limit()
                        sage: v = P.an_element(); v
                        1 + 2*L_2 + 3*L_3 + L_2^4
                        sage: v.degree()
                        8
                    """
                    return max(m.weight() for m in self.monomials())

            class FinitelyGeneratedAsDifferentialAlgebra(
                                            CategoryWithAxiom_over_base_ring):
                """
                The class of finitely generated H-graded proto Poisson vertex
                algebras with basis.
                """

                class Quotients(QuotientsCategory):
                    """
                    The category of quotients of finitely generated
                    H-graded Poisson vertex algebras with basis.
                    """
                    class ElementMethods:

                        def weight(self):
                            """
                            The conformal weight of this element.

                            EXAMPLES::

                                sage: V = vertex_algebras.Virasoro(QQ,1/2); V.register_lift()
                                sage: Q = V.quotient(V.ideal(V.find_singular(6)))
                                sage: A = Q.arc_algebra()
                                sage: A.inject_variables()
                                Defining L
                                sage: v = L**3*L.T(2)*L.T(); v
                                0
                                sage: v = L**2*L.T(2)*L.T(4); v
                                48*L_6*L_4*L_2^2
                                sage: v.weight()
                                14
                            """
                            return self.lift().weight()

                        def T(self, n=1):
                            r"""
                            The ``n``-th derivative of this element.

                            INPUT:

                            - ``n`` -- a non-negative integer (default: ``1``); the number
                              of derivatives to apply.

                            EXAMPLES::

                                sage: V = vertex_algebras.Virasoro(QQ,1/2)
                                sage: Q = V.quotient(V.ideal(V.find_singular(6)))
                                sage: A = Q.arc_algebra()
                                sage: v = A.an_element()
                                sage: v
                                1 + 2*L_2 + 3*L_3 + L_3*L_2
                                sage: v.T()
                                2*L_3 + 6*L_4 + L_3^2 + 2*L_4*L_2
                            """
                            return self.parent().retract(self.lift().T(n))

                        def _bracket_(self, other):
                            r"""
                            The `\lambda`-bracket of these two elements.

                            EXAMPLES::

                                sage: V = vertex_algebras.Affine(QQ, 'A1',1, names=('e','h','f'))
                                sage: Q = V.quotient(V.ideal(V.find_singular(2)))
                                sage: A = Q.arc_algebra()
                                sage: A.inject_variables()
                                Defining e, h, f
                                sage: e.bracket(f)
                                {0: h_1}

                                sage: V = vertex_algebras.Virasoro(QQ,1/2)
                                sage: Q = V.quotient(V.ideal(V.find_singular(6)))
                                sage: A = Q.arc_algebra()
                                sage: A.inject_variables()
                                Defining L
                                sage: L.bracket(L)
                                {}
                            """
                            p = self.parent()
                            sl = self.lift()
                            ol = other.lift()
                            return {k:p.retract(v) for k,v in sl._bracket_(ol).\
                                    items() if not p.retract(v).is_zero()}

                    class ParentMethods:

                        @cached_method
                        def one(self):
                            """
                            The unit of this quotient.

                            EXAMPLES::

                                sage: V = vertex_algebras.Virasoro(QQ,1/2)
                                sage: Q = V.quotient(V.ideal(V.find_singular(6)))
                                sage: A = Q.arc_algebra()
                                sage: A.one()
                                1
                            """
                            #I need this here instead than PVA.Quotients()
                            #because otherwise mro picks the one from
                            #monoids I do not know why
                            return self.retract(self.cover_algebra().one())

                class ParentMethods: #Graded.WithBasis.FinitelyGenerated

                    def get_weight(self,n):
                        r"""
                        The subspace of this poisson vertex
                        algebra of vectors with weight equal to ``n``.

                        INPUT:

                        - ``n`` -- a non-negative rational number.

                        OUTPUT:

                        a submodule of this Poisson vertex algebra.

                        EXAMPLES::

                            sage: V = vertex_algebras.NeveuSchwarz(QQ,1)
                            sage: P = V.classical_limit()
                            sage: M = P.get_weight(11/2); M
                            Free module generated by {0, 1, 2, 3, 4} over Rational Field
                            sage: [v.lift() for v in M.basis()]
                            [L_2^2*G_3/2, L_3*G_5/2, L_4*G_3/2, L_2*G_7/2, G_11/2]
                        """
                        if any(g.weight() not in QQ or g.weight == 0 for g in\
                               self.gens()):
                            raise NotImplementedError("get_weight is not "\
                                            "implemented for {}".format(self))

                        if n not in QQ or n < 0:
                            raise ValueError("n needs to be a non-negative "\
                                             "rational number")

                        return self.submodule([self(v) for v in \
                                                self._indices.subset(energy=n)])

                    def dimension_at_weight(self,n):
                        """
                        The dimension of the space of conformal weight
                        ``n`` of this Poisson vertex algebra.

                        INPUT:

                        - ``n`` -- a non-negative rational number.

                        EXAMPLES::

                            sage: V = vertex_algebras.NeveuSchwarz(QQ,1)
                            sage: P = V.classical_limit()
                            sage: P.dimension_at_weight(11/2)
                            5
                        """
                        if n not in QQ or n < 0:
                            raise ValueError("n must be a non-negative "\
                                             "rational number")
                        return self._indices.subset(energy=n).cardinality()

                    def hilbert_series(self,ord):
                        r"""
                        The graded character of this Poisson vertex
                        algebra.

                        INPUT:

                        - ``ord`` -- a positive rational number; the
                          precision order of the result.

                        OUTPUT:

                        The sum

                        .. MATH::

                            \sum_{n = 0}^{ord} q^n \mathrm{dim} P_n

                        where `n` runs over all rationals such that `P_n \neq 0`

                        EXAMPLES::

                            sage: V = vertex_algebras.NeveuSchwarz(QQ,1); P = V.classical_limit()
                            sage: P.hilbert_series(11/2)
                            1 + q^(3/2) + q^2 + q^(5/2) + q^3 + 2*q^(7/2) + 3*q^4 + 3*q^(9/2) + 3*q^5 + O(q^(11/2))
                            sage: V = vertex_algebras.Virasoro(QQ,1/2); P = V.arc_algebra()
                            sage: P.hilbert_series(10)
                            1 + q^2 + q^3 + 2*q^4 + 2*q^5 + 4*q^6 + 4*q^7 + 7*q^8 + 8*q^9 + O(q^10)
                        """
                        from sage.arith.functions import lcm
                        from sage.functions.other import floor
                        from sage.rings.all import QQ, ZZ
                        weights = [g.weight() for g in self.gens()]
                        if any([w not in QQ or w < 0 for w in weights]):
                            raise NotImplementedError("hilbert_series is not "\
                                              "implemented for {}".format(self))
                        if ord not in QQ or ord < 0:
                            raise ValueError("ord must be a positive rational "\
                                             "number")
                        l = lcm([g.weight().denominator() for g in self.gens()])
                        if l==1:
                            from sage.rings.power_series_ring import\
                                                                PowerSeriesRing
                            q = PowerSeriesRing(ZZ,'q', default_prec=ord).gen()
                            return sum(self.dimension_at_weight(n)*q**n for\
                                       n in range(floor(ord))).O(floor(ord))
                        else:
                            from sage.rings.puiseux_series_ring import\
                                                              PuiseuxSeriesRing
                            q = PuiseuxSeriesRing(ZZ,'q').gen()
                            ord = floor(ord*l)
                            f = sum(self.dimension_at_weight(n/l)*q**(n/l) for\
                                    n in range(ord))
                            return f.add_bigoh(ord/l)

        class FinitelyGeneratedAsDifferentialAlgebra(
                                            CategoryWithAxiom_over_base_ring):
            """
            The subcategory of finitely generated H-graded proto Poisson
            vertex algebras.
            """
