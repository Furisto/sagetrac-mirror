r"""
Classes of G-Lattices
===================

G-Lattices are defined by equipping the standard lattice in `\ZZ^n` with a group action.

We allow trivial group actions.


All lattices inherit from :class:`Lattice_generic`, and there are currently
two types of lattices: ambient lattices (:class:`Lattice_ambient`) and sublattices of ambient
lattices (:class:`SubLattice`).

One can define a lattice in 5 different ways:

- Giving a group and matrix actions for each generator.

- Giving a group and an integer.

- Giving a list of matrices or finite matrix group.

- Giving a list corresponding to the isomorphism type of a finite abelian group.

- Giving an ambient lattice and a list of vectors spanning an invariant submodule.


GLattice(group, actions)
-------------------------------

You can define a lattice by giving a group and matrix actions for each generator::

    sage: G = PermutationGroup([(1, 2), (3, 4, 5)])
    sage: G.gens()
    [(3,4,5), (1,2)]
    sage: act1 = matrix(3, [0, 1, 0, 0, 0, 1, 1, 0, 0])
    sage: act2 = matrix(3, [1, 0, 0, 0, 1, 0, 0, 0, 1])
    sage: act = [act1, act2]

We created the group `G` as `C_2 \times C_3`, and the action where `C_2` acts trivially.
One has to be careful when defining the action to match sage's order of the generators::

    sage: L = GLattice(G, act); L
    Ambient lattice of rank 3 with an action by a group of order 6

    sage: L._action_matrices
    [
    [0 1 0]  [1 0 0]
    [0 0 1]  [0 1 0]
    [1 0 0], [0 0 1]
    ]

GLattice(group, n)
-------------------------

If you provide a group and an integer `n`, you get the lattice of rank `n` with
trivial action of the group::

    sage: L = GLattice(SymmetricGroup(3), 2); L
    Ambient lattice of rank 2 with an action by a group of order 6
    sage: L._action_matrices
    [
    [1 0]  [1 0]
    [0 1], [0 1]
    ]

If you do not provide an integer, it will give the natural permutation action of the group as permutation group.

    sage: L = GLattice([2,3]); L; L._action_matrices
    Ambient lattice of rank 5 with an action by a group of order 6
    [
    [1 0 0 0 0]  [0 1 0 0 0]
    [0 1 0 0 0]  [1 0 0 0 0]
    [0 0 0 1 0]  [0 0 1 0 0]
    [0 0 0 0 1]  [0 0 0 1 0]
    [0 0 1 0 0], [0 0 0 0 1]
    ]


GLattice(List_of_matrices) or Lattice_ambient(Matrix_Group)
------------------------------------------------------------------

If you provide a list of matrices, Sage will construct the lattice with rank
equal to the the size of the matrices, and the group will be understood to be
the subgroup of `GL_n(\ZZ)` generated by the provided matrices.
This subgroup should be finite::

    sage: m1 = matrix(3, [0, 0, 1, -1, -1, -1, 1, 0, 0])
    sage: m2 = matrix(3, [-1, 0, 0, 0, -1, 0, 0, 0, -1])
    sage: m3 = matrix(3, [0, 1, 0, 1, 0, 0, -1, -1, -1])
    sage: L = GLattice([m1, m2, m3]); L
    Ambient lattice of rank 3 with an action by a group of order 8

    sage: L._action_matrices
    [
    [-1  0  0]  [ 0  0  1]  [ 0  1  0]
    [ 0 -1  0]  [-1 -1 -1]  [ 1  0  0]
    [ 0  0 -1], [ 1  0  0], [-1 -1 -1]
    ]

::

    sage: m1 = matrix(3, [0, 0, 1, -1, -1, -1, 1, 0, 0])
    sage: m2 = matrix(3, [-1, 0, 0, 0, -1, 0, 0, 0, -1])
    sage: m3 = matrix(3, [0, 1, 0, 1, 0, 0, -1, -1, -1])
    sage: G = MatrixGroup([m1,m2,m3]);G
    Matrix group over Integer Ring with 3 generators (
    [ 0  0  1]  [-1  0  0]  [ 0  1  0]
    [-1 -1 -1]  [ 0 -1  0]  [ 1  0  0]
    [ 1  0  0], [ 0  0 -1], [-1 -1 -1]
    )
    sage: L = GLattice(G); L
    Ambient lattice of rank 3 with an action by a group of order 8


GLattice(list_of_integers, action)
--------------------------------

Providing a list of integers corresponding to a finite abelian group, and action
matrices (or integer for the trivial action)::

    sage: L = GLattice([2,2,2,2]); L
    Ambient lattice of rank 8 with an action by a group of order 16
    sage: L._group
    Permutation Group with generators [(7,8), (5,6), (3,4), (1,2)]



SubLattice(lattice, generators)
-------------------------------

In order to create a sublattice, give a lattice and a list of vectors in the lattice::

    sage: L = GLattice(DihedralGroup(6), 3)
    sage: x, y, z = L.basis()
    sage: L.sublattice([x, y + 2*z])
    Sublattice of degree 3 and rank 2 with an action by a group of order 12 and echelon basis matrix
    [1 0 0]
    [0 1 2]

The algorithm checks if the sublattice is stable under the group action::

    sage: L = GLattice(SymmetricGroup(2), [matrix([[0,1], [1,0]])])
    sage: L.sublattice([L.basis()[0]])
    Traceback (most recent call last):
    ...
    ValueError: The basis is not stable under the action of the group


Attributes of a lattice
-----------------------

- ``lattice._group`` -- the group acting on the lattice

- ``lattice._generators`` -- the generators of that group

- ``lattice._rank`` -- the rank of the lattice

- ``lattice._action_matrices`` -- the matrices through which the group acts

- ``lattice._action._morphism`` -- the map (as a group homomorphism in GAP) from
    the group to ``GL(rank,ZZ)``

- ``lattice._GAPMap`` -- returns the Sage :class:`sage.categories.map.Map` element
    representing Lattice.action_morphism

- ``lattice._action`` -- the Sage action of the group on the lattice

- ``lattice._parent_lattice`` -- the parent lattice; this attribute only exists for
    the SubLattice class


Methods of a lattice
--------------------

- :meth:`Lattice_generic.group` -- the group acting on the lattice

- :meth:`Lattice_generic.display_action`` -- displays the matrices corresponding to the group action

- :meth:`Lattice_generic._act` -- the action of the group on the lattice

- :meth:`Lattice_generic.subgroup_lattice` -- restricts the action of
    the group to a subgroup.

- :meth:`Lattice_generic.sum_lattice` -- takes the direct sum of two lattices.

- :meth:`Lattice_generic.parent_lattice` -- returns the parent ambient lattice.

- :meth:`Lattice_generic.group_extend` -- returns a lattice with the pullback action of a group with map to the current lattice group.

- :meth:`Lattice_generic.rational_characters` -- the sublattice of
    elements fixed by the group.

- :meth:`Lattice_generic.quotient_ambient_sublattice` -- the quotient lattice
    of an ambient lattice by some sublattice

- :meth:`Lattice_generic.quotient_lattice` -- the quotient lattice
    of a lattice by some sublattice

- :meth:`Lattice_generic.isomorphic_ambient_lattice` -- gives an isomorphic
    ambient lattice, returns the same lattice if it is already ambient.

-- :meth:`Lattice_generic.GAPMatrixgroup` -- the matrix group corresponding to
    the action, as a GAP group.

- :meth:`Lattice_generic.colattice` -- the lattice where the action of the group
    is composed with the inverse transpose automorphism.

- :meth:`Lattice_generic.Tate_Cohomology` -- computes the Tate cohomology of the lattice

- :meth:`Lattice_generic.induced_lattice` -- the induction of the lattice to a bigger group

- :meth:`Lattice_generic.zero_sum_sublattice` -- the sublattice of zero sum vectors,
    can also give an ambient lattice isomorphic to this zero sum sublattice.

- :meth:`Lattice_generic.first_coboundary_space` -- the space of 1-coboundaries.

- :meth:`Lattice_generic.first_cocycle_space` -- the space of 1-cocycles.

- :meth:`Lattice_generic.first_cohomology_group` -- the first cohomology group.

- :meth:`Lattice_generic.Tate_Shafarevich_lattice` -- the tate-shafarevich group, i.e. the kernel of restriction maps to a list of subgroups.




EXAMPLES::

    sage: G = PermutationGroup([(1, 2), (3, 4, 5)])
    sage: G.gens()
    [(3,4,5), (1,2)]
    sage: act1 = matrix(3, [0, 1, 0, 0, 0, 1, 1, 0, 0])
    sage: act2 = matrix(3, [1, 0, 0, 0, 1, 0, 0, 0, 1])
    sage: act = [act1,act2]
    sage: L1 = GLattice(G, act); L1
    Ambient lattice of rank 3 with an action by a group of order 6

``L1`` is the group `C_2 \times C_3` acting on `\ZZ^3` via the identity for the first component and
an order 3 permutation for the second component.

::

    sage: L2 = GLattice(SymmetricGroup(3), 4); L2
    Ambient lattice of rank 4 with an action by a group of order 6

``L2`` is the symmetric group `S_3` acting trivially on `\ZZ^4`.

::

    sage: m1 = matrix(3, [0, 0, 1, -1, -1, -1, 1, 0, 0])
    sage: m2 = matrix(3, [-1, 0, 0, 0, -1, 0, 0, 0, -1])
    sage: m3 = matrix(3, [0, 1, 0, 1, 0, 0, -1, -1, -1])
    sage: L3 = GLattice([m1, m2, m3]); L3
    Ambient lattice of rank 3 with an action by a group of order 8

``L3`` is the lattice with action of the group generated by the matrices ``m1``, ``m2``, ``m3``,
which is also the group of GAP ID (3,3,3,3)
"""

###########################################################################
#       Copyright (C) 2018-2019 
#     Thomas RÃ¼d <tompa.rud@gmail.com>
#     David Roe <roed.math@gmail.com>
#
#  Distributed under the terms of the GNU General Public License (GPL)
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# (at your option) any later version.
#                  http://www.gnu.org/licenses/
###########################################################################


from __future__ import print_function, absolute_import

from sage.categories.action import PrecomposedAction
from sage.rings.integer_ring import ZZ
from sage.rings.integer import Integer
from sage.groups.perm_gps.permgroup import PermutationGroup
from sage.groups.perm_gps.constructor import PermutationGroupElement
from sage.groups.perm_gps.permgroup_named import SymmetricGroup
from sage.groups.perm_gps.permgroup_element import SymmetricGroupElement
from sage.categories.map import Map
from sage.modules.free_module import FreeModule_ambient_pid
from sage.modules.free_module import FreeModule_generic
from sage.modules.free_module import FreeModule_submodule_pid
from sage.categories.homset import Hom
from sage.misc.functional import kernel
from sage.groups.matrix_gps.catalog import GL
from sage.libs.gap.libgap import libgap
from sage.interfaces.gap import gap
from sage.groups.matrix_gps.finitely_generated import FinitelyGeneratedMatrixGroup_gap
from sage.matrix.constructor import matrix
from sage.misc.mrange import cartesian_product_iterator
from sage.matrix.special import block_diagonal_matrix
from sage.matrix.special import block_matrix
from sage.matrix.matrix_space import MatrixSpace
from sage.groups.matrix_gps.finitely_generated import MatrixGroup
from sage.matrix.matrix_integer_dense import Matrix_integer_dense
from sage.combinat.permutation import Permutation
from sage.groups.perm_gps.permgroup import load_hap
from sage.arith.misc import prime_divisors
from sage.arith.misc import xgcd



def GLattice(*args, **kwds):
    r"""
    Create a `G`-lattice: a finite-rank free `Z`-module with an action of a finite group `G`

    INPUT:

    You can define a `G`-lattice by providing any of the following inputs:

    - A group `G` and a list ``im_gens`` of `n \times n` matrices, one for each generator of `G`.

    - A group `G` and an integer `n`.  Produces the rank `n` lattice with trivial `G`-action.

    - An integer `n`.  As above, with the trivial group.

    - A list ``im_gens`` of `n \times n` matrices.  `G` will be taken to be the generated matrix group.

    - A finite matrix group `G`.

    - A permutation group `G`, in which case the action will be by permutation matrices.

    - A list of integers, in which case `G` will be taken to be the abelian group
      with the corresponding invariants.  If `n` is also specified the action will be trivial;
      if a list of matrices ``im_gens`` are given they will define the action;
      otherwise it will be the permutation action.

    The action will be checked to ensure that it is a homomorphism.


    EXAMPLES::

        sage: GLattice(2)
        Ambient lattice of rank 2 with an action by a group of order 1
        sage: GLattice([2, 3], 1)
        Ambient lattice of rank 1 with an action by a group of order 6
        sage: GLattice([2, 3], 1).group()
        Permutation Group with generators [(3,4,5), (1,2)]

    ::  

        sage: act1 = matrix(3, [0, 1, 0, 0, 0, 1, 1, 0, 0])
        sage: act2 = matrix.identity(3)
        sage: G = PermutationGroup([(1, 2), (3, 4, 5)])
        sage: GLattice(G, [act1, act2])
        Ambient lattice of rank 3 with an action by a group of order 6

    ::

        sage: m1 = matrix(3, [0, 0, 1, -1, -1, -1, 1, 0, 0])
        sage: m2 = matrix(3, [-1, 0, 0, 0, -1, 0, 0, 0, -1])
        sage: m3 = matrix(3, [0, 1, 0, 1, 0, 0, -1, -1, -1])
        sage: GLattice([m1, m2, m3])
        Ambient lattice of rank 3 with an action by a group of order 8
    
    ::
    
        sage: GLattice([2, 3])
        Ambient lattice of rank 5 with an action by a group of order 6
    """
    def kwd_set(xname, x):
        if xname in kwds:
            raise TypeError("GLattice() got multiple values for argument '%s'" % xname)
        kwds[xname] = x
    if len(args) == 1:
        x = args[0]
        if isinstance(x, (int, Integer)):
            kwd_set('n', x)
        elif isinstance(x, (list, tuple)):
            if all(isinstance(i, (int, Integer)) for i in x):
                kwd_set('G', x)
            else:
                kwd_set('im_gens', x)
        else:
            kwd_set('G', x)
    elif len(args) == 2:
        x, y = args
        kwd_set('G', x)
        if isinstance(y, (int, Integer)):
            kwd_set('n', y)
        elif isinstance(y, (list, tuple)):
            kwd_set('im_gens', y)
        else:
            raise TypeError("Invalid type for second argument")
    elif len(args) > 2:
        raise TypeError("GLattice() takes 2 positional arguments but %s were given" % (len(args)))

    def process_matrix_group(G):
        iso = gap.Group([i.gap() for i in G.gens()]).IsomorphismPermGroup()
        G = PermutationGroup(iso.Image().GeneratorsOfGroup())
        im_gens = [matrix(i) for i in iso.PreImage(G.gens()).sage()]
        return G, im_gens

    G = kwds.pop('G', None)
    if isinstance(G, FinitelyGeneratedMatrixGroup_gap):
        # Matrix groups implicitly specify the generators
        G, im_gens = process_matrix_group(G)
        kwd_set('im_gens', im_gens) # ensure that im_gens wasn't specified twice
    elif isinstance(G, SymmetricGroup):
        G = PermutationGroup(G.gens(), canonicalize=False)
    elif isinstance(G, (list, tuple)):
        if all(isinstance(i, (int, Integer)) for i in G):
            partial_sums = [1]
            for i in G:
                partial_sums.append(partial_sums[-1] + i)
            G = PermutationGroup([tuple(range(a,b)) for (a,b) in zip(partial_sums[:-1], partial_sums[1:])])
        else:
            raise ValueError("G must be a group or list of integers")
    im_gens = kwds.pop('im_gens', None)
    check = kwds.pop('check', True)
    n = kwds.pop('n', None)
    if kwds:
        raise TypeError("GLattice() got an unexpected keyword argument '%s'" % ("', '".join(kwds)))

    if im_gens is None and n is None:
        # Try to use permutation action to produce an action
        try:
            n = G.largest_moved_point()
            im_gens = [g.matrix() for g in G.gens()]
        except AttributeError:
            raise TypeError("For non-permutation groups, must specify at least one of 'im_gens' and 'n'")
    if G is None and im_gens is None:
        G = PermutationGroup([()])
        im_gens = [matrix.identity(n)]
    elif im_gens is None:
        im_gens = [matrix.identity(n) for g in G.gens()]
    elif G is None:
        G = MatrixGroup(im_gens)
        if G.base_ring() is not ZZ:
            raise ValueError("Generators must be specified with integer entries")
        G, im_gens = process_matrix_group(G)

    # Check consistency
    if n is None:
        n = im_gens[0].nrows()
    if not all(g.nrows() == n and g.ncols() == n for g in im_gens):
        raise ValueError("Inconsistent value of n")
    if len(im_gens) != G.ngens():
        raise ValueError("im_gens must have the same length as the number of generators of G")
    return Lattice_ambient(G, im_gens, check)

def extended_xgcd(lst, result=[ZZ(1)]):
    """
    Takes a list of integers, and gives a 2-tuple giving their gcd, and
    a list of Bezout coefficients

    INPUT:

    - ``lst`` -- the list of integers we want the gdc and Bezout coefficients.
    - ``result`` -- only used for recursion

    EXAMPLES::
    
        sage: from sage.modules.glattice import extended_xgcd
        sage: extended_xgcd([6,20,15])
        (1, [21, -7, 1])
        sage: extended_xgcd([12,20,28,30])
        (2, [-14, 7, 0, 1])
    """
    if len(lst) == 0:
        return (ZZ(0), [])
    elif len(lst) == 1:
        return (lst[0], result)
    else:
        a, b, c = xgcd(lst[0], lst[1])
        r = [b*i for i in result]
        return extended_xgcd([a] + lst[2:], r + [c])

class GAPMap_toGLn(Map):
    r"""
    Sage Map class for a group homomorphism to ``GL(n,\ZZ)`` in GAP.
    """

    def __init__(self, group, rank, hom):
        """
        Contruct a map

        INPUT:

        - ``group`` -- The domain of the homomorphism

        - ``rank`` -- The rank of the target matrix group

        - ``hom`` -- The group homomorphism as a GAP object

        EXAMPLES::

            sage: G = PermutationGroup([(1, 2), (3, 4, 5)])
            sage: act1 = matrix(3, [0, 1, 0, 0, 0, 1, 1, 0, 0])
            sage: act2 = matrix(3, [1, 0, 0, 0, 1, 0, 0, 0, 1])
            sage: act = [act1, act2]
            sage: L = GLattice(G, act);
            sage: L._action
            Left action by Full MatrixSpace of 3 by 3 dense matrices over Integer Ring on Ambient lattice of rank 3 with an action by a group of order 6
            with precomposition on left by Composite map:
              From: Permutation Group with generators [(3,4,5), (1,2)]
              To:   Full MatrixSpace of 3 by 3 dense matrices over Integer Ring
              Defn:   Generic map:
                      From: Permutation Group with generators [(3,4,5), (1,2)]
                      To:   General Linear Group of degree 3 over Integer Ring
                    then
                      Coercion morphism:
                      From: General Linear Group of degree 3 over Integer Ring
                      To:   Full MatrixSpace of 3 by 3 dense matrices over Integer Ring
        """
        Map.__init__(self, Hom(group, GL(rank, ZZ)))
        self._morphism = hom
        self._domain = group
        self._codomain = GL(rank,ZZ)

    def _call_(self, element):
        """
        
        EXAMPLES::

            sage: L = GLattice([2, 2])
            sage: a = L._action
            sage: m = a((1, 2))
            sage: m((1, 2, 3, 4))
            (2, 1, 3, 4)
            sage: m(L.basis()[0])
            (0, 1, 0, 0)

        """
        if element is tuple:
            Elt = Permutation(element)
        else:
            Elt = element
        return matrix((gap.Image(self._morphism,Elt)).sage())

###############################################################################
#
# Base class for all lattices
#
###############################################################################

class Lattice_generic(FreeModule_generic):
    """
    Generic classes for all lattices
    """
    def __init__(self, G, im_gens, check):
        """
        Constructs a generic lattice.

        INPUT:

        - ``G`` -- the permutation group acting on the lattice.

        - ``im_gens`` -- action of the group on the lattice, given as a list of matrices.

        EXAMPLES::

            sage: L = GLattice(SymmetricGroup(3), 5); L
            Ambient lattice of rank 5 with an action by a group of order 6
            sage: a,b,c,d,e = L.basis()

        ::

            sage: L.sublattice([a, b, c+d+e])
            Sublattice of degree 5 and rank 3 with an action by a group of order 6 and echelon basis matrix
            [1 0 0 0 0]
            [0 1 0 0 0]
            [0 0 1 1 1]

        ::

            sage: act1 = matrix(3, [0, 1, 0, 0, 0, 1, 1, 0, 0])
            sage: act2 = matrix.identity(3)
            sage: G = PermutationGroup([(1, 2), (3, 4, 5)])
            sage: GLattice(G, [act1,act2])
            Ambient lattice of rank 3 with an action by a group of order 6

        ::

            sage: m1 = matrix(3, [0, 0, 1, -1, -1, -1, 1, 0, 0])
            sage: m2 = matrix(3, [-1, 0, 0, 0, -1, 0, 0, 0, -1])
            sage: m3 = matrix(3, [0, 1, 0, 1, 0, 0, -1, -1, -1])
            sage: GLattice([m1, m2, m3])
            Ambient lattice of rank 3 with an action by a group of order 8

        ::

            sage: H = MatrixGroup([m1, m2, m3])
            sage: GLattice(H)
            Ambient lattice of rank 3 with an action by a group of order 8
        """

        self._group = G
        self._generators = G.gens()
        self._action_matrices = im_gens
        self._rank = im_gens[0].nrows()
        FreeModule_generic.__init__(self, ZZ, self._rank, self._rank)
        G = gap(G)
        GenG = gap(self._generators)
        Mats = gap(self._action_matrices)
        if self._rank == 1:
            gl = gap.Group([ [ [ -1 ] ] ])
        else:
            gl = gap.GL(self._rank,ZZ)
        if check:
            self._action_morphism = gap.GroupHomomorphismByImages(G, gl, GenG, Mats)
            if gap.IsBool(self._action_morphism):
                raise ValueError('The action is not well defined')
        else:
            self._action_morphism = gap.GroupHomomorphismByImagesNC(G, gl, GenG, Mats)
        self._GAPMap = GAPMap_toGLn(self._group, self._rank, self._action_morphism)
        A = MatrixSpace(ZZ, self._rank).get_action(self)
        self._action = PrecomposedAction(A, self._GAPMap, None)

    def _act(self, g, e):
        """
        Computes the action of the group_element on a lattice element.

        INPUT:

        - ``g`` -- an element of the group acting on the lattice.

        - ``e`` -- an element of the lattice we wish to compute the action for.

        EXAMPLES::

            sage: G = PermutationGroup([(1, 2), (3, 4, 5)])
            sage: act1 = matrix(3, [0, 1, 0, 0, 0, 1, 1, 0, 0])
            sage: act2 = matrix.identity(3)
            sage: L1 = GLattice(G, [act1,act2])
            sage: L1._act(L1.group()[1], L1.basis()[0])
            (0, 1, 0)

        ::

            sage: L2 = GLattice(PermutationGroup([(2,3), (1,6,3), (7,6,4,5)]), 1)
            sage: L2._act(L2.group()[1], L2.basis()[0])
            (1)
        """
        return  self._action.act(g,e)

    ##### METHODS FOR LATTICES WITH GROUP ACTIONS######
    def group(self):
        """
        Returns the group associated with the lattice.

        EXAMPLES::

            sage: L1 = GLattice(SymmetricGroup(3), 5)
            sage: L1.group()
            Permutation Group with generators [(1,2,3), (1,2)]

        ::

            sage: L2 = GLattice(PermutationGroup([(2,3), (1,6,3), (7,6,4,5)]), 1)
            sage: L2.group()
            Permutation Group with generators [(4,5,7,6), (2,3), (1,6,3)]

        ::

            sage: L3 = GLattice([-matrix.identity(3)])
            sage: L3.group()
            Permutation Group with generators [(1,2)]
        """
        return self._group

    def display_action(self):
        """
        Shows information about the group and its action on the lattice.


        EXAMPLES::

            sage: L = GLattice([2, 3])
            sage: L.display_action()
            The group of order 6 generated by permutations [(3,4,5), (1,2)] acts as follows: 
            (3,4,5) acts via [1, 0, 0, 0, 0]
                             [0, 1, 0, 0, 0]
                             [0, 0, 0, 1, 0]
                             [0, 0, 0, 0, 1]
                             [0, 0, 1, 0, 0]
            (1,2) acts via [0, 1, 0, 0, 0]
                           [1, 0, 0, 0, 0]
                           [0, 0, 1, 0, 0]
                           [0, 0, 0, 1, 0]
                           [0, 0, 0, 0, 1]
        """

        Ggen=self.group().gens()
        print("The group of order %s"%(self.group().order())+" generated by permutations %s"%Ggen+" acts as follows: ")

        for g,a in zip(Ggen,self._action_matrices):
            print(str(g)+" acts via "+str(list(a[0])))
            for i in range(1,a.nrows()):
                print(" "*len(str(g))+"          "+str(list(a[i])))


    def subgroup_lattice(self,subgp):
        """
        Changes the group acting on the lattice to a subgroup.

        INPUT:

        - ``subgp`` -- the subgroup we wish to restrict the lattice to

        EXAMPLES::

            sage: G = SymmetricGroup(4)
            sage: H = DihedralGroup(4)
            sage: L = GLattice(G, 5)
            sage: L.subgroup_lattice(H)
            Ambient lattice of rank 5 with an action by a group of order 8
            sage: _._group
            Dihedral group of order 8 as a permutation group
        """
        return subgroup_lattice(self,subgp)

    def sum_lattice(self, lat):
         """
         Takes a lattice and outputs the sum of the two lattices.

         INPUT :

         - ``lat`` -- Lattice we wish to sum with the current lattice.

         EXAMPLES::

             sage: Lat = GLattice([2], 1)
             sage: Lat._action_matrices
             [[1]]
             sage: G = Lat.group()
             sage: Lat2 = GLattice(1).induced_lattice(G)
             sage: Lat2._action_matrices
             [
             [0|1]
             [-+-]
             [1|0]
             ]
             sage: L = Lat.sum_lattice(Lat2); L; L._action_matrices
             Ambient lattice of rank 3 with an action by a group of order 2
             [
             [1|0 0]
             [-+---]
             [0|0 1]
             [0|1 0]
             ]

         """
         g = self.group()
         act = [block_diagonal_matrix([A, B])
                for (A, B) in zip(self._action_matrices, lat._action_matrices)]
         return Lattice_ambient(g, act)

    def parent_lattice(self):
        """
        Gives the parent ambient lattice, itself for an ambient lattice, and the ambient lattice for a sublattice.


        EXAMPLES::

            sage: L = GLattice([2, 3])
            sage: L.parent_lattice() is L
            True
            sage: ZL = L.zero_sum_sublattice()
            sage: ZL.parent_lattice()
            Ambient lattice of rank 5 with an action by a group of order 6
            sage: ZL.parent_lattice() is L
            True 

        """
        return self.parent_lattice()

    def rational_characters(self):
        """
        Computes the rational charactesr over the base field, in other words the sublattice of elements fixed by the group.

        EXAMPLES::

            sage: G = PermutationGroup([(1,2),(3,4),(5,6),(7,8)])
            sage: L = GLattice(1)
            sage: IL = L.induced_lattice(G)
            sage: ROS = L.norm_one_restriction_of_scalars(G)

        ::

            sage: IL.rational_characters()
            Sublattice of degree 16 and rank 1 with an action by a group of order 16 and echelon basis matrix
            [1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1]
            sage: ROS.rational_characters()
            Free module of degree 15 and rank 0 over Integer Ring
            Echelon basis matrix:
            []
            sage: L.rational_characters()
            Sublattice of degree 1 and rank 1 with an action by a group of order 1 and echelon basis matrix
            [1]
        """
        kers = [kernel((m - matrix.identity(self._rank)).transpose()) for m in self._action_matrices]
        res = self
        for i in kers:
            res = res.intersection(i)
        if res.rank() == 0:
            return res
        else:
            return SubLattice(self, res.basis())


    def group_extend(self, hom):
        """
        Given a group homomorphism with target in the associated group of the lattice, we create a lattice with the pullback action.

        INPUTS:

        -- ``hom`` -- GAP group homomorphism


        EXAMPLES::

            sage: G=PermutationGroup([(1,2,3,4),(1,2)])
            sage: Gg=libgap(G)
            sage: Hom=gap.GroupHomomorphismByImages(Gg,Gg,G.gens(),G.gens())
            sage: L=GLattice(G,3)
            sage: L.group_extend(Hom)
            Ambient lattice of rank 3 with an action by a group of order 24
            sage: _._action_matrices
            [
            [1 0 0]  [1 0 0]
            [0 1 0]  [0 1 0]
            [0 0 1], [0 0 1]
            ]

        ::

            sage: G = gap.SymmetricGroup(3)
            sage: H = gap.SymmetricGroup(2)
            sage: Ggen = gap.GeneratorsOfGroup(G)
            sage: [a] = gap.GeneratorsOfGroup(H)
            sage: hom = gap.GroupHomomorphismByImages(G, H, Ggen, [a*a, a])
            sage: L = GLattice(SymmetricGroup(2)); L._action_matrices
            [
            [0 1]
            [1 0]
            ]
            sage: EL=L.group_extend(hom); EL._action_matrices
            [
            [0 1]  [1 0]
            [1 0], [0 1]
            ]

        """
        mor = self._action_morphism
        Ggap = hom.Source()
        G = PermutationGroup(Ggap.GeneratorsOfGroup())
        I = [gap.Image(hom,i) for i in G.gens()]
        a = [matrix((mor.Image(i)).sage()) for i in I]
        return Lattice_ambient(G,a)



    def isomorphic_ambient_lattice(self):
        """
        Returns an isomorphic ambient lattice.

        .. NOTE::

            For ambient lattices it just returns the lattice itself, this method is motsly useful for sublattices.


        EXAMPLES::

            sage: G = PermutationGroup([(1, 2), (3, 4, 5)])
            sage: act1 = matrix(3, [0, 1, 0, 0, 0, 1, 1, 0, 0])
            sage: act2 = matrix.identity(3)
            sage: L1 = GLattice(G, [act1,act2])

        ::

            sage: x, y, z = L1.basis()
            sage: SL = L1.sublattice([x-y, y-z])
            sage: L1.isomorphic_ambient_lattice() is L1
            True
            sage: X = SL.isomorphic_ambient_lattice(); X
            Ambient lattice of rank 2 with an action by a group of order 6
            sage: X._action_matrices
            [
            [ 0  1]  [1 0]
            [-1 -1], [0 1]
            ]

        ::

            sage: L = GLattice(SymmetricGroup(2))
            sage: x, y = L.basis()
            sage: SL = L.sublattice([x+y])
            sage: X = SL.isomorphic_ambient_lattice(); X
            Ambient lattice of rank 1 with an action by a group of order 2
            sage: X.basis()
            [
            (1)
            ]
            sage: X._action_matrices
            [[1]]
        """
        return self.isomorphic_ambient_lattice()

    def GAPMatrixGroup(self):
        """
        The image of the action of the group inside
        ``GL(rank,ZZ)`` as a GAP group::

        EXAMPLES::
            sage: G = PermutationGroup([(1, 2), (3, 4, 5)])
            sage: act1 = matrix(3, [0, 1, 0, 0, 0, 1, 1, 0, 0])
            sage: act2 = matrix.identity(3)
            sage: L1 = GLattice(G, [act1,act2])
            sage: L1.GAPMatrixGroup()
            Group([ [ [ 0, 1, 0 ], [ 0, 0, 1 ], [ 1, 0, 0 ] ],
              [ [ 1, 0, 0 ], [ 0, 1, 0 ], [ 0, 0, 1 ] ] ])

        ::

            sage: L2 = GLattice(PermutationGroup([(2,3), (1,6,3), (7,6,4,5)]), 1)
            sage: L2.GAPMatrixGroup()
            Group([ [ [ 1 ] ], [ [ 1 ] ], [ [ 1 ] ] ])

        ::

            sage: m1 = matrix(3, [0, 0, 1, -1, -1, -1, 1, 0, 0])
            sage: m2 = matrix(3, [-1, 0, 0, 0, -1, 0, 0, 0, -1])
            sage: m3 = matrix(3, [0, 1, 0, 1, 0, 0, -1, -1, -1])
            sage: L3 = GLattice([m1, m2, m3])
            sage: L3.GAPMatrixGroup()
            Group([ [ [ -1, 0, 0 ], [ 0, -1, 0 ], [ 0, 0, -1 ] ], 
              [ [ 0, 0, 1 ], [ -1, -1, -1 ], [ 1, 0, 0 ] ], 
              [ [ 0, 1, 0 ], [ 1, 0, 0 ], [ -1, -1, -1 ] ] ])

        """
        f = self._GAPMap
        return gap.Image(f._morphism)


    def colattice(self):
        """
        Outputs the lattice with action of the same group, but its action is
        composed with the inverse transpose automorphism of ``GL(n,ZZ)``

        EXAMPLES::

            sage: L = GLattice(CyclicPermutationGroup(6), [matrix([[0,1], [-1,-1]])])
            sage: L._action_matrices
            [
            [ 0  1]
            [-1 -1]
            ]
            sage: L.colattice()._action_matrices
            [
            [-1  1]
            [-1  0]
            ]
        """
        newacts = [ i.inverse().transpose() for i in self._action_matrices]
        return Lattice_ambient(self._group,newacts)

    def Tate_Cohomology(self,n):
        """
        Returns the isomorphism type of the `n`-th Tate cohomology group. This is a slight adaptation of the code from Hoshi and Yamasaki done on GAP

        INPUT:

        - ``n`` -- the index of the cohomology group to compute.


        EXAMPLES::

            sage: G = PermutationGroup([(1, 2), (3, 4, 5)])
            sage: act1 = matrix(3, [0, 1, 0, 0, 0, 1, 1, 0, 0])
            sage: act2 = matrix.identity(3)
            sage: L1 = GLattice(G, [act1, act2])
            sage: for i in range(-5, 6):
            ....:     print("H^"+str(i)+": "+str(L1.Tate_Cohomology(i)))
            H^-5:  []
            H^-4:  [2]
            H^-3:  []
            H^-2:  [2]
            H^-1:  []
            H^0:  [2]
            H^1:  []
            H^2:  [2]
            H^3:  []
            H^4:  [2]
            H^5:  []

        ::

            sage: L2 = GLattice(SymmetricGroup(3), 4)
            sage: for i in range(-5, 6):
            ....:     print("H^"+str(i)+": "+str(L2.Tate_Cohomology(i)))
            H^-5:  []
            H^-4:  [6, 6, 6, 6]
            H^-3:  []
            H^-2:  [2, 2, 2, 2]
            H^-1:  []
            H^0:  [6, 6, 6, 6]
            H^1:  []
            H^2:  [2, 2, 2, 2]
            H^3:  []
            H^4:  [6, 6, 6, 6]
            H^5:  []

        ::

            sage: m1 = matrix(3, [0, 0, 1, -1, -1, -1, 1, 0, 0])
            sage: m2 = matrix(3, [-1, 0, 0, 0, -1, 0, 0, 0, -1])
            sage: m3 = matrix(3, [0, 1, 0, 1, 0, 0, -1, -1, -1])
            sage: L3 = GLattice([m1, m2, m3])
            sage: for i in range(-5, 6):
            ....:     print("H^"+str(i)+": "+str(L3.Tate_Cohomology(i)))
            H^-5:  [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]
            H^-4:  [2, 2, 2, 2, 2, 2, 2, 2]
            H^-3:  [2, 2, 2, 2, 2, 2]
            H^-2:  [2, 2, 2]
            H^-1:  [2]
            H^0:  []
            H^1:  [2]
            H^2:  [2]
            H^3:  [2, 2, 2]
            H^4:  [2, 2, 2, 2]
            H^5:  [2, 2, 2, 2, 2, 2, 2]
        """
        return self.Tate_Cohomology(n)

    def first_coboundary_space(self):
        """
        Returns the space of 1-coboundaries of the group with coefficient in the lattice. 
        The coboundaries are vectors of size  ``rn`` where ``r`` is the rank of the lattice and ``n`` is the dimension of the group.
        Its is the concatenation of images of each group element.


        EXAMPLES::

            sage: G = PermutationGroup([(1,2,3),(4,5)])
            sage: GM = GLattice(1)
            sage: L = GM.norm_one_restriction_of_scalars(G)
            sage: CB = L.first_coboundary_space(); CB
            Free module of degree 30 and rank 5 over Integer Ring
            Echelon basis matrix:
            [ 0  0  0  0  0  1  1  0  2  2  0  1  1  2  2  0 -1  0  1  0  0 -1 -1  1  1 -1  0  0  0  1]
            [ 0  0  0  0  0  0  2  0  2  2  0  2  1  1  2  0  0 -1  1  0  1  1  0  2  2 -1  1  0  0  0]
            [ 0  0  0  0  0  0  0  1 -1  0  0  0  1  0 -1  1  1  2  1  1 -1  0  1  0  0  0 -1  1  0  0]
            [ 0  0  0  0  0  0  0  0  0  0  1  1  2  2  0  1  1  2  2  0 -1 -1  1  1  0 -1 -1  1  1  0]
            [ 0  0  0  0  0  0  0  0  0  0  0  0  3  3  0  0  0  3  3  0 -3 -3  0  0  0 -3 -3  0  0  0]
            sage: CC = L.first_cocycle_space();
            sage: CC.quotient(CB)
            Finitely generated module V/W over Integer Ring with invariants (6)

        Here computing the coboundaries lets us compute the first cohomology group. The last line tells us this cohomology group is ``ZZ/6ZZ``.
        """

        lat = self.isomorphic_ambient_lattice()
        r = lat.rank()
        group = lat.group()
        grouplist = [g for g in group]
        actionmat = [matrix((gap.Image(lat._action_morphism,g)).sage()) for g in grouplist]
        B = lat.basis()
        Module = FreeModule_ambient_pid(ZZ,r*group.order())
        coboundary_basis = []
        if not grouplist[0] == group.identity():
            grouplist = [group.identity()] + grouplist.remove(group.identity())
        for b in B: 
            l = []
            for i in actionmat:
                l += i*b-b
            coboundary_basis.append(l)
        return FreeModule_submodule_pid(Module,coboundary_basis)
    



    def first_cocycle_space(self):
        """
        Computes the 1-cocycle space of the group with coefficient in the lattice.
        They are represented as a concatenation of vectors of images of every group elements.


        EXAMPLES::

            sage: G = PermutationGroup([(1, 2, 3), (4, 5)])
            sage: GM = GLattice(1)
            sage: L = GM.norm_one_restriction_of_scalars(G)
            sage: CB = L.first_coboundary_space()
            sage: CC = L.first_cocycle_space(); CC
            Free module of degree 30 and rank 5 over Integer Ring
            Echelon basis matrix:
            [ 0  0  0  0  0  1  0  0  1  1  0  0  0  1  1  0 -1  0  0  0  0 -1 -1  0  0  0  0  0  0  1]
            [ 0  0  0  0  0  0  1  0  1  1  0  1  0  0  1  0  0 -1  0  0  1  1  0  1  1  0  1  0  0  0]
            [ 0  0  0  0  0  0  0  1 -1  0  0  0  0 -1 -1  1  1  1  0  1  0  1  1  0  0  1  0  1  0  0]
            [ 0  0  0  0  0  0  0  0  0  0  1  1  0  0  0  1  1  0  0  0  1  1  1  1  0  1  1  1  1  0]
            [ 0  0  0  0  0  0  0  0  0  0  0  0  1  1  0  0  0  1  1  0 -1 -1  0  0  0 -1 -1  0  0  0]
            sage: CC.quotient(CB)
            Finitely generated module V/W over Integer Ring with invariants (6)
        
        ::

            sage: L2 = GLattice([2, 2]).zero_sum_sublattice()
            sage: CC2 = L2.first_cocycle_space(); CC2
            Free module of degree 12 and rank 2 over Integer Ring
            Echelon basis matrix:
            [ 0  0  0  0  0  1  0  0  0  0  0  1]
            [ 0  0  0  0  0  0  1 -1  0  1 -1  0]
            sage: CB2 = L2.first_coboundary_space()
            sage: CC2.quotient(CB2)
            Finitely generated module V/W over Integer Ring with invariants (2)
        
        In the second example, the first cohomology is isomorphic to ``ZZ/2 ZZ``. Note that it computes the
        cocycles and coboundary spaces of an isomorphic ambient lattice, not the lattice itself.

        ::

            sage: L3 = GLattice([3], 3)
            sage: L3.first_coboundary_space() == L3.first_cocycle_space()
            True

        """
        lat = self.isomorphic_ambient_lattice()
        r = lat.rank()
        group = lat.group()
        o = group.order()
        rank = r*o
        grouplist = [g for g in group]
        actionmat = [matrix((gap.Image(lat._action_morphism,g)).sage()) for g in grouplist]
        B = lat.basis()
        Module = FreeModule_ambient_pid(ZZ,rank)
        Basis = Module.basis()
        if not grouplist[0] == group.identity():
            move_first(grouplist,group.identity())

        cocycle_space = FreeModule_submodule_pid(Module, [Basis[i] for i in range(r,rank)])

        #Now we apply the cocycle condition for every element of G
        conditions = []
        for g in group.gens():
            ind = grouplist.index(g)
            matbuild = []
            for i in range(o):
                mat = [matrix.zero(r)]*o
                k = grouplist.index(g.inverse()*grouplist[i])
                mat[k] += actionmat[ind]
                mat[ind] += matrix.identity(r)
                matbuild.append(mat)
            conditions.append(block_matrix(matbuild)-1)
        for c in conditions:
            cocycle_space = cocycle_space.intersection(kernel(c.transpose()))
        return cocycle_space

    def first_cohomology_group(self):
        """
        Compute the first cohomology group of a group with coefficient in the lattice. 
        The result is returned as a list composed of two elements : 
        + List of integers corresponding to the isomorphism type as finite abelian group.
        + Generating cocycles of the cohomology group as concatenated vectors of images of each group element.


        EXAMPLES::

            sage: L = GLattice([2, 2]).zero_sum_sublattice()
            sage: L.first_cohomology_group()
            [[2], [(0, 0, 0, 0, 0, 0, 1, -1, 0, 1, -1, 0)]]

        ::

            sage: m1 = matrix(3, [0, 0, 1, -1, -1, -1, 1, 0, 0])
            sage: m2 = matrix(3, [-1 ,0 ,0 ,0, -1, 0, 0, 0, -1])
            sage: m3 = matrix(3, [0, 1, 0, 1, 0, 0, -1, -1, -1])
            sage: L3 = GLattice([m1, m2, m3])
            sage: L3.first_cohomology_group()
            [[2],
             [(0, 0, 0, 1, -1, -1, 1, -1, -1, 0, 0, 0, 1, -1, -1, 0, 0, 0, 0, 0, 0, 1, -1, -1)]]
            sage: L3.first_cohomology_group()[0] == L3.Tate_Cohomology(1)
            True
        """


        lat = self
        Coc = lat.first_cocycle_space()
        Cob = lat.first_coboundary_space()
        M = matrix(ZZ, [Coc.coordinate_vector(i) for i in Cob.basis()])


        [a,b,c] = M.smith_form()

        P = c.inverse().transpose()
        list_torsion = []
        list_generators = []
        for i in range(a.nrows()):
            if a[i,i] > 1:
                list_torsion.append(a[i,i])
                list_generators.append(sum(P[j,i]*Coc.basis()[j] for j in range(P.ncols())))

        return [list_torsion,list_generators]



    def Tate_Shafarevich_lattice(self,subgp_list):
        """
        Takes a lattice and list of subgroups, computed the kernel of the first cohomology group
        under the restriction map to all the subgroups. The output is a couple consisting of the size of
        the kernel, and the list of cocycles in the kernel. Cocycles are represented as concatenated vectors of images of group elements.


        INPUT:

        - ``subgp_list`` -- list of subgroup we want to compute the kernel of corresponding restriction map of.


        EXAMPLES::

            sage: GM = GLattice(1)
            sage: G = PermutationGroup([(1, 2), (3, 4)])
            sage: L = GM.norm_one_restriction_of_scalars(G)
            sage: SUBGG = G.subgroups()
            sage: CSUB = [g for g in SUBGG if g.is_cyclic()]
            sage: L.Tate_Shafarevich_lattice(CSUB)
            [1, [(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)]]
            sage: L.Tate_Shafarevich_lattice([SUBGG[0]])
            [4,
             [(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0),
              (0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0),
              (0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0),
              (0, 0, 0, 0, 1, 1, 1, 2, 1, 1, 1, 0)]]
            sage: L.Tate_Shafarevich_lattice([SUBGG[0],SUBGG[1]])
            [2,
             [(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0), (0, 0, 0, 0, 1, 1, 1, 2, 1, 1, 1, 0)]]


        """
        lat = self
        [isom,gens] = lat.first_cohomology_group()
        product = list(cartesian_product_iterator([range(i) for i in isom]))
        tate_sha = [sum(k[i]*gens[i] for i in range(len(gens))) for k in product]
        # We enter the full cohomology group in the Tate cohomology group, we will erase them
        # if they do not vanish on some subgroup.
        #for i in range(len(isom)):
        #    tate_sha += [k*gens[i] for k in range(1,isom[i])]

        grouplist = [g for g in lat.group()]
        for subgp in subgp_list:
            subgp_index = []
            for h in subgp:
                for i in range(len(grouplist)):
                    if grouplist[i] == h:
                        subgp_index.append(i)


            g_cocycles_basis = [matrix(len(grouplist),b) for b in tate_sha]

            images_as_h_cocyles = [m[subgp_index] for m in g_cocycles_basis]
            listified_images = [[i for j in m for i in j] for m in images_as_h_cocyles]

            cobounds_h = (lat.subgroup_lattice(subgp)).first_coboundary_space()
            DummyLat = GLattice(subgp,lat.rank()*subgp.order())
            dummybasis = DummyLat.basis()
            notcobounds = []
            for e in range(len(tate_sha)):
                elt = sum(listified_images[e][i]*dummybasis[i] for i in range(len(listified_images[e])))
                if (not elt in cobounds_h):
                    notcobounds.append(e)
            tate_sha = [tate_sha[i] for i in range(len(tate_sha)) if i not in notcobounds]
        return [len(tate_sha),tate_sha]

    def induced_lattice(self, group, build=True):
        """
        The ambient lattice obtained by inducing the representation of
        the group to a bigger group.

        INPUT:

        - ``group`` -- a group containing the group for this lattice.

        - ``build`` -- boolean (default True).  If False, just returns the matrices
           that define the action on the induced lattice but doesn't build the lattice.

        .. NOTE::

            This is not yet implemented when a lattice is declared with a matrix group since
            Sage doesn't handle cosets for matrix groups.

        EXAMPLES::

            sage: G = PermutationGroup([(1, 2), (3, 4, 5)])
            sage: act1 = matrix(3, [0, 1, 0, 0, 0, 1, 1, 0, 0])
            sage: act2 = matrix(3, [1, 0, 0, 0, 1, 0, 0, 0, 1])
            sage: L1 = GLattice(G, [act1, act2])
            sage: L1.induced_lattice(SymmetricGroup(5))
            Ambient lattice of rank 60 with an action by a group of order 120

            sage: L2 = GLattice(SymmetricGroup(3), 4)
            sage: L2.induced_lattice(SymmetricGroup(4), False)
            [
            [0 0 0 0|0 0 0 0|0 0 0 0|1 0 0 0]  [1 0 0 0|0 0 0 0|0 0 0 0|0 0 0 0]
            [0 0 0 0|0 0 0 0|0 0 0 0|0 1 0 0]  [0 1 0 0|0 0 0 0|0 0 0 0|0 0 0 0]
            [0 0 0 0|0 0 0 0|0 0 0 0|0 0 1 0]  [0 0 1 0|0 0 0 0|0 0 0 0|0 0 0 0]
            [0 0 0 0|0 0 0 0|0 0 0 0|0 0 0 1]  [0 0 0 1|0 0 0 0|0 0 0 0|0 0 0 0]
            [-------+-------+-------+-------]  [-------+-------+-------+-------]
            [1 0 0 0|0 0 0 0|0 0 0 0|0 0 0 0]  [0 0 0 0|1 0 0 0|0 0 0 0|0 0 0 0]
            [0 1 0 0|0 0 0 0|0 0 0 0|0 0 0 0]  [0 0 0 0|0 1 0 0|0 0 0 0|0 0 0 0]
            [0 0 1 0|0 0 0 0|0 0 0 0|0 0 0 0]  [0 0 0 0|0 0 1 0|0 0 0 0|0 0 0 0]
            [0 0 0 1|0 0 0 0|0 0 0 0|0 0 0 0]  [0 0 0 0|0 0 0 1|0 0 0 0|0 0 0 0]
            [-------+-------+-------+-------]  [-------+-------+-------+-------]
            [0 0 0 0|1 0 0 0|0 0 0 0|0 0 0 0]  [0 0 0 0|0 0 0 0|0 0 0 0|1 0 0 0]
            [0 0 0 0|0 1 0 0|0 0 0 0|0 0 0 0]  [0 0 0 0|0 0 0 0|0 0 0 0|0 1 0 0]
            [0 0 0 0|0 0 1 0|0 0 0 0|0 0 0 0]  [0 0 0 0|0 0 0 0|0 0 0 0|0 0 1 0]
            [0 0 0 0|0 0 0 1|0 0 0 0|0 0 0 0]  [0 0 0 0|0 0 0 0|0 0 0 0|0 0 0 1]
            [-------+-------+-------+-------]  [-------+-------+-------+-------]
            [0 0 0 0|0 0 0 0|1 0 0 0|0 0 0 0]  [0 0 0 0|0 0 0 0|1 0 0 0|0 0 0 0]
            [0 0 0 0|0 0 0 0|0 1 0 0|0 0 0 0]  [0 0 0 0|0 0 0 0|0 1 0 0|0 0 0 0]
            [0 0 0 0|0 0 0 0|0 0 1 0|0 0 0 0]  [0 0 0 0|0 0 0 0|0 0 1 0|0 0 0 0]
            [0 0 0 0|0 0 0 0|0 0 0 1|0 0 0 0], [0 0 0 0|0 0 0 0|0 0 0 1|0 0 0 0]
            ]
        """
        return self.induced_lattice(group, build)

    def zero_sum_sublattice(self, ambient=False):
        r"""
        Returns the sublattice of elements with coordinates summing up to zero.

        INPUT:

        - ``ambient`` -- Boolean, if ambient is True the algorithm will give
        an ambient lattice isomorphic to the zero sum sublattice. If False or
        left blank, it will give the sublattice of zero sum vectors.
        (default option is True)


        .. NOTE::

            The zero sum sublattice is not necessarily stable under the group
            action, as the last example will illustrate.

        EXAMPLES::

            sage: G = PermutationGroup([(1, 2), (3, 4, 5)])
            sage: act1 = matrix(3, [0, 1, 0, 0, 0, 1, 1, 0, 0])
            sage: act2 = matrix(3, [1, 0, 0, 0, 1, 0, 0, 0, 1])
            sage: L1 = GLattice(G, [act1, act2])
            sage: L2 = GLattice(SymmetricGroup(3), 4)

        ::

            sage: L1.zero_sum_sublattice()
            Sublattice of degree 3 and rank 2 with an action by a group of order 6 and echelon basis matrix
            [ 1  0 -1]
            [ 0  1 -1]
            sage: L2.zero_sum_sublattice()
            Sublattice of degree 4 and rank 3 with an action by a group of order 6 and echelon basis matrix
            [ 1  0  0 -1]
            [ 0  1  0 -1]
            [ 0  0  1 -1]

        We can make them directly ambient lattices::

            sage: L1.zero_sum_sublattice(True)
            Ambient lattice of rank 2 with an action by a group of order 6
            sage: _._action_matrices
            [
            [ 0  1]  [1 0]
            [-1 -1], [0 1]
            ]
            sage: L2.zero_sum_sublattice(True)
            Ambient lattice of rank 3 with an action by a group of order 6
            sage: _._action_matrices
            [
            [1 0 0]  [1 0 0]
            [0 1 0]  [0 1 0]
            [0 0 1], [0 0 1]
            ]

        Now we decide not to transform it into an ambient lattice, but to create the sublattice of
        zero sum vectors.::

            sage: L = GLattice(SymmetricGroup(3), 5)
            sage: L.zero_sum_sublattice()
            Sublattice of degree 5 and rank 4 with an action by a group of order 6 and echelon basis matrix
            [ 1  0  0  0 -1]
            [ 0  1  0  0 -1]
            [ 0  0  1  0 -1]
            [ 0  0  0  1 -1]
            sage: L.zero_sum_sublattice().zero_sum_sublattice()
            Sublattice of degree 5 and rank 4 with an action by a group of order 6 and echelon basis matrix
            [ 1  0  0  0 -1]
            [ 0  1  0  0 -1]
            [ 0  0  1  0 -1]
            [ 0  0  0  1 -1]
            sage: L.zero_sum_sublattice(True).zero_sum_sublattice(True)
            Ambient lattice of rank 3 with an action by a group of order 6


        Here we see that the zero sum sublattice of the zero sum sublattice is itself,
        which is not the case when we return an ambient ambient lattice.::

            sage: L = GLattice(SymmetricGroup(3), 5)
            sage: SL = L.sublattice([L.basis()[2]+3*L.basis()[4], 5*L.basis()[0]+L.basis()[1], L.basis()[1]+6*L.basis()[3]]); SL
            Sublattice of degree 5 and rank 3 with an action by a group of order 6 and echelon basis matrix
            [ 5  0  0 -6  0]
            [ 0  1  0  6  0]
            [ 0  0  1  0  3]
            sage: SL.zero_sum_sublattice()
            Sublattice of degree 5 and rank 2 with an action by a group of order 6 and echelon basis matrix
            [  5   3  -5  12 -15]
            [  0   4  -7  24 -21]

        Here is an example of lattice whose zero sum submodule over ``\ZZ``
        is not stable under the group action::

            sage: G = SymmetricGroup(2)
            sage: m = matrix(2, [-1,0,0,1])
            sage: L = GLattice(G, [m])
            sage: L.zero_sum_sublattice()
            Traceback (most recent call last):
            ValueError: The basis is not stable under the action of the group
        """
        return self.zero_sum_sublattice(ambient)

    def norm_one_restriction_of_scalars(self, group):
        """
        Combines the induction and zero sum methods to return the character
        lattice corresponding to a norm 1 restriction of scalars of a Torus.

        INPUT:

        - ``group`` -- the group used for the induction, when restricting scalars.


        .. NOTE::

            Note that this method involves taking a zero sum submodule, which needs not be
            stable under the action of the group.

        EXAMPLES::

            sage: G = PermutationGroup([(1, 2), (3, 4, 5)])
            sage: act1 = matrix(3, [0, 1, 0, 0, 0, 1, 1, 0, 0])
            sage: act2 = matrix(3, [1, 0, 0, 0, 1, 0, 0, 0, 1])
            sage: L1 = GLattice(G, [act1, act2])
            sage: L1.norm_one_restriction_of_scalars(SymmetricGroup(5))
            Ambient lattice of rank 59 with an action by a group of order 120

        ::

            sage: L2 = GLattice(SymmetricGroup(3), 4)
            sage: L2.norm_one_restriction_of_scalars(SymmetricGroup(4))
            Ambient lattice of rank 15 with an action by a group of order 24
        """
        return self.norm_one_restriction_of_scalars(self,group)

    def quotient_ambient_sublattice(self, sublattice, check=True):
        """
        Computes the quotient of an ambient lattice by a saturated proper sublattice.

        INPUT:

        - ``sublattice`` -- sublattice by which we want to quotient

        - ``check`` -- boolean, true if one wants to check that the
            sublattice is saturated and proper

        EXAMPLES::

            sage: G = SymmetricGroup(3)
            sage: L = GLattice(2)
            sage: LL = GLattice(G, 5)
            sage: IL = L.induced_lattice(G)
            sage: ZL = IL.zero_sum_sublattice()
            sage: SL = LL.sublattice([LL.basis()[0], LL.basis()[1]+ LL.basis()[2], LL.basis()[4]])

            ::

            sage: QL1 = LL.quotient_ambient_sublattice(SL); QL1
            Ambient lattice of rank 2 with an action by a group of order 6
            sage: QL1._action_matrices
            [
            [1 0]  [1 0]
            [0 1], [0 1]
            ]

            ::

            sage: QL2 = IL.quotient_ambient_sublattice(ZL); QL2
            Ambient lattice of rank 1 with an action by a group of order 6
            sage: QL2._action_matrices
            [[1], [1]]


        """

        M = matrix(sublattice.basis())

        SM = M.smith_form()
        #M is a matrix taking vectors in the basis of the sublattice and giving their vector in the ambient lattice.

        if check and ((not SM[0][sublattice.rank()-1,sublattice.rank()-1] == 1) or sublattice.rank() == self.rank()):
            raise ValueError("The sublattice is not saturated or not proper")


        P = SM[2].transpose()

        # P is a matrix such that there is a matrix with PMQ diagonal with 1's on the diagonal

        Pi = P.inverse()
        # if r is the rank of the sublattice,
        # The columns of Pi are vectors of  a basis of the ambient lattice where the first r are a basis of the sublattice, and the rest
        # are a basis of the complement (it is the complement as a Z-module, but need not be stable under the action of the group)

        index = range(sublattice.rank(),self.rank())
        v = Pi[range(self.rank()),index]

        A = [(P*i*v)[list(index)] for i in self._action_matrices]
        # This computes the action on the vectors of the complement of the sublattice
        return Lattice_ambient(self.group(),A)

    def dim_shift(self, build=False):
        """
        Returns a lattice whose ``i``th Tate cohomology group is the ``i+1``th Tate cohomology group of the original lattice.
        
        INPUT:

        - ``build`` -- Boolean, if false, returns a pair of lattices whose quotient is the dimension-shifted lattice. If True, returns the dimension-shifted lattice itself

        EXAMPLES::


            sage: L = GLattice(1)
            sage: G = SymmetricGroup(2)
            sage: GM = GLattice(1)
            sage: G = PermutationGroup([(1, 2), (3, 4)])
            sage: IL = GM.induced_lattice(G)
            sage: m = IL._action_matrices[0]
            sage: B = m.eigenspaces_right()[0][1].basis()
            sage: SL1 = IL.sublattice(B)
            sage: SL2 = SL1.zero_sum_sublattice()
            sage: QL = IL.quotient_lattice(SL2); QL
            Ambient lattice of rank 3 with an action by a group of order 4
            sage: QL.Tate_Cohomology(1)
            []
            sage: QL.Tate_Cohomology(2)
            [2]
            sage: DQL = QL.dim_shift(True)
            sage: DQL.Tate_Cohomology(1)
            [2]
            


        """
        lat = self.isomorphic_ambient_lattice()
        GG = lat.group()
        H = PermutationGroup([()])
        G = [c[0] for c in GG.cosets(H,'left')]
        TL = lat.subgroup_lattice(H).induced_lattice(GG)
        Newbasis = []
        Basiselt = 0
        r = lat.rank()
        Indbasis = TL.basis()
        for b in lat.basis():
            for i in range(len(G)):
                elt = lat._act(G[i].inverse(),b)
                Basiselt += sum(elt[j]*Indbasis[j+i*r] for j in range(len(elt)))
            Newbasis.append(Basiselt)
            Basiselt = 0
        ImageL = SubLattice(TL,Newbasis)
        if build:
            return TL.quotient_lattice(ImageL)
        else:
            return [TL,ImageL]

    def sublattice(self,basis, check=True):
        """
        Constructs the sublattice spanned by a list of vectors.

        INPUT:

        - ``basis`` -- Desired basis for the sublattice
        - ``check`` -- Boolean, false if we do not want to check 
        that the lattice is stable under the action of the group.
        
        -EXAMPLE:

            sage: L = GLattice(SymmetricGroup(3))
            sage: SL = L.sublattice([sum(i for i in L.basis())]); SL
            Sublattice of degree 3 and rank 1 with an action by a group of order 6 and echelon basis matrix
            [1 1 1]

        """

        return SubLattice(self, basis, check)



    def quotient_lattice(self, sublattice, check=True):
        """
        Returns an ambient lattice isomorphic to the quotient of two lattices.
        Slightly slower than quotient_ambient_lattice for ambient lattices

        INPUT:

        - ``sublattice`` -- sublattice by which we want to quotient

        - ``check`` -- boolean, true if one wants to check that the
            sublattice is saturated and proper

        EXAMPLES::

            sage: m = matrix([[0,0,0,0,0,1],[0,0,0,0,1,0],[0,0,0,1,0,0],[0,0,1,0,0,0],[0,1,0,0,0,0],[1,0,0,0,0,0]])
            sage: L = GLattice([2],[m]); L._action_matrices
            [
            [0 0 0 0 0 1]
            [0 0 0 0 1 0]
            [0 0 0 1 0 0]
            [0 0 1 0 0 0]
            [0 1 0 0 0 0]
            [1 0 0 0 0 0]
            ]
            sage: B = L.basis()
            sage: SL = L.sublattice([B[1], B[2], B[3], B[4]])
            sage: SSL = SL.sublattice([B[2], B[3]])
            sage: SSSL1 = SSL.sublattice([B[2]+B[3]])
            sage: SSSL2 = SSL.sublattice([B[2]-B[3]])

        ::

            sage: Q1 = L.quotient_lattice(SL); Q1; Q1._action_matrices
            Ambient lattice of rank 2 with an action by a group of order 2
            [
            [0 1]
            [1 0]
            ]
            sage: Q2 = L.quotient_lattice(SSSL1); Q2; Q2._action_matrices
            Ambient lattice of rank 5 with an action by a group of order 2
            [
            [ 0  0  0 -1  0]
            [ 0  0  0  0  1]
            [ 0  0 -1  0  0]
            [-1  0  0  0  0]
            [ 0  1  0  0  0]
            ]
            sage: Q3 = SL.quotient_lattice(SSL); Q3; Q3._action_matrices
            Ambient lattice of rank 2 with an action by a group of order 2
            [
            [0 1]
            [1 0]
            ]
            sage: Q4 = SL.quotient_lattice(SSSL1); Q4; Q4._action_matrices
            Ambient lattice of rank 3 with an action by a group of order 2
            [
            [ 0  0 -1]
            [ 0 -1  0]
            [-1  0  0]
            ]
            sage: Q5 = SL.quotient_lattice(SSSL2); Q5; Q5._action_matrices
            Ambient lattice of rank 3 with an action by a group of order 2
            [
            [ 0  0 -1]
            [ 0  1  0]
            [-1  0  0]
            ]
            sage: Q6 = SSL.quotient_lattice(SSSL1); Q6; Q6._action_matrices
            Ambient lattice of rank 1 with an action by a group of order 2
            [[-1]]
            sage: Q7 = SSL.quotient_lattice(SSSL2); Q7; Q7._action_matrices
            Ambient lattice of rank 1 with an action by a group of order 2
            [[1]]
        """
        oldBasis = self.basis()
        act_builder = []
        for g in self._group.gens():
            mat_builder = []
            for i in oldBasis:
                mat_builder.append(self.coordinate_vector(self._act(g,i)))
            act_builder.append(matrix(mat_builder).transpose())



        M = matrix([self.coordinate_vector(i) for i in sublattice.basis()]).transpose()

        SM = M.smith_form()

        if check and ((not SM[0][M.ncols()-1,M.ncols()-1] == 1) or sublattice.rank() == self.rank()):
            raise ValueError("The sublattice is not saturated or not proper"    )

        P = SM[1]

        Pi = P.inverse()

        index = range(sublattice.rank(),self.rank())

        v = Pi[range(self.rank()),index]

        A = [(P*i*v)[list(index)] for i in act_builder]
        n = A[0].nrows()
        ide = matrix.identity(n)
        J = matrix([ide[n-1-k] for k in range(n)])
        # This computes the action on the vectors of the complement of the sublattice
        return Lattice_ambient(self.group(),[J*(a.transpose())*J for a in A])


class Lattice_ambient(FreeModule_ambient_pid,Lattice_generic):
    """
    Class for ambient lattices.
    """
    def __init__(self, galois, action, check=True):
        r"""
        Constructs an ambient lattice.

        INPUT:

        - ``galois`` -- the group acting on the lattice, either permutation
            group or finite sugroup of ``GL(n,\ZZ)`` for some n. It can be a list
            of integers for a finite abelian group of that type.

        - ``action`` -- the list of matrices by which the generators of the group
            act, or an integer for the trivial action on the ambient free
            ``\ZZ`` module of that rank.

        EXAMPLES::

            sage: act1 = matrix(3, [0, 1, 0, 0, 0, 1, 1, 0, 0])
            sage: act2 = matrix.identity(3)
            sage: G = PermutationGroup([(1, 2), (3, 4, 5)])
            sage: GLattice(G, [act1,act2])
            Ambient lattice of rank 3 with an action by a group of order 6

        ::

            sage: m1 = matrix(3, [0, 0, 1, -1, -1, -1, 1, 0, 0])
            sage: m2 = matrix(3, [-1, 0, 0, 0, -1, 0, 0, 0, -1])
            sage: m3 = matrix(3, [0, 1, 0, 1, 0, 0, -1, -1, -1])
            sage: GLattice([m1, m2, m3])
            Ambient lattice of rank 3 with an action by a group of order 8
        """
        Lattice_generic.__init__(self, galois, action, check)
        FreeModule_ambient_pid.__init__(self, ZZ, self._rank)


    def _repr_(self):
        """
        The print representation of an ambient lattice.

        EXAMPLES::

            sage: GLattice(1)
            Ambient lattice of rank 1 with an action by a group of order 1
            sage: GLattice(SymmetricGroup(3))
            Ambient lattice of rank 3 with an action by a group of order 6
        """
        return "Ambient lattice of rank %s"%(self.rank())+" with an action by a group of order %s"%(self.group().order())


    def subgroup_lattice(self, subgp):
        """
        Restrict the group acting on the lattice to a subgroup

        INPUT:

        - ``subgp`` -- the subgroup we want to restrict the lattice to

        EXAMPLES::

            sage: G = SymmetricGroup(3)
            sage: H = CyclicPermutationGroup(3)
            sage: m1 = matrix(3, [0,1,0,0,0,1,1,0,0])
            sage: m2 = matrix(3, [0,1,0,1,0,0,0,0,1])
            sage: L = GLattice(G, [m1,m2])
            sage: L1 = GLattice(G, [m1,m2])

        ::

            sage: L2 = L1.subgroup_lattice(H); L2
            Ambient lattice of rank 3 with an action by a group of order 3
            sage: L2._group
            Cyclic group of order 3 as a permutation group
            sage: L2._action_matrices
            [
            [0 1 0]
            [0 0 1]
            [1 0 0]
            ]

        Now we induce the lattice back to ``S_3`` and check we get different cohomologies::

            sage: L3 = L2.induced_lattice(G)
            sage: L3._action_matrices
            [
            [0 1 0|0 0 0]  [0 0 0|0 0 1]
            [0 0 1|0 0 0]  [0 0 0|1 0 0]
            [1 0 0|0 0 0]  [0 0 0|0 1 0]
            [-----+-----]  [-----+-----]
            [0 0 0|0 0 1]  [0 1 0|0 0 0]
            [0 0 0|1 0 0]  [0 0 1|0 0 0]
            [0 0 0|0 1 0], [1 0 0|0 0 0]
            ]
            sage: for i in range(-5, 6):
            ....:     print("H^"+str(i)+": "+str(L1.Tate_Cohomology(i)))
            H^-5:  []
            H^-4:  [2]
            H^-3:  []
            H^-2:  [2]
            H^-1:  []
            H^0:  [2]
            H^1:  []
            H^2:  [2]
            H^3:  []
            H^4:  [2]
            H^5:  []
            sage: for i in range(-5, 6):
            ....:     print("H^"+str(i)+": "+str(L3.Tate_Cohomology(i)))
            H^-5:  []
            H^-4:  []
            H^-3:  []
            H^-2:  []
            H^-1:  []
            H^0:  []
            H^1:  []
            H^2:  []
            H^3:  []
            H^4:  []
            H^5:  []
        """
        mor = self._action_morphism
        I = [gap.Image(mor,i).sage() for i in subgp.gens()]
        a = [matrix(i) for i in I]
        return Lattice_ambient(subgp,a)

    def isomorphic_ambient_lattice(self):
        """
        Gives an isomorphic ambient lattice, in this case it returns itself.

        EXAMPLES::

            sage: L = GLattice(1)
            sage: LL = L.isomorphic_ambient_lattice(); LL
            Ambient lattice of rank 1 with an action by a group of order 1
            sage: LL is L
            True
        """
        return self

    def parent_lattice(self):
        """
        Returns the parent ambient lattice, in this case itself.

        EXAMPLES::

            sage: L = GLattice([2],5)
            sage: L.parent_lattice() == L
            True

        """
        return self

    def Tate_Cohomology(self,n):
        """
        Computes the Tate cohomology of an ambient character lattice.

        INPUT:

        -``n`` -- integer corresponding to the cohomology group to compute.

        .. NOTE::

            More examples are done in Lattice_generic documentation,
            and in the AlgebraicTorus one.

        EXAMPLES::


            sage: G = CyclicPermutationGroup(58)
            sage: mat = matrix(2, [0,1,1,0])
            sage: L = GLattice(G, [mat])
            sage: for i in range(-5, 6):
            ....:     print("H^"+str(i)+": "+str(L.Tate_Cohomology(i)))
            H^-5:  []
            H^-4:  [29]
            H^-3:  []
            H^-2:  [29]
            H^-1:  []
            H^0:  [29]
            H^1:  []
            H^2:  [29]
            H^3:  []
            H^4:  [29]
            H^5:  []
        """
     
        MG = self.GAPMatrixGroup()
        G = libgap(self.group())
        if n == 0:
            M = matrix.zero(self._rank)
            Lst = [libgap(i) for i in self._group]
            for i in Lst:
                M += matrix(gap.Image(self._action_morphism,i).sage())
            #M = matrix((libgap.Sum(MG)).sage())
            S = M.smith_form(False,True)
            R = S.rank()
            RR = [S[i][i] for i in range(R)]
            return [i for i in RR if i>1]
        elif n == -1:
            m = gap([])
            for i in gap.GeneratorsOfGroup(MG):
                m = gap.Concatenation(m,i-gap.Identity(MG))
            ms = matrix(m.sage())
            s = ms.smith_form(False,True)
            r = s.rank()
            rr = gap([s[i][i] for i in range(r)])
            return [i for i in rr if i>1]
        else:
            load_hap()
            if self._rank == 1:
                gl = gap.Group([ [ [ -1 ] ] ])
            else:
                gl = gap.GL(self._rank,ZZ)
            mor = gap.GroupHomomorphismByImages(G,gl,gap(self.group().gens()),gap([m for m in self._action_matrices]))
            if n>0:
                #This computes the standard resolution of G in HAP
                R = gap.ResolutionFiniteGroup(G,n+1)
                #Then applies the map to the action to the resolution
                TR = gap.HomToIntegralModule(R,mor)
                #Might have a problem because gap does only right actions ?
                return (gap.Cohomology(TR,n)).sage()
            else:
                R = gap.ResolutionFiniteGroup(G,-n)
                TR = gap.TensorWithIntegralModule(R,mor)
                return (gap.Homology(TR,-n-1)).sage()


    def induced_lattice(self, group, build=True):
        """
        Given a bigger group than the original acting on the lattice,
        contructs the induced module on that larger group.

        INPUT:

        - ``group`` -- the bigger group to which we want to induce the lattice

        - ``build`` -- boolean, True if we want to return the induced lattice,
            otherwise the method just returns the set of matrices defining the
            induced action.

        .. NOTE::

            If a matrix group is entered, it will find an isomorphic permutation group
            to do the induction, so one has to be careful that the isomorphic group
            will contain the permutation group of the lattice. If the lattice is declared
            with matrices, or a matrix group, then inputing a bigger matrix group here
            should work.

        EXAMPLES::

            sage: G = CyclicPermutationGroup(3)
            sage: mat = matrix(3, [0,1,0,0,0,1,1,0,0])
            sage: L = GLattice(G, [mat])
            sage: L.induced_lattice(SymmetricGroup(3))
            Ambient lattice of rank 6 with an action by a group of order 6
            sage: L.induced_lattice(SymmetricGroup(3),False)
            [
            [0 1 0|0 0 0]  [0 0 0|0 0 1]
            [0 0 1|0 0 0]  [0 0 0|1 0 0]
            [1 0 0|0 0 0]  [0 0 0|0 1 0]
            [-----+-----]  [-----+-----]
            [0 0 0|0 0 1]  [0 1 0|0 0 0]
            [0 0 0|1 0 0]  [0 0 1|0 0 0]
            [0 0 0|0 1 0], [1 0 0|0 0 0]
            ]

        ::

            sage: m1 = matrix(3, [0, 0, 1, -1, -1, -1, 1, 0, 0])
            sage: m2 = matrix(3, [-1, 0, 0, 0, -1, 0, 0, 0, -1])
            sage: m3 = matrix(3, [0, 1, 0, 1, 0, 0, -1, -1, -1])
            sage: G = MatrixGroup([m1,m2,m3])
            sage: H = MatrixGroup([m1,m2])
            sage: L = GLattice(H)
            sage: L.induced_lattice(G)
            Ambient lattice of rank 6 with an action by a group of order 8
            sage: _._action_matrices
            [
            [ 0  0  0|-1  0  0]  [ 0  0  0| 0  0 -1]  [ 0  0  0| 0  0  1]
            [ 0  0  0| 0 -1  0]  [ 0  0  0| 1  1  1]  [ 0  0  0|-1 -1 -1]
            [ 0  0  0| 0  0 -1]  [ 0  0  0|-1  0  0]  [ 0  0  0| 1  0  0]
            [--------+--------]  [--------+--------]  [--------+--------]
            [-1  0  0| 0  0  0]  [ 0  0 -1| 0  0  0]  [ 0  0  1| 0  0  0]
            [ 0 -1  0| 0  0  0]  [ 1  1  1| 0  0  0]  [-1 -1 -1| 0  0  0]
            [ 0  0 -1| 0  0  0], [-1  0  0| 0  0  0], [ 1  0  0| 0  0  0]
            ]
        """
        if isinstance(group,FinitelyGeneratedMatrixGroup_gap):
            gapgroup = gap.Group([i.gap() for i in group.gens()])
            iso = gap.IsomorphismPermGroup(gapgroup)
            permg = gap.Image(iso)
            genperm = gap.GeneratorsOfGroup(permg)
            return self.induced_lattice(PermutationGroup(genperm),build)
        
        elif isinstance(group, SymmetricGroup):
            group = PermutationGroup(group.gens(), canonicalize=False)
        LCos = group.cosets(self._group,'left')
        LCosReps = [i[0] for i in LCos]
        LCosnum = len(LCos)
         #get_coset_index will take an element g of G and return the index of the coset it belongs to
        def get_coset_index(g):
            for i in range(LCosnum):
                if g in LCos[i]:
                    return i
            raise ValueError('Found an element which does not belong to any coset')

        #decomp takes an element g of the big group G, and returns a pair
        def decomp(g):
            i = get_coset_index(g)
            return [i, (LCosReps[i].inverse())*g]
        r"""
        decomp2(element,index) will do the main computation for the group action on the
        induced lattice (we deal with finite groups so induced is the same as coinduced)
        ``\ZZ[G]\otimes_{\ZZ[H]} L ``

         To do so, we look at the multiplication g*gi where gi is a representative of the
         ith left coset
        """
        def decomp2(g,i):
            return decomp(g*LCosReps[i])

        #Now we create block matrices corresponding to actions of each generator of G, it
        #is the composition of a block unimodular matrix for permutation of blocks
        #and the block diagonal matrix applying the correct element of H to each block

        def make_matrix(g):
            Lst = []
            Bigmatlist = []
            for i in range(LCosnum):
                Lst.append(decomp2(g,i))
            Matlist = [matrix.zero(self._rank) for j in range(LCosnum)]
            Matlist = [matrix((gap.Image(self._action_morphism,gap(j[1]))).sage())
                       for j in Lst]
            for i in range(LCosnum):
                Bigmatlist += [Matlist[j] if Lst[j][0] == i else matrix.zero(self._rank)
                               for j in range(LCosnum)]
            return block_matrix(LCosnum,LCosnum,Bigmatlist)

        GGen=self._generators
        gens_induced_act = [make_matrix(g) for g in group.gens()]
        if build:
            return Lattice_ambient(group, gens_induced_act)
        else:
            return gens_induced_act

    def zero_sum_sublattice(self, ambient=False):
        """
        Gives the lattice consisting of vectors with zero sum of coordinates.

        INPUT:

        - ``ambient`` -- boolean, if True it will give an ambient lattice isomorphic to
            the sublattice of vectors with zero sum of coordinates. If False or left blank
            the method returns the sublattice of zero sum vectors.

        .. NOTE::

            More examples are done in the Lattice_generic and SubLattice classes.

        EXAMPLES::

            sage: L = GLattice(DihedralGroup(4), 4)
            sage: L.zero_sum_sublattice()
            Sublattice of degree 4 and rank 3 with an action by a group of order 8 and echelon basis matrix
            [ 1  0  0 -1]
            [ 0  1  0 -1]
            [ 0  0  1 -1]

        ::

            sage: L.zero_sum_sublattice(True)
            Ambient lattice of rank 3 with an action by a group of order 8
        """
        if ambient:
            A = self
            acts = self._action_matrices
            newacts = [A[[i for i in range(A.ncols()-1)], [i for i in range(A.ncols()-1)]]-A[[i for i in range(A.ncols()-1)], [A.ncols()-1]]*matrix(1, [1 for i in range(A.ncols()-1)]) for A in acts]
            return Lattice_ambient(self._group,newacts)
        else:
            oldBasis = self.basis()
            newBasis = [ oldBasis[i]-oldBasis[len(oldBasis)-1]     for i in range(len(oldBasis)-1)  ]
            return SubLattice(self,newBasis)
        r"""
        This does the following, for each nxn matrix defining the action of the induced representation,
        it extracts two blocks
        (        |   )
        (    A   | B )     A which is of size n-1 x n-1
        (        |   ) and B which is of size n-1 x 1
        (------------)
        (    C   | D )

        Then it computes the action for the norm 1 restriction of scalars, which is
        A - B * (1,1,...,1)

        Indeed, since the norm 1 restriction lattice will be the sublattice
        of elements summing up to 1, so we only consider the first n-1 basis elements,
        doing the matrix computation, the element l = (l_1,...l_(n-1)) is sent to
        A *l + B * (-sum_i l_i), which is the transformation A-B*(1,...,1)
        """

    def norm_one_restriction_of_scalars(self, group):
        """
        Compute the lattice corresponding to norm one restriction of scalars
        of a torus.

        INPUT:

        -``group`` -- group for the induction, corresponding to the restriction
            of scalars.


        .. NOTE::

            More examples are computed in the AlgeraicTorus class and Lattice_generic.

        EXAMPLES::

            sage: L = GLattice(DihedralGroup(4), 4)
            sage: ROS = L.norm_one_restriction_of_scalars(SymmetricGroup(4));ROS
            Ambient lattice of rank 11 with an action by a group of order 24
            sage: ROS._action_matrices
            [
            [0 0 0 0 1 0 0 0 0 0 0]  [ 1  0  0  0  0  0  0 -1  0  0  0]
            [0 0 0 0 0 1 0 0 0 0 0]  [ 0  1  0  0  0  0  0 -1  0  0  0]
            [0 0 0 0 0 0 1 0 0 0 0]  [ 0  0  1  0  0  0  0 -1  0  0  0]
            [0 0 0 0 0 0 0 1 0 0 0]  [ 0  0  0  1  0  0  0 -1  0  0  0]
            [1 0 0 0 0 0 0 0 0 0 0]  [ 0  0  0  0  0  0  0 -1  1  0  0]
            [0 1 0 0 0 0 0 0 0 0 0]  [ 0  0  0  0  0  0  0 -1  0  1  0]
            [0 0 1 0 0 0 0 0 0 0 0]  [ 0  0  0  0  0  0  0 -1  0  0  1]
            [0 0 0 1 0 0 0 0 0 0 0]  [ 0  0  0  0  0  0  0 -1  0  0  0]
            [0 0 0 0 0 0 0 0 1 0 0]  [ 0  0  0  0  1  0  0 -1  0  0  0]
            [0 0 0 0 0 0 0 0 0 1 0]  [ 0  0  0  0  0  1  0 -1  0  0  0]
            [0 0 0 0 0 0 0 0 0 0 1], [ 0  0  0  0  0  0  1 -1  0  0  0]
            ]
            sage: for i in range(-5, 6):
            ....:     print("H^"+str(i)+": "+str(L.Tate_Cohomology(i)))
            H^-5:  [2, 2, 2, 2, 2, 2, 2, 2]
            H^-4:  [2, 2, 2, 2, 2, 2, 2, 2, 4, 4, 4, 4]
            H^-3:  [2, 2, 2, 2]
            H^-2:  [2, 2, 2, 2, 2, 2, 2, 2]
            H^-1:  []
            H^0:  [8, 8, 8, 8]
            H^1:  []
            H^2:  [2, 2, 2, 2, 2, 2, 2, 2]
            H^3:  [2, 2, 2, 2]
            H^4:  [2, 2, 2, 2, 2, 2, 2, 2, 4, 4, 4, 4]
            H^5:  [2, 2, 2, 2, 2, 2, 2, 2]
            sage: for i in range(-5, 6):
            ....:     print("H^"+str(i)+": "+str(ROS.Tate_Cohomology(i)))
            H^-5: [2, 2, 2, 2, 2, 2, 6]
            H^-4: [2, 2, 2, 2, 2, 2, 2, 4, 4, 4]
            H^-3: [2, 2, 2]
            H^-2: [2, 2, 2, 2, 2, 2, 2]
            H^-1: []
            H^0: [8, 8, 8]
            H^1: []
            H^2: [2, 2, 2, 2, 2, 2, 2]
            H^3: [2, 2, 6]
            H^4: [2, 2, 2, 2, 2, 2, 2, 4, 4, 4]
            H^5: [2, 2, 2, 2, 2, 2, 2]
        """

        IL = self.induced_lattice(group)
        b = sum(i for i in IL.basis())
        SL = SubLattice(IL,[b])
        return IL.quotient_ambient_sublattice(SL)


class SubLattice(Lattice_generic,FreeModule_submodule_pid):
    """
    Class for sublattices of ambient lattices (or sublattices themselves).

    INPUT:

    - ``lattice`` -- the lattice (ambient or not) in which our lattice embeds

    - ``basis`` -- a set of generators of the sublattice
    """
    def __init__(self, lattice, basis, check=True):
        """
        Initialization of sublattice.



        EXAMPLES::

            sage: L = GLattice([10]); L
            Ambient lattice of rank 10 with an action by a group of order 10
            sage: b = sum(L.basis())
            sage: L.sublattice([b])
            Sublattice of degree 10 and rank 1 with an action by a group of order 10 and echelon basis matrix
            [1 1 1 1 1 1 1 1 1 1]
        """
        Lattice_generic.__init__(self,lattice._group, lattice._action_matrices, check)
        FreeModule_submodule_pid.__init__(self, lattice.parent_lattice(), basis)

        self._parent_lattice = lattice.parent_lattice()
        if check:
            for i in lattice._group.gens():
                for j in basis:
                    if not lattice._act(i,j) in self:
                        raise ValueError("The basis is not stable under the action of the group")

    def _repr_(self):
        """
        The print representation of a  sublattice.

        EXAMPLES::

            sage: L = GLattice(3)
            sage: SL = L.sublattice([sum(i for i in L.basis())]); SL
            Sublattice of degree 3 and rank 1 with an action by a group of order 1 and echelon basis matrix
            [1 1 1]
            sage: SL2 = L.zero_sum_sublattice(); SL2
            Sublattice of degree 3 and rank 2 with an action by a group of order 1 and echelon basis matrix
            [ 1  0 -1]
            [ 0  1 -1]

        """
        return "Sublattice of degree %s"%(self.degree())+" and rank %s"%(self.rank()) +" with an action by a group of order %s"%(self.group().order())+" and echelon basis matrix\n%s"%(self.echelonized_basis_matrix()
)

    def parent_lattice(self):
        """
        Returns the ambient lattice containing the sublattice ``self``.

        EXAMPLES::

            sage: L = GLattice(DihedralGroup(4),4).zero_sum_sublattice()
            sage: L.parent_lattice()
            Ambient lattice of rank 4 with an action by a group of order 8
        """
        return self._parent_lattice


    def subgroup_lattice(self,subgp):
        """
        Restrict the group acting on the sublattice to a subgroup

        INPUT:

        - ``subgp`` -- the subgroup we want to restrict the lattice to

        EXAMPLES::

            sage: G = SymmetricGroup(3)
            sage: H = CyclicPermutationGroup(2)
            sage: m1 = matrix(3, [0,1,0,0,0,1,1,0,0])
            sage: m2 = matrix(3, [0,1,0,1,0,0,0,0,1])
            sage: L = GLattice(G, [m1,m2])
            sage: a,b,c = L.basis()
            sage: SL = L.sublattice([a+b+c])
            sage: SL2 = SL.subgroup_lattice(H); SL2
            Sublattice of degree 3 and rank 1 with an action by a group of order 2 and echelon basis matrix
            [1 1 1]
            sage: SL2._group
            Cyclic group of order 2 as a permutation group
            sage: SL2._action_matrices
            [
            [0 1 0]
            [1 0 0]
            [0 0 1]
            ]

        This time we can see that inducing this lattice back to ``G`` we
        get a lattice isomorphic to ``L``::

            sage: SL3 = SL2.induced_lattice(G)
            sage: SL3._action_matrices
            [
            [0|0|1]  [1|0|0]
            [-+-+-]  [-+-+-]
            [1|0|0]  [0|0|1]
            [-+-+-]  [-+-+-]
            [0|1|0], [0|1|0]
            ]
        """
        return SubLattice(self.parent_lattice().subgroup_lattice(subgp),self.basis())

    def isomorphic_ambient_lattice(self):
        """
        Gives an isomorphic ambient lattice.

        EXAMPLES::

            sage: L = GLattice(DihedralGroup(4), 4)
            sage: SL1 = L.zero_sum_sublattice()
            sage: L = GLattice(DihedralGroup(4), 4)
            sage: SL1 = L.zero_sum_sublattice();SL1
            Sublattice of degree 4 and rank 3 with an action by a group of order 8 and echelon basis matrix
            [ 1  0  0 -1]
            [ 0  1  0 -1]
            [ 0  0  1 -1]
            sage: SL1.isomorphic_ambient_lattice()
            Ambient lattice of rank 3 with an action by a group of order 8
        """
        oldBasis = self.basis()
        act_builder = []
        for g in self._group.gens():
            mat_builder = []
            for i in oldBasis:
                mat_builder.append(self.coordinate_vector(self._act(g,i)))
            act_builder.append(matrix(mat_builder).transpose())
        return Lattice_ambient(self._group,act_builder)

    def Tate_Cohomology(self,n):
        """
        Computes the isomorphism type of the Tate cohomology groups of the sublattice.

        INPUT:

        - ``n`` -- integer corresponding to the cohomology group we compute.

        EXAMPLES::

            sage: L = GLattice(DihedralGroup(4), 4)
            sage: SL = L.zero_sum_sublattice()
            sage: for i in range(-5, 6):
            ....:     print("H^"+str(i)+": "+str(SL.Tate_Cohomology(i)))
            H^-5:  [2, 2, 2, 2, 2, 2]
            H^-4:  [2, 2, 2, 2, 2, 2, 4, 4, 4]
            H^-3:  [2, 2, 2]
            H^-2:  [2, 2, 2, 2, 2, 2]
            H^-1:  []
            H^0:  [8, 8, 8]
            H^1:  []
            H^2:  [2, 2, 2, 2, 2, 2]
            H^3:  [2, 2, 2]
            H^4:  [2, 2, 2, 2, 2, 2, 4, 4, 4]
            H^5:  [2, 2, 2, 2, 2, 2]

        ::

            sage: G = DihedralGroup(4)
            sage: m1 = matrix(2, [0,1,1,0])
            sage: m2 = -matrix.identity(2)
            sage: L = GLattice(G, [m1,m2])
            sage: for i in range(-5, 6):
            ....:     print("H^"+str(i)+": "+str(L.Tate_Cohomology(i)))
            H^-5:  [2, 2, 2]
            H^-4:  [2, 2]
            H^-3:  [2, 2]
            H^-2:  [2]
            H^-1:  [2]
            H^0:  []
            H^1:  [2]
            H^2:  [2]
            H^3:  [2, 2]
            H^4:  [2, 2]
            H^5:  [2, 2, 2]
            sage: SL1 = L.zero_sum_sublattice()
            sage: a,b = L.basis()
            sage: SL2 = L.sublattice([a+b])
            sage: for i in range(-5, 6):
            ....:     print("H^"+str(i)+": "+str(SL1.Tate_Cohomology(i)))
            H^-5:  [2, 2, 2]
            H^-4:  [2, 2]
            H^-3:  [2, 2]
            H^-2:  [2]
            H^-1:  [2]
            H^0:  []
            H^1:  [2]
            H^2:  [2]
            H^3:  [2, 2]
            H^4:  [2, 2]
            H^5:  [2, 2, 2]
            sage: for i in range(-5, 6):
            ....:     print("H^"+str(i)+": "+str(SL2.Tate_Cohomology(i)))
            H^-5:  [2, 2, 2]
            H^-4:  [2, 2]
            H^-3:  [2, 2]
            H^-2:  [4]
            H^-1:  [2]
            H^0:  []
            H^1:  [2]
            H^2:  [4]
            H^3:  [2, 2]
            H^4:  [2, 2]
            H^5:  [2, 2, 2]
        """
        return self.isomorphic_ambient_lattice().Tate_Cohomology(n)

    def induced_lattice(self,group):
        """
        Compute an ambient lattice isomorphic to the induction of this lattice
        to a larger group.

        INPUT:

        - ``group`` -- the larger group to induce the lattice to.

        EXAMPLE::

            sage: G = DihedralGroup(4)
            sage: m1 = matrix(2, [0, 1, 1, 0])
            sage: m2 = -matrix.identity(2)
            sage: L = GLattice(G, [m1, m2])
            sage: SL1 = L.zero_sum_sublattice()
            sage: a,b = L.basis()
            sage: SL2 = L.sublattice([a+b])

        ::

            sage: SL1.induced_lattice(SymmetricGroup(4))
            Ambient lattice of rank 3 with an action by a group of order 24
            sage: _._action_matrices
            [
            [-1| 0| 0]  [ 0|-1| 0]
            [--+--+--]  [--+--+--]
            [ 0| 0| 1]  [-1| 0| 0]
            [--+--+--]  [--+--+--]
            [ 0|-1| 0], [ 0| 0| 1]
            ]
            sage: SL2.induced_lattice(SymmetricGroup(4))
            Ambient lattice of rank 3 with an action by a group of order 24
            sage: _._action_matrices
            [
            [ 1| 0| 0]  [ 0|-1| 0]
            [--+--+--]  [--+--+--]
            [ 0| 0|-1]  [-1| 0| 0]
            [--+--+--]  [--+--+--]
            [ 0| 1| 0], [ 0| 0|-1]
            ]
        """
        return self.isomorphic_ambient_lattice().induced_lattice(group)

    def norm_one_restriction_of_scalars(self, group):
        """
        Compute the ambient lattice.

        INPUT:

        - ``group`` -- the bigger group corresponding to the induction for
        the restriction of scalars.


        EXAMPLES::

            sage: G = DihedralGroup(4)
            sage: L = GLattice(G, 3)
            sage: SL = L.zero_sum_sublattice()
            sage: SL.norm_one_restriction_of_scalars(SymmetricGroup(4))
            Ambient lattice of rank 5 with an action by a group of order 24
            sage: _._action_matrices
            [
            [0 0 1 0 0]  [ 1  0  0 -1  0]
            [0 0 0 1 0]  [ 0  1  0 -1  0]
            [1 0 0 0 0]  [ 0  0  0 -1  1]
            [0 1 0 0 0]  [ 0  0  0 -1  0]
            [0 0 0 0 1], [ 0  0  1 -1  0]
            ]
        """
        return self.isomorphic_ambient_lattice().norm_one_restriction_of_scalars(group)

    def zero_sum_sublattice(self, ambient=False):
        """
        Creates the sublattice of the vectors with zero sum of coordinates
        in the ambient module.

        INPUT:

        - ``ambient`` -- boolean, if True the method returns an ambient lattice
            isomorphic to the zero sum sublattice.

        .. NOTE::

            Again, not all zero sum lattices are stable under the action of the group,
            this method can fail in those cases.

        EXAMPLES::

            sage: G = SymmetricGroup(3)
            sage: L1 = GLattice(G, 5)
            sage: a,b,c,d,e = L1.basis()
            sage: SL1 = L1.sublattice([a+2*b+d, d-5*e, 3*c]); SL1
            Sublattice of degree 5 and rank 3 with an action by a group of order 6 and echelon basis matrix
            [ 1  2  0  0  5]
            [ 0  0  3  0  0]
            [ 0  0  0  1 -5]
            sage: SL1.zero_sum_sublattice()
            Sublattice of degree 5 and rank 2 with an action by a group of order 6 and echelon basis matrix
            [  1   2   0   2  -5]
            [  0   0  12   3 -15]
            sage: SL1.zero_sum_sublattice(True)
            Ambient lattice of rank 2 with an action by a group of order 6

        Next is another example of sublattice where the zero sum submodule
        is not stable under the group action::

            sage: G2 = CyclicPermutationGroup(2)
            sage: m = matrix([[0,1,0,0,0], [1,0,0,0,0], [0,0,1,0,0], [0,0,0,-1,0], [0,0,0,0,-1]])
            sage: L2 = GLattice(G2, [m])
            sage: a,b,c,d,e = L2.basis()
            sage: SL2 = L2.sublattice([a,b,d]); SL2
            Sublattice of degree 5 and rank 3 with an action by a group of order 2 and echelon basis matrix
            [1 0 0 0 0]
            [0 1 0 0 0]
            [0 0 0 1 0]
            sage: SL2.zero_sum_sublattice()
            Traceback (most recent call last):
            ValueError: The basis is not stable under the action of the group
        """
        oldBasis = self.basis()
        newBasis = []
        diagonal = 0
        for i in self._parent_lattice.basis():
            diagonal += i
        totals = [i.inner_product(diagonal) for i in oldBasis]
        gcd,coefs = extended_xgcd(totals)
        if gcd == 0:
            return self
        dist_elt = 0
        for i in range(len(oldBasis)):
            dist_elt += coefs[i]*oldBasis[i]
        for i in range(len(oldBasis)):
            newBasis.append(oldBasis[i]-(totals[i]/gcd)*dist_elt)
        while 0 in newBasis:
            newBasis.remove(0)
        result = SubLattice(self._parent_lattice,newBasis)
        return result if not ambient else result.isomorphic_ambient_lattice()


