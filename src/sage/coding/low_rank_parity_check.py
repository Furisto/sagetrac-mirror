r"""
Low Rank Parity Check (LRPC) Code

This module provides the :class:`~sage.coding.low_rank_parity_check.LRPCCode`, which constructs
LRPC Codes, which are the rank metric equivalent of LDPC codes and are
defined as the codes with parity check matrix `H` such that subspace `F` generated by `H`'s coefficients
is of dimension `d`.

This module also provides :class:`~sage.coding.low_rank_parity_check.LRPCCodeGeneratorMatrixEncoder`,
an encoder based on the generator matrix. It also provides a decoder
:class:`~sage.coding.low_rank_parity_check.LRPCBasicSyndromeDecoder`, which corrects errors using
the general decoding algorithm for LRPC codes defined in [GMRZ2013]_.

AUTHOR:

- Maaike van Leuken (2021-2-26): initial version
"""

# ****************************************************************************
#       Copyright (C) 2019 MAAIKE VAN LEUKEN <maaikevanleuken97@gmail.com>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# (at your option) any later version.
#                  https://www.gnu.org/licenses/
# ****************************************************************************

from sage.coding.linear_rank_metric import AbstractLinearRankMetricCode
from .linear_code import LinearCodeGeneratorMatrixEncoder
from sage.categories.fields import Fields
from sage.matrix.constructor import matrix
from sage.coding.decoder import Decoder
from sage.modules.free_module_element import vector
from sage.modules.free_module import span
from sage.coding.code_constructions import from_parity_check_matrix
from sage.functions.log import log
from sage.functions.other import floor

class LRPCCode(AbstractLinearRankMetricCode):
    r"""
    An LRPC code.

    DEFINITION:
    A linear Low Rank Parity Check code of rank `d`, length `n` and dimension `k` over `\mathbb{f}_{q^m}`
    is the set of all codewords `c`, such that `c \in x \cdot G` for all `x \in \mathbb{F_{q^m}}`
    Where `G` is the generator matrix derived from the parity check matrix `H`, which coefficients span
    a sub-vector space `F` of `\mathbb{F}_{q^m}` of dimension `d`. The construction of LRPC codes is
    random. In some cases, for parameters where `d` is close to `n` or `m`, the construction might fail.
    To obtain equal LRPC codes, one can give a parity check matrix `H`. This is done in the examples
    for reproducibility.

    EXAMPLES:

        An LRPC code can be constructed in the following way::

            sage: q = 2; n = 5; k = 1; m = 5; d = 2;
            sage: C = codes.LRPCCode(GF(q**m), n, k, d); C
            [5, 1, 2] LRPC code over GF(32)/GF(2)

        An example of an LRPC code with larger parameters::

            sage: q = 2; n = 22; k = 11; m = 11; r = 5; d = 2;
            sage: C = codes.LRPCCode(GF(q**m), n, k, d); C
            [22, 11, 2] LRPC code over GF(2048)/GF(2)

        An LRPC code can also be constructed by giving a parity check matrix `H`::

            sage: q = 2; n = 5; k = 1; m = 5; d = 2
            sage: z5 = GF(q**m).gen()
            sage: H = [(z5^4 + z5^3 + z5^2 + 1, 0, z5^4 + z5^3 + z5^2 + 1, z5^4 + z5^3 + z5, 0), \
            (z5^4 + z5^3 + z5^2 + 1, z5^4 + z5^3 + z5, 0, z5^4 + z5^3 + z5^2 + 1, z5^4 + z5^3 + z5),\
            (0, 0, z5^4 + z5^3 + z5, z5^4 + z5^3 + z5, 0), \
            (0, z5^4 + z5^3 + z5, 0, z5^4 + z5^3 + z5, z5^4 + z5^3 + z5^2 + 1)]
            sage: C = codes.LRPCCode(GF(q**m), n, k, d, parity_check_matrix=matrix(H)); C
            [5, 1, 2] LRPC code over GF(32)/GF(2)

        The construction of the code is probabilistic, so sometimes, the subspace `F` does not have the
        correct dimension `d`::

            sage: q = 2; n = 3; d = 2; k = 1; r = 1; m = 4;
            sage: z4 = GF(q**m).gen()
            sage: H = [(0, z4^2, z4^2), (0, z4^2, z4^2)]
            sage: C = codes.LRPCCode(GF(q**m), n, k, d, parity_check_matrix=matrix(H));
            Traceback (most recent call last):
            ...
            ValueError: This is not a good LRPC code, since the dimension of the support of the parity is not equal to 2.
    """
    _registered_encoders = {}
    _registered_decoders = {}

    def __init__(self, base_field, length, dimension, d, sub_field=None, parity_check_matrix=None):
        r"""
        Representation of a low-rank parity check (LRPC) code.

        INPUT:

        - ``base_field`` -- finite field of order `q^m` where `q` is a prime power
          and `m` is an integer, the extension degree.

        - ``length`` -- length of the resulting code

        - ``dimension`` -- dimension of the resulting code

        - ``d`` -- the rank of the code, such that `F` has dimension ``d``

        - ``sub_field`` -- (default: ``None``) finite field of order `q`
          which is a subfield of the ``base_field``. If not given, it is the
          prime subfield of the ``base_field``.

        - ``parity_check_matrix`` -- (default: ``None``) the parity check matrix
          the code should have. If not given, it is computed randomly below
          such that its coefficients span the subspace `F` of dimension ``d``.

        TESTS:

        If ``d`` is bigger than the degree of the extension an error is
        raised:

            sage: C = C = codes.LRPCCode(GF(64), 7, 3, 7)
            Traceback (most recent call last):
            ...
            ValueError: The dimension of the support of the parity check matrix cannot be larger than the extension_degree.

        If ``d`` is bigger than the degree of the extension an error is
        raised:

            sage: C = codes.LRPCCode(GF(8), 2, 1, 3)
            Traceback (most recent call last):
            ...
            ValueError: The dimension of the support of the parity check matrix cannot be larger than length of the code.

        If ``d`` is smaller than 1, an error is raised:

            sage: C = C = codes.LRPCCode(GF(64), 7, 3, 0)
            Traceback (most recent call last):
            ...
            ValueError: The dimension of the support of the parity check matrix must be larger than 0.
        """
        self._dimension = dimension
        self._d = d

        if sub_field == None:
            sub_field = base_field.base_ring()
        if d > log(base_field.cardinality(), sub_field.cardinality()):
            raise ValueError("The dimension of the support of the parity check matrix cannot be larger than the extension_degree. ")
        if d > length:
            raise ValueError("The dimension of the support of the parity check matrix cannot be larger than length of the code. ")
        if d <= 0:
            raise ValueError("The dimension of the support of the parity check matrix must be larger than 0.")
        if parity_check_matrix != None:
            parity_check_matrix = matrix(parity_check_matrix)
            if parity_check_matrix.rank() != length-dimension:
                raise ValueError("This is not a good LRPC code, since the dimension of the support of the parity is not equal to %d." %(d))
            self._parity_check = parity_check_matrix
            self.basis = from_parity_check_matrix(self._parity_check).generator_matrix()
            self._sup = None            # Compute this in ``self.support_of_parity()``.
        else:
            F = span([vector(base_field.random_element()) for _ in range(d)], sub_field)
            if F.dimension() != d:
                raise ValueError("This is not a good LRPC code, since the dimension of the support of the parity is not equal to %d." %(d))
            self._sup = F
            elems = [self.poly_form_of_vector(elem, base_field) for elem in list(F)]

            from random import choice
            temp = [[0 for _ in range(length)] for _ in range(length-dimension)]
            for i in range(length-dimension):
                for j in range(length):
                    temp[i][j] = choice(elems)

            self._parity_check = matrix(base_field, temp)
            self.basis = from_parity_check_matrix(self._parity_check).generator_matrix()

        super(LRPCCode, self).__init__(base_field, sub_field, length, "GeneratorMatrix", "SyndromeDecoder", self.basis)

    def _repr_(self):
        r"""
        Return a string representation of ``self``.

        EXAMPLES::

            sage: q = 2; n = 22; k = 11; m = 11; r = 5; d = 2;
            sage: C = codes.LRPCCode(GF(q**m), n, k, d); C
            [22, 11, 2] LRPC code over GF(2048)/GF(2)
        """
        R = self.base_field()
        S = self.sub_field()
        if R and S in Fields():
            return "[%s, %s, %s] LRPC code over GF(%s)/GF(%s)"%(self.length(), self.dimension(), self.rank(), R.cardinality(), S.cardinality())
        else:
            return "[%s, %s, %s] LRPC code over %s/%s"%(self.length(), self.dimension(), self.rank(), R, S)

    def _latex_(self):
        r"""
        Return a latex representation of ``self``.

        EXAMPLES::

            sage: q = 2; n = 22; k = 11; m = 11; r = 5; d = 2;
            sage: C = codes.LRPCCode(GF(q**m), n, k, d); C
            [22, 11, 2] LRPC code over GF(2048)/GF(2)
            sage: latex(C)
            [22, 11, 2] \textnormal{ linear LRPC code over } \Bold{F}_{2^{11}}/\Bold{F}_{2}
        """
        return "[%s, %s, %s] \\textnormal{ linear LRPC code over } %s/%s"\
                % (self.length(), self.dimension(), self.rank(),
                self.base_field()._latex_(), self.sub_field()._latex_())

    def __eq__(self, other):
        r"""
        Tests equality between LRPC Code objects.
        Two codes are equal if they contain the same codewords. This happens when
        the generator matrices or the parity check matrices in systematic form of both
        codes are equal. Here we use the generator matrices to verify this, since these are
        generated in ``__init__`` in systematic form.

        INPUT:

        - ``other`` -- another LRPC Code object

        OUTPUT:

        - ``True`` or ``False``

        EXAMPLES::

            sage: C1 = codes.LRPCCode(GF(2**10), 8, 4, 2)
            sage: C2 = codes.LRPCCode(GF(2**10), 8, 4, 2)
            sage: C1 == C2
            False

        Two codes `C_1` and `C_2`, with generator and parity check matrix `G_1`, `H_1` and  G_2`, `H_2`
        respectively, are equal if `G_1H_2^T = G_2H_1^T = 0`::

            sage: z5 = GF(2**5).gen()
            sage: H1 = [(z5^4 + z5^3 + z5^2, z5^4 + z5^3 + z5^2, z5^4 + z5^3 + z5^2, z5^4 + z5^3 + z5^2, 0),
            ....: (z5^4 + z5^3 + z5^2, z5^4 + z5^3 + z5^2, 0, z5^4 + z5^3 + z5^2, z5^4 + z5^3 + z5^2)]
            sage: C1 = codes.LRPCCode(GF(2**5), 5, 3, 1, parity_check_matrix=matrix(H1));
            sage: C2 = codes.LRPCCode(GF(2**5), 5, 3, 1, parity_check_matrix=H1)
            sage: C1 == C2
            True
        """
        return  isinstance(other, LRPCCode) \
                and self.base_field() == other.base_field() \
                and self.sub_field() == other.sub_field() \
                and self.rank() == other.rank() \
                and self.length() == other.length() \
                and self.dimension() == other.dimension() \
                and self.generator_matrix() * other.parity_check_matrix().transpose() \
                 == other.generator_matrix() * self.parity_check_matrix().transpose() == 0

    def generator_matrix(self):
        r"""
        Return the generator matrix of ``self``.

        EXAMPLES::

            sage: q = 2; n = 5; k = 2; m = 5; d = 3
            sage: z5 = GF(q**m).gen()
            sage: H = [(z5^4 + z5^3 + z5 + 1, z5^2, z5^4 + z5^2 + 1, z5^4 + z5^3 + z5^2 + z5 + 1, z5^3 + z5^2 + z5),\
            ....: (z5^2, 0, z5^4 + z5^3 + z5 + 1, z5^2, z5^4 + z5^2 + 1),\
            ....: (z5^2, z5^4 + z5^3 + z5^2 + z5 + 1, z5^2, z5^4 + z5^3 + z5 + 1, 0)]
            sage: C = codes.LRPCCode(GF(q**m), n, k, d, parity_check_matrix=matrix(H)); C
            [5, 2, 3] LRPC code over GF(32)/GF(2)
            sage: G = C.generator_matrix(); G
            [               1                0 z5^4 + z5^3 + z5             z5^2    z5^4 + z5 + 1]
            [               0                1 z5^4 + z5^3 + z5         z5^2 + 1    z5^4 + z5 + 1]
            sage: G * C.parity_check_matrix().transpose()
            [0 0 0]
            [0 0 0]
        """
        return self.basis

    def parity_check_matrix(self):
        r"""
        Return the parity check matrix of ``self``.

        This is the generator matrix of the dual code of ``self``.

        EXAMPLES::

            sage: q = 2; n = 5; k = 2; m = 5; d = 3
            sage: z5 = GF(q**m).gen()
            sage: H = [(z5^4 + z5^3 + z5 + 1, z5^2, z5^4 + z5^2 + 1, z5^4 + z5^3 + z5^2 + z5 + 1, z5^3 + z5^2 + z5),\
            ....: (z5^2, 0, z5^4 + z5^3 + z5 + 1, z5^2, z5^4 + z5^2 + 1),\
            ....: (z5^2, z5^4 + z5^3 + z5^2 + z5 + 1, z5^2, z5^4 + z5^3 + z5 + 1, 0)]
            sage: C = codes.LRPCCode(GF(q**m), n, k, d, parity_check_matrix=matrix(H)); C
            [5, 2, 3] LRPC code over GF(32)/GF(2)
            sage: C.parity_check_matrix()
            [       z5^4 + z5^3 + z5 + 1                        z5^2             z5^4 + z5^2 + 1 z5^4 + z5^3 + z5^2 + z5 + 1            z5^3 + z5^2 + z5]
            [                       z5^2                           0        z5^4 + z5^3 + z5 + 1                        z5^2             z5^4 + z5^2 + 1]
            [                       z5^2 z5^4 + z5^3 + z5^2 + z5 + 1                        z5^2        z5^4 + z5^3 + z5 + 1                           0]
            sage: matrix(H) == C.parity_check_matrix()
            True
        """
        return self._parity_check

    def rank(self):
        r"""
        Return the dimension of the subspace spanned by the coefficients of the parity check matrix.

        EXAMPLES::

            sage: q = 2; n = 5; k = 2; m = 5; d = 3
            sage: z5 = GF(q**m).gen()
            sage: H = [(z5^4 + z5^3 + z5 + 1, z5^2, z5^4 + z5^2 + 1, z5^4 + z5^3 + z5^2 + z5 + 1, z5^3 + z5^2 + z5),\
            ....: (z5^2, 0, z5^4 + z5^3 + z5 + 1, z5^2, z5^4 + z5^2 + 1),\
            ....: (z5^2, z5^4 + z5^3 + z5^2 + z5 + 1, z5^2, z5^4 + z5^3 + z5 + 1, 0)]
            sage: C = codes.LRPCCode(GF(q**m), n, k, d, parity_check_matrix=matrix(H)); C
            [5, 2, 3] LRPC code over GF(32)/GF(2)
            sage: C.rank()
            3
        """
        return self._d

    def support_of_parity(self):
        r"""
        Return F, the subspace of ``self.base_field`` generated by the coefficients of ``self.parity_check``.

        EXAMPLES::

            sage: q = 2; n = 5; k = 2; m = 5; d = 3
            sage: z5 = GF(q**m).gen()
            sage: H = [(z5^4 + z5^3 + z5 + 1, z5^2, z5^4 + z5^2 + 1, z5^4 + z5^3 + z5^2 + z5 + 1, z5^3 + z5^2 + z5),\
            ....: (z5^2, 0, z5^4 + z5^3 + z5 + 1, z5^2, z5^4 + z5^2 + 1),\
            ....: (z5^2, z5^4 + z5^3 + z5^2 + z5 + 1, z5^2, z5^4 + z5^3 + z5 + 1, 0)]
            sage: C = codes.LRPCCode(GF(q**m), n, k, d, parity_check_matrix=matrix(H)); C
            [5, 2, 3] LRPC code over GF(32)/GF(2)
            sage: C.parity_check_matrix()
            [       z5^4 + z5^3 + z5 + 1                        z5^2             z5^4 + z5^2 + 1 z5^4 + z5^3 + z5^2 + z5 + 1            z5^3 + z5^2 + z5]
            [                       z5^2                           0        z5^4 + z5^3 + z5 + 1                        z5^2             z5^4 + z5^2 + 1]
            [                       z5^2 z5^4 + z5^3 + z5^2 + z5 + 1                        z5^2        z5^4 + z5^3 + z5 + 1                           0]
            sage: F = C.support_of_parity(); F
            Vector space of degree 5 and dimension 3 over Finite Field of size 2
            Basis matrix:
            [1 0 0 0 1]
            [0 1 0 1 0]
            [0 0 1 0 0]
        """
        if self._sup == None:
            self._sup = sum([self.support(row) for row in self.parity_check_matrix()])
        return self._sup

    def parity_in_support(self):
        r"""
        Rewrite the parity check matrix `H` in terms of its support `F`.
        Each element of `H` can be rewritten as:
        `H_{ij} = \sum_{k = 0}^{d-1} H_{ijk}F_k`

        EXAMPLES::

            sage: q = 2; n = 5; k = 2; m = 5; d = 3
            sage: z5 = GF(q**m).gen()
            sage: H = [(z5^4 + z5^3 + z5 + 1, z5^2, z5^4 + z5^2 + 1, z5^4 + z5^3 + z5^2 + z5 + 1, z5^3 + z5^2 + z5),\
            ....: (z5^2, 0, z5^4 + z5^3 + z5 + 1, z5^2, z5^4 + z5^2 + 1),\
            ....: (z5^2, z5^4 + z5^3 + z5^2 + z5 + 1, z5^2, z5^4 + z5^3 + z5 + 1, 0)]
            sage: C = codes.LRPCCode(GF(q**m), n, k, d, parity_check_matrix=matrix(H)); C
            [5, 2, 3] LRPC code over GF(32)/GF(2)
            sage: C.parity_check_matrix()
            [       z5^4 + z5^3 + z5 + 1                        z5^2             z5^4 + z5^2 + 1 z5^4 + z5^3 + z5^2 + z5 + 1            z5^3 + z5^2 + z5]
            [                       z5^2                           0        z5^4 + z5^3 + z5 + 1                        z5^2             z5^4 + z5^2 + 1]
            [                       z5^2 z5^4 + z5^3 + z5^2 + z5 + 1                        z5^2        z5^4 + z5^3 + z5 + 1                           0]
            sage: F = C.support_of_parity(); F
            Vector space of degree 5 and dimension 3 over Finite Field of size 2
            Basis matrix:
            [1 0 0 0 1]
            [0 1 0 1 0]
            [0 0 1 0 0]
            sage: HinF = C.parity_in_support(); HinF
            [[(1, 1, 0), (0, 0, 1), (1, 0, 1), (1, 1, 1), (0, 1, 1)],
             [(0, 0, 1), (0, 0, 0), (1, 1, 0), (0, 0, 1), (1, 0, 1)],
             [(0, 0, 1), (1, 1, 1), (0, 0, 1), (1, 1, 0), (0, 0, 0)]]
            sage: a = HinF[0][0]* matrix(F.basis()); a
            (1, 1, 0, 1, 1)
            sage: C.poly_form_of_vector(a)
            z5^4 + z5^3 + z5 + 1
            sage: C.poly_form_of_vector(a) == H[0][0]
            True
        """
        F = self.support_of_parity()
        H = self.parity_check_matrix()
        n = self.length()
        k = self.dimension()
        return [[self.rewrite_in_basis(H[i][j], F.basis()) for j in range(n)] for i in range(n-k)]

####################### encoders ###############################

class LRPCCodeGeneratorMatrixEncoder(LinearCodeGeneratorMatrixEncoder):
    def __init__(self, code):
        r"""
        Encoder for LRPC codes based on the generator matrix.
        A message `m` is encrypted as `mG=c`.

        INPUT:

        - ``code`` -- the associated code of this encoder

        EXAMPLES::

            sage: q = 2; n = 5; k = 2; m = 5; d = 3
            sage: z5 = GF(q**m).gen()
            sage: H = [(z5^4 + z5^3 + z5 + 1, z5^2, z5^4 + z5^2 + 1, z5^4 + z5^3 + z5^2 + z5 + 1, z5^3 + z5^2 + z5),\
            ....: (z5^2, 0, z5^4 + z5^3 + z5 + 1, z5^2, z5^4 + z5^2 + 1),\
            ....: (z5^2, z5^4 + z5^3 + z5^2 + z5 + 1, z5^2, z5^4 + z5^3 + z5 + 1, 0)]
            sage: C = codes.LRPCCode(GF(q**m), n, k, d, parity_check_matrix=matrix(H)); C
            [5, 2, 3] LRPC code over GF(32)/GF(2)
            sage: E = C.encoder()
            sage: m = list(E.message_space())[12]; m
            (z5^3 + z5^2 + z5, 0)
            sage: E.encode(m)
            (z5^3 + z5^2 + z5, 0, z5^4 + z5^3, z5^4 + z5^3 + z5^2 + 1, z5^3 + 1)
            sage: E.encode(m) in C
            True
        """
        if not isinstance(code, LRPCCode):
            raise ValueError("code has to be a LRPC code")

        super(LRPCCodeGeneratorMatrixEncoder, self).__init__(code)

####################### decoders ###############################


class LRPCBasicSyndromeDecoder(Decoder):
    r"""
    Syndrome decoder for LRPC codes as defined in [GMRZ2013]_, in particular,
    the general decoding algorithm in Figure 1.
    """
    def __init__(self, code):
        r"""
        INPUT:

        - ``code`` -- the associated code of this decoder

        EXAMPLES::

            sage: n = 74; k = 37; d = 4; r = 4; m = 41;
            sage: C = codes.LRPCCode(GF(2**m), n, k, d)
            sage: D = C.decoder(); D
            Basic LRPC syndrome decoder for [74, 37, 4] LRPC code over GF(2199023255552)/GF(2)

        TESTS:

        If the code is not an LRPC code, an error is raised:

            sage: C = codes.GabidulinCode(GF(8), 3, 2)
            sage: D = codes.decoders.LRPCBasicSyndromeDecoder(C)
            Traceback (most recent call last):
            ...
            ValueError: Code has to be an LRPC code.
        """
        if not isinstance(code, LRPCCode):
             raise ValueError("Code has to be an LRPC code.")

        self._D_H = [None for i in range(floor((code.length() - code.dimension())/2)+1)]

        super(LRPCBasicSyndromeDecoder, self).__init__(code, code.ambient_space(), code._default_encoder_name)


    def _repr_(self):
        r"""
        Return a string representation of ``self``.

        EXAMPLES:

            sage: q = 2; n = 22; k = 11; m = 11; r = 5; d = 2;
            sage: C = codes.LRPCCode(GF(q**m), n, k, d); C
            [22, 11, 2] LRPC code over GF(2048)/GF(2)
            sage: D = codes.decoders.LRPCBasicSyndromeDecoder(C); D
            Basic LRPC syndrome decoder for [22, 11, 2] LRPC code over GF(2048)/GF(2)
        """
        return "Basic LRPC syndrome decoder for %s" % self.code()

    def _latex_(self):
        r"""
        Return a latex representation of ``self``.

        EXAMPLES:

            sage: q = 2; n = 22; k = 11; m = 11; r = 5; d = 2;
            sage: C = codes.LRPCCode(GF(q**m), n, k, d); C
            [22, 11, 2] LRPC code over GF(2048)/GF(2)
            sage: D = codes.decoders.LRPCBasicSyndromeDecoder(C); D
            Basic LRPC syndrome decoder for [22, 11, 2] LRPC code over GF(2048)/GF(2)
            sage: latex(D)
            \textnormal{Syndrome decoder for } [22, 11, 2] \textnormal{ linear LRPC code over } \Bold{F}_{2^{11}}/\Bold{F}_{2}
        """
        return "\\textnormal{Syndrome decoder for } %s" % self.code()._latex_()

    def __eq__(self, other):
        r"""
        Tests equality between LRPC Syndrome Decoder objects.

        INPUT:

        - ``other`` -- another LRPC Syndrome Decoder

        OUTPUT:

        - ``True`` or ``False``

        EXAMPLES::

            sage: q = 2; n = 22; k = 11; m = 11; r = 5; d = 2;
            sage: C1 = codes.LRPCCode(GF(q**m), n, k, d)
            sage: H = C1.parity_check_matrix()
            sage: C2 = codes.LRPCCode(GF(q**m), n, k, d, parity_check_matrix=H);
            sage: D1 = codes.decoders.LRPCBasicSyndromeDecoder(C1)
            sage: D2 = codes.decoders.LRPCBasicSyndromeDecoder(C2)
            sage: D1 == D2
            True

            sage: C3 = codes.LRPCCode(GF(q**m), n, k, d);
            sage: D3 = codes.decoders.LRPCBasicSyndromeDecoder(C3)
            sage: D2 == D3
            False
        """
        return isinstance(other, LRPCBasicSyndromeDecoder) \
            and self.code() == other.code()

    def decoding_radius(self):
        r"""
        The upper bound for the decoding radius is `\frac{n-k}{2}`,
        according to Remark 6 in [GMRZ2013]_.

        EXAMPLES::

            sage: q = 2; n = 22; k = 11; m = 11; r = 5; d = 2;
            sage: C = codes.LRPCCode(GF(q**m), n, k, d); C
            [22, 11, 2] LRPC code over GF(2048)/GF(2)
            sage: D = codes.decoders.LRPCBasicSyndromeDecoder(C); D
            Basic LRPC syndrome decoder for [22, 11, 2] LRPC code over GF(2048)/GF(2)
            sage: D.decoding_radius()
            5
        """
        C = self.code()
        n = C.length()
        k = C.dimension()
        return floor((n-k)/2)

    def syndrome_space_computation(self, received):
        r"""
        Compute the syndrome and the syndrome space. This is step 1 in the algorithm
        described in [GMRZ2013]_ in Figure 1. The first output of this function is the
        syndrome of ``received``, the second output is the support of that syndrome.

        INPUT:

        - ``received`` -- the received word, i.e. `y = x + e` for codeword `x` and error vector `e`

        EXAMPLES::

            sage: q = 2; n = 7; k = 2; m = 5; d = 3; r = 1
            sage: z5 = GF(q**m).gen()
            sage: H = [(z5^4 + z5^3 + z5^2 + 1, z5^4 + z5^3 + z5^2 + 1, z5^3 + z5^2, z5^4 + z5^3, z5^2 + 1, 0, z5^4 + z5^2),\
             (0, z5^3 + 1, z5^4 + z5^3, 0, z5^3 + z5^2, z5^4 + z5^2, z5^4 + z5^2),\
             (0, 0, 0, z5^4 + z5^3 + z5^2 + 1, z5^4 + z5^2, z5^4 + z5^3 + z5^2 + 1, z5^2 + 1),\
             (z5^4 + 1, z5^4 + 1, z5^4 + z5^3, z5^3 + z5^2, z5^2 + 1, z5^3 + z5^2, z5^4 + z5^3),\
             (z5^4 + 1, z5^3 + z5^2, z5^4 + 1, z5^3 + 1, z5^4 + z5^3, z5^3 + z5^2, z5^3 + 1)]
            sage: C = codes.LRPCCode(GF(q**m), n, k, d, parity_check_matrix=matrix(H)); C
            [7, 2, 3] LRPC code over GF(32)/GF(2)
            sage: D = C.decoder()
            sage: e = C.find_e_of_rank(r); x = C.random_element(); y = x + e; e # random
            (z5^3, 0, 0, z5^3, 0, 0, z5^3)
            sage: s, S = D.syndrome_space_computation(y); s # random
            (z5^4 + z5^3 + z5^2, z5^4 + 1, z5^4 + z5^3 + z5^2 + z5, z5^3 + z5^2 + 1, z5^4 + z5^3 + z5^2)
            sage: S # random
            Vector space of degree 5 and dimension 3 over Finite Field of size 2
            Basis matrix:
            [1 0 0 0 1]
            [0 1 0 0 0]
            [0 0 1 1 1]

            sage: q = 2; n = 5; k = 1; m = 5; d = 2; r = 1
            sage: C = codes.LRPCCode(GF(2**m), n, k, d); D = C.decoder();
            sage: e = C.find_e_of_rank(r); x = C.random_element(); y = x + e; y  # random
            (z5^3 + 1, z5^3 + z5^2, z5^3 + z5^2, 0, z5^3 + z5^2)
            sage: s, S = D.syndrome_space_computation(y); s # random
            (z5^4 + z5^2 + z5 + 1, z5^3 + z5^2 + z5, z5^3 + z5^2 + z5, 0)
            sage: S # random
            Vector space of degree 5 and dimension 2 over Finite Field of size 2
            Basis matrix:
            [1 0 0 1 1]
            [0 1 1 1 0]
        """
        C = self.code()
        n = C.length()
        k = C.dimension()
        H = C.parity_check_matrix()

        if H.dimensions() != (n-k, n):
            raise ValueError("Dimensions of parity check matrix incorrect.")
        if len(received) != n:
            raise ValueError("Length of received vector incorrect.")

        s = H * vector(received)
        S = C.support(s)
        return s, S

    def subspace_com(self, spaces):
        r"""
        Find the intersection of a number of subspaces.

        INPUT:

        - ``spaces`` -- list of subspaces to be combined

        EXAMPLES::

            sage: q = 2; n = 7; k = 2; m = 5; d = 3; r = 1
            sage: z5 = GF(q**m).gen()
            sage: H = [(z5^4 + z5^3 + z5^2 + 1, z5^4 + z5^3 + z5^2 + 1, z5^3 + z5^2, z5^4 + z5^3, z5^2 + 1, 0, z5^4 + z5^2),\
             (0, z5^3 + 1, z5^4 + z5^3, 0, z5^3 + z5^2, z5^4 + z5^2, z5^4 + z5^2),\
             (0, 0, 0, z5^4 + z5^3 + z5^2 + 1, z5^4 + z5^2, z5^4 + z5^3 + z5^2 + 1, z5^2 + 1),\
             (z5^4 + 1, z5^4 + 1, z5^4 + z5^3, z5^3 + z5^2, z5^2 + 1, z5^3 + z5^2, z5^4 + z5^3),\
             (z5^4 + 1, z5^3 + z5^2, z5^4 + 1, z5^3 + 1, z5^4 + z5^3, z5^3 + z5^2, z5^3 + 1)]
            sage: C = codes.LRPCCode(GF(q**m), n, k, d, parity_check_matrix=matrix(H)); C
            [7, 2, 3] LRPC code over GF(32)/GF(2)
            sage: D = C.decoder()
            sage: e = C.find_e_of_rank(r); x = C.random_element(); y = x + e; e # random
            (z5^3, 0, 0, z5^3, 0, 0, z5^3)
            sage: s, S = D.syndrome_space_computation(y); s # random
            (z5^4 + z5^3 + z5^2, z5^4 + 1, z5^4 + z5^3 + z5^2 + z5, z5^3 + z5^2 + 1, z5^4 + z5^3 + z5^2)
            sage: S # random
            Vector space of degree 5 and dimension 3 over Finite Field of size 2
            Basis matrix:
            [1 0 0 0 1]
            [0 1 0 0 0]
            [0 0 1 1 1]
            sage: F = C.support_of_parity()
            sage: fbase = [i for i in F.basis()]
            sage: finverse = [1/C.poly_form_of_vector(f, C.base_field()) for f in fbase]
            sage: sgens = [C.poly_form_of_vector(ss, C.base_field()) for ss in S.gens()]
            sage: mults = [[vector(inv*ss) for ss in sgens] for inv in finverse]
            sage: Si = [span(m, C.sub_field()) for m in mults]; Si # random
            [Vector space of degree 5 and dimension 3 over Finite Field of size 2
             Basis matrix:
             [1 0 0 0 0]
             [0 0 1 0 1]
             [0 0 0 1 0],
             Vector space of degree 5 and dimension 3 over Finite Field of size 2
             Basis matrix:
             [1 0 0 0 1]
             [0 1 0 0 0]
             [0 0 0 1 0],
             Vector space of degree 5 and dimension 3 over Finite Field of size 2
             Basis matrix:
             [1 1 0 0 0]
             [0 0 1 0 0]
             [0 0 0 1 0]]
            sage: D.subspace_com(Si) # random
            Vector space of degree 5 and dimension 1 over Finite Field of size 2
            Basis matrix:
            [0 0 0 1 0]

            sage: q = 2; n = 5; k = 1; m = 5; d = 2; r = 1
            sage: C = codes.LRPCCode(GF(2**m), n, k, d); D = C.decoder();
            sage: e = C.find_e_of_rank(r); x = C.random_element(); y = x + e; y  # random
            (z5^3 + 1, z5^3 + z5^2, z5^3 + z5^2, 0, z5^3 + z5^2)
            sage: s, S = D.syndrome_space_computation(y); s # random
            (z5^4 + z5^2 + z5 + 1, z5^3 + z5^2 + z5, z5^3 + z5^2 + z5, 0)
            sage: S # random
            Vector space of degree 5 and dimension 2 over Finite Field of size 2
            Basis matrix:
            [1 0 0 1 1]
            [0 1 1 1 0]
            sage: F = C.support_of_parity()
            sage: fbase = [i for i in F.basis()]
            sage: finverse = [1/C.poly_form_of_vector(f, C.base_field()) for f in fbase]
            sage: sgens = [C.poly_form_of_vector(ss, C.base_field()) for ss in S.gens()]
            sage: mults = [[vector(inv*ss) for ss in sgens] for inv in finverse]
            sage: Si = [span(m, C.sub_field()) for m in mults]; Si # random
            [Vector space of degree 5 and dimension 2 over Finite Field of size 2
             Basis matrix:
             [1 0 0 1 0]
             [0 1 1 1 0],
             Vector space of degree 5 and dimension 2 over Finite Field of size 2
             Basis matrix:
             [1 0 0 1 0]
             [0 1 1 0 1]]
            sage: D.subspace_com(Si) # random
            Vector space of degree 5 and dimension 1 over Finite Field of size 2
            Basis matrix:
            [1 0 0 1 0]
        """
        if len(spaces) < 1:
            raise ValueError("The number of spaces to be combined should be larger than 1.")
        temp = spaces[0].intersection(spaces[1])
        for i in range(2, len(spaces)):
            temp = temp.intersection(spaces[i])
        return temp

    def recover_error_support(self, S):
        r"""
        Compute the syndrome and the syndrome space. This is step 2 in the algorithm
        described in [GMRZ2013]_ in Figure 1.

        Getting the correct E is probabilistic. Probability of failure is defined in
        Proposition 2 [GMRZ2013]_.

        INPUT:

        - ``S`` -- the syndrome space, the support of the syndrome s

        EXAMPLES::

            sage: q = 2; n = 7; k = 2; m = 5; d = 3; r = 1
            sage: z5 = GF(q**m).gen()
            sage: H = [(z5^4 + z5^3 + z5^2 + 1, z5^4 + z5^3 + z5^2 + 1, z5^3 + z5^2, z5^4 + z5^3, z5^2 + 1, 0, z5^4 + z5^2),\
             (0, z5^3 + 1, z5^4 + z5^3, 0, z5^3 + z5^2, z5^4 + z5^2, z5^4 + z5^2),\
             (0, 0, 0, z5^4 + z5^3 + z5^2 + 1, z5^4 + z5^2, z5^4 + z5^3 + z5^2 + 1, z5^2 + 1),\
             (z5^4 + 1, z5^4 + 1, z5^4 + z5^3, z5^3 + z5^2, z5^2 + 1, z5^3 + z5^2, z5^4 + z5^3),\
             (z5^4 + 1, z5^3 + z5^2, z5^4 + 1, z5^3 + 1, z5^4 + z5^3, z5^3 + z5^2, z5^3 + 1)]
            sage: C = codes.LRPCCode(GF(q**m), n, k, d, parity_check_matrix=matrix(H)); C
            [7, 2, 3] LRPC code over GF(32)/GF(2)
            sage: D = C.decoder()
            sage: e = C.find_e_of_rank(r); x = C.random_element(); y = x + e; e # random
            (z5^3, 0, 0, z5^3, 0, 0, z5^3)
            sage: s, S = D.syndrome_space_computation(y); s # random
            (z5^4 + z5^3 + z5^2, z5^4 + 1, z5^4 + z5^3 + z5^2 + z5, z5^3 + z5^2 + 1, z5^4 + z5^3 + z5^2)
            sage: S # random
            Vector space of degree 5 and dimension 3 over Finite Field of size 2
            Basis matrix:
            [1 0 0 0 1]
            [0 1 0 0 0]
            [0 0 1 1 1]
            sage: E = D.recover_error_support(S); E # random
            Vector space of degree 5 and dimension 1 over Finite Field of size 2
            Basis matrix:
            [0 0 0 1 0]
            sage: C.support(e) == E
            True

            sage: q = 2; n = 7; k = 2; m = 5; d = 2; r = 1
            sage: C = codes.LRPCCode(GF(2**m), n, k, d); D = C.decoder();
            sage: e = C.find_e_of_rank(r);
            sage: x = C.random_element(); y = x + e;
            sage: s, S = D.syndrome_space_computation(y); s # random
            (z5^4 + z5^3 + z5^2 + z5, z5^3 + z5^2 + z5 + 1, z5^4 + z5^3 + z5^2 + z5, z5^4 + 1, z5^3 + z5^2 + z5 + 1)
            sage: S # random
            Vector space of degree 5 and dimension 2 over Finite Field of size 2
            Basis matrix:
            [1 0 0 0 1]
            [0 1 1 1 1]
            sage: E = D.recover_error_support(S); E # random
            Vector space of degree 5 and dimension 1 over Finite Field of size 2
            Basis matrix:
            [0 0 0 0 1]
            sage: C.support(e) == E
            True
        """
        C = self.code()
        F = C.support_of_parity()

        fbase = [i for i in F.basis()]
        finverse = [1/C.poly_form_of_vector(f, C.base_field()) for f in fbase]
        sgens = [C.poly_form_of_vector(ss, C.base_field()) for ss in S.gens()]
        mults = [[vector(inv*ss) for ss in sgens] for inv in finverse]
        Si = [span(m, C.sub_field()) for m in mults]
        if len(Si) > 1:
            return self.subspace_com(Si)
        else:
            return Si[0]

    def compute_product_space(self, E, F):
        r"""
        Compute the product space `P = \langle E.F \rangle`.

        INPUT:

        - ``E`` -- the first subspace, the support of the error vector

        - ``F`` -- the second subspace, the span of the elements of H

        EXAMPLES::

            sage: q = 2; n = 7; k = 2; m = 5; d = 3; r = 1
            sage: z5 = GF(q**m).gen()
            sage: H = [(z5^4 + z5^3 + z5^2 + 1, z5^4 + z5^3 + z5^2 + 1, z5^3 + z5^2, z5^4 + z5^3, z5^2 + 1, 0, z5^4 + z5^2),\
             (0, z5^3 + 1, z5^4 + z5^3, 0, z5^3 + z5^2, z5^4 + z5^2, z5^4 + z5^2),\
             (0, 0, 0, z5^4 + z5^3 + z5^2 + 1, z5^4 + z5^2, z5^4 + z5^3 + z5^2 + 1, z5^2 + 1),\
             (z5^4 + 1, z5^4 + 1, z5^4 + z5^3, z5^3 + z5^2, z5^2 + 1, z5^3 + z5^2, z5^4 + z5^3),\
             (z5^4 + 1, z5^3 + z5^2, z5^4 + 1, z5^3 + 1, z5^4 + z5^3, z5^3 + z5^2, z5^3 + 1)]
            sage: C = codes.LRPCCode(GF(q**m), n, k, d, parity_check_matrix=matrix(H)); C
            [7, 2, 3] LRPC code over GF(32)/GF(2)
            sage: D = C.decoder()
            sage: e = C.find_e_of_rank(r); x = C.random_element(); y = x + e; e # random
            (z5^3, 0, 0, z5^3, 0, 0, z5^3)
            sage: s, S = D.syndrome_space_computation(y);
            sage: E = D.recover_error_support(S); E # random
            Vector space of degree 5 and dimension 1 over Finite Field of size 2
            Basis matrix:
            [0 0 0 1 0]
            sage: F = C.support_of_parity(); F
            Vector space of degree 5 and dimension 3 over Finite Field of size 2
            Basis matrix:
            [1 0 0 0 1]
            [0 0 1 0 1]
            [0 0 0 1 1]
            sage: D.compute_product_space(E, F) # random
            Vector space of degree 5 and dimension 3 over Finite Field of size 2
            Basis matrix:
            [0 0 1 1 1]
            [1 0 0 0 1]
            [0 1 1 1 1]

            sage: q = 2; n = 7; k = 2; m = 5; d = 2; r = 1
            sage: C = codes.LRPCCode(GF(2**m), n, k, d); D = C.decoder();
            sage: e = C.find_e_of_rank(r);
            sage: x = C.random_element(); y = x + e;
            sage: s, S = D.syndrome_space_computation(y); s # random
            (z5^4 + z5^3 + z5^2 + z5, z5^3 + z5^2 + z5 + 1, z5^4 + z5^3 + z5^2 + z5, z5^4 + 1, z5^3 + z5^2 + z5 + 1)
            sage: S # random
            Vector space of degree 5 and dimension 2 over Finite Field of size 2
            Basis matrix:
            [1 0 0 0 1]
            [0 1 1 1 1]
            sage: E = D.recover_error_support(S); E # random
            Vector space of degree 5 and dimension 1 over Finite Field of size 2
            Basis matrix:
            [0 0 0 0 1]
            sage: F = C.support_of_parity()
            sage: D.compute_product_space(E, F) # random
            Vector space of degree 5 and dimension 2 over Finite Field of size 2
            Basis matrix:
            [1 0 0 0 1]
            [0 1 1 1 1]
        """
        C = self.code()
        partE = [C.poly_form_of_vector(E.gens()[i], C.base_field()) for i in range(len(E.gens()))];
        partF = [C.poly_form_of_vector(F.gens()[i], C.base_field()) for i in range(len(F.gens()))];
        p = [vector(e*f) for f in partF for e in partE];
        return span(p, already_echelonized=True);

    def compute_A_H_r(self, hijv, r):
        r"""
        The `(n-k)rd \times nr` matrix `A_H^r` allows to rewrite the system `He^t = s` in the
        base field `\mathbb{F}_q`. `A_H^r` does not depend on `e`, just on its rank ``r``.

        The description of this matrix `A_H^r` is given in Definition 5 in [GMRZ2013]_.

        INPUT:

        - ``hijv`` -- the matrix `h_{ijv}`, parity check matrix `H` rewritten in `F`

        - ``r`` -- the rank of the error vector `e`

        EXAMPLES::

            sage: q = 2; n = 7; k = 2; m = 5; d = 3; r = 1
            sage: z5 = GF(q**m).gen()
            sage: H = [(z5^4 + z5^3 + z5^2 + 1, z5^4 + z5^3 + z5^2 + 1, z5^3 + z5^2, z5^4 + z5^3, z5^2 + 1, 0, z5^4 + z5^2),\
             (0, z5^3 + 1, z5^4 + z5^3, 0, z5^3 + z5^2, z5^4 + z5^2, z5^4 + z5^2),\
             (0, 0, 0, z5^4 + z5^3 + z5^2 + 1, z5^4 + z5^2, z5^4 + z5^3 + z5^2 + 1, z5^2 + 1),\
             (z5^4 + 1, z5^4 + 1, z5^4 + z5^3, z5^3 + z5^2, z5^2 + 1, z5^3 + z5^2, z5^4 + z5^3),\
             (z5^4 + 1, z5^3 + z5^2, z5^4 + 1, z5^3 + 1, z5^4 + z5^3, z5^3 + z5^2, z5^3 + 1)]
            sage: C = codes.LRPCCode(GF(q**m), n, k, d, parity_check_matrix=matrix(H)); C
            [7, 2, 3] LRPC code over GF(32)/GF(2)
            sage: D = C.decoder()
            sage: hijv = C.parity_in_support(); hijv
            [[(1, 1, 1), (1, 1, 1), (0, 1, 1), (0, 0, 1), (1, 1, 0), (0, 0, 0), (0, 1, 0)],
             [(0, 0, 0), (1, 0, 1), (0, 0, 1), (0, 0, 0), (0, 1, 1), (0, 1, 0), (0, 1, 0)],
             [(0, 0, 0), (0, 0, 0), (0, 0, 0), (1, 1, 1), (0, 1, 0), (1, 1, 1), (1, 1, 0)],
             [(1, 0, 0), (1, 0, 0), (0, 0, 1), (0, 1, 1), (1, 1, 0), (0, 1, 1), (0, 0, 1)],
             [(1, 0, 0), (0, 1, 1), (1, 0, 0), (1, 0, 1), (0, 0, 1), (0, 1, 1), (1, 0, 1)]]
            sage: AHr = D.compute_A_H_r(hijv, r); AHr
            [1 1 0 0 1 0 0]
            [1 1 1 0 1 0 1]
            [1 1 1 1 0 0 0]
            [0 1 0 0 0 0 0]
            [0 0 0 0 1 1 1]
            [0 1 1 0 1 0 0]
            [0 0 0 1 0 1 1]
            [0 0 0 1 1 1 1]
            [0 0 0 1 0 1 0]
            [1 1 0 0 1 0 0]
            [0 0 0 1 1 1 0]
            [0 0 1 1 0 1 1]
            [1 0 1 1 0 0 1]
            [0 1 0 0 0 1 0]
            [0 1 0 1 1 1 1]

            sage: q = 2; n = 5; k = 1; m = 5; d = 2; r = 1
            sage: z5 = GF(q**m).gen()
            sage: H = [(z5^4 + z5^3 + z5^2 + 1, 0, z5^4 + z5^3 + z5^2 + 1, z5^4 + z5^3 + z5, 0), \
            (z5^4 + z5^3 + z5^2 + 1, z5^4 + z5^3 + z5, 0, z5^4 + z5^3 + z5^2 + 1, z5^4 + z5^3 + z5),\
            (0, 0, z5^4 + z5^3 + z5, z5^4 + z5^3 + z5, 0), \
            (0, z5^4 + z5^3 + z5, 0, z5^4 + z5^3 + z5, z5^4 + z5^3 + z5^2 + 1)]
            sage: C = codes.LRPCCode(GF(q**m), n, k, d, parity_check_matrix=matrix(H)); C
            [5, 1, 2] LRPC code over GF(32)/GF(2)
            sage: D = C.decoder(); D
            Basic LRPC syndrome decoder for [5, 1, 2] LRPC code over GF(32)/GF(2)
            sage: hijv = C.parity_in_support(); hijv
            [[(1, 0), (0, 0), (1, 0), (0, 1), (0, 0)],
             [(1, 0), (0, 1), (0, 0), (1, 0), (0, 1)],
             [(0, 0), (0, 0), (0, 1), (0, 1), (0, 0)],
             [(0, 0), (0, 1), (0, 0), (0, 1), (1, 0)]]
            sage: AHr = D.compute_A_H_r(hijv, r); AHr
            [1 0 1 0 0]
            [0 0 0 1 0]
            [1 0 0 1 0]
            [0 1 0 0 1]
            [0 0 0 0 0]
            [0 0 1 1 0]
            [0 0 0 0 1]
            [0 1 0 1 0]
        """
        C = self.code()
        d = C.rank()
        n = C.length()
        k = C.dimension()
        temp = [[0 for j in range(n*r)] for i in range((n-k)*r*d)]

        for u in range(r):
            for i in range(n-k):
                for j in range(n):
                    for v in range(d):
                        temp[u + v*r + i*r*d][u + j*r] = hijv[i][j][v]

        return matrix(C.sub_field(), temp)

    def get_decoding_matrix(self, AHr, r):
        r"""
        Return the decoding matrix for a specific rank.

        INPUT:

        - ``AHr`` -- the matrix `A_H^r`

        - ``r`` -- the rank of the error vector

        EXAMPLES::

            sage: q = 2; n = 7; k = 2; m = 5; d = 3; r = 1
            sage: z5 = GF(q**m).gen()
            sage: H = [(z5^4 + z5^3 + z5^2 + 1, z5^4 + z5^3 + z5^2 + 1, z5^3 + z5^2, z5^4 + z5^3, z5^2 + 1, 0, z5^4 + z5^2),\
             (0, z5^3 + 1, z5^4 + z5^3, 0, z5^3 + z5^2, z5^4 + z5^2, z5^4 + z5^2),\
             (0, 0, 0, z5^4 + z5^3 + z5^2 + 1, z5^4 + z5^2, z5^4 + z5^3 + z5^2 + 1, z5^2 + 1),\
             (z5^4 + 1, z5^4 + 1, z5^4 + z5^3, z5^3 + z5^2, z5^2 + 1, z5^3 + z5^2, z5^4 + z5^3),\
             (z5^4 + 1, z5^3 + z5^2, z5^4 + 1, z5^3 + 1, z5^4 + z5^3, z5^3 + z5^2, z5^3 + 1)]
            sage: C = codes.LRPCCode(GF(q**m), n, k, d, parity_check_matrix=matrix(H)); C
            [7, 2, 3] LRPC code over GF(32)/GF(2)
            sage: D = C.decoder()
            sage: hijv = C.parity_in_support(); hijv
            [[(1, 1, 1), (1, 1, 1), (0, 1, 1), (0, 0, 1), (1, 1, 0), (0, 0, 0), (0, 1, 0)],
             [(0, 0, 0), (1, 0, 1), (0, 0, 1), (0, 0, 0), (0, 1, 1), (0, 1, 0), (0, 1, 0)],
             [(0, 0, 0), (0, 0, 0), (0, 0, 0), (1, 1, 1), (0, 1, 0), (1, 1, 1), (1, 1, 0)],
             [(1, 0, 0), (1, 0, 0), (0, 0, 1), (0, 1, 1), (1, 1, 0), (0, 1, 1), (0, 0, 1)],
             [(1, 0, 0), (0, 1, 1), (1, 0, 0), (1, 0, 1), (0, 0, 1), (0, 1, 1), (1, 0, 1)]]
            sage: AHr = D.compute_A_H_r(hijv, r); AHr
            [1 1 0 0 1 0 0]
            [1 1 1 0 1 0 1]
            [1 1 1 1 0 0 0]
            [0 1 0 0 0 0 0]
            [0 0 0 0 1 1 1]
            [0 1 1 0 1 0 0]
            [0 0 0 1 0 1 1]
            [0 0 0 1 1 1 1]
            [0 0 0 1 0 1 0]
            [1 1 0 0 1 0 0]
            [0 0 0 1 1 1 0]
            [0 0 1 1 0 1 1]
            [1 0 1 1 0 0 1]
            [0 1 0 0 0 1 0]
            [0 1 0 1 1 1 1]
            sage: DH = D.get_decoding_matrix(AHr, r); DH
            [0 0 1 0 1 1 1]
            [0 0 0 1 0 0 0]
            [1 0 1 0 1 0 1]
            [1 0 1 1 0 1 0]
            [1 0 1 1 1 1 1]
            [1 1 0 1 1 1 0]
            [0 1 1 0 1 0 1]
        """
        if self._D_H[r] == None:
            self.compute_D_H(AHr, r)
        return self._D_H[r]

    def compute_D_H(self, AHr, r):
        r"""
        Compute the decoding matrix `D_H` of parity check matrix H, by finding an
        `nr \times nr` invertible submatrix of `A_H^r`. Using this matrix `D_H`,
        the `nr` values `e_{ij}` can be recovered by simple matrix multiplication.
        See Definition 6 in [GMRZ2013]_. This function has no output, but stores
        `D_H` in the decoder's decoding matrices list.

        INPUT:

        - ``AHr`` -- the matrix `A_H^r`

        - ``r`` -- the rank of the error vector

        TESTS:

        This function does not have a return value, but it gives an error message if the
        decoding matrix `D_H` does not exist for this ``AHr``::

            sage: q = 2; n = 5; k = 1; m = 5; d = 2; r = 1
            sage: z5 = GF(q**m).gen()
            sage: H = [(z5^4 + z5^3 + z5^2 + 1, 0, z5^4 + z5^3 + z5^2 + 1, z5^4 + z5^3 + z5, 0), \
            (z5^4 + z5^3 + z5^2 + 1, z5^4 + z5^3 + z5, 0, z5^4 + z5^3 + z5^2 + 1, z5^4 + z5^3 + z5),\
            (0, 0, z5^4 + z5^3 + z5, z5^4 + z5^3 + z5, 0), \
            (0, z5^4 + z5^3 + z5, 0, z5^4 + z5^3 + z5, z5^4 + z5^3 + z5^2 + 1)]
            sage: C = codes.LRPCCode(GF(q**m), n, k, d, parity_check_matrix=matrix(H)); C
            [5, 1, 2] LRPC code over GF(32)/GF(2)
            sage: D = C.decoder(); D
            Basic LRPC syndrome decoder for [5, 1, 2] LRPC code over GF(32)/GF(2)
            sage: hijv = C.parity_in_support(); hijv
            [[(1, 0), (0, 0), (1, 0), (0, 1), (0, 0)],
             [(1, 0), (0, 1), (0, 0), (1, 0), (0, 1)],
             [(0, 0), (0, 0), (0, 1), (0, 1), (0, 0)],
             [(0, 0), (0, 1), (0, 0), (0, 1), (1, 0)]]
            sage: AHr = D.compute_A_H_r(hijv, r); AHr
            [1 0 1 0 0]
            [0 0 0 1 0]
            [1 0 0 1 0]
            [0 1 0 0 1]
            [0 0 0 0 0]
            [0 0 1 1 0]
            [0 0 0 0 1]
            [0 1 0 1 0]
            sage: D.compute_D_H(AHr, r);
            Traceback (most recent call last):
            ...
            ValueError: There is no invertible submatrix available for these parameters.
        """
        nr = AHr.dimensions()[1]
        for i in range(AHr.dimensions()[0]-nr):
            A = AHr.submatrix(i, 0, nr, nr)
            try:
                D = A.inverse()
                self._D_H[r] = D
                break
            except ZeroDivisionError:
                continue
        if self._D_H[r] == None:
            raise ValueError("There is no invertible submatrix available for these parameters.")

    def _flatten(self, A):
        r"""
        Flatten list ``A``.

        INPUT:

        - ``A`` -- the list of lists to be flattened

        EXAMPLES::

            sage: q = 2; n = 7; k = 2; m = 5; d = 3; r = 1
            sage: z5 = GF(q**m).gen()
            sage: H = [(z5^4 + z5^3 + z5^2 + 1, z5^4 + z5^3 + z5^2 + 1, z5^3 + z5^2, z5^4 + z5^3, z5^2 + 1, 0, z5^4 + z5^2),\
             (0, z5^3 + 1, z5^4 + z5^3, 0, z5^3 + z5^2, z5^4 + z5^2, z5^4 + z5^2),\
             (0, 0, 0, z5^4 + z5^3 + z5^2 + 1, z5^4 + z5^2, z5^4 + z5^3 + z5^2 + 1, z5^2 + 1),\
             (z5^4 + 1, z5^4 + 1, z5^4 + z5^3, z5^3 + z5^2, z5^2 + 1, z5^3 + z5^2, z5^4 + z5^3),\
             (z5^4 + 1, z5^3 + z5^2, z5^4 + 1, z5^3 + 1, z5^4 + z5^3, z5^3 + z5^2, z5^3 + 1)]
            sage: C = codes.LRPCCode(GF(q**m), n, k, d, parity_check_matrix=matrix(H)); C
            [7, 2, 3] LRPC code over GF(32)/GF(2)
            sage: D = C.decoder()
            sage: hijv = C.parity_in_support(); hijv
            [[(1, 1, 1), (1, 1, 1), (0, 1, 1), (0, 0, 1), (1, 1, 0), (0, 0, 0), (0, 1, 0)],
             [(0, 0, 0), (1, 0, 1), (0, 0, 1), (0, 0, 0), (0, 1, 1), (0, 1, 0), (0, 1, 0)],
             [(0, 0, 0), (0, 0, 0), (0, 0, 0), (1, 1, 1), (0, 1, 0), (1, 1, 1), (1, 1, 0)],
             [(1, 0, 0), (1, 0, 0), (0, 0, 1), (0, 1, 1), (1, 1, 0), (0, 1, 1), (0, 0, 1)],
             [(1, 0, 0), (0, 1, 1), (1, 0, 0), (1, 0, 1), (0, 0, 1), (0, 1, 1), (1, 0, 1)]]
            sage: D._flatten(hijv)
            [(1, 1, 1),
             (1, 1, 1),
             (0, 1, 1),
             (0, 0, 1),
             (1, 1, 0),
             (0, 0, 0),
             (0, 1, 0),
             (0, 0, 0),
             (1, 0, 1),
             (0, 0, 1),
             (0, 0, 0),
             (0, 1, 1),
             (0, 1, 0),
             (0, 1, 0),
             (0, 0, 0),
             (0, 0, 0),
             (0, 0, 0),
             (1, 1, 1),
             (0, 1, 0),
             (1, 1, 1),
             (1, 1, 0),
             (1, 0, 0),
             (1, 0, 0),
             (0, 0, 1),
             (0, 1, 1),
             (1, 1, 0),
             (0, 1, 1),
             (0, 0, 1),
             (1, 0, 0),
             (0, 1, 1),
             (1, 0, 0),
             (1, 0, 1),
             (0, 0, 1),
             (0, 1, 1),
             (1, 0, 1)]
        """
        B = []
        for i in range(len(A)):
            for j in range(len(A[0])):
                B += [A[i][j]]
        return B

    def _failure_probability(self, r):
        r"""
        The probability of failure is given in Theorem 1 of "Low Rank Parity Check
        Codes and their Application to Cryptography".

        INPUT:
        - ``AHr`` -- the matrix `A_H^r`

        - ``r`` -- the rank of the error vector

        EXAMPLES::

            sage: q = 2; n = 7; k = 2; m = 5; d = 3; r = 1
            sage: C = codes.LRPCCode(GF(q**m), n, k, d); D = C.decoder();
            sage: D._failure_probability(r)
            1/8
        """
        C = self.code()
        n = C.length()
        k = C.dimension()
        d = C.rank()
        q = C.characteristic()
        return q**-(n-k+1-r*d)

    def _decode(self, y, r):
        r"""
        Probabilistic decoding algorithm described in [GMRZ2013]_, in particular Section 4 and 5.

        As defined in [GMRZ2013]_, from the matrix `A_H^r` we can compute the decoding matrix of `H`, `D_H`.
        This decoding matrix is only dependent of the rank weight ``r`` of the error, hence we can keep
        a list with all decoding matrices for all possible ranks of the error. Then we only have to compute
        `D_H` once when decoding multiple received ``y`` with the same error weight.

        INPUT:

        - ``y`` -- the received word

        - ``r`` -- the rank of the error

        EXAMPLES::

            sage: q = 2; n = 7; k = 2; m = 5; d = 3; r = 1
            sage: z5 = GF(q**m).gen()
            sage: H = [(z5^4 + z5^3 + z5^2 + 1, z5^4 + z5^3 + z5^2 + 1, z5^3 + z5^2, z5^4 + z5^3, z5^2 + 1, 0, z5^4 + z5^2),\
             (0, z5^3 + 1, z5^4 + z5^3, 0, z5^3 + z5^2, z5^4 + z5^2, z5^4 + z5^2),\
             (0, 0, 0, z5^4 + z5^3 + z5^2 + 1, z5^4 + z5^2, z5^4 + z5^3 + z5^2 + 1, z5^2 + 1),\
             (z5^4 + 1, z5^4 + 1, z5^4 + z5^3, z5^3 + z5^2, z5^2 + 1, z5^3 + z5^2, z5^4 + z5^3),\
             (z5^4 + 1, z5^3 + z5^2, z5^4 + 1, z5^3 + 1, z5^4 + z5^3, z5^3 + z5^2, z5^3 + 1)]
            sage: C = codes.LRPCCode(GF(q**m), n, k, d, parity_check_matrix=matrix(H)); C
            [7, 2, 3] LRPC code over GF(32)/GF(2)
            sage: D = C.decoder()
            sage: e = C.find_e_of_rank(r); x = C.random_element(); y = x + e;
            sage: x_found, a = D._decode(y,r)
            Probability of failure with these parameters is 1/8
            sage: x_found == x
            True
            sage: G = C.generator_matrix()
            sage: a == x/G
            True

            sage: q = 2; n = 5; k = 1; m = 5; d = 2; r = 1
            sage: z5 = GF(q**m).gen()
            sage: H = [(z5^2 + 1, z5^2 + 1, z5^4 + z5 + 1, 0, z5^4 + z5^2 + z5), \
             (z5^2 + 1, 0, z5^4 + z5 + 1, z5^4 + z5^2 + z5, z5^4 + z5 + 1), \
             (z5^4 + z5^2 + z5, z5^2 + 1, 0, z5^2 + 1, z5^4 + z5^2 + z5), \
             (z5^4 + z5^2 + z5, z5^2 + 1, z5^4 + z5 + 1, z5^4 + z5 + 1, 0)]
            sage: C = codes.LRPCCode(GF(q**m), n, k, d, parity_check_matrix=matrix(H)); C
            [5, 1, 2] LRPC code over GF(32)/GF(2)
            sage: D = C.decoder(); D
            Basic LRPC syndrome decoder for [5, 1, 2] LRPC code over GF(32)/GF(2)
            sage: e = C.find_e_of_rank(r); x = C.random_element(); y = x + e;
            sage: x_found, a = D._decode(y,r)
            Probability of failure with these parameters is 1/8
            sage: x_found == x
            True
            sage: G = C.generator_matrix()
            sage: a == x/G
            True
        """
        C = self.code()
        H = C.parity_check_matrix()
        G = C.generator_matrix()
        F = C.support_of_parity();
        d = F.rank();
        n = C.length()
        k = C.dimension()

        print("Probability of failure with these parameters is " + str(self._failure_probability(r)))

        # Step 1) Syndrome space computation.
        s, S = self.syndrome_space_computation(y)

        # Step 2) Recovering the error support.
        E = self.recover_error_support(S)
        if E.dimension() != r:
            raise ValueError("The dimension of the computed error support is not correct. ")

        # Step 3) Compute the product space `P` and rewrite the syndrome in terms of `P`.
        P = self.compute_product_space(E, F)
        if P.dimension() != r*d:
            raise ValueError("The dimension of the computed product space is not correct. ")

        s_prime = vector(self._flatten([C.rewrite_in_basis(elem, P.basis()) for elem in s]))

        # Step 4) Set up the left side of the system and solve it.

        # If there is already a decoding matrix for this ``r``, we can solve the system directly.
        if self._D_H[r] != None:
            i = 0
            while i < ((n-k)*r*d - n*r):
                e_prime = self._D_H[r] * s_prime[i:i+n*r]
                i += 1
                M = matrix(E.basis())
                e = vector([C.poly_form_of_vector(e_prime[i:i+r]*M, C.base_field()) for i in range(0, len(e_prime), r)])
                if C.rank_weight_of_vector(e) == r:
                    x = y - e
                    try:
                        return x, x/G
                    except ValueError:
                        continue

        # Otherwise, we compute `A_H^r` and try to find `D_H`. Then we can either solve the system using `D_H` if it exists,
        # or with `A_H^r`.
        else:
            hijv = C.parity_in_support()
            AHr = self.compute_A_H_r(hijv, r)

            DH = self.get_decoding_matrix(AHr, r)
            if DH != None:
                i = 0
                # Decoding with DH is successful if we take the correct nr values for `s'`. Try different parts of `s'`
                # until a solution is found of correct rank ``r``.
                while i < ((n-k)*r*d - n*r):
                    e_prime = self._D_H[r] * s_prime[i:i+n*r]
                    i += 1
                    M = matrix(E.basis())
                    e = vector([C.poly_form_of_vector(e_prime[i:i+r]*M, C.base_field()) for i in range(0, len(e_prime), r)])
                    if C.rank_weight_of_vector(e) == r:
                        x = y - e
                        try:
                            return x, x/G
                        except ValueError:
                            continue
            else:
                e_prime = AHr.solve_right(s_prime)
                M = matrix(E.basis())
                e = vector([C.poly_form_of_vector(e_prime[i:i+r]*M, C.base_field()) for i in range(0, len(e_prime), r)])
                x = y - e
                return x, x/G


    def decode_to_code(self, y, r):
        r"""
        Decode the received vector to the original codeword.

        INPUT:

        - ``y`` -- the received word

        - ``r`` -- the rank of the error

        EXAMPLES::

            sage: q = 2; n = 7; k = 2; m = 5; d = 3; r = 1
            sage: z5 = GF(q**m).gen()
            sage: H = [(z5^4 + z5^3 + z5^2 + 1, z5^4 + z5^3 + z5^2 + 1, z5^3 + z5^2, z5^4 + z5^3, z5^2 + 1, 0, z5^4 + z5^2),\
             (0, z5^3 + 1, z5^4 + z5^3, 0, z5^3 + z5^2, z5^4 + z5^2, z5^4 + z5^2),\
             (0, 0, 0, z5^4 + z5^3 + z5^2 + 1, z5^4 + z5^2, z5^4 + z5^3 + z5^2 + 1, z5^2 + 1),\
             (z5^4 + 1, z5^4 + 1, z5^4 + z5^3, z5^3 + z5^2, z5^2 + 1, z5^3 + z5^2, z5^4 + z5^3),\
             (z5^4 + 1, z5^3 + z5^2, z5^4 + 1, z5^3 + 1, z5^4 + z5^3, z5^3 + z5^2, z5^3 + 1)]
            sage: C = codes.LRPCCode(GF(q**m), n, k, d, parity_check_matrix=matrix(H)); C
            [7, 2, 3] LRPC code over GF(32)/GF(2)
            sage: D = C.decoder()
            sage: e = C.find_e_of_rank(r); x = C.random_element(); y = x + e;
            sage: x_found = D.decode_to_code(y,r)
            Probability of failure with these parameters is 1/8
            sage: x_found == x
            True

            sage: q = 2; n = 5; k = 1; m = 5; d = 2; r = 1
            sage: z5 = GF(q**m).gen()
            sage: H = [(z5^2 + 1, z5^2 + 1, z5^4 + z5 + 1, 0, z5^4 + z5^2 + z5), \
             (z5^2 + 1, 0, z5^4 + z5 + 1, z5^4 + z5^2 + z5, z5^4 + z5 + 1), \
             (z5^4 + z5^2 + z5, z5^2 + 1, 0, z5^2 + 1, z5^4 + z5^2 + z5), \
             (z5^4 + z5^2 + z5, z5^2 + 1, z5^4 + z5 + 1, z5^4 + z5 + 1, 0)]
            sage: C = codes.LRPCCode(GF(q**m), n, k, d, parity_check_matrix=matrix(H)); C
            [5, 1, 2] LRPC code over GF(32)/GF(2)
            sage: D = C.decoder(); D
            Basic LRPC syndrome decoder for [5, 1, 2] LRPC code over GF(32)/GF(2)
            sage: e = C.find_e_of_rank(r); x = C.random_element(); y = x + e;
            sage: x_found = D.decode_to_code(y,r)
            Probability of failure with these parameters is 1/8
            sage: x_found == x
            True
        """
        return self._decode(y, r)[0]

    def decode_to_message(self, y, r):
        r"""
        Decode the received vector to the original message.

        INPUT:

        - ``y`` -- the received word

        - ``r`` -- the rank of the error

        EXAMPLES::

            sage: q = 2; n = 7; k = 2; m = 5; d = 3; r = 1
            sage: z5 = GF(q**m).gen()
            sage: H = [(z5^4 + z5^3 + z5^2 + 1, z5^4 + z5^3 + z5^2 + 1, z5^3 + z5^2, z5^4 + z5^3, z5^2 + 1, 0, z5^4 + z5^2),\
             (0, z5^3 + 1, z5^4 + z5^3, 0, z5^3 + z5^2, z5^4 + z5^2, z5^4 + z5^2),\
             (0, 0, 0, z5^4 + z5^3 + z5^2 + 1, z5^4 + z5^2, z5^4 + z5^3 + z5^2 + 1, z5^2 + 1),\
             (z5^4 + 1, z5^4 + 1, z5^4 + z5^3, z5^3 + z5^2, z5^2 + 1, z5^3 + z5^2, z5^4 + z5^3),\
             (z5^4 + 1, z5^3 + z5^2, z5^4 + 1, z5^3 + 1, z5^4 + z5^3, z5^3 + z5^2, z5^3 + 1)]
            sage: C = codes.LRPCCode(GF(q**m), n, k, d, parity_check_matrix=matrix(H)); C
            [7, 2, 3] LRPC code over GF(32)/GF(2)
            sage: D = C.decoder()
            sage: e = C.find_e_of_rank(r); x = C.random_element(); y = x + e;
            sage: G = C.generator_matrix()
            sage: a_found = D.decode_to_message(y,r);
            Probability of failure with these parameters is 1/8
            sage: a_found == x/G
            True

            sage: q = 2; n = 5; k = 1; m = 5; d = 2; r = 1
            sage: z5 = GF(q**m).gen()
            sage: H = [(z5^2 + 1, z5^2 + 1, z5^4 + z5 + 1, 0, z5^4 + z5^2 + z5), \
             (z5^2 + 1, 0, z5^4 + z5 + 1, z5^4 + z5^2 + z5, z5^4 + z5 + 1), \
             (z5^4 + z5^2 + z5, z5^2 + 1, 0, z5^2 + 1, z5^4 + z5^2 + z5), \
             (z5^4 + z5^2 + z5, z5^2 + 1, z5^4 + z5 + 1, z5^4 + z5 + 1, 0)] \
            sage: C = codes.LRPCCode(GF(q**m), n, k, d, parity_check_matrix=matrix(H)); C
            [5, 1, 2] LRPC code over GF(32)/GF(2)
            sage: D = C.decoder(); D
            Basic LRPC syndrome decoder for [5, 1, 2] LRPC code over GF(32)/GF(2)
            sage: e = C.find_e_of_rank(r); x = C.random_element(); y = x + e;
            sage: G = C.generator_matrix()
            sage: a_found = D.decode_to_message(y,r);
            Probability of failure with these parameters is 1/8
            sage: a_found == x/G
            True
        """
        return self._decode(y, r)[1]


############################## registration ####################################

LRPCCode._registered_encoders["GeneratorMatrix"] = LRPCCodeGeneratorMatrixEncoder
LRPCCode._registered_decoders['SyndromeDecoder'] = LRPCBasicSyndromeDecoder