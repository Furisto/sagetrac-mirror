# -*- coding: utf-8 -*-
r"""
Cuspidal subgroups of modular abelian varieties

AUTHORS:

- William Stein (2007-03, 2008-02)

EXAMPLES: We compute the cuspidal subgroup of `J_1(13)`::

    sage: A = J1(13)
    sage: C = A.cuspidal_subgroup(); C
    Finite subgroup with invariants [19, 19] over QQ of Abelian variety J1(13) of dimension 2
    sage: C.gens()
    [[(1/19, 0, 0, 9/19)], [(0, 1/19, 1/19, 18/19)]]
    sage: C.order()
    361
    sage: C.invariants()
    [19, 19]

We compute the cuspidal subgroup of `J_0(54)`::

    sage: A = J0(54)
    sage: C = A.cuspidal_subgroup(); C
    Finite subgroup with invariants [3, 3, 3, 3, 3, 9] over QQ of Abelian variety J0(54) of dimension 4
    sage: C.gens()
    [[(1/3, 0, 0, 0, 0, 1/3, 0, 2/3)], [(0, 1/3, 0, 0, 0, 2/3, 0, 1/3)], [(0, 0, 1/9, 1/9, 1/9, 1/9, 1/9, 2/9)], [(0, 0, 0, 1/3, 0, 1/3, 0, 0)], [(0, 0, 0, 0, 1/3, 1/3, 0, 1/3)], [(0, 0, 0, 0, 0, 0, 1/3, 2/3)]]
    sage: C.order()
    2187
    sage: C.invariants()
    [3, 3, 3, 3, 3, 9]

We compute the subgroup of the cuspidal subgroup generated by
rational cusps.

::

    sage: C = J0(54).rational_cusp_subgroup(); C
    Finite subgroup with invariants [3, 3, 9] over QQ of Abelian variety J0(54) of dimension 4
    sage: C.gens()
    [[(1/3, 0, 0, 1/3, 2/3, 1/3, 0, 1/3)], [(0, 0, 1/9, 1/9, 7/9, 7/9, 1/9, 8/9)], [(0, 0, 0, 0, 0, 0, 1/3, 2/3)]]
    sage: C.order()
    81
    sage: C.invariants()
    [3, 3, 9]

This might not give us the exact rational torsion subgroup, since
it might be bigger than order `81`::

    sage: J0(54).rational_torsion_subgroup().multiple_of_order()
    243

TESTS::

    sage: C = J0(54).cuspidal_subgroup()
    sage: loads(dumps(C)) == C
    True
    sage: D = J0(54).rational_cusp_subgroup()
    sage: loads(dumps(D)) == D
    True
"""

###########################################################################
#       Copyright (C) 2007 William Stein <wstein@gmail.com>               #
#  Distributed under the terms of the GNU General Public License (GPL)    #
#                  http://www.gnu.org/licenses/                           #
###########################################################################

from finite_subgroup                import FiniteSubgroup
from sage.rings.all                 import infinity, QQ, gcd, ZZ
from sage.rings.arith               import euler_phi
from sage.rings.arith               import number_of_divisors
from sage.matrix.all                import matrix, diagonal_matrix
from sage.modular.arithgroup.all    import is_Gamma0
from sage.modular.cusps             import Cusp
from sage.structure.element         import ModuleElement
from sage.structure.formal_sum      import FormalSum


class CuspidalSubgroup_generic(FiniteSubgroup):
    def _compute_lattice(self, rational_only=False, rational_subgroup=False):
        r"""
        Return a list of vectors that define elements of the rational
        homology that generate this finite subgroup.

        INPUT:


        -  ``rational_only`` - bool (default: False); if
           ``True``, only use rational cusps.


        OUTPUT:


        -  ``list`` - list of vectors


        EXAMPLES::

            sage: J = J0(37)
            sage: C = sage.modular.abvar.cuspidal_subgroup.CuspidalSubgroup(J)
            sage: C._compute_lattice()
            Free module of degree 4 and rank 4 over Integer Ring
            Echelon basis matrix:
            [  1   0   0   0]
            [  0   1   0   0]
            [  0   0   1   0]
            [  0   0   0 1/3]
            sage: J = J0(43)
            sage: C = sage.modular.abvar.cuspidal_subgroup.CuspidalSubgroup(J)
            sage: C._compute_lattice()
            Free module of degree 6 and rank 6 over Integer Ring
            Echelon basis matrix:
            [  1   0   0   0   0   0]
            [  0 1/7   0 6/7   0 5/7]
            [  0   0   1   0   0   0]
            [  0   0   0   1   0   0]
            [  0   0   0   0   1   0]
            [  0   0   0   0   0   1]
            sage: J = J0(22)
            sage: C = sage.modular.abvar.cuspidal_subgroup.CuspidalSubgroup(J)
            sage: C._compute_lattice()
            Free module of degree 4 and rank 4 over Integer Ring
            Echelon basis matrix:
            [1/5 1/5 4/5   0]
            [  0   1   0   0]
            [  0   0   1   0]
            [  0   0   0 1/5]
            sage: J = J1(13)
            sage: C = sage.modular.abvar.cuspidal_subgroup.CuspidalSubgroup(J)
            sage: C._compute_lattice()
            Free module of degree 4 and rank 4 over Integer Ring
            Echelon basis matrix:
            [ 1/19     0     0  9/19]
            [    0  1/19  1/19 18/19]
            [    0     0     1     0]
            [    0     0     0     1]

        We compute with and without the optional
        ``rational_only`` option.

        ::

            sage: J = J0(27); G = sage.modular.abvar.cuspidal_subgroup.CuspidalSubgroup(J)
            sage: G._compute_lattice()
            Free module of degree 2 and rank 2 over Integer Ring
            Echelon basis matrix:
            [1/3   0]
            [  0 1/3]
            sage: G._compute_lattice(rational_only=True)
            Free module of degree 2 and rank 2 over Integer Ring
            Echelon basis matrix:
            [1/3   0]
            [  0   1]
        """
        A = self.abelian_variety()
        Cusp = A.modular_symbols()
        Amb  = Cusp.ambient_module()
        Eis  = Amb.eisenstein_submodule()

        C = Amb.cusps()
        N = Amb.level()

        if rational_subgroup:
            # QQ-rational subgroup of cuspidal subgroup
            assert A.is_ambient()
            Q = Cusp.abvarquo_rational_cuspidal_subgroup()
            return Q.V()

        if rational_only:
            # subgroup generated by differences of rational cusps
            if not is_Gamma0(A.group()):
                raise NotImplementedError('computation of rational cusps only implemented in Gamma0 case.')
            if not N.is_squarefree():
                data = [n for n in range(2,N) if gcd(n,N) == 1]
                C = [c for c in C if is_rational_cusp_gamma0(c, N, data)]

        v = [Amb([infinity, alpha]).element() for alpha in C]
        cusp_matrix = matrix(QQ, len(v), Amb.dimension(), v)

        # TODO -- refactor something out here
        # Now we project onto the cuspidal part.
        B = Cusp.free_module().basis_matrix().stack(Eis.free_module().basis_matrix())
        X = B.solve_left(cusp_matrix)
        X = X.matrix_from_columns(range(Cusp.dimension()))
        lattice = X.row_module(ZZ) + A.lattice()
        return lattice

class CuspidalSubgroup(CuspidalSubgroup_generic):
    """
    EXAMPLES::

        sage: a = J0(65)[2]
        sage: t = a.cuspidal_subgroup()
        sage: t.order()
        6
    """
    def _repr_(self):
        """
        String representation of the cuspidal subgroup.

        EXAMPLES::

            sage: G = J0(27).cuspidal_subgroup()
            sage: G._repr_()
            'Finite subgroup with invariants [3, 3] over QQ of Abelian variety J0(27) of dimension 1'
        """
        return "Cuspidal subgroup %sover QQ of %s"%(self._invariants_repr(), self.abelian_variety())


    def lattice(self):
        """
        Returned cached tuple of vectors that define elements of the
        rational homology that generate this finite subgroup.

        OUTPUT:


        -  ``tuple`` - cached


        EXAMPLES::

            sage: J = J0(27)
            sage: G = J.cuspidal_subgroup()
            sage: G.lattice()
            Free module of degree 2 and rank 2 over Integer Ring
            Echelon basis matrix:
            [1/3   0]
            [  0 1/3]

        Test that the result is cached::

            sage: G.lattice() is G.lattice()
            True
        """
        try:
            return self.__lattice
        except AttributeError:
            lattice = self._compute_lattice(rational_only = False)
            self.__lattice = lattice
            return lattice


class RationalCuspSubgroup(CuspidalSubgroup_generic):
    """
    EXAMPLES::

        sage: a = J0(65)[2]
        sage: t = a.rational_cusp_subgroup()
        sage: t.order()
        6
    """
    def _repr_(self):
        """
        String representation of the cuspidal subgroup.

        EXAMPLES::

            sage: G = J0(27).rational_cusp_subgroup()
            sage: G._repr_()
            'Finite subgroup with invariants [3] over QQ of Abelian variety J0(27) of dimension 1'
        """
        return "Subgroup generated by differences of rational cusps %sover QQ of %s"%(self._invariants_repr(), self.abelian_variety())


    def lattice(self):
        """
        Return lattice that defines this group.

        OUTPUT: lattice

        EXAMPLES::

            sage: G = J0(27).rational_cusp_subgroup()
            sage: G.lattice()
            Free module of degree 2 and rank 2 over Integer Ring
            Echelon basis matrix:
            [1/3   0]
            [  0   1]

        Test that the result is cached.

        ::

            sage: G.lattice() is G.lattice()
            True
        """
        try:
            return self.__lattice
        except AttributeError:
            lattice = self._compute_lattice(rational_only = True)
            self.__lattice = lattice
            return lattice

class RationalCuspidalSubgroup(CuspidalSubgroup_generic):
    """
    EXAMPLES::

        sage: a = J0(65)[2]
        sage: t = a.rational_cuspidal_subgroup()
        sage: t.order()
        6
    """
    def _repr_(self):
        """
        String representation of the cuspidal subgroup.

        EXAMPLES::

            sage: G = J0(27).rational_cuspidal_subgroup()
            sage: G._repr_()
            'Finite subgroup with invariants [3] over QQ of Abelian variety J0(27) of dimension 1'
        """
        return "Rational cuspidal subgroup %sover QQ of %s"%(self._invariants_repr(), self.abelian_variety())

    def lattice(self):
        """
        Return lattice that defines this group.

        OUTPUT: lattice

        EXAMPLES::

            sage: G = J0(27).rational_cuspidal_subgroup()
            sage: G.lattice()
            Free module of degree 2 and rank 2 over Integer Ring
            Echelon basis matrix:
            [1/3   0]
            [  0   1]

        Test that the result is cached.

        ::

            sage: G.lattice() is G.lattice()
            True
        """
        try:
            return self.__lattice
        except AttributeError:
            lattice = self._compute_lattice(rational_subgroup = True)
            self.__lattice = lattice
            return lattice

def is_rational_cusp_gamma0(c, N, data):
    """
    Return True if the rational number c is a rational cusp of level N.
    This uses remarks in Glenn Steven's Ph.D. thesis.

    INPUT:


    -  ``c`` - a cusp

    -  ``N`` - a positive integer

    -  ``data`` - the list [n for n in range(2,N) if
       gcd(n,N) == 1], which is passed in as a parameter purely for
       efficiency reasons.


    EXAMPLES::

        sage: from sage.modular.abvar.cuspidal_subgroup import is_rational_cusp_gamma0
        sage: N = 27
        sage: data = [n for n in range(2,N) if gcd(n,N) == 1]
        sage: is_rational_cusp_gamma0(Cusp(1/3), N, data)
        False
        sage: is_rational_cusp_gamma0(Cusp(1), N, data)
        True
        sage: is_rational_cusp_gamma0(Cusp(oo), N, data)
        True
        sage: is_rational_cusp_gamma0(Cusp(2/9), N, data)
        False
    """
    num = c.numerator()
    den = c.denominator()
    for d in data:
        if not c.is_gamma0_equiv(Cusp(num, d*den), N):
            return False
    return True


class RationalCuspidalSubgroupLigozat(FiniteSubgroup):
    r"""
    This class calculates the cuspidal subgroup of `J_0(N)` using
    Ligozat's formula, as described in [Yaz]_.

    Let `V` be the vector space generated by cusps and invariant under
    Galois action, and `W` be the vector space generated by modular
    functions under multiplications with divisors supported on the
    cusps. Ligozat's thesis [Ligo]_ gives a description of `W` explicitly,
    along with the divisors attached to each such function.

    Here we denote `\Lambda:V \rightarrow W` such that
    `\Lambda^{-1}(f)` is the principal divisor attached to the
    modular function `f`. Under these hypothesis, the condition for
    an integral element `v \in V` to be a principal divisor is equivalent to
    the following four conditions:

    1) `v\Lambda` is integral
    2) `v` is of degree 0
    3) `v` is Galois invariant
    4) Some parity condition to insure that an invariant is a perfect square

    We denote `V_i` to be the lattice attached to condition `i`, and
    the rational cuspidal subgroup of `J` is given by the lattice
    `V_1 \cap V_2` modulo `\cap V_i`.

    EXAMPLES::

        sage: J = J0(15)
        sage: C = J.rational_cuspidal_subgroup_ligozat()
        sage: C
        Finite subgroup with invariants (2, 4) over QQ of Abelian variety J0(15) of dimension 1

    REFERENCES:

    .. [Ligo] Gérard Ligozat, Courbes modulaires de genre 1.
       Mémoires de la Société Mathématique de France, 43 (1975), p. 5-80,
       http://www.numdam.org/item?id=MSMF_1975__43__5_0

    .. [Yaz] Soroosh Yazdani, Modular Abelian varieties of odd modular degree.
       Algebra & Number Theory, 5 (2011), p. 37-62,
       http://msp.org/ant/2011/5-1/p02.xhtml
    """

    def _compute_lambda(self):
        r"""
        This computes the matrix `\Lambda:V \rightarrow W`.

        This is done prime by prime `\Lambda_p:V_p \rightarrow W_p`,
        where `V_p=\span(P_{p^r} | (p^r | N)` and `W_p =
        \span(\eta_{p^r})` where `\eta_n(\tau)=\eta(n\tau)` and `\eta`
        is the modular `\eta` function. Here `P_{p^r}` is the Galois
        stable divisor of degree `1` of cusps in the conjugacy class
        `{i \over p^r}`.  We have `V=\Otimes V_p` and `W=\otimes W_p`
        with the obvious identifications (`\otimes
        P_{p_i^{s_i}}=P_{\prod p_i^{s_i}}`).

        Under these identifications `Lambda` is given by a tridiagonal
        matrix, and the map `\Lambda:V \rightarrow W` is given
        by `24 \Otimes \Lambda_p`.

        TESTS::

            sage: J = J0(15)
            sage: C = J.rational_cuspidal_subgroup_ligozat()
            sage: C._compute_lambda()
            [15/8 -3/8|-5/8  1/8]
            [-3/8 15/8| 1/8 -5/8]
            [---------+---------]
            [-5/8  1/8|15/8 -3/8]
            [ 1/8 -5/8|-3/8 15/8]

            sage: J = J0(25)
            sage: C = J.rational_cuspidal_subgroup_ligozat()
            sage: C._compute_lambda()
            [    1  -1/5     0]
            [ -1/4 13/10  -1/4]
            [    0  -1/5     1]
        """
        ret = matrix(1, 1, [24])
        for p, f in self.level().factor():
            # Create the tridiagonal matrix \Lambda_p.
            Lp = {}
            Lp[(0, 0)] = p*(p-1)
            Lp[(0,1)] = 1-p
            Lp[(f, f)] = p*(p-1)
            Lp[(f, f-1)] = 1-p
            for i in range(1, f):
                Lp[(i, i-1)] = -p
                Lp[(i, i)] = p**2+1
                Lp[(i, i+1)] = -p

            Lambda_p = matrix(f+1, f+1, Lp)/((p**2-1)*euler_phi(p**f))
            ret = ret.tensor_product(Lambda_p)

        return ret

    def _compute_P_d_integral(self):
        r"""
        This function calculates the module of integral elements in
        `V`.

        This is generated by `n P_d` where `n` is the number of
        cusps `{i \over d}` in the same conjugacy class.

        This is implemented as tensor product (even though there are
        more direct approaches for it) to be consistent with the algorithm
        in [Yaz]_.

        TESTS::

            sage: J = J0(25)
            sage: C = J.rational_cuspidal_subgroup_ligozat()
            sage: C._compute_P_d_integral()
            Sparse free module of degree 3 and rank 3 over Integer Ring
            Echelon basis matrix:
            [1 0 0]
            [0 4 0]
            [0 0 1]
        """
        Vb = matrix(1, 1, [1])
        for p, f in self.level().factor():
            Vp = diagonal_matrix([euler_phi(p**min(i, f-i))
                                  for i in range(f+1)])
            Vb = Vb.tensor_product(Vp)

        return Vb.row_module()

    def _compute_parity_module(self):
        r"""
        This computes the elements in `W` that satisfy the
        parity condition (4) of Ligozat [Ligo]_
        (Proposition 1.3, (5) in [Yaz].)

        In particular, if `\eta_d` is in the module that is returned,
        then `\prod_{d | n} d^{\eta_d}` will be a perfect square.

        TESTS::

            sage: J = J0(25)
            sage: C = J.rational_cuspidal_subgroup_ligozat()
            sage: C._compute_parity_module()
            Free module of degree 3 and rank 3 over Integer Ring
            Echelon basis matrix:
            [1 0 0]
            [0 2 0]
            [0 0 1]

            sage: J = J0(15)
            sage: C = J.rational_cuspidal_subgroup_ligozat()
            sage: C._compute_parity_module()
            Free module of degree 4 and rank 4 over Integer Ring
            Echelon basis matrix:
            [1 0 0 0]
            [0 1 1 1]
            [0 0 2 0]
            [0 0 0 2]
        """
        facs = self.level().factor()

        pars = []
        for q, _ in facs:
            par_i = matrix(1, 1, [1])
            for p, f in facs:
                if p == q:
                    f_i = matrix(1, 1+f, [i % 2 for i in range(f+1)])
                    par_i = par_i.tensor_product(f_i)
                else:
                    e_i = matrix(1, 1+f, [1 for i in range(f+1)])
                    par_i = par_i.tensor_product(e_i)
            pars.append(par_i.list())

        psi = matrix(pars).transpose()

        Zn = ZZ**psi.ncols()
        ZnEven = (Zn.matrix()*2).row_module(ZZ)
        W = ZZ**psi.nrows()
        Psi = W.Hom(Zn)(psi)

        return Psi.inverse_image(ZnEven)

    def V0(self):
        r"""
        Return integral degree zero divisors on cusps that are
        Galois invariant.

        EXAMPLES::

            sage: J = J0(15)
            sage: C = J.rational_cuspidal_subgroup_ligozat()
            sage: C.V0()
            Free module of degree 4 and rank 3 over Integer Ring
            Echelon basis matrix:
            [ 1  0  0 -1]
            [ 0  1  0 -1]
            [ 0  0  1 -1]

            sage: J = J0(25)
            sage: C = J.rational_cuspidal_subgroup_ligozat()
            sage: C.V0()
            Free module of degree 3 and rank 2 over Integer Ring
            Echelon basis matrix:
            [ 1  0 -1]
            [ 0  4 -4]
        """
        try:
            return self.__V0
        except AttributeError:
            pass

        # V2 the degree zero lattice
        d = number_of_divisors(self.level())
        V = ZZ**d
        deg = V.Hom(ZZ**1)([1 for _ in range(d)])
        V2 = deg.inverse_image((ZZ**1).span([]))

        # V3 is the lattice of integral cuspidal divisors invariant under Galois
        V3 = self._compute_P_d_integral()

        self.__V0 = V2.intersection(V3)
        return self.__V0


    def Vprincipal(self):
        r"""
        Return the module of principal divisors generated by
        modular functions that are product of `\eta` functions.

        EXAMPLES::

            sage: J = J0(25)
            sage: C = J.rational_cuspidal_subgroup_ligozat()
            sage: C.Vprincipal()
            Free module of degree 3 and rank 2 over Integer Ring
            Echelon basis matrix:
            [ 1  0 -1]
            [ 0  4 -4]

            sage: J = J0(15)
            sage: C = J.rational_cuspidal_subgroup_ligozat()
            sage: C.Vprincipal()
            Free module of degree 4 and rank 3 over Integer Ring
            Echelon basis matrix:
            [ 1  1  3 -5]
            [ 0  2  0 -2]
            [ 0  0  4 -4]
        """
        try:
            return self.__Vprincipal
        except AttributeError:
            pass

        L = self._compute_lambda()
        d = L.nrows()

        V = ZZ**d
        W = L.row_module(ZZ)

        # V1 is the inverse image of Lambda^{-1}(Z^n)
        lamb = V.Hom(W)(L.rows())
        V1 = lamb.inverse_image(W.ambient_module())

        # V4 is the lattice satisfying the parity condition
        Weven = self._compute_parity_module().intersection(W)
        V4 = lamb.inverse_image(Weven)

        self.__Vprincipal = self.V0().intersection(V1).intersection(V4)
        return self.__Vprincipal

    def module(self):
        r"""
        Return the underlying module for the cuspidal subgroup.

        EXAMPLES::

            sage: J = J0(15)
            sage: C = J.rational_cuspidal_subgroup_ligozat()
            sage: C.module()
            Finitely generated module V/W over Integer Ring with invariants (2, 4)
        """
        try:
            return self.__module
        except AttributeError:
            self.__module = self.V0() / self.Vprincipal()
            return self.__module

    def gens(self):
        r"""
        Return the generators of the rational cuspidal subgroup.

        EXAMPLES::

            sage: J = J0(15)
            sage: C = J.rational_cuspidal_subgroup_ligozat()
            sage: C.gens()
            [-P15 + P5, -P15 + P3]
        """
        return [RationalCuspidalPoint(self, v) for v in self.module().gens()]

    def invariants(self):
        r"""
        Return the invariants of the rational cuspidal subgroup.

        EXAMPLES::

            sage: J = J0(15)
            sage: C = J.rational_cuspidal_subgroup_ligozat()
            sage: C.invariants()
            (2, 4)
        """
        return self.module().invariants()

    def level(self):
        r"""
        Return the level of the ambient Abelian variety.

        EXAMPLES::

            sage: J = J0(15)
            sage: C = J.rational_cuspidal_subgroup_ligozat()
            sage: C.level()
            15
        """
        return self.abelian_variety().level()


class RationalCuspidalPoint(ModuleElement):
    def __init__(self, parent, element, check=False):
        r"""
        An element of a rational cuspidal subgroup of a modular Abelian variety.

        INPUT:

        - ``parent`` - a subgroup of the cuspidal subgroup of
          `J_0(N)`

        - ``element`` - an element in the quotient module of degree zero
          divisors of cusps modulo principal divisors.

        - ``check`` - bool (default: False) whether to check
          that element is in the appropriate module

        EXAMPLES::

            sage: J = J0(15)
            sage: C = J.rational_cuspidal_subgroup_ligozat()
            sage: C.0
            -P15 + P5
            sage: (C.0).additive_order()
            2
        """
        ModuleElement.__init__(self, parent)
        if check:
            raise NotImplemented

        self._N = parent.level()
        cuspname = matrix(1, 1, [1])
        for p, f in self._N.factor():
            cuspname = cuspname.tensor_product(matrix(1, f+1, [p**i for i in range(f+1)]))
        self.__cuspnames = cuspname.list()
        self.__element = element

    def element(self):
        r"""
        Return the element in the quotient module.

        EXAMPLES::

            sage: J = J0(15)
            sage: C = J.rational_cuspidal_subgroup_ligozat()
            sage: v = (C.0).element()
            sage: v
            (1, 0)
            sage: v.parent()
            Finitely generated module V/W over Integer Ring with invariants (2, 4)
        """
        return self.__element

    def _repr_(self):
        r"""
        Return the text representing the cusp.

        EXAMPLES::

            sage: J = J0(15)
            sage: C = J.rational_cuspidal_subgroup_ligozat()
            sage: C.0
            -P15 + P5
        """
        vbar = self.element()
        L = vbar.lift().list()
        replist = []
        for i in range(len(L)):
            if L[i] != 0:
                replist.append((L[i], "P"+str(self.__cuspnames[i])))
        return FormalSum(replist)._repr_()

    def _add_(self, other):
        r"""
        Adds two elements in the cuspidal subgroup.

        EXAMPLES::

            sage: J = J0(15)
            sage: C = J.rational_cuspidal_subgroup_ligozat()
            sage: C.0 + C.1
            -2*P15 + P3 + P5
        """
        return RationalCuspidalPoint(self.parent(),
                                     self.__element + other.__element)

    def _sub_(self, other):
        r"""
        Substracts two elements in the cuspidal subgroup.

        EXAMPLES::

            sage: J = J0(15)
            sage: C = J.rational_cuspidal_subgroup_ligozat()
            sage: C.0-C.1
            -4*P15 + 3*P3 + P5
        """
        return RationalCuspidalPoint(self.parent(),
                                     self.__element - other.__element)

    def _neg_(self):
        r"""
        Return the negative of the element.

        EXAMPLES::

            sage: J = J0(15)
            sage: C = J.rational_cuspidal_subgroup_ligozat()
            sage: C.0
            -P15 + P5
            sage: -C.0
            -P15 + P5
            sage: C.1
            -P15 + P3
            sage: -C.1
            -3*P15 + 3*P3
        """
        return RationalCuspidalPoint(self.parent(), -self.__element )

    def _rmul_(self, left):
        r"""
        Return the product of self by left.

        EXAMPLES::

            sage: J = J0(15)
            sage: J = J0(15)
            sage: C = J.rational_cuspidal_subgroup_ligozat()
            sage: C.0
            -P15 + P5
            sage: 2*C.0
            0
            sage: 3*C.0
            -P15 + P5
        """
        return RationalCuspidalPoint(self.parent(),
                                     ZZ(left) * self.__element)

    def _lmul_(self, right):
        r"""
        Return the product of self by right.

        EXAMPLES::

            sage: J = J0(15)
            sage: C = J.rational_cuspidal_subgroup_ligozat()
            sage: C.0
            -P15 + P5
            sage: (C.0)*2
            0
            sage: (C.0)*3
            -P15 + P5
        """
        return RationalCuspidalPoint(self.parent(),
                                     self.__element * ZZ(right))

    def __eq__(self, other):
        r"""
        Check if two elements are the same.

        EXAMPLES::

            sage: J = J0(15)
            sage: C = J.rational_cuspidal_subgroup_ligozat()
            sage: pt = C.0
            sage: pt == (pt*2)
            False
            sage: pt == (pt*3)
            True
        """
        if self.parent().abelian_variety() != other.parent().abelian_variety():
            return False
        return self.element() == other.element()

    def __ne__(self, other):
        r"""
        Check if two elements are different.

        EXAMPLES::

            sage: J = J0(15)
            sage: C = J.rational_cuspidal_subgroup_ligozat()
            sage: pt = C.0
            sage: pt != (pt*2)
            True
            sage: pt != (pt*3)
            False
        """
        return not( self == other )


    def additive_order(self):
        r"""
        Return the additive order of self.

        EXAMPLES::

            sage: J = J0(15)
            sage: C = J.rational_cuspidal_subgroup_ligozat()
            sage: (C.0).additive_order()
            2
            sage: (C.1).additive_order()
            4
        """
        return self.element().additive_order()
