r"""
Origami

An origami is:

- a couple of permutations

- a covering of the torus ramified over one point

- gluing of squares

- Abelian differential on Riemann surface with rational periods

EXAMPLES::

    sage: E = origamis.EierlegendeWollmilchsau()
    sage: E.r()
    (1,2,3,4)(5,6,7,8)
    sage: E.u()
    (1,5,3,7)(2,8,4,6)
    sage: E.stratum_component()
    H_3(1^4)^c
    sage: E.lyapunov_exponents_approx()   # abs tol 1e-3
    [0.0000485630931783940, 0.0000452662733371477]

    sage: o = Origami('(1,2,3,4,5,6)','(1,7)')
    sage: V = o.veech_group()
    sage: V
    Arithmetic subgroup of index 54
    sage: G = V.coset_graph()
    sage: G.diameter()
    16
"""
from origami_dense import Origami_dense_pyx

from sage.structure.sage_object import SageObject
from sage.groups.perm_gps.permgroup import PermutationGroup
from sage.groups.perm_gps.permgroup import PermutationGroupElement
from sage.misc.cachefunc import cached_method
from copy import copy
from sage.matrix.constructor import matrix, identity_matrix

from sage.categories.finite_enumerated_sets import FiniteEnumeratedSets

from sage.rings.integer import Integer
from sage.modules.free_module import VectorSpace
from sage.rings.rational_field import QQ
from sage.structure.parent import Parent
from sage.structure.element import Element
from sage.structure.unique_representation import UniqueRepresentation

from sage.interfaces.gap import gap

from sage.plot.plot import options

def flatten_word(w):
    l = []
    for i,j in w:
        l.append(i*j)
    return ''.join(l)

def permutation_simplicial_action(r,u,n,w):
    r"""
    From a word in 'l','r' return the simplicial action on homology as
    well as the obtained origami.

    INPUT:

    - ``r`` and ``u`` - permutations

    - ``n`` - the degree of the permutations

    - ``w`` - a string in 'l' and 'r' or a list of 2-tuples which are made of
      the letter 'l' or 'r' and a positive integer

    """
    if w is None:
        w = []
    elif isinstance(w,list):
        w = flatten_word(w)

    res = identity_matrix(2*n)

    for letter in reversed(w):
        if letter == 'l':
            u = u*~r
            m = identity_matrix(2*n)
            m[:n,n:] = u.matrix()
            res = m * res
        elif letter == 'r':
            r = r*~u
            m = identity_matrix(2*n)
            m[n:,:n] = r.matrix()
            res = m * res
        else:
            raise ValueError, "does not understand the letter %s" %str(letter)

    return r,u,res

#
# Origami and pillow case cover constructors
#

def Origami(r, u,
        sparse=False,
        check=True,
        as_tuple=False,
        positions=None, name=None):
    r"""
    Constructor for origami

    INPUT:

    - ``r``, ``u`` - two permutations

    - ``sparse`` - boolean (default: False)

    - ``check`` - boolean (default: True) - whether or not check the input

    - ``as_tuple`` - boolean (default: False) - if True, assume that ``r`` and
      ``u`` are tuples on [0,...,N-1] (time efficient)

    - ``positions`` - list of 2-tuples (default: None) - position of the squares
      for drawings

    - ``name`` - an optional name to the origami

    """
    if not as_tuple:
        r = PermutationGroupElement(r, check=check)
        u = PermutationGroupElement(u, check=check)

        r = [i-1 for i in r.domain()]
        u = [i-1 for i in u.domain()]

        N = max(len(r),len(u))
        r.extend(xrange(len(r),N))
        u.extend(xrange(len(u),N))

    elif check:
        sr = set(r)
        su = set(u)
        N = len(r)
        if len(u) != N:
            raise ValueError, "the two tuples must be of the same length"
        for i in xrange(N):
            if not i in sr:
                raise ValueError, "%d is not in r=%s" %(i,str(r))
            if not i in su:
                raise ValueError, "%d is not in u=%s" %(i,str(u))

    o = Origami_dense(tuple(r),tuple(u))

    if check and not o.is_connected():
        print "Warning: the origami is not connected"

    if name is not None:
        o.rename(name)
    if positions is not None:
        o.set_positions(positions)
    return o

class Origami_dense(Origami_dense_pyx):
    r"""
    Dense origami

    A dense origami is represented by a couple ``(r,u)`` of permutations such
    that the group ``G = <r,u>`` generated by ``r`` and ``u`` acts transitively.
    The latter condition corresponds to the connectivity of the translation surface.

    EXAMPLES::

        sage: o = Origami('(1,2,3,4)(5,6)', '(1,3,5)(2,4,6)')
        sage: o
        (1,2,3,4)(5,6)
        (1,3,5)(2,4,6)
        sage: o.stratum_component()
        H_2(2)^hyp
        sage: o.veech_group().index()
        6
    """
    def as_graph(self):
        r"""
        Return the graph associated to self

        The graph associated to an origami is the graph on [1,...,N] for which
        the edges correspond to the action of the permutations `r` and `u`.

        EXAMPLES::

            sage: o=Origami('(1,2)','(1,3)')
            sage: G = o.as_graph(); G
            Looped multi-digraph on 3 vertices
            sage: G.vertices()
            [0, 1, 2]
            sage: G.edges()
            [(0, 1, 'r'), (0, 2, 'u'), (1, 0, 'r'), (1, 1, 'u'), (2, 0, 'u'), (2, 2, 'r')]
        """
        from sage.graphs.digraph import DiGraph

        G = DiGraph(multiedges=True,loops=True)
        N = self.nb_squares()
        r = self.r_tuple()
        u = self.u_tuple()
        for i in xrange(N):
            G.add_edge(i,r[i],'r')
            G.add_edge(i,u[i],'u')
        return G

    def is_connected(self):
        r"""
        Check whether the origami is connected or not

        It is equivalent to ask whether the group generated by `r` and `u` acts
        transitively on the `\{1,\dots,n\}`.

        EXAMPLES::

            sage: o = Origami('(1,2)','(1,3)')
            sage: o.is_connected()
            True
            sage: o = Origami('(1,2)(3,4)','(1,2)',check=False)
            sage: o.is_connected()
            False
        """
        return self.as_graph().is_connected()

    def connected_components(self):
        r"""
        Return the list of connected origami that composes this origami.
        """
        cc = self.as_graph().connected_components()
        r = self.r_tuple()
        u = self.u_tuple()
        if len(cc) == 1:
            return [self]
        l = []
        for c in cc:
            rr = [None] * len(c)
            uu = [None] * len(c)
            d = dict((c[i],i) for i in xrange(len(c)))
            for i in c:
                rr[d[i]] = d[r[i]]
                uu[d[i]] = d[u[i]]
            l.append(Origami(rr,uu,check=False,as_tuple=True))
        return l

    def is_isomorphic(self,other):
        r"""
        Isomorphism test

        EXAMPLES::

            sage: o1 = Origami('(1,2)','(1,3)')
            sage: o2 = Origami('(1,2)','(2,3)')
            sage: o3 = Origami('(1,3)','(1,2)')
            sage: o1.is_isomorphic(o2) and o2.is_isomorphic(o1)
            True
            sage: o1.is_isomorphic(o3) and o3.is_isomorphic(o1)
            True
            sage: o2.is_isomorphic(o3) and o3.is_isomorphic(o2)
            True
        """
        ss = self.relabel()
        oo = other.relabel()
        return (ss.r_tuple() == oo.r_tuple()) and (ss.u_tuple() == oo.u_tuple())

    #
    # Component of stratum
    #

    def stratum_component(self,verbose=False):
        r"""
        Return the component of stratum this origami belongs to.

        EXAMPLES::

            sage: o = Origami('(1,2)','(1,3)')
            sage: o.stratum_component()
            H_2(2)^hyp

            sage: r = '(1)(2)(3,4)(5,6,7,8)(9,10)'
            sage: u = '(1,2,3,5,6,10)(4,9)(7,8)'
            sage: Origami(r,u).stratum_component()
            H_4(2^3)^even
            sage: Origami(u,r).stratum_component()
            H_4(2^3)^even

            sage: r = '(1,2,3,4,5)(6,7,8,9,10)'
            sage: u = '(1,6)(2,10)(3,9)(4,8)(5,7)'
            sage: o = Origami(r,u)
            sage: o.stratum_component()
            H_5(4^2)^odd
        """
        return self.cylinder_diagram().stratum_component()

    #
    # Orientation quotient (quad. diff.)
    #

    def is_orientation_cover(self):
        r"""
        Return true if the origami is an orientation cover of a quadratic
        differential.

        It is equivalent to say that `-1` is in the Veech group.

        EXAMPLES::

            sage: o = Origami('(1,2)','(1,3)')
            sage: o.is_orientation_cover()
            True

            sage: r = '(1,2,3,4,5,6,7,8,9,10)'
            sage: u = '(3,5,7,9,4,8,10)'
            sage: o = Origami(r, u)
            sage: o.is_orientation_cover()
            False
        """
        return self.relabel() == self.inverse().relabel()

    is_quadratic_cover = is_orientation_cover

    def orientation_data(self,points=False,verbose=0):
        r"""
        Return the list of quadratic stratum and ramification data associated to
        the orientation quotients of this origami. If the origami is primitive,
        then there is at most one orientation quotient.

        Each element of the list is a 3-tuple containing:

        - a quadratic stratum

        - the list of degrees of zeros which are ramified in the covering
          (consider only integer points)

        - the partition of half-integers points which are mapped to poles
          (middle of squares, horizontal edges, vertical edges)

        INPUT:

        - ``points`` - boolean (default: False) - return singularitiy tuples and
          not only degrees

        EXAMPLES:

        The stratum H(2) contains two families of primitive origamis for an odd
        number of squares. Every surface in H(2) is a covering of a quadratic
        differential in Q(1,-1^5). The ramification data gives an invariant for
        those families::

            sage: o = Origami('(1,2,3,4,5)','(2,1)')
            sage: o.stratum_component()
            H_2(2)^hyp
            sage: o.orientation_data()
            [(Q_0(1, -1^5), (2,), (1, 3, 1))]
            sage: o = Origami('(1,2,3)','(1,4,5)')
            sage: o.stratum_component()
            H_2(2)^hyp
            sage: o.orientation_data()
            [(Q_0(1, -1^5), (2, 0, 0), (1, 1, 1))]

            sage: o = Origami('(1)(2)(3,4)(5,6,7)','(1,2,3)(4,5)(6)(7)')
            sage: o.stratum_component()
            H_3(4)^hyp
            sage: o.orientation_data()
            [(Q_0(3, -1^7), (0, 4, 0), (3, 1, 1))]
            sage: o = Origami('(1)(2)(3)(4,5)(6,7)','(1,2,3,4)(5,6,7)')
            sage: o.stratum_component()
            H_3(4)^hyp
            sage: o.orientation_data()
            [(Q_0(3, -1^7), (4,), (3, 1, 3))]
            sage: o = Origami('(1)(2)(3)(4,5)(6,7)','(1,2,3,4)(5,6)(7)')
            sage: o.stratum_component()
            H_3(4)^hyp
            sage: o.orientation_data()
            [(Q_0(3, -1^7), (4,), (5, 1, 1))]

            sage: o = Origami('(1,2,4)(3,6,5)','(1,3)(2,5)(4,6)')
            sage: for q,_,_ in o.orientation_data(): print q
            Q_1(4, -1^4)
            Q_1(4, -1^4)
            Q_1(4, -1^4)
            Q_0(1^2, -1^6)
        """
        sf1,m1 = self.to_standard_form(return_map=True)
        sf2,m2 = self.inverse().to_standard_form(return_map=True)

        # condition of being preserved by -Id (which means that there is a non
        # orientable automorphism)
        if sf1 != sf2:
            return []

        from sage.dynamics.flat_surfaces.quadratic_strata import QuadraticStratum

        m = m2 * ~m1  # one element which reverses orientation
        if verbose:
            print "m  =",m
        r = self.r()
        u = self.u()
        assert(m*r*~m == ~r and m*u*~m == ~u) # check

        rot_pi = r*u
        rot_2pi = r*u*~r*~u
        singularities = rot_2pi.cycle_tuples(singletons=True)
        degrees = {}
        for a in map(len, singularities):
            a=a-1
            if a:
                if a in degrees: degrees[a] += 1
                else: degrees[a] = 1

        res = []

        # consider all orientation reversing involutions
        G = self.automorphism_group()
        for g in G:
            mm = m * g # an automorphism which reverses the orientation
            if mm.order() > 2:
                continue

            if verbose:
                print "g  =",g
                print "mm =",mm

            # fixed points which are not integer points
            squares = []; h_edges = []; v_edges = []
            for i in xrange(1,self.nb_squares()+1):
                if mm(i) == i: squares.append(i)
                if mm(i) == u(i): h_edges.append(i)
                if mm(i) == r(i): v_edges.append(i)

            # fixed integer points
            vertices = []
            ramifications = dict((d,0) for d in degrees)
            ramifications[0] = 0
            for c in singularities:
                if rot_pi(c[len(c)//2]) == mm(c[0]):
                    vertices.append(c)
                    ramifications[len(c)-1] += 1

            if verbose:
                print "ramifications"
                print "  deg. of int. pts.",ramifications
                print "  h_edges",len(h_edges)
                print "  v_edges",len(v_edges)
                print "  centers",len(squares)

            qdegrees = dict((d-1,ramifications[d]) for d in ramifications)
            qdegrees[-1] += len(squares) + len(h_edges) + len(v_edges)
            qdegrees.update((2*d,(degrees[d]-ramifications[d])/2) for d in degrees)

            if points:
                res.append((
                    QuadraticStratum(qdegrees),
                    vertices,
                    (squares,h_edges,v_edges)))
            else:
                res.append((
                    QuadraticStratum(qdegrees),
                    tuple(len(c)-1 for c in vertices),
                    (len(squares),len(h_edges),len(v_edges))))

            if verbose:
                print " stratum", res[-1][0]
            assert(not res[-1][0].is_empty())  # check that the stratum is non empty!

        return res

    def is_hyperelliptic(self,stratum=False):
        r"""
        Return True if this origami is hyperelliptic

        If ``stratum`` is set to ``True``, then returns also the corresponding
        stratum of quadratic differentials this origami is a cover from.

        EXAMPLES::

            sage: o = Origami('(1,2)','(1,3)')
            sage: o.is_hyperelliptic()
            True
            sage: o.is_hyperelliptic(stratum=True)
            (True, Q_0(1, -1^5))

            sage: o = origamis.Podium([3,3,2,1])
            sage: o.is_hyperelliptic()
            False
            sage: o.is_hyperelliptic(stratum=True)
            (False, None)
        """
        for q,_,_ in self.orientation_data():
            if q.genus() == 0:
                if stratum:
                    return True,q
                return True

        if stratum:
            return False, None
        return False

    def to_pillowcase_cover(self):
        r"""
        Returns the corresponding pillow case cover (quadratic differential)

        Either the degree of the pillow case is the number of squares or the
        double.
        """
        r = self.r_tuple()
        r_inv = self.r_inv_tuple()
        u = self.u_tuple()
        u_inv = self.u_inv_tuple()

        oo = Origami(self.r()**2,self.u()**2)

        if oo.is_connected():
            n = self.nb_squares()
            g0 = [None] * (2*n)
            g1 = [None] * (2*n)
            g2 = [None] * (2*n)
            g3 = [None] * (2*n)

            for i in xrange(n):
                g0[2*i] = 2*u_inv[r_inv[i]]+1
                g1[2*i] = 2*u_inv[i]+1
                g2[2*i] = 2*i+1
                g3[2*i] = 2*r_inv[i]+1

                g0[2*i+1] = 2*u[r[i]]
                g1[2*i+1] = 2*u[i]
                g2[2*i+1] = 2*i
                g3[2*i+1] = 2*r[i]

            from pillowcase_cover import PillowCaseCover
            return PillowcaseCover(g0,g1,g2,g3,as_tuple=True)

        else:
            raise NotImplementedError("not implement for non connected origamis")

    #
    # Quotients and covers
    #

    def reduce(self):
        r"""
        Return a reduced origami isomorphic (up to SL(2,QQ) action) to that origami.

        EXAMPLES::

            sage: o = Origami('(1,2)(3,4)','(1,3,5,6)(2,4)')
            sage: o.lattice_of_periods()
            (1, 0, 2)
            sage: o.reduce()
            (1,2)(3)
            (1,3)(2)

            sage: o = Origami('(1,2)(3,4,5,6)','(1,3,5)(2,4,6)')
            sage: o.lattice_of_periods()
            (2, 0, 1)
            sage: o.reduce()
            (1)(2,3)
            (1,2,3)

            sage: o = Origami('(1,2)(3,4,5,6)','(1,3,4,5)(2,6)')
            sage: o.lattice_of_periods()
            (2, 1, 1)
            sage: o.reduce()
            (1)(2,3)
            (1,2,3)
        """
        N = self.nb_squares()
        w,t,h = self.lattice_of_periods() # ((w,0),(t,h))
        vol = h*w
        NN = N//vol

        # two trivial cases
        if NN == 1:
            return Origami('(1)','(1)')
        elif NN == N:
            return self

        # 1. find a square with some singularity in the bot-left corner
        r = self.r()
        u = self.u()
        v = (~r * ~u * r * u).cycle_tuples()

        # 2. then rebuild new permutation with pr and pu
        pr = r**w
        pu = r**t * u**h

        n = 1
        test = [v[0][0]]
        relabel = {v[0][0]:0}
        uu = [None] * NN
        rr = [None] * NN

        while test:
            i = test.pop()
            if i not in relabel:
                relabel[i] = n
                n += 1
            j = pr(i)
            if j not in relabel:
                test.append(j)
                relabel[j] = n
                n += 1
            rr[relabel[i]] = relabel[j]

            j = pu(i)
            if j not in relabel:
                test.append(j)
                relabel[j] = n
                n += 1
            uu[relabel[i]] = relabel[j]

        return Origami(rr,uu,as_tuple=True)

    def is_primitive(self,return_base=False):
        r"""
        An origami is primitive if it does not cover an other origami.

        An origami is primitive if the action of the monodromy group has no non
        trivial block.

        EXAMPLE::

            sage: o = Origami('(1,2)','(1,3)')
            sage: o.is_primitive()
            True
            sage: o = Origami('(1,2)(3,4)','(1,3,5,6)(2,4)')
            sage: o.is_primitive()
            False
        """
        from sage.rings.arith import is_prime
        if is_prime(self.nb_squares()):
            return True

        return bool(gap.IsPrimitive(self.monodromy()))

    def is_quasi_primitive(self):
        r"""
        An origami is quasi primitive if it is reduced and all intermediate
        covers are of genus 1.

        SEE ALSO:

            :meth:`is_primitive` and :meth:`is_reduced`

        EXAMPLES::

            sage: o = Origami('(1,2)(3,4)','(1,3)')
            sage: o.is_primitive()
            False
            sage: o.is_quasi_primitive()
            True

            sage: o = Origami('(1,2,3,4)(5)(6)','(1,5)(3,6)')
            sage: o.is_primitive()
            False
            sage: o.is_quasi_primitive()
            False
        """
        from sage.rings.arith import is_prime
        if is_prime(self.nb_squares()):
            return True

        #TODO: this is *very* stupid
        # there should be something more direct in gap
        return self.is_reduced() and all(o == self or o.genus() == 1 for o in self.lattice_of_quotients())

    def intermediate_covers(self, degree=None):
        r"""
        Return the list of intermediate covers of this origami.

        If ``degree`` is specified, only intermediate covers of given degree are
        returned.

        EXAMPLES::

            sage: o = Origami('(3,4,5)', '(1,2,3)(4,6,7)(5,8,9)')
            sage: for oo in o.intermediate_covers():
            ....:    print oo.nb_squares()
            ....:    print oo
            ....:    print "- - - - - -"
            1
            (1)
            (1)
            - - - - - -
            3
            (1)(2)(3)
            (1,2,3)
            - - - - - -
            9
            (1)(2)(3,4,5)(6)(7)(8)(9)
            (1,2,3)(4,6,7)(5,8,9)
            - - - - - -
            sage: o.intermediate_covers(degree=3)
            [(1)(2)(3)
            (1,2,3)]
        """
        G = self.monodromy()
        n = self.nb_squares()
        r = self.r()
        u = self.u()
        blocks = map(list, gap.AllBlocks(G))
        if degree is not None:
            degree = int(degree)
            n_div_d = n // degree
            if n%degree:
                raise ValueError("degree={} does not divide the number of squares n={}".format(degree,n))
            blocks = [b for b in blocks if len(b) == n_div_d]

        covers = []
        for b in blocks:
            orbit = gap.Orbit(G,b,gap.OnSets)
            action = gap.Action(G,orbit,gap.OnSets)
            rr,uu = gap.GeneratorsOfGroup(action)
            covers.append(Origami(rr,uu))
        if degree is None or degree == 1:
            covers.append(Origami([1],[1]))
        if degree is None or degree == n:
            covers.append(self)
        if degree is None:
            covers.sort(key=lambda o: o.nb_squares())
        return covers

    def lattice_of_quotients(self,verbose=False):
        r"""
        Return the lattice of quotients of this origami.

        The set of quotients of an origami contain a maximal element (itself)
        and a minimal element (the 1-torus). More generally, it is organised as
        a lattice.

        EXAMPLES::

            sage: o = Origami('(1,2)','(1,3)')
            sage: P = o.normal_cover().lattice_of_quotients(); P
            Finite lattice containing 6 elements
            sage: for p in P:
            ....:     print p.nb_squares(), p.stratum_component()
            6 H_3(2^2)^odd
            3 H_2(2)^hyp
            3 H_2(2)^hyp
            3 H_2(2)^hyp
            2 H_1(0)^hyp
            1 H_1(0)^hyp
        """
        from sage.combinat.posets.lattices import LatticePoset
        G = self.monodromy()
        n = self.nb_squares()
        r = self.r()
        u = self.u()
        blocks = list(gap("AllBlocks")(G))
        if verbose:
            print blocks
        d = {}
        for b in blocks:
            orbit = gap("Orbit")(G,b,gap("OnSets"))
            action = gap("Action")(G,orbit,gap("OnSets"))
            rr,uu = gap("GeneratorsOfGroup")(action)
            d[frozenset(map(Integer,b))] = Origami(rr,uu)
        d[frozenset(range(1,n+1))] = Origami([1],[1])
        d[frozenset([1])] = self
        if verbose:
            for i in d:
                print i,"->\n",d[i]
        E = d.values()
        R = [(d[i],d[j]) for i in d for j in d if i.issubset(j)]
        return LatticePoset((E,R))

    def is_regular(self):
        r"""
        An origami is regular if its automorphism group acts transitively on the
        squares.

        EXAMPLES::

            sage: o = origamis.EierlegendeWollmilchsau()
            sage: o.is_regular()
            True
            sage: o.is_normal()
            True

        ::

            sage: o = Origami('(1,3,2,4,5,6)','(1,5)')
            sage: o.is_regular()
            False
            sage: o.is_normal()
            False
        """
        return bool(gap.IsTransitive(
                        self.automorphism_group(),
                        gap("[1..%d]" %(self.nb_squares()))
                        ))

    def is_quasi_regular(self):
        r"""
        An origami `(r,u)` is *quasi-regular* if the normal closure of the
        commutator `c = rur^{-1}u^{-1}` is contained in the automorphism group.

        Equivalently, a quasi-regular origami is a translation surface which is
        a normal cover of a torus ramified over several rational points.
        """
        return self.quotient().genus() == 1
        # other method from Gap
        #G = self.monodromy()
        #A = self.automorphism_group()
        #r = self.r(); u = self.u()
        #C = G.subgroup([r*u*~r*~u])
        #NC = gap.NormalClosure(G,C)
        #return gap.IsSubgroup(A,NC)

    def is_normal(self):
        r"""
        Tests if this origami is a normal cover of the torus

        An origami is normal if the subgroup of `F_2` that defines the cover is
        normal. It is equivalent to say that the order of the automorphism group
        equals the number of squares or that the automorphism group acts
        transitively on the squares.

        EXAMPLES::

            sage: o = Origami('(1,2)','(1,3)')
            sage: o.is_normal()
            False
            sage: o.is_regular()
            False

            sage: o = origamis.Escalator(4)
            sage: o.is_normal()
            True
            sage: o.is_normal() == o.is_regular()
            True
        """
        return self.automorphism_group().order() == self.nb_squares()

    def cover(self, sr, su, check=True, as_tuple=False):
        r"""
        Build the (ramified) cover of this origami by sr and su

        INPUT:

        - `sr`, `su` - two list of N permutations where N is the number of
          squares of this origami

        - `check` - whether or not check the input

        - `as_tuple` - assume that sr and su are list of tuples of the same
          length and corresponds to permutations of [0,...,d-1] (much more
          efficient in time)

        EXAMPLES::

            sage: o = Origami('(1,2)','(1,3)'); o
            (1,2)(3)
            (1,3)(2)
            sage: o.cover(['(1,2)','',''],['','',''])
            (1,5,4,2)(3)(6)
            (1,3)(2)(4,6)(5)
        """
        from sage.groups.perm_gps.permgroup_named import SymmetricGroup

        N = self.nb_squares()
        if len(sr) != N or len(su) != N:
            raise ValueError, "sr and su should be two lists of length %d" %N

        r = self.r_tuple()
        u = self.u_tuple()

        if not as_tuple:
            sr = map(lambda x: [i-1 for i in PermutationGroupElement(x,check=check).domain()], sr)
            su = map(lambda x: [i-1 for i in PermutationGroupElement(x,check=check).domain()], su)

            d = max(len(x) for x in sr+su)

            for p in sr: p.extend(xrange(len(p),d))
            for p in su: p.extend(xrange(len(p),d))
        else:
            d = len(sr[0])

        rr = [None]*N*d
        uu = [None]*N*d

        for i in xrange(N):
            for j in xrange(d):
                rr[i+N*j] = r[i] + N*sr[i][j]
                uu[i+N*j] = u[i] + N*su[i][j]

        return Origami(rr,uu,check=check,as_tuple=True)

    def normal_cover(self):
        r"""
        Return the normal cover of this origami.
        """
        from itertools import imap
        G = self.monodromy()
        A = gap.Action(G,G,gap.OnRight)
        x,y = list(gap.GeneratorsOfGroup(A))
        return Origami(x,y)


    def rename(self, name):
        self._name = name

    #
    # Attribute access
    #

    def r(self):
        r"""
        Return the right permutation of the origami.

        EXAMPLES::

            sage: o = Origami('(1,2,3)','(1,2)')
            sage: o.r()
            (1,2,3)
        """
        return PermutationGroupElement([i+1 for i in self.r_tuple()],check=False)

    def r_inv(self):
        r"""
        Return the inverse of the right permutation

        EXAMPLES::

            sage: o = Origami('(1,2,3)','(1,2)')
            sage: o.r_inv()
            (1,3,2)
        """
        return PermutationGroupElement([i+1 for i in self.r_inv_tuple()],check=False)

    def u(self):
        r"""
        Return the up permutation of the origami

        EXAMPLES::

            sage: o = Origami('(1,2)','(1,2,3,4)')
            sage: o.u()
            (1,2,3,4)
        """
        return PermutationGroupElement([i+1 for i in self.u_tuple()],check=False)

    def u_inv(self):
        r"""
        Return the inverse of the up permutation of the origami

        EXAMPLES::

            sage: o = Origami('(1,2)','(1,2,3,4)')
            sage: o.u_inv()
            (1,4,3,2)
        """
        return PermutationGroupElement([i+1 for i in self.u_inv_tuple()],check=False)

    #
    # Autf(F2) and GL(2,Z) action
    #

    def apply_word(self,w):
        r"""
        Apply a word in l,r to self
        """
        o = copy(self)

        for letter in w[-1]:
            if letter[0] == 'l':
                o = o.horizontal_twist(letter[1])
            else:
                o = o.vertical_twist(letter[1])

        return o

    #
    # Automorphisms and quotients
    #

    def monodromy(self, relative=False):
        r"""
        Return the monodromy group of the origami.

        The monodromy group of an origami is the group generated by the
        permutations ``r`` and ``u`` from which it is defined.

        INPUT:

        - ``relative`` -- if ``True`` return the monodromy relative to the
          largest torus over which this origami is a cover (possibly ramified
          over several points)

        EXAMPLES::

            sage: o = Origami('(1,2)','(1,3)')
            sage: G = o.monodromy()
            sage: G
            Permutation Group with generators [(1,2), (1,3)]
            sage: G.order()
            6
        """
        from sage.groups.perm_gps.permgroup import PermutationGroup
        if relative is False or self.lattice_of_absolute_periods() == (1,0,1):
            return PermutationGroup([self.r(),self.u()], canonicalize=False)

        elif relative is True:
            from sage.interfaces.gap import gap
            d = self.optimal_degree()

            G = self.monodromy()
            B = map(list, gap.AllBlocks(G))
            B = [b for b in B if len(b) == d]
            if len(B) != 1:
                for b in B:
                    orbit = gap.Orbit(G,b,gap.OnSets)
                    action = gap.Action(G,orbit,gap.OnSets)
                    if gap.IsAbelian(action):
                        break
                else:
                    raise RuntimeError("an error occurred... please contact 20100.delecroix@gmail.com")
            else:
                b = B[0]
            H = gap.Stabilizer(G,b,gap.OnSets)
            action = gap.Action(H,b,gap.OnPoints)
            return PermutationGroup(list(gap.GeneratorsOfGroup(action)), canonicalize=False)
        else:
            raise ValueError("relative must be a boolean")

    def automorphism_group(self,positive=True):
        r"""
        Returns the automorphism group of the origami as a permutation group

        The automorpism group of a translation surface is the set of affine
        diffeomorphisms which have a trivial linear part. For an origami, it
        corresponds combinatorially to the centralizer of the group generated by
        the permutations ``r`` and ``u`` that define this origami.

        EXAMPLES:

        The L with 3 squares has no automorphisms::

            sage: o = Origami('(1,2)','(1,3)')
            sage: G = o.automorphism_group()
            sage: G.order()
            1

        The 4-squares square tiled surface in H(1,1) has non trivial
        automorphism for which the quotient is a torus with two squares::

            sage: o = Origami('(1,2)(3,4)','(2,3)')
            sage: G = o.automorphism_group()
            sage: G.order()
            2
            sage: oo = o.quotient(G)
            sage: oo
            (1,2)
            (1)(2)
            sage: oo.stratum(fake_zeros=True)
            H_1(0^2)
        """
        if positive == False:
            raise NotImplementedError, "not yet"

        from sage.all import SymmetricGroup
        Sn = SymmetricGroup(self.nb_squares())
        G = gap.Subgroup(Sn,[self.r(),self.u()])
        C = gap.Centralizer(Sn,G)
        return Sn.subgroup(list(gap.GeneratorsOfGroup(C)))

    translation_group = automorphism_group

    def quotient(self, H=None):
        r"""
        Returns a quotient of self by the group ``H``.

        The group ``H`` must be a subgroup of the automorphism group of this
        origami. If ``H`` is None, it is set by default to the full automorphism
        group.

        EXAMPLES::

            sage: o = Origami('(1,2)(3,4)','(2,3)')
            sage: G = o.automorphism_group()
            sage: G.order()
            2
            sage: oo = o.quotient(G)
            sage: print oo
            (1,2)
            (1)(2)
            sage: oo.genus()
            1
        """
        if H is None:
            H = self.translation_group()
        elif not H.is_subgroup(self.automorphism_group()):
            raise ValueError, "H must be a sub group of the automorphism group"

        classes = H.orbits()
        classes_inv = [None] * (self.nb_squares()+1)
        for i,c in enumerate(classes):
            for j in c:
                classes_inv[j] = i+1

        r = self.r()
        u = self.u()

        rr = []
        uu = []

        for c in classes:
            rr.append(classes_inv[r(c[0])])
            uu.append(classes_inv[u(c[0])])

        return Origami(rr,uu,check=False)

    #
    # Pickling
    #

    def __reduce__(self):
        r"""
        Pickling

        EXAMPLES::

            sage: o = Origami('(1,2)','(1,3)')
            sage: loads(dumps(o)) == o
            True
        """
        return Origami,(
                # r, u
                self.r_tuple(),self.u_tuple(),
                # sparse, check, as_tuple
                False,False,True,
                # positions, name
                getattr(self, '_pos', None),
                getattr(self, '__custom_name', None))

    #
    # String representation, latex and plot
    #

    def __str__(self):
        r"""
        String representation

        EXAMPLES::

            sage: print Origami('(1,2)','(1,3)').__str__()
            (1,2)(3)
            (1,3)(2)
            sage: print Origami('(1,2)','(1,3)',name='toto').__str__()
            (1,2)(3)
            (1,3)(2)
        """
        sr = self.r().cycle_string(singletons=True)
        su = self.u().cycle_string(singletons=True)
        return sr + "\n" + su


    def __repr__(self):
        if hasattr(self, '_name'):
            return self._name
        return self.__str__()

    def _latex_(self):
        r"""
        Latex representation of self

        EXAMPLES::

            sage: print Origami('(1,2)','(1,3)')._latex_()
            (1,2)(3) \atop (1,3)(2)
        """
        sr = self.r().cycle_string(singletons=True)
        su = self.u().cycle_string(singletons=True)
        return sr + " \\atop " + su

    def set_positions(self, pos):
        r"""
        Choose position of the squares for plotting

        set self._positions
        set self._lr_frontiers
        set self._tb_frontiers
        """
        r = self.r_tuple()
        u = self.u_tuple()
        if len(pos) != self.nb_squares():
            raise ValueError, "not enough positions"

        rl_frontiers = []
        tb_frontiers = []
        for i in xrange(self.nb_squares()):
            x,y = pos[i]
            xx,yy = pos[r[i]]
            if y != yy or x+1 != xx:
                rl_frontiers.append(i)

            xx,yy = pos[u[i]]
            if x != xx or y+1 != yy:
                tb_frontiers.append(i)

        self._pos = pos
        self._rl_frontiers = set(rl_frontiers)
        self._tb_frontiers = set(tb_frontiers)

    @options(
            side=True,side_color=(0.6,0.6,0.6),side_linestyle='dashed',side_alpha=0.8,
            frontier=True,frontier_color=(0.4,0.4,0.4),
            square=True,square_color=(0,0,1),square_alpha=0.1,
            text_square=True,text_square_color=(0,0,0),text_square_fontsize=11,
            text_frontier=True,text_frontier_color=(0.4,0.4,0.4),text_frontier_fontsize=8,
            vertex=True)
    def plot(self,**args):
        r"""
        Plot the normal form of self

        The positions of each square follow a naive algorithm. If you belive
        that a better picture exists look at the method .set_positions()

        EXAMPLES::

            sage: o = origamis.Escalator(3)
            sage: o.plot()
            Graphics object consisting of 71 graphics primitives
        """
        if not hasattr(self, '_pos'):
            # if not use cylinder diagram
            o = self.to_standard_form()
            cyls = o.cylinder_decomposition()
            H = 0
            pos = []
            for cyl in cyls:
                _,_,w,h,_,_ = cyl
                for j in xrange(h):
                    pos.extend((i,H) for i in xrange(w))
                    H += 1
                H += 0.5
            o.set_positions(pos)
            return o.plot()

        from sage.plot.plot import Graphics
        from sage.plot.polygon import polygon2d
        from sage.plot.line import line2d
        from sage.plot.text import text
        from sage.plot.colors import rainbow
        from sage.plot.point import point2d

        d = {
            'side': {},
            'frontier':{},
            'square':{},
            'text_square':{},
            'text_frontier':{}
            }
        for key,value in args.iteritems():
            for k in d.keys():
                if key.startswith(k + '_'):
                    d[k][key[len(k)+1:]] = value

        r = self.r_tuple()
        u = self.u_tuple()

        urvertices = {}
        dlvertices = {}
        vv = self.vertices()
        colors = rainbow(len(vv),'rgbtuple')
        for j in xrange(len(vv)):
            v = vv[j]
            for i in v.up_right_tuple():
                urvertices[i-1] = colors[j]
            for i in v.down_left_tuple():
                dlvertices[i-1] = colors[j]

        G = Graphics()
        for i in xrange(self.nb_squares()):
            x0,y0 = self._pos[i]
            x1 = x0+1; y1 = y0+1
            if args['square']:
                G += polygon2d([(x0,y0),(x1,y0),(x1,y1),(x0,y1)],**d['square'])
            if args['text_square']:
                G += text("%d" %(i+1),(x0+0.5,y0+0.5),**d['text_square'])

        for i in xrange(self.nb_squares()):
            x0,y0 = self._pos[i]
            x1 = x0+1; y1 = y0+1

            if i in self._rl_frontiers:
                xx0,yy0 = self._pos[r[i]]
                if args['frontier']:
                    G += line2d([(x1,y0),(x1,y1)],**d['frontier'])
                    G += line2d([(xx0,yy0),(xx0,yy0+1)],**d['frontier'])
                if args['text_frontier']:
                    G += text("%d" %(r[i]+1),(x1-0.08,y0+0.5),**d['text_frontier'])
                    G += text("%d" %(i+1),(xx0+0.08,yy0+0.5),**d['text_frontier'])
                if args['vertex'] and i in urvertices:
                    G += point2d((xx0,yy0+1),color=urvertices[i],pointsize=30)
                if args['vertex'] and r[i] in dlvertices:
                    G += point2d((x0+1,y0),color=dlvertices[r[i]],pointsize=30)
            else:
                G += line2d([(x1,y0),(x1,y1)],**d['side'])

            if i in self._tb_frontiers:
                xx0,yy0 = self._pos[u[i]]
                if args['frontier']:
                    G += line2d([(x0,y1),(x1,y1)],**d['frontier'])
                    G += line2d([(xx0,yy0),(xx0+1,yy0)],**d['frontier'])
                if args['text_frontier']:
                    G += text("%d" %(u[i]+1),(x0+0.5,y1-0.08),**d['text_frontier'])
                    G += text("%d" %(i+1),(xx0+0.5,yy0+0.08),**d['text_frontier'])
                if args['vertex'] and i in urvertices:
                    G += point2d((xx0+1,yy0),color=urvertices[i],pointsize=30)
                if args['vertex'] and u[i] in dlvertices:
                    G += point2d((x0,y0+1),color=dlvertices[u[i]],pointsize=30)
            else:
                if args['frontier']:
                    G += line2d([(x0,y1),(x1,y1)],**d['side'])

            if args['vertex'] and i in dlvertices:
                G += point2d((x0,y0),color=dlvertices[i],pointsize=30)
            if args['vertex'] and i in urvertices:
                G += point2d((x1,y1),color=urvertices[i],pointsize=30)

        G.axes(False)
        return G

    def show(self):
        r"""
        Show a picture of this origami.
        """
        self.plot().show(axes=False,aspect_ratio=1)

    #
    # standard form
    #


    #TODO
    def characteristic_cover(self):
        r"""
        Returns the characteristic cover of this origami
        """
        raise NotImplementedError

    #
    # Cylinder decomposition in horizontal direction
    #

    def cylinder_decomposition(self):
        r"""
        Returns the cylinder decomposition of the standard form of this origami.

        OUTPUT:

        A list of cylinders where each cylinder is a 6-tuple
        ``(bot,top,w,h,bot_twist,top_twist)`` where

        - ``bot`` and ``top`` are list of right squares adjacent to
          singularities (the order is in the direction of the permutation r of
          the origami)

        - ``w`` and ``h`` are width and height of the cylinder

        - ``bot_twist`` and ``top_twist`` are twist between the minimum square
          number and the minimum square number adjacent to a singularity.

        EXAMPLES::

            sage: r  = '(1,2,3,4)(5,6)'
            sage: u0 = '(1,5)(2,6)(3)(4)'
            sage: u1 = '(1,5,2,6,3,4)'
            sage: u2 = '(1,5,3)(2,6,4)'
            sage: u3 = '(1,5,4,3,2,6)'
        """
        o = self.to_standard_form()
        r = o.r()
        ri = ~r
        u = o.u()
        ui = ~u

        udr_sq = [] # (up-right,down-right) couples adjacent to singularities
        for v in (ui*ri*u*r).cycle_tuples():
            udr_sq.extend((j,ui(j)) for j in v)

        if not udr_sq: # torus
            udr_sq = [(1,ui(1))]

        udr_sq.sort()
        udr_tot = set(udr_sq)

        cyls = []
        while udr_sq:
            j,ji = udr_sq.pop(0)
            k = r.orbit(j)  # the min is not necessarily at a singularity
            jj = min(k)     # because of the standard form. Hence we
                            # construct the r orbit of j.
                            # the bot twist is the distance between the
                            # min square and the min singularity
                            # width is r^-1(j)-j
            bot_twist = j-jj
            w = ri(jj)-jj+1
            bot = [(j,ji)]
            while udr_sq and udr_sq[0][0] < w+jj:
                bot.append(udr_sq.pop(0))
            l = min(x[1] for x in udr_tot)

            h = (l-jj)//w + 1
            top = filter(lambda i: jj+(h-1)*w <= i[1] and i[1] < jj+h*w, udr_tot)
            top.sort(cmp=lambda x,y: -x[1].__cmp__(y[1]))

            top_twist = min(t[1] for t in top) - (jj+(h-1)*w)

            #top.reverse()
            cyls.append((bot,top,w,h,bot_twist,top_twist))

            udr_tot = udr_tot.difference(top)

        return cyls

    def cylinder_diagram(self, data=False):
        r"""
        Returns the cylinder diagram corresponding to the horizontal direction.
        If ``data`` is True, returns as well the list of lengths of
        separatrices, the heigths of cylinders and the twists.

        The *cylinder diagram* of a completely periodic surface encodes the
        combinatorics of cylinders and saddle connections. From a cylinder
        diagram and its metric data, it is possible to build the surface back.

        INPUT:

        - ``data`` - boolean (default: False) - if True, return the cylinder
          diagrams, the lengths, the heights and twists.

        EXAMPLES:

        The two examples in the stratum H(2)::

            sage: o1 = Origami('(1,2,3)','(2,3)')
            sage: o1.stratum()
            H_2(2)
            sage: c1 = o1.cylinder_diagram()
            sage: c1.ncyls()
            1
            sage: c1.nseps()
            3
            sage: o2 = Origami('(1,2)','(1,3)')
            sage: o2.stratum()
            H_2(2)
            sage: c2 = o2.cylinder_diagram()
            sage: c2.ncyls()
            2
            sage: c2.nseps()
            3

            sage: r = (1,2,0,4,5,6,3)
            sage: u = (1,2,3,5,4,0,6)
            sage: o = Origami(r,u,as_tuple=True)
            sage: c,lengths,heights,twists = o.cylinder_diagram(True)
            sage: c.cylcoord_to_origami(lengths,heights,twists) == o
            True

        TESTS:

        Check consistency of cylinder data::

            sage: r = '(1,2,3,4,5,6,7,8)(9,10,11,12,13,14,15,16)'
            sage: u = '(1,9,3,15,5,13,7,11)(2,14,8,16,6,10,4,12)'
            sage: o3 = Origami(r,u)
            sage: c3 = o3.cylinder_diagram()
            sage: c3.ncyls()
            2
            sage: c3.nseps()
            8
            sage: r = '(1,2,3,4)(5,6,7,8)(9,10,11,12)(13,14,15,16)'
            sage: u = '(1,5,3,10)(2,9,13,11)(4,8,15,6)(7,14,12,16)'
            sage: o4 = Origami(r,u)
            sage: c4 = o4.cylinder_diagram()
            sage: c4.ncyls()
            4
            sage: c4.nseps()
            8
        """
        from sage.dynamics.flat_surfaces.separatrix_diagram import CylinderDiagram

        cyl_dec = self.cylinder_decomposition()

        # find a renumerotation for edges
        edges = []
        cyl_ren = []
        for i,cyl in enumerate(cyl_dec):
            edges.extend(cyl[0])
            cyl_ren.append((cyl[0][0][0],i))

        edges.sort()   # index to edge
        e2i = dict((edges[i],i) for i in xrange(len(edges)))  # edge to index
        cyl_ren.sort()
        cyl_ren = dict((j[0],i) for i,j in enumerate(cyl_ren))

        # now build a cylinder diagram with lengths, twists and heights
        cyls = []
        lengths = [None]*len(edges)
        heights = [None]*len(cyl_dec)
        twists = []
        for b,t,w,h,_,_ in cyl_dec:
            ww = w
            n = cyl_ren[b[0][0]]
            for i in xrange(len(b)-1):
                lengths[e2i[b[i]]] = b[i+1][0] - b[i][0]
                ww -= lengths[e2i[b[i]]]
            lengths[e2i[b[-1]]] = ww
            heights[n] = h

            bot = tuple(e2i[e] for e in b)
            top = tuple(e2i[e] for e in t)
            s_bot = edges[min(bot)][0]
#            print "min(bot) = %d   s_bot = %d" %(min(bot),s_bot)
            s_top = edges[min(top)][1]
#            print "min(top) = %d   s_top = %d" %(min(top),s_top)
            twists.append((s_top - s_bot) % w)
            cyls.append((bot,top))

        if data:
            return CylinderDiagram(cyls), lengths, heights, twists
        else:
            return CylinderDiagram(cyls)

    #
    # Homology
    #

    def absolute_period_generators(self):
        r"""
        Return a generating set of the absolute periods of this origami.

        To each curve on an origami, we can associate its holonomy (that is an
        element of `\ZZ \times \ZZ`). This function returns a generating set of
        the module generated by holonomies of closed curves.

        EXAMPLES::

            sage: o = Origami('(1,2,3,4)(5,6)', '(1,5)(2,6)')
            sage: o.absolute_period_generators()
            [(2, 0), (2, 0), (0, 1), (0, 1)]
        """
        cyl,lengths,heights,twists = self.cylinder_diagram(data=True)
        r = cyl.to_ribbon_graph_with_holonomies(lengths,heights,twists)
        periods = []
        for c in r.cycle_basis():
            s = sum(r._holonomies[e[0]] for e in c)
            if s:
                periods.append(s)
        return periods

    def up_right_vertex(self, i):
        r"""
        Return the vertex at the top right corner of the ``i``-th square.

        EXAMPLES::

            sage: o = Origami('(1,2,3,4)(5,6)', '(1,5)(2,6)')
            sage: o.up_right_vertex(1)
            vertex (1,)
            sage: o.up_right_vertex(2)
            vertex (2, 6, 4)
            sage: o.up_right_vertex(4)
            vertex (2, 6, 4)
            sage: o.up_right_vertex(2) == o.up_right_vertex(6)
            True
        """
        return self._vertices().up_right_vertex(i)

    def down_left_vertex(self, i):
        r"""
        Return the vertex at the down left corner of the ``i``-th square.

        EXAMPLES::

            sage: o = Origami('(1,2,3)(4,5)', '(2,5,4)')
            sage: o.down_left_vertex(2)
            vertex (1, 5)
            sage: o.down_left_vertex(1)
            vertex (3,)
        """
        return self._vertices().down_left_vertex(i)

    vertex = up_right_vertex

    @cached_method
    def _vertices(self, register_automorphism_action=False):
        r"""
        INPUT:

        - ``register_automorphism_action`` - (default is ``False``) whether the
          action of the automorphism group of the origami is registered on the
          vertices
        """
        return OrigamiVertices(self, register_automorphism_action)

    def vertices(self, fake_zeros=False, register_automorphism_action=False):
        r"""
        Return the vertices of self.

        INPUT:

        - ``fake_zeros`` - (default is ``False``) whether all corners are
          considered

        EXAMPLES::

            sage: o = origamis.Escalator(4)
            sage: o.vertices()
            [vertex (1, 5), vertex (2, 6), vertex (3, 7), vertex (4, 8)]
        """
        if fake_zeros:
            return list(self._vertices())
        else:
            return filter(lambda v: v.degree(), self._vertices())

    def vertex_degrees(self, fake_zeros=False):
        r"""
        Return the list of degree of the vertices

        EXAMPLES::

            sage: o = Origami('(1,2,3,4,5)', '(1,5,3,2,4)')
            sage: o.vertex_degrees()
            [4]

            sage: o = origamis.ProjectiveLine(5)
            sage: o.vertex_degrees()
            [2, 2]
        """
        return sorted((v.degree() for v in self.vertices(fake_zeros)), reverse=True)

    def nb_vertices(self, fake_zeros=False):
        r"""
        Return the number of vertices of the origami

        INPUT:

        - ``fake_zeros`` - if ``True`` all corners of square is considered as a
          vertex. Otherwise only singularities matter. Default is ``False``.

        EXAMPLES::

            sage: o = Origami('(1,2)','(1,3)')
            sage: o.nb_vertices()
            1
            sage: o = Origami('(1,2,3)(4,5,6)','(3,4)')
            sage: o.nb_vertices()
            2
            sage: o.nb_vertices(fake_zeros=True)
            4
        """
        return len(self.vertices(fake_zeros))

    def stratum(self, fake_zeros=False):
        r"""
        Stratum of this origami.

        EXAMPLES::

            sage: o = Origami('(1,2)','(1,3)')
            sage: o.stratum()
            H_2(2)

        One can ask for fake zeroes and get the stratum with all punctures
        marked::

            sage: o = Origami('(1,2,3)','(1,4)')
            sage: o.stratum(fake_zeros=False)
            H_2(2)
            sage: o.stratum(fake_zeros=True)
            H_2(2, 0)
        """
        from sage.dynamics.flat_surfaces.abelian_strata import AbelianStratum
        degrees = self.vertex_degrees(fake_zeros)
        if degrees:
            return AbelianStratum(degrees)
        return AbelianStratum(0)

    def genus(self):
        r"""
        Return the genus of the origami

        EXAMPLES::

            sage: o = Origami('(1,2)','(1,3)')
            sage: o.genus()
            2
            sage: o = Origami('(1,2)(3,4)','(1,3)')
            sage: o.genus()
            2
        """
        return self.stratum().genus()

    def chain_complex(self):
        r"""
        Return the chain complex of the origami

        EXAMPLES::

            sage: o = Origami('(1,2,3,4)','(1,5)')
            sage: o.chain_complex()
            Chain complex of origami
            (1,2,3,4)(5)
            (1,5)(2)(3)(4)
        """
        return OrigamiChainComplex(self)

    def loop_space(self):
        r"""
        The loop space is the subspace of H_1(S,Sigma; Z) generated by the
        (dual) loop around each singularity

        Its dimension is s-1
        """
        vecs = []
        for v in self.vertices(True):
            vecs.append(sum(v.outgoing_vectors()) - sum(v.incoming_vectors()))

        return self.chain_space().subspace(vecs)

    def fundamental_group(self):
        r"""
        Return the fundamental group of this origami in terms of generators of
        the gree group.

        OUTPUT:

        - the free group on two generators (gap object)

        - a subgroup of the preceding group (gap object)

        """
        from sage.graphs.digraph import DiGraph

        F = gap("FreeGroup")(2)
        Fgens = list(gap("GeneratorsOfGroup")(F))
        name_to_gen = {'x': Fgens[0], 'y': Fgens[1]}  # generators
        G = self.dual_graph()
        T = DiGraph(implementation='c_graph')

        vertices = set(range(1,self.nb_squares()))
        d = {}  # the group element at the end of the edge
        d[0] = Fgens[0]*Fgens[0]**-1  # the identity !!!

        l = [0]
        T.add_vertex(0)
        rest = []
        while vertices:
            v = l.pop()
            for e in G.outgoing_edge_iterator(v):
                if T.has_vertex(e[1]):
                    rest.append(e)
                else:
                    T.add_edge(e)
                    d[e[1]] = d[e[0]] * name_to_gen[e[2]]
                    l.append(e[1])
                    vertices.remove(e[1])
                G.delete_edge(e)
            for e in G.incoming_edge_iterator(v):
                if T.has_vertex(e[0]):
                    rest.append(e)
                else:
                    T.add_edge(e)
                    d[e[0]] = d[e[1]] * name_to_gen[e[2]]**-1
                    l.append(e[0])
                    vertices.remove(e[0])
                G.delete_edge(e)

        rest.extend(G.edges())

        gens = []
        for e in rest:
            gens.append(d[e[0]] * name_to_gen[e[2]] * d[e[1]]**-1)

        return F,gap("Subgroup")(F,gens)

    #
    # Homology representation of automorphism group
    #

    def character_of_vertices_permutation(self, fake_zeros=True):
        r"""
        Return the character associated to the action of the automorphism group
        of self on vertices.

        INPUT:

        - ``fake_zeros`` - boolean (default: True) - whether or not consider
          fake zeros.

        EXAMPLES::

            sage: print "TODO"
            TODO
        """
        from sage.groups.class_function import ClassFunction

        A = self.automorphism_group()
        V = self.vertices(fake_zeros=fake_zeros)
        chi = []
        for g in A.conjugacy_classes_representatives():
            chi.append(sum(g*v == v for v in V)) # nb of fixed point of g
        return ClassFunction(A,chi)

    def character_of_holonomy_free_representation(self):
        r"""
        Return the character of the holonomy free representation.
        """
        from sage.groups.class_function import ClassFunction

        G = self.monodromy()
        A = self.automorphism_group()

        # build the character of the regular representation of A
        # we assume that id is the first item of
        # A.conjugacy_class_representatives()
        cc = A.conjugacy_classes_representatives()
        chi = [G.order()] + [0]*(len(cc)-1)

        # character of vertices permutation
        chi_v = self.character_of_vertices_permutation()

        return ClassFunction(A, [i-j for i,j in zip(chi,chi_v)])

    def homology_isotypic_components(self, ring=None):
        r"""
        The natural action is twice the regular representation (for which
        isotypical component are easy to compute).

        OUTPUT:

        a list of 2-tuples (character, basis).
        """
        if ring is None:
            from sage.rings.complex_double import CDF
            ring = CDF
        n = self.nb_squares()
        A = self.automorphism_group()
        C = self.character_of_holonomy_free_representation()
        D = C.decompose()

        # canonical numerotation for holonomy
        P = {}
        for d,r in D:
            v = d.values()
            p = matrix(ring,n)
            for i,cc in enumerate(G.conjugacy_classes_representative()):
                for a in gap.ConjugacyClass(A,cc):
                    pass

            P[r] = d*r[0] / A.order() * p

    #
    # KZ and GL(2,Z) action
    #

    def sl2z_simplicial_action(self,w,return_origamis=False):
        r"""
        Return a matrix action on the canonical 1-dimensional chains

        We return the action on the origami in standard forms...

        See also :meth:`automorphism_simplicial_action`

        OUTPUT:

        - ``o1,o2`` - the origamis at the begining and at the end

        - ``m`` - the matrix

        """
        o = self.to_standard_form()

        r = o.r()
        u = o.u()
        n = o.nb_squares()

        rr,uu,m1 = permutation_simplicial_action(r,u,n,w)

        oo = Origami(rr,uu)
        ooo,s = oo.to_standard_form(True)

        m2 = matrix(2*n)
        m2[:n,:n] = s.matrix().transpose()
        m2[n:,n:] = s.matrix().transpose()

        if return_origamis:
            return o,ooo,m2*m1
        return m2*m1

    def automorphism_simplicial_action(self, g):
        r"""
        Return the simplicial action of the automorphism ``g``.

        See also: :meth:`sl2z_simplicial_action`
        """
        from sage.matrix.constructor import matrix

        N = self.nb_squares()

        m = matrix(2*N)
        for i in xrange(N):
            m[g(i+1)-1, i] = 1
            m[N+g(i+1)-1, N+i] = 1
        return m

    def veech_group(self):
        r"""
        Returns the Veech group of this origami.

        EXAMPLES::

            sage: o = Origami('(1,2)','(1,3)')
            sage: G = o.veech_group()
            sage: G
            Arithmetic subgroup with permutations of right cosets
             S2=(2,3)
             S3=(1,2,3)
             L=(1,2)
             R=(1,3)

        Most geometric information on the quotient of the upper half plane by
        the Veech group can be recovered from ``G``::

            sage: G.index()
            3
            sage: G.genus()
            0
            sage: G.ncusps()
            2
            sage: G.nu2()
            1
            sage: G.nu3()
            0

        As well as some arithmetic informations::

            sage: G.is_congruence()
            True
            sage: G.generalised_level()
            2

        Note that the fact of being congruent is rather exceptional::

            sage: o = Origami('(1,2,3,4)','(4,5)')
            sage: o.veech_group().is_congruence()
            False

            sage: o = Origami('(1,2,3,4,5)','(5,6)')
            sage: o.veech_group().is_congruence()
            False

            sage: o = Origami('(1,2,3,4,5,6)','(6,7)')
            sage: o.veech_group().is_congruence()
            False

        TESTS:

        An error is raised if the origami is not connected::

            sage: o = Origami('(1,2)','(3,4)')
            Warning: the origami is not connected
            sage: o.veech_group()
            Traceback (most recent call last):
            ...
            ValueError: the origami is not connected! The Veech group
            computation is disabled in that case.
        """
        return self.teichmueller_curve().veech_group()

    @cached_method
    def teichmueller_curve(self):
        r"""
        Return the teichmueller curve of this origami

        The result is cached for future usage.

        .. SEEALSO::

            :class:`~sage.dynamics.flat_surfaces.origamis.teichmueller_curve.TeichmuellerCurveOfOrigami_class`

        EXAMPLES::

            sage: o = Origami('(1,2)','(1,3)')
            sage: t = o.teichmueller_curve()
            sage: t
            Teichmueller curve of the origami
            (1)(2,3)
            (1,2)(3)
            sage: t.sum_of_lyapunov_exponents()
            4/3
            sage: for o in t.cusp_representatives():
            ....:     print o[0]
            ....:     print o[1]
            (1)(2,3)
            (1,2)(3)
            2
            (1,2,3)
            (1)(2,3)
            1
        """
        if not self.is_connected():
            raise ValueError("the origami is not connected! The Veech group computation is disabled in that case.")
        from teichmueller_curve import TeichmuellerCurveOfOrigami
        return TeichmuellerCurveOfOrigami(self)

    def sum_of_lyapunov_exponents(self):
        r"""
        Returns the sum of Lyapunov exponents for this origami

        EXAMPLES::

            sage: o = Origami('(1,2)','(1,3)')
            sage: o.sum_of_lyapunov_exponents()
            4/3
            sage: o = Origami('(1,2)(3,4)','(2,3)')
            sage: o.sum_of_lyapunov_exponents()
            3/2

        TESTS:

        An error is raised if the origami is not connected::

            sage: o = Origami('(1,2)','(3,4)')
            Warning: the origami is not connected
            sage: o.sum_of_lyapunov_exponents()
            Traceback (most recent call last):
            ...
            ValueError: the origami is not connected! The Veech group
            computation is disabled in that case.
        """
        return self.teichmueller_curve().sum_of_lyapunov_exponents()

#
# Other stuff which should be moved in a more geometrical place (like CW
# complex or embeeded graph or whatever).
#

from sage.categories.action import Action

class ActionOnOrigamiObjects(Action):
    r"""
    Generic action of the automorphism group of an origami.
    """
    def __init__(self, objects):
        import operator
        o = objects.origami()
        # Action.__init__(G,S,is_left,op)
        Action.__init__(
                self,
                o.automorphism_group(),
                objects,
                True,
                operator.mul)

    def _call_(self, g, x):
        r"""
        Action of g on x.
        """
        return x._acted_upon_(g, True)

class OrigamiObjects(Parent):
    def chain_space(self):
        return VectorSpace(QQ, self.cardinality())

    @cached_method
    def cycle_space(self):
        r"""
        The space of cycles.
        """
        return self.derivative().right_kernel()

    @cached_method
    def border_space(self):
        r"""
        The border space.
        """
        return self.derivative().column_space()

class OrigamiFaces(OrigamiObjects):
    def __init__(self, origami):
        Parent.__init__(self, category=FiniteEnumeratedSets())
        self._origami = origami

    def cardinality(self):
        return self._origami.nb_squares()

    def derivative(self):
        n = self._origami.nb_squares()
        ri = self._origami.r_inv_tuple()
        ui = self._origami.u_inv_tuple()
        der = matrix(2*n,n,ring=QQ)
        for i in xrange(n):
            if ui[i] != i: # horiz sides
                der[i,i] = -1
                der[ui[i],i] = 1
            if ri[i] != i: # vert sides
                der[n+i,i] = 1
                der[n+ri[i],i] = -1
        return der

class OrigamiEdges(OrigamiObjects):
    r"""
    """
    def __init__(self, origami):
        Parent.__init__(self)
        self._origami = origami
        ri = origami.r_inv_tuple()
        ui = origami.u_inv_tuple()
        n = origami.nb_squares()

        self._starts = [None]*(2*n)
        self._ends = [None]*(2*n)
        for i in xrange(n):
            self._ends[i] = origami.vertex(i+1).index()
            self._starts[i] = origami.vertex(ri[i]+1).index()

            self._ends[n+i] = origami.vertex(i+1).index()
            self._starts[n+i] = origami.vertex(ui[i]+1).index()

    def origami(self):
        return self._origami

    # about elements

    def _element_constructor(self, i):
        if i >= 0 and i < 2*o.nb_squares():
            return o.chain_complex().chain_space(1).gen(i)

    def start(self,i):
        return self._starts[i]

    def end(self,i):
        return self._ends[i]

    # about global derivation

    def cardinality(self):
        return 2*self._origami.nb_squares()

    def derivative(self):
        m = self._origami.nb_vertices(True)
        n = 2*self._origami.nb_squares()
        der = matrix(m,n,ring=QQ)
        for i in xrange(n):
            if self._starts[i] != self._ends[i]:
                der[self._ends[i], i] = 1
                der[self._starts[i], i] = -1
        return der

    # geometric stuff (should be moved in cylinder diagrams)

    def is_simple_closed_curve(self, c):
        r"""
        Test if c is a simple closed curve
        """
        assert(c in self.chain_space())
        d = c.dict()
        for i in d:
            if d[i] != 1 and d[i] != -1:
                return False

        vertices = set([])
        for i in d:
            if d[i] == 1:
                v = self.end(i)
            else:
                v = self.start(i)
            if v in vertices:
                return False

            vertices.add(v)

        return True

    def simple_closed_curve_to_vertex_in_out(self, c):
        r"""
        From a curve c (as a vector) returns two dictionnaries associated to
        input/output view from each visited vertices
        """
        c_in = {}
        c_out = {}
        for i,j in c.dict().iteritems():
            if j == 1:
                c_in[self.start(i)] = i
                c_out[self.end(i)] = i
            elif j == -1:
                c_in[self.end(i)] = i
                c_out[self.start(i)] = i
            else:
                raise ValueError, "not a simple closed curve"
        return c_in, c_out

    def basis_of_simple_closed_curves(self):
        from sage.graphs.digraph import DiGraph
        from sage.all import randint

        n = self._origami.nb_squares()
        C = self.chain_space()
        G = DiGraph(multiedges=True,loops=True,implementation='c_graph')

        for i in xrange(2*n):
            G.add_edge(self._starts[i], self._ends[i], i)

        waiting = [0]
        gens = []
        reps = [None] * G.num_verts()
        reps[0] = C.zero()

        while waiting:
            x = waiting.pop(randint(0,len(waiting)-1))
            for v0,v1,e in G.outgoing_edges(x):
                if reps[v1] is not None:
                    gens.append(reps[v0] + C.gen(e) - reps[v1])
                else:
                    reps[v1] = reps[v0] + C.gen(e)
                    waiting.append(v1)

        return gens

    def intersection(self, c1, c2):
        r"""
        Returns the intersection of c1 and c2 assuming that they are simple
        closed curves
        """
        assert(self.is_simple_closed_curve(c1) and self.is_simple_closed_curve(c2))

        c1_in, c1_out = self.simple_closed_curve_to_vertex_in_out(c1)
        c2_in, c2_out = self.simple_closed_curve_to_vertex_in_out(c2)

        intersection = 0
        for vert in c1_in:
            if vert in c2_in:
                if c1_in[vert] == c2_in[vert]:
                    if c1_out[vert] == c2_out[vert]:
                        pass
                    elif are_cyclically_ordered(
                            c1_in[vert], c1_out[vert], c2_out[vert]):
                        intersection += 1

                elif c1_out[vert] == c2_out[vert]:
                    if are_cyclically_ordered(
                            c1_out[vert], c2_in[vert], c1_in[vert]):
                        intersection -= 1

                elif are_cyclically_ordered(
                        c1_in[vert],c2_in[vert],c1_out[vert]):
                    if are_cyclically_ordered(
                            c1_out[vert],c2_out[vert],c1_in[vert]):
                            intersection += 1

                elif are_cyclically_ordered(
                        c1_in[vert],c2_out[vert],c1_out[vert]):
                    intersection -= 1

        return intersection

    def winding(self, c):
        r"""
        Return the winding of the curve c
        """
        assert(self.is_simple_closed_curve(c))
        pass

class OrigamiVertices(OrigamiObjects):
    r"""
    The set of vertices of an origami.

    It is in bijection with the biclasses H  G  C where H is the stabilizer of
    1 and C is the subgroup generated by the commutator ``r u r**-1 u **-1``.
    """
    def __init__(self, origami, register_automorphism_action=False):
        Parent.__init__(self, category=FiniteEnumeratedSets())
        self._origami = origami

        self._vertices = []
        self._vertices_inv = {}
        self._vertex_from_ur = {}
        self._vertex_from_dl = {}

        r = origami.r()
        u = origami.u()
        ru = r*u
        vperm = ru*~r*~u

        for ur in vperm.cycle_tuples(singletons=True):
            dl = map(ru,ur)
            v = OrigamiVertex(self, ur, tuple(dl))
            self._vertices_inv[v] = len(self._vertices)
            self._vertices.append(v)
            for i in ur:
                self._vertex_from_ur[i] = v
            for i in dl:
                self._vertex_from_dl[i] = v

        if register_automorphism_action:
            self.register_action(ActionOnOrigamiObjects(self))

    def origami(self):
        r"""
        Return the underlying origami.

        EXAMPLES::

            sage: o = Origami('(1,2,3,4)','(1,5)')
            sage: V = o._vertices()
            sage: V.origami()
            (1,2,3,4)(5)
            (1,5)(2)(3)(4)
            sage: V.origami() is o
            True
        """
        return self._origami

    def cardinality(self):
        r"""
        The number of vertices.

        EXAMPLES::

            sage: o = Origami('(1,2,3,4)','(1,5)')
            sage: V = o._vertices()
            sage: V.cardinality()
            3
        """
        return Integer(len(self._vertices))

    def chain_space(self):
        r"""
        Return the space of chain on this finite set of vertices.

        EXAMPLES::

            sage: o = Origami('(1,2,3,4)', '(1,5)')
            sage: V = o._vertices()
            sage: V.chain_space()
            Vector space of dimension 3 over Rational Field
        """
        return VectorSpace(QQ, self.cardinality())

    def derivative(self):
        r"""
        Return the derivative matrix.

        That is a matrix from the chain space to `\QQ`.

        EXAMPLES::

            sage: o = Origami('(1,2,3,4)', '(1,5)')
            sage: V = o._vertices()
            sage: V.derivative()
            [1 1 1]
        """
        return matrix([1]*len(self._vertices), ring=QQ)

    def _repr_(self):
        return "Vertices of origami\n%s" %self.origami()

    def __contains__(self, v):
        return v in self._vertices

    def up_right_vertex(self, i):
        r"""
        Return the vertex that is in the up right corner of the ``i``-th square.

        EXAMPLES::

            sage: o = Origami('(1,2,3,4)', '(1,5)')
            sage: V = o._vertices()
            sage: V.up_right_vertex(2)
            vertex (2,)
        """
        return self._vertex_from_ur[i]

    def down_left_vertex(self, i):
        r"""
        Return the vertex that is in the down left corner of the ``i``-th square.

        EXAMPLES::

            sage: o = Origami('(1,2,3,4)', '(1,5)')
            sage: V = o._vertices()
            sage: V.down_left_vertex(2)
            vertex (1, 5, 4)
        """
        return self._vertex_from_dl[i]

    vertex = up_right_vertex
    _element_constructor_ = up_right_vertex

    def vertex_index(self, v):
        r"""
        Return the index of the vertex ``v``.

        EXAMPLES::

            sage: o = Origami('(1,2,3,4)', '(1,5)')
            sage: V = o._vertices()
            sage: v0 = V.up_right_vertex(2)
            sage: v0
            vertex (2,)
            sage: V.vertex_index(v0)
            1
            sage: V[1] == v0
            True

            sage: v1 = V.up_right_vertex(5)
            sage: v1
            vertex (1, 5, 4)
            sage: V.vertex_index(v1)
            0
            sage: V[0] == v1
            True
        """
        return self._vertices_inv[v]

    def __getitem__(self, i):
        r"""
        Access to a given element.
        """
        return self._vertices[i]

    def __iter__(self):
        r"""
        Iterator over the vertices.
        """
        return iter(self._vertices)

class OrigamiVertex(Element):
    def __init__(self, parent, ur, dl):
        Element.__init__(self, parent)
        self._ur = ur
        self._dl = dl

    def _repr_(self):
        return "vertex %s" %(str(self._ur))

    def __str__(self):
        return str(self._ur)

    def __hash__(self):
        return hash((self._ur,self._dl))

    def __eq__(self, other):
        return (type(self) == type(other) and
                self.parent() == other.parent() and
                self._ur == other._ur)

    def __ne__(self, other):
        return (type(self) != type(other) or
                self.parent() != other.parent() or
                self._ur != other._ur)

    def _acted_upon_(self, g, on_left):
        r"""
        Return the action of the element g of the automorphism group of the
        origami on self.
        """
        if not on_left:
            return self.parent().up_right_vertex(g(self._ur[0]))
        else:
            return self.parent().up_right_vertex(g(self._ur[0]))

    def index(self):
        return self.parent().vertex_index(self)

    def degree(self):
        return len(self._ur)-1

    def up_right_tuple(self):
        return self._ur

    def down_left_tuple(self):
        return self._dl

    # adjacent vectors

    def adjacent_edge_indices(self):
        r"""
        Returns a 2-tuple (incoming,outgoing)
        """
        return self.incoming_edge_indices(), self.outgoing_edge_indices()

    def outgoing_edge_indices(self):
        n = self.parent().origami().nb_squares()
        ri = ~self.parent().origami().r()
        ui = ~self.parent().origami().u()
        res = []
        for i in self._dl:
            res.append(ui(i)-1)
            res.append(n+ri(i)-1)
        return res

    def incoming_edge_indices(self):
        res = []
        n = self.parent().origami().nb_squares()
        for i in self._ur:
            res.append(i-1)
            res.append(n+i-1)
        return res

    @cached_method
    def edge_positions(self):
        r"""
        The position of the edges.
        """
        d_in = {}
        d_out = {}
        e_in = self.incoming_edge_indices()
        e_out = self.outgoing_edge_indices()
        k = 0
        for i in xrange(0,len(e_in),2):
            d_in[e_in[i]] = k
            d_in[e_in[i+1]] = k+1
            d_out[e_out[i]] = k+2
            d_out[e_out[i+1]] = k+3
            k += 4
        return d_in, d_out

    def incoming_edge_position(self, i):
        return self.edge_positions()[0][i]

    def outgoing_edge_positions(self, i):
        return self.edge_positions()[1][i]

class OrigamiChainComplex(SageObject, UniqueRepresentation):
    r"""
    Chain complex for reduced homology of the origami
    """
    def __init__(self, origami):
        self._origami = origami
        self._objects = [OrigamiVertices(origami), OrigamiEdges(origami), OrigamiFaces(origami)]

    def origami(self):
        r"""
        Return the underlying origami.
        """
        return self._origami

    def chain_space(self, degree):
        r"""
        Chain space.

        INPUT:

        - ``degree`` -- either

        """
        assert(degree > -2 and degree < 3)
        if degree == -1:
            return VectorSpace(QQ,1)
        return self._objects[degree].chain_space()

    def cycle_space(self, degree):
        r"""
        Returns the space of cycles of degree i

        Zi = ker(der: C_i -> C_{i-1})
        """
        assert(degree > -2 and degree < 3)
        if degree == -1:
            return VectorSpace(QQ,1)
        return self._objects[degree].cycle_space()

    def border_space(self, degree):
        r"""
        Returns the space of borders of degree i

        Bi = im(der: C_{i+1} -> Ci)
        """
        assert(degree > -2 and degree < 3)
        if degree == 2:
            return self._objects[2].chain_space().subspace([])
        return self._objects[degree+1].border_space()

    def _repr_(self):
        return "Chain complex of origami\n%s" %(self.origami())
