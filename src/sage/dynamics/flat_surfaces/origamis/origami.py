r"""
Origami

An origami is:

- a couple of permutations

- a covering of the torus ramified over one point

- gluing of squares

- a pair (G,r,u,H) where G is a finite group generated by r and u, H is a
  subgroup of G that does not contain a non-trivial normal subgroup of G. The
  origami is:

  - regular iff H = 1

  - primitive iff H is maximal

- cylinder diagram with integer coordinates

- Abelian differential on Riemann surface with rational periods

.. TODO::

    compute the maximal torus above which the origami is a cover (not
    necessarily ramified over one point)
    compute monodromy from the maximal torus (this is a free group but which
    much more generators)

"""
from origami_dense import Origami_dense_pyx, PillowcaseCover_dense_pyx

from sage.structure.sage_object import SageObject
from sage.groups.perm_gps.permgroup import PermutationGroup
from sage.groups.perm_gps.permgroup import PermutationGroupElement
from sage.misc.cachefunc import cached_method
from copy import copy
from sage.matrix.constructor import matrix, identity_matrix

from sage.rings.integer import Integer
from sage.all import VectorSpace
from sage.all import QQ
from sage.structure.parent import Parent
from sage.structure.element import Element
from sage.structure.unique_representation import UniqueRepresentation

from sage.all import gap

from sage.plot.plot import options

def flatten_word(w):
    l = []
    for i,j in w:
        l.append(i*j)
    return ''.join(l)

def permutation_simplicial_action(r,u,n,w):
    r"""
    From a word in 'l','r' return the simplicial action on homology as
    well as the obtained origami.

    INPUT:

    - ``r`` and ``u`` - permutations

    - ``n`` - the degree of the permutations

    - ``w`` - a string in 'l' and 'r' or a list of 2-tuples which are made of
      the letter 'l' or 'r' and a positive integer

    """
    if w is None:
        w = []
    elif isinstance(w,list):
        w = flatten_word(w)

    res = identity_matrix(2*n)

    for letter in reversed(w):
        if letter == 'l':
            u = u*~r
            m = identity_matrix(2*n)
            m[:n,n:] = u.matrix()
            res = m * res
        elif letter == 'r':
            r = r*~u
            m = identity_matrix(2*n)
            m[n:,:n] = r.matrix()
            res = m * res
        else:
            raise ValueError, "does not understand the letter %s" %str(letter)

    return r,u,res

#
# Origami and pillow case cover constructors
#

def Origami(r, u,
        sparse=False,
        check=True,
        as_tuple=False,
        positions=None, name=None):
    r"""
    Constructor for origami

    INPUT:

    - ``r``, ``u`` - two permutations

    - ``sparse`` - boolean (default: False)

    - ``check`` - boolean (default: True) - whether or not check the input

    - ``as_tuple`` - boolean (default: False) - if True, assume that ``r`` and
      ``u`` are tuples on [0,...,N-1] (time efficient)

    - ``positions`` - list of 2-tuples (default: None) - position of the squares
      for drawings

    - ``name`` - an optional name to the origami

    """
    if not as_tuple:
        r = PermutationGroupElement(r, check=check)
        u = PermutationGroupElement(u, check=check)

        r = [i-1 for i in r.domain()]
        u = [i-1 for i in u.domain()]

        N = max(len(r),len(u))
        r.extend(xrange(len(r),N))
        u.extend(xrange(len(u),N))

    elif check:
        sr = set(r)
        su = set(u)
        N = len(r)
        if len(u) != N:
            raise ValueError, "the two tuples must be of the same length"
        for i in xrange(N):
            if not i in sr:
                raise ValueError, "%d is not in r=%s" %(i,str(r))
            if not i in su:
                raise ValueError, "%d is not in u=%s" %(i,str(u))

    o = Origami_dense(tuple(r),tuple(u))

    if check and not o.is_connected():
        print "Warning: the origami is not connected"

    if name is not None:
        o.rename(name)
    if positions is not None:
        o.set_positions(positions)
    return o

def PillowcaseCover(g0, g1, g2, g3=None,
        sparse=False,
        check=True,
        as_tuple=False,
        positions=None, name=None):
    r"""
    Pillowcase cover constructor.
    """
    if not as_tuple:
        g0 = PermutationGroupElement(g0, check=check)
        g1 = PermutationGroupElement(g1, check=check)
        g2 = PermutationGroupElement(g2, check=check)
        if g3 is None:
            g3 = (~g2) * (~g1) * (~g0)
        else:
            g3 = PermutationGroupElement(g3, check=check)

        g0 = [i-1 for i in g0.domain()]
        g1 = [i-1 for i in g1.domain()]
        g2 = [i-1 for i in g2.domain()]
        g3 = [i-1 for i in g3.domain()]

        N = max([len(g0),len(g1),len(g2),len(g3)])
        g0.extend(xrange(len(g0),N))
        g1.extend(xrange(len(g1),N))
        g2.extend(xrange(len(g2),N))
        g3.extend(xrange(len(g3),N))

    elif check:
        s0 = set(g0)
        s1 = set(g1)
        s2 = set(g2)
        s3 = set(g3)
        N = len(g0)
        if len(g1) != N or len(g2) != N or len(g3) != N:
            raise ValueError, "the four tuples must be of the same length"
        for i in xrange(N):
            if not i in g0:
                raise ValueError, "%d is not in g0=%s" %(i,str(g0))
            if not i in g1:
                raise ValueError, "%d is not in g1=%s" %(i,str(g1))
            if not i in g2:
                raise ValueError, "%d is not in g2=%s"%(i,str(g2))
            if not i in g3:
                raise ValueError, "%d is not in g3=%s"%(i,str(g3))

    pcc = PillowcaseCover_dense(tuple(g0),tuple(g1),tuple(g2),tuple(g3))

    if name is not None:
        pcc.rename(name)
#    if positions is not None:
#        o.set_positions(positions)
    if check:
        pcc._check()
    return pcc


#
# Origami classes
# (there should exists a class covering of a flat surface from which those two
# below inherit)
#

def rauzy_move((ltop,lbot),l):
    r"""
    Start from a generalized permutation given as ((ltop,lbot),l)
    where ltop and lbot are lists with the top and bottom labels
    (the labels are assumed to pair up -- no check), and l is a
    dictionary of lengths for the labels used in ltop, lbot.

    rauzy_move will apply one Rauzy move at the rightmost end:

    - if rightmost top and bottom intervals have distinct lengths,
      do the usual thing

    - if rightmost top and bottom intervals have same label, error

    - if rightmost top and bottom intervals have same length but
      not same label, just remove one of the labels

    Note: this code was originally used to compute the connected component of an
    origami. This is no more ncessary but it might be a good idea to keep for
    double check
    """
    if len(ltop) < 2 and len(lbot) < 2:
        raise ValueError, "cannot induce, too few intervals"
    ktop = ltop[-1]
    kbot = lbot[-1]
    lltop = ltop[:-1]
    llbot = lbot[:-1]
    ll = l.copy()
    if l[ktop] - l[kbot] > 0:
        # print "bottom interval shorter\n"

        # ltop[-1] is some symbol ktop, which appears twice: once as ltop[-1], and the other
        # time either as ltop[j] for j < len(ltop) - 1 or as lbot[j] for j < len(lbot) - 1;
        # as ltop[-1], ktop needs to be replaced by [ltop[-1],lbot[-1]],
        # the other occurrence of ktop needs to be replaced
        # - by [ltop[-1],lbot[-1]] if it is lbot[j]
        # - by [lbot[-1],ltop[-1]] if it is ltop[j]
        # the dictionary of lengths needs one update: ll[ktop] = l[ktop] - l[kbot]

        if ktop in lltop: lltop.insert(lltop.index(ktop),kbot)
        else: llbot.insert(llbot.index(ktop)+1,kbot)
        lltop.append(ktop)
        ll[ktop] = l[ktop] - l[kbot]

    elif l[ktop] - l[kbot] < 0:
        # print "top interval shorter\n"

        # lbot[-1] is some symbol kbot, which appears twice: once as lbot[-1], and the other
        # time either as lbot[j] for j < len(lbot) - 1 or as ltop[j] for j < len(ltop) - 1;
        # as lbot[-1], kbot needs to be replaced by [lbot[-1],ltop[-1]],
        # the other occurrence of ktop needs to be replaced
        # - by [lbot[-1],ltop[-1]] if it is ltop[j]
        # - by [ltop[-1],lbot[-1]] if it is lbot[j]
        # the dictionary of lenghts needs one update: ll[kbot] = l[kbot] - l[ktop]

        if kbot in llbot: llbot.insert(llbot.index(kbot),ktop)
        else: lltop.insert(lltop.index(kbot)+1,ktop)
        llbot.append(kbot)
        ll[kbot] = l[kbot] - l[ktop]

    elif ktop == kbot:
        # in this case the surface has a torus component... weird.
        raise ValueError, ("it seems the surface \n %s \n %s \n %s either is disconnected or has genus 1" %s(ltop,lbot,l))
    else:
        # ktop != kbot but the intervals labeled ktop and kbot have equal lengths
        # just remove ktop and kbot at the end of ltop and lbot, and match the
        # remaining ktop and kbot (keep only one of the names; also in the length dict)
        if ktop in lltop: lltop[lltop.index(ktop)] = kbot
        else: llbot[llbot.index(ktop)] = kbot
        ll.pop(ktop)

    return ((lltop,llbot),ll)

def iet_of_origami(o):
    r"""
    x, y are permutations which together represent an origami
    this origami is assumed to be a torus cover
    (ie corresponds to an abelian differential)

    First get a multi-iet by considering the first return to I, the union of antidiagonals
    of all squares, of the flow in direction (1,u), where u is the golden mean.
    The antidiagonals are parametrized by their horizontal coordinate, so that they appear
    to have length 1, therefore I has length n. Apply Rauzy moves until I has length 1.

    We could define an iet by using this permutation and this length vector
    p = Permutation([(lambda k: 2*y((k+1)//2) if k%2 else 2*x(k//2)-1)(j) for j in range(1,n+1)])
    l = [2-u,u-1] * n
    """
    from sage.dynamics.interval_exchanges.all import iet
    from sage.rings.number_field.all import NumberField
    from sage.rings.polynomial.all import PolynomialRing
    from sage.rings.all import RR

    sigma = o.r()
    tau = o.u()
    n = o.nb_squares()

    R = PolynomialRing(QQ,'x')
    x = R.gen()
    K = NumberField(x**2 - x - 1, 'a',embedding=RR(1.618))
    phi = K.gen()

    ltop = []
    for k in xrange(1,n+1):
        ltop.extend([(k,0),(k,1)])
    lbot = []
    for k in xrange(1,n+1):
        lbot.extend([(sigma.inverse()(k),1),(tau.inverse()(k),0)])
    l = {}
    for k in xrange(1,n+1):
        l[k,0] = 2 - RR(phi)
        l[k,1] = RR(phi) - 1

    while sum(l.values())>1:
        ((ltop, lbot), l) = rauzy_move((ltop,lbot),l)

    return iet.Permutation(ltop,lbot),l

class Origami_generic(object):
    r"""
    Abstract class for origami classes

    The following classes should be implemented

    - dense origami

    - sparse origami

    - regular origami

    This class assumes that the following methods are implemented in derived
    classes... (?)

    r, r_tuple, r_inv, r_inv_tuple
    u, u_tuple, u_inv, u_inv_tuple
    monodromy
    automorphism_group
    cylinder_decomposition
    quotient
    """
    def as_graph(self):
        r"""
        Return the graph associated to self

        The graph associated to an origami is the graph on [1,...,N] for which
        the edges correspond to the action of the permutations `r` and `u`.

        EXAMPLES::

            sage: o=Origami('(1,2)','(1,3)')
            sage: G = o.as_graph(); G
            Looped multi-digraph on 3 vertices
            sage: G.vertices()
            [0, 1, 2]
            sage: G.edges()
            [(0, 1, 'r'), (0, 2, 'u'), (1, 0, 'r'), (1, 1, 'u'), (2, 0, 'u'), (2, 2, 'r')]
        """
        from sage.graphs.digraph import DiGraph

        G = DiGraph(multiedges=True,loops=True)
        N = self.nb_squares()
        r = self.r_tuple()
        u = self.u_tuple()
        for i in xrange(N):
            G.add_edge(i,r[i],'r')
            G.add_edge(i,u[i],'u')
        return G

    def is_connected(self):
        r"""
        Check whether the origami is connected or not

        It is equivalent to ask whether the group generated by `r` and `u` acts
        transitively on the `\{1,\dots,n\}`.

        EXAMPLES::

            sage: o = Origami('(1,2)','(1,3)')
            sage: o.is_connected()
            True
            sage: o = Origami('(1,2)(3,4)','(1,2)',check=False)
            sage: o.is_connected()
            False
        """
        return self.as_graph().is_connected()

    def connected_components(self):
        r"""
        Return the list of connected origami that composes this origami.
        """
        cc = self.as_graph().connected_components()
        r = self.r_tuple()
        u = self.u_tuple()
        if len(cc) == 1:
            return [self]
        l = []
        for c in cc:
            rr = [None] * len(c)
            uu = [None] * len(c)
            d = dict((c[i],i) for i in xrange(len(c)))
            for i in c:
                rr[d[i]] = d[r[i]]
                uu[d[i]] = d[u[i]]
            l.append(Origami(rr,uu,check=False,as_tuple=True))
        return l

    def is_isomorphic(self,other):
        r"""
        Isomorphism test

        EXAMPLES::

            sage: o1 = Origami('(1,2)','(1,3)')
            sage: o2 = Origami('(1,2)','(2,3)')
            sage: o3 = Origami('(1,3)','(1,2)')
            sage: o1.is_isomorphic(o2) and o2.is_isomorphic(o1)
            True
            sage: o1.is_isomorphic(o3) and o3.is_isomorphic(o1)
            True
            sage: o2.is_isomorphic(o3) and o3.is_isomorphic(o2)
            True
        """
        ss = self.relabel()
        oo = other.relabel()
        return (ss.r_tuple() == oo.r_tuple()) and (ss.u_tuple() == oo.u_tuple())

    #
    # Component of stratum
    #

    def stratum_component(self,verbose=False):
        r"""
        Return the component of stratum this origami belongs to.

        EXAMPLES::

            sage: o = Origami('(1,2)','(1,3)')
            sage: o.stratum_component()
            H_hyp(2)

            sage: r = '(1)(2)(3,4)(5,6,7,8)(9,10)'
            sage: u = '(1,2,3,5,6,10)(4,9)(7,8)'
            sage: Origami(r,u).stratum_component()
            H_even(2,2,2)
            sage: Origami(u,r).stratum_component()
            H_even(2,2,2)
        """
        return self.cylinder_diagram().stratum_component()

    #
    # Orientation quotient (quad. diff.)
    #

    def is_orientation_cover(self):
        r"""
        Return true if the origami is an orientation cover of a quadratic
        differential.

        EXAMPLES::

            sage: o = Origami('(1,2)','(1,3)')
            sage: o.is_orientation_cover()
            True
        """
        return self.relabel() == self.inverse().relabel()

    def is_quadratic_cover(self, stratum=True):
        r"""
        Return True if the origami is a cover of a quadratic differential. It is
        equivalent to say that `-1` is in the Veech group.

        EXAMPLES::

            sage: o = Origami('(1,2)','(1,3)')
            sage: o.is_quadratic_cover()
            True
            sage: o.is_orientation_cover()
            False
        """
        return self.relabel() == self.inverse().relabel()

    def orientation_data(self,points=False,verbose=0):
        r"""
        Return the list of quadratic stratum and ramification data associated to
        the orientation quotients of this origami. If the origami is primitive,
        then there is at most one orientation quotient.

        Each element of the list is a 3-tuple containing:

        - a quadratic stratum

        - the list of degrees of zeros which are ramified in the covering
          (consider only integer points)

        - the partition of half-integers points which are mapped to poles
          (middle of squares, horizontal edges, vertical edges)

        INPUT:

        - ``points`` - boolean (default: False) - return singularitiy tuples and
          not only degrees

        EXAMPLES:

        The stratum H(2) contains two families of primitive origamis for an odd
        number of squares. Every surface in H(2) is a covering of a quadratic
        differential in Q(1,-1^5). The ramification data gives an invariant for
        those families::

            sage: o = Origami('(1,2,3,4,5)','(2,1)')
            sage: o.stratum_component()
            H_hyp(2)
            sage: o.orientation_data()
            [(Q(1, -1^5), (2,), (1, 3, 1))]
            sage: o = Origami('(1,2,3)','(1,4,5)')
            sage: o.stratum_component()
            H_hyp(2)
            sage: o.orientation_data()
            [(Q(1, -1^5), (2, 0, 0), (1, 1, 1))]

            sage: o = Origami('(1)(2)(3,4)(5,6,7)','(1,2,3)(4,5)(6)(7)')
            sage: o.stratum_component()
            H_hyp(4)
            sage: o.orientation_data()
            [(Q(3, -1^7), (0, 4, 0), (3, 1, 1))]
            sage: o = Origami('(1)(2)(3)(4,5)(6,7)','(1,2,3,4)(5,6,7)')
            sage: o.stratum_component()
            H_hyp(4)
            sage: o.orientation_data()
            [(Q(3, -1^7), (4,), (3, 1, 3))]
            sage: o = Origami('(1)(2)(3)(4,5)(6,7)','(1,2,3,4)(5,6)(7)')
            sage: o.stratum_component()
            H_3(4)^hyp
            sage: o.orientation_data()
            [(Q(3, -1^7), (4,), (5, 1, 1))]

            sage: o = Origami('(1,2,4)(3,6,5)','(1,3)(2,5)(4,6)')
            sage: for q,_,_ in o.orientation_data(): print q
            Q(4, -1^4)
            Q(4, -1^4)
            Q(4, -1^4)
            Q(1^2, -1^6)
        """
        sf1,m1 = self.to_standard_form(return_map=True)
        sf2,m2 = self.inverse().to_standard_form(return_map=True)

        # condition of being preserved by -Id (which means that there is a non
        # orientable automorphism)
        if sf1 != sf2:
            return []

        from sage.dynamics.flat_surfaces.quadratic_strata import QuadraticStratum

        m = m2 * ~m1  # one element which reverses orientation
        if verbose:
            print "m  =",m
        r = self.r()
        u = self.u()
        assert(m*r*~m == ~r and m*u*~m == ~u) # check

        rot_pi = r*u
        rot_2pi = r*u*~r*~u
        singularities = rot_2pi.cycle_tuples(singletons=True)
        degrees = {}
        for a in map(len, singularities):
            a=a-1
            if a:
                if a in degrees: degrees[a] += 1
                else: degrees[a] = 1

        res = []

        # consider all orientation reversing involutions
        G = self.automorphism_group()
        for g in G:
            mm = m * g # an automorphism which reverses the orientation
            if mm.order() > 2:
                continue

            if verbose:
                print "g  =",g
                print "mm =",mm

            # fixed points which are not integer points
            squares = []; h_edges = []; v_edges = []
            for i in xrange(1,self.nb_squares()+1):
                if mm(i) == i: squares.append(i)
                if mm(i) == u(i): h_edges.append(i)
                if mm(i) == r(i): v_edges.append(i)

            # fixed integer points
            vertices = []
            ramifications = dict((d,0) for d in degrees)
            ramifications[0] = 0
            for c in singularities:
                if rot_pi(c[len(c)//2]) == mm(c[0]):
                    vertices.append(c)
                    ramifications[len(c)-1] += 1

            if verbose:
                print "ramifications"
                print "  deg. of int. pts.",ramifications
                print "  h_edges",len(h_edges)
                print "  v_edges",len(v_edges)
                print "  centers",len(squares)

            qdegrees = dict((d-1,ramifications[d]) for d in ramifications)
            qdegrees[-1] += len(squares) + len(h_edges) + len(v_edges)
            qdegrees.update((2*d,(degrees[d]-ramifications[d])/2) for d in degrees)

            if points:
                res.append((
                    QuadraticStratum(qdegrees),
                    vertices,
                    (squares,h_edges,v_edges)))
            else:
                res.append((
                    QuadraticStratum(qdegrees),
                    tuple(len(c)-1 for c in vertices),
                    (len(squares),len(h_edges),len(v_edges))))

            if verbose:
                print " stratum", res[-1][0]
            assert(not res[-1][0].is_empty())  # check that the stratum is non empty!

        return res

    def is_hyperelliptic(self,stratum=False):
        r"""
        Return True if this origami is hyperelliptic

        If ``stratum`` is set to ``True``, then returns also the corresponding
        stratum of quadratic differentials this origami is a cover from.

        EXAMPLES::

            sage: o = Origami('(1,2)','(1,3)')
            sage: o.is_hyperelliptic()
            True
            sage: o.is_hyperelliptic(stratum=True)
            (True, (Q(1, -1^5), (2,), (3, 1, 1)))

            sage: o = origamis.podium([3,3,2,1])
            sage: o.is_hyperelliptic()
            False
            sage: o.is_hyperelliptic(stratum=True)
            (False, None)
        """
        for q,_,_ in self.orientation_data():
            if q.genus() == 0:
                if stratum:
                    return True,q
                return True

        if stratum:
            return False, None
        return False

    def to_pillowcase_cover(self):
        r"""
        Returns the corresponding pillow case cover (quadratic differential)

        Either the degree of the pillow case is the number of squares or the
        double.
        """
        r = self.r_tuple()
        r_inv = self.r_inv_tuple()
        u = self.u_tuple()
        u_inv = self.u_inv_tuple()

        oo = Origami(self.r()**2,self.u()**2)

        if oo.is_connected():
            n = self.nb_squares()
            g0 = [None] * (2*n)
            g1 = [None] * (2*n)
            g2 = [None] * (2*n)
            g3 = [None] * (2*n)

            for i in xrange(n):
                g0[2*i] = 2*u_inv[r_inv[i]]+1
                g1[2*i] = 2*u_inv[i]+1
                g2[2*i] = 2*i+1
                g3[2*i] = 2*r_inv[i]+1

                g0[2*i+1] = 2*u[r[i]]
                g1[2*i+1] = 2*u[i]
                g2[2*i+1] = 2*i
                g3[2*i+1] = 2*r[i]

            return PillowcaseCover(g0,g1,g2,g3,as_tuple=True)

        else:
            raise NotImplementedError("not implement for non connected origamis")


    #
    # Quotients and covers
    #


    def reduce(self):
        r"""
        Return a reduced origami isomorphic (up to SL(2,QQ) action) to that origami.

        EXAMPLES::

            sage: o = Origami('(1,2)(3,4)','(1,3,5,6)(2,4)')
            sage: o.lattice_of_periods()
            (1, 0, 2)
            sage: o.reduce()
            (1,2)(3)
            (1,3)(2)

            sage: o = Origami('(1,2)(3,4,5,6)','(1,3,5)(2,4,6)')
            sage: o.lattice_of_periods()
            (2, 0, 1)
            sage: o.reduce()
            (1)(2,3)
            (1,2,3)

            sage: o = Origami('(1,2)(3,4,5,6)','(1,3,4,5)(2,6)')
            sage: o.lattice_of_periods()
            (2, 1, 1)
            sage: o.reduce()
            (1)(2,3)
            (1,2,3)
        """
        N = self.nb_squares()
        w,t,h = self.lattice_of_periods() # ((w,0),(t,h))
        vol = h*w
        NN = N//vol

        # two trivial cases
        if NN == 1:
            return Origami('(1)','(1)')
        elif NN == N:
            return self

        # 1. find a square with some singularity in the bot-left corner
        r = self.r()
        u = self.u()
        v = (~r * ~u * r * u).cycle_tuples()

        # 2. then rebuild new permutation with pr and pu
        pr = r**w
        pu = r**t * u**h

        n = 1
        test = [v[0][0]]
        relabel = {v[0][0]:0}
        uu = [None] * NN
        rr = [None] * NN

        while test:
            i = test.pop()
            if i not in relabel:
                relabel[i] = n
                n += 1
            j = pr(i)
            if j not in relabel:
                test.append(j)
                relabel[j] = n
                n += 1
            rr[relabel[i]] = relabel[j]

            j = pu(i)
            if j not in relabel:
                test.append(j)
                relabel[j] = n
                n += 1
            uu[relabel[i]] = relabel[j]

        return Origami(rr,uu,as_tuple=True)

    def is_primitive(self,return_base=False):
        r"""
        An origami is primitive if it does not cover an other origami.

        An origami is primitive if the action of the monodromy group has no non
        trivial block.

        EXAMPLE::

            sage: o = Origami('(1,2)','(1,3)')
            sage: o.is_primitive()
            True
            sage: o = Origami('(1,2)(3,4)','(1,3,5,6)(2,4)')
            sage: o.is_primitive()
            False
        """
        from sage.rings.arith import is_prime
        if is_prime(self.nb_squares()):
            return True

        return bool(gap.IsPrimitive(self.monodromy()))

    def lattice_of_quotients(self,verbose=False):
        r"""
        Return the lattice of quotients of this origami.

        The set of quotients of an origami contain a maximal element (itself)
        and a minimal element (the 1-torus). More generally, it is organised as
        a lattice.

        EXAMPLES::

            sage: o = Origami('(1,2)','(1,3)')
            sage: P = o.normal_cover().lattice_of_quotients(); P
            Finite lattice containing 6 elements
            sage: for p in P:
            ...     print p.element.nb_squares(),p.element.stratum_component()
            6 H_odd(2^2)
            3 H_hyp(2)
            2 H_hyp(0)
            3 H_hyp(2)
            3 H_hyp(2)
            1 H_hyp(0)

            sage: 
        """
        from sage.combinat.posets.lattices import LatticePoset
        G = self.monodromy()
        n = self.nb_squares()
        r = self.r()
        u = self.u()
        blocks = list(gap("AllBlocks")(G))
        if verbose:
            print blocks
        d = {}
        for b in blocks:
            orbit = gap("Orbit")(G,b,gap("OnSets"))
            action = gap("Action")(G,orbit,gap("OnSets"))
            rr,uu = gap("GeneratorsOfGroup")(action)
            d[frozenset(map(Integer,b))] = Origami(rr,uu)
        d[frozenset(range(1,n+1))] = Origami([1],[1])
        d[frozenset([1])] = self
        if verbose:
            for i in d:
                print i,"->\n",d[i]
        E = d.values()
        R = [(d[i],d[j]) for i in d for j in d if i.issubset(j)]
        return LatticePoset((E,R))

    def is_regular(self):
        r"""
        An origami is regular if its automorphism group acts transitively on the
        squares.

        EXAMPLES::

            sage: o = origamis.eierlegende_wollmilchsau()
            sage: print o
            (1,2,3,4)(5,6,7,8)
            (1,5,3,7)(2,8,4,6)
            sage: o.is_regular()
            True
            sage: o.is_regular() == o.is_normal()
            True

        ::

            sage: o = Origami('(1,3,2,4,5,6)','(1,5)')
            sage: o.is_regular()
            False
            sage: o.is_regular() == o.is_normal()
            True
        """
        return bool(gap.IsTransitive(
                        self.automorphism_group(),
                        gap("[1..%d]" %(self.nb_squares()))
                        ))

    def is_quasi_regular(self):
        r"""
        An origami `(r,u)` is *quasi-regular* if the normal closure of the
        commutator `c = rur^{-1}u^{-1}` is contained in the automorphism group.

        Equivalently, a quasi-regular origami is a translation surface which is
        a normal cover of a torus ramified over several rational points.
        """
        return self.quotient().genus() == 1
        # other method from Gap
        #G = self.monodromy()
        #A = self.automorphism_group()
        #r = self.r(); u = self.u()
        #C = G.subgroup([r*u*~r*~u])
        #NC = gap.NormalClosure(G,C)
        #return gap.IsSubgroup(A,NC)

    def is_normal(self):
        r"""
        Tests if this origami is a normal cover of the torus

        An origami is normal if the subgroup of `F_2` that defines the cover is
        normal. It is equivalent to say that the order of the automorphism group
        equals the number of squares or that the automorphism group acts
        transitively on the squares.

        EXAMPLES::

            sage: o = Origami('(1,2)','(1,3)')
            sage: o.is_normal()
            False
            sage: o.is_normal() == o.is_regular()
            True

            sage: o = origamis.escalator(4)
            sage: o.is_normal()
            True
            sage: o.is_normal() == o.is_regular()
            True
        """
        return self.automorphism_group().order() == self.nb_squares()

    def cover(self, sr, su, check=True, as_tuple=False):
        r"""
        Build the (ramified) cover of this origami by sr and su

        INPUT:

        - `sr`, `su` - two list of N permutations where N is the number of
          squares of this origami

        - `check` - whether or not check the input

        - `as_tuple` - assume that sr and su are list of tuples of the same
          length and corresponds to permutations of [0,...,d-1] (much more
          efficient in time)

        EXAMPLES::

            sage: o = Origami('(1,2)','(1,3)'); o
            (1,2)(3)
            (1,3)(2)
            sage: o.cover(['(1,2)','',''],['','',''])
            (1,5,4,2)(3)(6)
            (1,3)(2)(4,6)(5)
        """
        from sage.groups.perm_gps.permgroup_named import SymmetricGroup

        N = self.nb_squares()
        if len(sr) != N or len(su) != N:
            raise ValueError, "sr and su should be two lists of length %d" %N

        r = self.r_tuple()
        u = self.u_tuple()

        if not as_tuple:
            sr = map(lambda x: [i-1 for i in PermutationGroupElement(x,check=check).domain()], sr)
            su = map(lambda x: [i-1 for i in PermutationGroupElement(x,check=check).domain()], su)

            d = max(len(x) for x in sr+su)

            for p in sr: p.extend(xrange(len(p),d))
            for p in su: p.extend(xrange(len(p),d))
        else:
            d = len(sr[0])

        rr = [None]*N*d
        uu = [None]*N*d

        for i in xrange(N):
            for j in xrange(d):
                rr[i+N*j] = r[i] + N*sr[i][j]
                uu[i+N*j] = u[i] + N*su[i][j]

        return Origami(rr,uu,check=check,as_tuple=True)

    def normal_cover(self):
        r"""
        Return the normal cover of this origami.
        """
        from itertools import imap
        G = self.monodromy()
        A = gap.Action(G,G,gap.OnRight)
        x,y = list(gap.GeneratorsOfGroup(A))
        return Origami(x,y)

class PillowcaseCover_generic(object):
    r"""
    Generic class for pillowcase cover.
    """
    def _check(self):
        x = self.g(0) * self.g(1) * self.g(2) * self.g(3)
        if not x.is_one():
            raise ValueError

    def monodromy(self):
        r"""
        Return the monodromy group of the pillowcase cover.

        The monodromy group of an origami is the group generated by the
        permutations `g_i` for `i` in 0,1,2,3.
        """
        from sage.groups.perm_gps.permgroup import PermutationGroup
        return PermutationGroup(self.g())

    def as_graph(self):
        r"""
        Return the graph associated to self

        The graph associated to an origami is the graph on [1,...,N] for which
        the edges correspond to the action of the permutations `r` and `u`.

        EXAMPLES::

            sage: o=Origami('(1,2)','(1,3)')
            sage: G = o.as_graph(); G
            Looped multi-digraph on 3 vertices
            sage: G.vertices()
            [0, 1, 2]
            sage: G.edges()
            [(0, 1, 'r'), (0, 2, 'u'), (1, 0, 'r'), (1, 1, 'u'), (2, 0, 'u'), (2, 2, 'r')]
        """
        from sage.graphs.digraph import DiGraph

        G = DiGraph(multiedges=True,loops=True)
        d = self.degree()
        g = [self.g_tuple(i) for i in xrange(4)]
        for i in xrange(d):
            for j in xrange(4):
                G.add_edge(i,g[j][i],j)
        return G

    def is_connected(self):
        r"""
        Check whether the origami is connected or not

        It is equivalent to ask whether the group generated by `r` and `u` acts
        transitively on the `\{1,\dots,n\}`.

        EXAMPLES::

            sage: o = Origami('(1,2)','(1,3)')
            sage: o.is_connected()
            True
            sage: o = Origami('(1,2)(3,4)','(1,2)',check=False)
            sage: o.is_connected()
            False
        """
        return self.as_graph().is_connected()

    def connected_components(self):
        r"""
        Return the list of connected origami that composes this origami.
        """
        cc = self.as_graph().connected_components()
        g = [self.g_tuple(i) for i in xrange(4)]
        if len(cc) == 1:
            return [self]
        l = []
        for c in cc:
            gg = [[None] * len(c) for _ in xrange(4)]
            d = dict((c[i],i) for i in xrange(len(c)))
            for i in c:
                for j in xrange(4):
                    gg[j][d[i]] = d[g[j][i]]
            l.append(Pillowcase_cover(g[0],g[1],g[2],g[3],check=True,as_tuple=True))
        return l

    def is_orientable(self):
        r"""
        Test whether the foliation is orientable.
        """
        return self.as_graph().to_undirected().is_bipartite()

    def to_origami(self):
        r"""
        If self is orientable returns it as a cover of a torus, otherwise raise
        an AssertionError.
        """
        assert self.is_orientable()

        raise NotImplementedError

    def profile(self,i=None):
        r"""
        Return the profile (= ramification type above each pole).
        """
        if i is None:
            return [self.profile(i) for i in xrange(4)]
        return sorted((len(c) for c in self.g(i).cycle_tuples(singletons=True)),reverse=True)

    def stratum(self,fake_zeros=False):
        r"""
        Return the stratum of self. It may be either a stratum of Abelian or
        quadratic differentials.
        """
        p = sum(self.profile(),[])
        if self.is_orientable():
            from sage.dynamics.flat_surfaces.abelian_strata import AbelianStratum
            if fake_zeros:
                zeros = [(i-2)//2 for i in p]
            else:
                zeros = [(i-2)//2 for i in p if i != 2]
            if zeros == []:
                return AbelianStratum([0])
            return AbelianStratum(zeros)

        else:
            from sage.dynamics.flat_surfaces.quadratic_strata import QuadraticStratum
            if fake_zeros:
                zeros = [i-2 for i in p]
            else:
                zeros = [i-2 for i in p if i != 2]
            return QuadraticStratum(zeros)


    def is_primitive(self,return_base=False):
        r"""
        An origami is primitive if it does not cover an other origami.

        An origami is primitive if the action of the monodromy group has no non
        trivial block.

        EXAMPLE::

            sage: o = Origami('(1,2)','(1,3)')
            sage: o.is_primitive()
            True
            sage: o = Origami('(1,2)(3,4)','(1,3,5,6)(2,4)')
            sage: o.is_primitive()
            False
        """
        from sage.rings.arith import is_prime
        if is_prime(self.degree()):
            return True

        return bool(gap.IsPrimitive(self.monodromy()))


class Origami_dense(Origami_dense_pyx,Origami_generic):
    r"""
    Dense origami

    A dense origami is represented by a couple ``(r,u)`` of permutations such
    that the group ``G = <r,u>`` generated by ``r`` and ``u`` acts transitively.
    The latter condition corresponds to the connectivity of the translation surface.
    """
    def rename(self, name):
        self._name = name

    #
    # Attribute access
    #

    def r(self):
        r"""
        Return the right permutation of the origami.

        EXAMPLES::

            sage: o = Origami('(1,2,3)','(1,2)')
            sage: o.r()
            (1,2,3)
        """
        return PermutationGroupElement([i+1 for i in self.r_tuple()],check=False)

    def r_inv(self):
        r"""
        Return the inverse of the right permutation

        EXAMPLES::

            sage: o = Origami('(1,2,3)','(1,2)')
            sage: o.r_inv()
            (1,3,2)
        """
        return PermutationGroupElement([i+1 for i in self.r_inv_tuple()],check=False)

    def u(self):
        r"""
        Return the up permutation of the origami

        EXAMPLES::

            sage: o = Origami('(1,2)','(1,2,3,4)')
            sage: o.u()
            (1,2,3,4)
        """
        return PermutationGroupElement([i+1 for i in self.u_tuple()],check=False)

    def u_inv(self):
        r"""
        Return the inverse of the up permutation of the origami

        EXAMPLES::

            sage: o = Origami('(1,2)','(1,2,3,4)')
            sage: o.u_inv()
            (1,4,3,2)
        """
        return PermutationGroupElement([i+1 for i in self.u_inv_tuple()],check=False)

    #
    # Autf(F2) and GL(2,Z) action
    #

    def apply_word(self,w):
        r"""
        Apply a word in l,r to self
        """
        o = copy(self)

        for letter in w[-1]:
            if letter[0] == 'l':
                o = o.horizontal_twist(letter[1])
            else:
                o = o.vertical_twist(letter[1])

        return o

    #
    # Automorphisms and quotients
    #

    def monodromy(self):
        r"""
        Return the monodromy group of the origami.

        The monodromy group of an origami is the group generated by the
        permutations ``r`` and ``u`` from which it is defined.

        EXAMPLES::

            sage: o = Origami('(1,2)','(1,3)')
            sage: G = o.monodromy()
            sage: G
            Permutation Group with generators [(1,2), (1,3)]
            sage: G.order()
            6
        """
        from sage.groups.perm_gps.permgroup import PermutationGroup
        return PermutationGroup([self.r(),self.u()])

    def automorphism_group(self,positive=True):
        r"""
        Returns the automorphism group of the origami as a permutation group

        The automorpism group of a translation surface is the set of affine
        diffeomorphisms which have a trivial linear part. For an origami, it
        corresponds combinatorially to the centralizer of the group generated by
        the permutations ``r`` and ``u`` that define this origami.

        EXAMPLES:

        The L with 3 squares has no automorphisms::

            sage: o = Origami('(1,2)','(1,3)')
            sage: G = o.automorphism_group()
            sage: G.order()
            1

        The 4-squares square tiled surface in H(1,1) has non trivial
        automorphism for which the quotient is a torus with two squares::

            sage: o = Origami('(1,2)(3,4)','(2,3)')
            sage: G = o.automorphism_group()
            sage: G.order()
            2
            sage: oo = o.quotient(G)
            sage: oo
            (1,2)
            (1)(2)
            sage: oo.stratum(fake_zeros=True)
            H(0^2)
        """
        if positive == False:
            raise NotImplementedError, "not yet"

        from sage.all import SymmetricGroup
        Sn = SymmetricGroup(self.nb_squares())
        G = gap.Subgroup(Sn,[self.r(),self.u()])
        C = gap.Centralizer(Sn,G)
        return Sn.subgroup(list(gap.GeneratorsOfGroup(C)))

    translation_group = automorphism_group

    def quotient(self, H=None):
        r"""
        Returns a quotient of self by the group ``H``.

        The group ``H`` must be a subgroup of the automorphism group of this
        origami. If ``H`` is None, it is set by default to the full automorphism
        group.

        EXAMPLES::

            sage: o = Origami('(1,2)(3,4)','(2,3)')
            sage: G = o.automorphism_group()
            sage: G.order()
            2
            sage: oo = o.quotient(G)
            sage: print oo
            (1,2)
            (1)(2)
            sage: oo.genus()
            1
        """
        if H is None:
            H = self.translation_group()
        elif not H.is_subgroup(self.automorphism_group()):
            raise ValueError, "H must be a sub group of the automorphism group"

        classes = H.orbits()
        classes_inv = [None] * (self.nb_squares()+1)
        for i,c in enumerate(classes):
            for j in c:
                classes_inv[j] = i+1

        r = self.r()
        u = self.u()

        rr = []
        uu = []

        for c in classes:
            rr.append(classes_inv[r(c[0])])
            uu.append(classes_inv[u(c[0])])

        return Origami(rr,uu,check=False)

    #TODO
    def maximal_torus(self):
        r"""
        Return the biggest torus this origami cover.
        """
        raise NotImplementedError

    #
    # Pickling
    #

    def __reduce__(self):
        r"""
        Pickling

        EXAMPLES::

            sage: o = Origami('(1,2)','(1,3)')
            sage: loads(dumps(o)) == o
            True
        """
        return Origami,(
                # r, u
                self.r_tuple(),self.u_tuple(),
                # sparse, check, as_tuple
                False,False,True,
                # positions, name
                getattr(self, '_pos', None),
                getattr(self, '__custom_name', None))

    #
    # String representation, latex and plot
    #

    def __str__(self):
        r"""
        String representation

        EXAMPLES::

            sage: print Origami('(1,2)','(1,3)').__str__()
            (1,2)(3)
            (1,3)(2)
            sage: print Origami('(1,2)','(1,3)',name='toto').__str__()
            (1,2)(3)
            (1,3)(2)
        """
        sr = self.r().cycle_string(singletons=True)
        su = self.u().cycle_string(singletons=True)
        return sr + "\n" + su


    def __repr__(self):
        if hasattr(self, '_name'):
            return self._name
        return self.__str__()

    def _latex_(self):
        r"""
        Latex representation of self

        EXAMPLES::

            sage: print Origami('(1,2)','(1,3)')._latex_()
            (1,2)(3) \atop (1,3)(2)
        """
        sr = self.r().cycle_string(singletons=True)
        su = self.u().cycle_string(singletons=True)
        return sr + " \\atop " + su

    def set_positions(self, pos):
        r"""
        Choose position of the squares for plotting

        set self._positions
        set self._lr_frontiers
        set self._tb_frontiers
        """
        r = self.r_tuple()
        u = self.u_tuple()
        if len(pos) != self.nb_squares():
            raise ValueError, "not enough positions"

        rl_frontiers = []
        tb_frontiers = []
        for i in xrange(self.nb_squares()):
            x,y = pos[i]
            xx,yy = pos[r[i]]
            if y != yy or x+1 != xx:
                rl_frontiers.append(i)

            xx,yy = pos[u[i]]
            if x != xx or y+1 != yy:
                tb_frontiers.append(i)

        self._pos = pos
        self._rl_frontiers = set(rl_frontiers)
        self._tb_frontiers = set(tb_frontiers)

    @options(
            side=True,side_color=(0.6,0.6,0.6),side_linestyle='dashed',side_alpha=0.8,
            frontier=True,frontier_color=(0.4,0.4,0.4),
            square=True,square_color=(0,0,1),square_alpha=0.1,
            text_square=True,text_square_color=(0,0,0),text_square_fontsize=11,
            text_frontier=True,text_frontier_color=(0.4,0.4,0.4),text_frontier_fontsize=8,
            vertex=True)
    def plot(self,**args):
        r"""
        Plot the normal form of self

        The positions of each square follow a naive algorithm. If you belive
        that a better picture exists look at the method .set_positions()

        EXAMPLES::

            sage: o = origamis.escalator(3)
            sage: o.plot()
        """
        if not hasattr(self, '_pos'):
            # if not use cylinder diagram
            o = self.to_standard_form()
            cyls = o.cylinder_decomposition()
            H = 0
            pos = []
            for cyl in cyls:
                _,_,w,h,_,_ = cyl
                for j in xrange(h):
                    pos.extend((i,H) for i in xrange(w))
                    H += 1
                H += 0.5
            o.set_positions(pos)
            return o.plot()

        from sage.plot.plot import Graphics
        from sage.plot.polygon import polygon2d
        from sage.plot.line import line2d
        from sage.plot.text import text
        from sage.plot.colors import rainbow
        from sage.plot.point import point2d

        d = {
            'side': {},
            'frontier':{},
            'square':{},
            'text_square':{},
            'text_frontier':{}
            }
        for key,value in args.iteritems():
            for k in d.keys():
                if key.startswith(k + '_'):
                    d[k][key[len(k)+1:]] = value

        r = self.r_tuple()
        u = self.u_tuple()

        urvertices = {}
        dlvertices = {}
        vv = self.vertices()
        colors = rainbow(len(vv),'rgbtuple')
        for j in xrange(len(vv)):
            v = vv[j]
            for i in v.up_right_tuple():
                urvertices[i-1] = colors[j]
            for i in v.down_left_tuple():
                dlvertices[i-1] = colors[j]

        G = Graphics()
        for i in xrange(self.nb_squares()):
            x0,y0 = self._pos[i]
            x1 = x0+1; y1 = y0+1
            if args['square']:
                G += polygon2d([(x0,y0),(x1,y0),(x1,y1),(x0,y1)],**d['square'])
            if args['text_square']:
                G += text("%d" %(i+1),(x0+0.5,y0+0.5),**d['text_square'])

        for i in xrange(self.nb_squares()):
            x0,y0 = self._pos[i]
            x1 = x0+1; y1 = y0+1

            if i in self._rl_frontiers:
                xx0,yy0 = self._pos[r[i]]
                if args['frontier']:
                    G += line2d([(x1,y0),(x1,y1)],**d['frontier'])
                    G += line2d([(xx0,yy0),(xx0,yy0+1)],**d['frontier'])
                if args['text_frontier']:
                    G += text("%d" %(r[i]+1),(x1-0.08,y0+0.5),**d['text_frontier'])
                    G += text("%d" %(i+1),(xx0+0.08,yy0+0.5),**d['text_frontier'])
                if args['vertex'] and i in urvertices:
                    G += point2d((xx0,yy0+1),color=urvertices[i],pointsize=30)
                if args['vertex'] and r[i] in dlvertices:
                    G += point2d((x0+1,y0),color=dlvertices[r[i]],pointsize=30)
            else:
                G += line2d([(x1,y0),(x1,y1)],**d['side'])

            if i in self._tb_frontiers:
                xx0,yy0 = self._pos[u[i]]
                if args['frontier']:
                    G += line2d([(x0,y1),(x1,y1)],**d['frontier'])
                    G += line2d([(xx0,yy0),(xx0+1,yy0)],**d['frontier'])
                if args['text_frontier']:
                    G += text("%d" %(u[i]+1),(x0+0.5,y1-0.08),**d['text_frontier'])
                    G += text("%d" %(i+1),(xx0+0.5,yy0+0.08),**d['text_frontier'])
                if args['vertex'] and i in urvertices:
                    G += point2d((xx0+1,yy0),color=urvertices[i],pointsize=30)
                if args['vertex'] and u[i] in dlvertices:
                    G += point2d((x0,y0+1),color=dlvertices[u[i]],pointsize=30)
            else:
                if args['frontier']:
                    G += line2d([(x0,y1),(x1,y1)],**d['side'])

            if args['vertex'] and i in dlvertices:
                G += point2d((x0,y0),color=dlvertices[i],pointsize=30)
            if args['vertex'] and i in urvertices:
                G += point2d((x1,y1),color=urvertices[i],pointsize=30)

        return G

    def show(self):
        r"""
        Show a picture of this origami.
        """
        self.plot().show(axes=False,aspect_ratio=1)

    #
    # standard form
    #


    #TODO
    def characteristic_cover(self):
        r"""
        Returns the characteristic cover of this origami
        """
        raise NotImplementedError

    #
    # Cylinder decomposition in horizontal direction
    #

    def cylinder_decomposition(self):
        r"""
        Returns the cylinder decomposition of the standard form of this origami.

        OUTPUT:

        A list of cylinders where each cylinder is a 6-tuple
        ``(bot,top,w,h,bot_twist,top_twist)`` where

        - ``bot`` and ``top`` are list of right squares adjacent to
          singularities (the order is in the direction of the permutation r of
          the origami)

        - ``w`` and ``h`` are width and height of the cylinder

        - ``bot_twist`` and ``top_twist`` are twist between the minimum square
          number and the minimum square number adjacent to a singularity.

        EXAMPLES::

            sage: r  = '(1,2,3,4)(5,6)'
            sage: u0 = '(1,5)(2,6)(3)(4)'
            sage: u1 = '(1,5,2,6,3,4)'
            sage: u2 = '(1,5,3)(2,6,4)'
            sage: u3 = '(1,5,4,3,2,6)'
        """
        o = self.to_standard_form()
        r = o.r()
        ri = ~r
        u = o.u()
        ui = ~u

        udr_sq = [] # (up-right,down-right) couples adjacent to singularities
        for v in (ui*ri*u*r).cycle_tuples():
            udr_sq.extend((j,ui(j)) for j in v)

        if not udr_sq: # torus
            udr_sq = [(1,ui(1))]

        udr_sq.sort()
        udr_tot = set(udr_sq)

        cyls = []
        while udr_sq:
            j,ji = udr_sq.pop(0)
            k = r.orbit(j)  # the min is not necessarily at a singularity
            jj = min(k)     # because of the standard form. Hence we
                            # construct the r orbit of j.
                            # the bot twist is the distance between the
                            # min square and the min singularity
                            # width is r^-1(j)-j
            bot_twist = j-jj
            w = ri(jj)-jj+1
            bot = [(j,ji)]
            while udr_sq and udr_sq[0][0] < w+jj:
                bot.append(udr_sq.pop(0))
            l = min(x[1] for x in udr_tot)

            h = (l-jj)//w + 1
            top = filter(lambda i: jj+(h-1)*w <= i[1] and i[1] < jj+h*w, udr_tot)
            top.sort(cmp=lambda x,y: -x[1].__cmp__(y[1]))

            top_twist = min(t[1] for t in top) - (jj+(h-1)*w)

            #top.reverse()
            cyls.append((bot,top,w,h,bot_twist,top_twist))

            udr_tot = udr_tot.difference(top)

        return cyls

    def cylinder_diagram(self, data=False):
        r"""
        Returns the cylinder diagram corresponding to the horizontal direction.
        If ``data`` is True, returns as well the list of lengths of
        separatrices, the heigths of cylinders and the twists.

        The *cylinder diagram* of a completely periodic surface encodes the
        combinatorics of cylinders and saddle connections. From a cylinder
        diagram and its metric data, it is possible to build the surface back.

        INPUT:

        - ``data`` - boolean (default: False) - if True, return the cylinder
          diagrams, the lengths, the heights and twists.

        EXAMPLES:

        The two examples in the stratum H(2)::

            sage: o1 = Origami('(1,2,3)','(2,3)')
            sage: o1.stratum()
            H(2)
            sage: c1 = o1.cylinder_diagram()
            sage: c1.ncyls()
            1
            sage: c1.nseps()
            3
            sage: o2 = Origami('(1,2)','(1,3)')
            sage: o2.stratum()
            H(2)
            sage: c2 = o2.cylinder_diagram()
            sage: c2.ncyls()
            2
            sage: c2.nseps()
            3

            sage: r = (1,2,0,4,5,6,3)
            sage: u = (1,2,3,5,4,0,6)
            sage: o = Origami(r,u,as_tuple=True)
            sage: c,lengths,heights,twists = o.cylinder_diagram(True)
            sage: c.cylcoord_to_origami(lengths,heights,twists) == o
            True

        TESTS:

        Check consistency of cylinder data::

            sage: r = '(1,2,3,4,5,6,7,8)(9,10,11,12,13,14,15,16)'
            sage: u = '(1,9,3,15,5,13,7,11)(2,14,8,16,6,10,4,12)'
            sage: o3 = Origami(r,u)
            sage: c3 = o3.cylinder_diagram()
            sage: c3.ncyls()
            2
            sage: c3.nseps()
            8
            sage: r = '(1,2,3,4)(5,6,7,8)(9,10,11,12)(13,14,15,16)'
            sage: u = '(1,5,3,10)(2,9,13,11)(4,8,15,6)(7,14,12,16)'
            sage: o4 = Origami(r,u)
            sage: c4 = o4.cylinder_diagram()
            sage: c4.ncyls()
            4
            sage: c4.nseps()
            8
        """
        from sage.dynamics.flat_surfaces.separatrix_diagram import CylinderDiagram

        cyl_dec = self.cylinder_decomposition()

        # find a renumerotation for edges
        edges = []
        cyl_ren = []
        for i,cyl in enumerate(cyl_dec):
            edges.extend(cyl[0])
            cyl_ren.append((cyl[0][0][0],i))

        edges.sort()   # index to edge
        e2i = dict((edges[i],i) for i in xrange(len(edges)))  # edge to index
        cyl_ren.sort()
        cyl_ren = dict((j[0],i) for i,j in enumerate(cyl_ren))

        # now build a cylinder diagram with lengths, twists and heights
        cyls = []
        lengths = [None]*len(edges)
        heights = [None]*len(cyl_dec)
        twists = []
        for b,t,w,h,_,_ in cyl_dec:
            ww = w
            n = cyl_ren[b[0][0]]
            for i in xrange(len(b)-1):
                lengths[e2i[b[i]]] = b[i+1][0] - b[i][0]
                ww -= lengths[e2i[b[i]]]
            lengths[e2i[b[-1]]] = ww
            heights[n] = h

            bot = tuple(e2i[e] for e in b)
            top = tuple(e2i[e] for e in t)
            s_bot = edges[min(bot)][0]
#            print "min(bot) = %d   s_bot = %d" %(min(bot),s_bot)
            s_top = edges[min(top)][1]
#            print "min(top) = %d   s_top = %d" %(min(top),s_top)
            twists.append((s_top - s_bot) % w)
            cyls.append((bot,top))

        if data:
            return CylinderDiagram(cyls), lengths, heights, twists
        else:
            return CylinderDiagram(cyls)

    #
    # Homology
    #

    def up_right_vertex(self, i):
        r"""
        Returns the vertex at the top right corner of the square i
        """
        return OrigamiVertices(self).up_right_vertex(i)

    def down_left_vertex(self, i):
        return OrigamiVertices(self).down_left_vertex(i)

    vertex = up_right_vertex

    def vertices(self, fake_zeros=False, register_automorphism_action=True):
        r"""
        Return the vertices of self.
        """
        if fake_zeros:
            return OrigamiVertices(self,register_automorphism_action)
        else:
            return filter(lambda v: v.degree(), OrigamiVertices(self,register_automorphism_action))

    def vertex_degrees(self, fake_zeros=False):
        return sorted((v.degree() for v in self.vertices(fake_zeros)),reverse=True)

    def nb_vertices(self, fake_zeros=False):
        r"""
        Return the number of vertices of the origami
        """
        return len(self.vertices(fake_zeros))

    def stratum(self, fake_zeros=False):
        r"""
        Stratum of this origami.

        EXAMPLES::

            sage: o = Origami('(1,2)','(1,3)')
            sage: o.stratum()
            H(2)

        One can ask for fake zeroes and get the stratum with all punctures
        marked::

            sage: o = Origami('(1,2,3)','(1,4)')
            sage: o.stratum(fake_zeros=False)
            H(2)
            sage: o.stratum(fake_zeros=True)
            H(2, 0)
        """
        from sage.dynamics.flat_surfaces.abelian_strata import AbelianStratum
        degrees = self.vertex_degrees(fake_zeros)
        if degrees:
            return AbelianStratum(degrees)
        return AbelianStratum(0)

    def genus(self):
        r"""
        Return the genus of the origami

        EXAMPLES::

            sage: o = Origami('(1,2)','(1,3)')
            sage: o.genus()
            2
            sage: o = Origami('(1,2)(3,4)','(1,3)')
            sage: o.genus()
            2
        """
        return self.stratum().genus()

    def chain_complex(self):
        r"""
        Return the chain complex of the origami

        EXAMPLES::

            sage: o = Origami('(1,2,3,4)','(1,5)')
            sage: o.chain_complex()
            Chain complex of origami
            (1,2,3,4)(5)
            (1,5)(2)(3)(4)

        We now play with cyclic cover::

            sage: o = origamis.CyclicCover([1,1,1,9]).relabel()

        """
        return OrigamiChainComplex(self)

    def loop_space(self):
        r"""
        The loop space is the subspace of H_1(S,Sigma; Z) generated by the
        (dual) loop around each singularity

        Its dimension is s-1
        """
        vecs = []
        for v in self.vertices(True):
            vecs.append(sum(v.outgoing_vectors()) - sum(v.incoming_vectors()))

        return self.chain_space().subspace(vecs)

    def fundamental_group(self):
        r"""
        Return the fundamental group of this origami in terms of generators of
        the gree group.

        OUTPUT:

        - the free group on two generators (gap object)

        - a subgroup of the preceding group (gap object)

        """
        from sage.graphs.digraph import DiGraph

        F = gap("FreeGroup")(2)
        Fgens = list(gap("GeneratorsOfGroup")(F))
        name_to_gen = {'x': Fgens[0], 'y': Fgens[1]}  # generators
        G = self.dual_graph()
        T = DiGraph(implementation='c_graph')

        vertices = set(range(1,self.nb_squares()))
        d = {}  # the group element at the end of the edge
        d[0] = Fgens[0]*Fgens[0]**-1  # the identity !!!

        l = [0]
        T.add_vertex(0)
        rest = []
        while vertices:
            v = l.pop()
            for e in G.outgoing_edge_iterator(v):
                if T.has_vertex(e[1]):
                    rest.append(e)
                else:
                    T.add_edge(e)
                    d[e[1]] = d[e[0]] * name_to_gen[e[2]]
                    l.append(e[1])
                    vertices.remove(e[1])
                G.delete_edge(e)
            for e in G.incoming_edge_iterator(v):
                if T.has_vertex(e[0]):
                    rest.append(e)
                else:
                    T.add_edge(e)
                    d[e[0]] = d[e[1]] * name_to_gen[e[2]]**-1
                    l.append(e[0])
                    vertices.remove(e[0])
                G.delete_edge(e)

        rest.extend(G.edges())

        gens = []
        for e in rest:
            gens.append(d[e[0]] * name_to_gen[e[2]] * d[e[1]]**-1)

        return F,gap("Subgroup")(F,gens)

    #
    # Homology representation of automorphism group
    #

    def character_of_vertices_permutation(self, fake_zeros=True):
        r"""
        Return the character associated to the action of the automorphism group
        of self on vertices.

        INPUT:

        - ``fake_zeros`` - boolean (default: True) - whether or not consider
          fake zeros.

        EXAMPLES::

            sage: print "TODO"
            TODO
        """
        from sage.groups.class_function import ClassFunction

        A = self.automorphism_group()
        V = self.vertices(fake_zeros=fake_zeros)
        chi = []
        for g in A.conjugacy_classes_representatives():
            chi.append(sum(g*v == v for v in V)) # nb of fixed point of g
        return ClassFunction(A,chi)

    def character_of_holonomy_free_representation(self):
        r"""
        Return the character of the holonomy free representation.
        """
        from sage.groups.class_function import ClassFunction

        G = self.monodromy()
        A = self.automorphism_group()

        # build the character of the regular representation of A
        # we assume that id is the first item of
        # A.conjugacy_class_representatives()
        cc = A.conjugacy_classes_representatives()
        chi = [G.order()] + [0]*(len(cc)-1)

        # character of vertices permutation
        chi_v = self.character_of_vertices_permutation()

        return ClassFunction(A, [i-j for i,j in zip(chi,chi_v)])

    def homology_isotypic_components(self, ring=None):
        r"""
        The natural action is twice the regular representation (for which
        isotypical component are easy to compute).

        OUTPUT:

        a list of 2-tuples (character, basis).
        """
        if ring is None:
            from sage.rings.complex_double import CDF
            ring = CDF
        n = self.nb_squares()
        A = self.automorphism_group()
        C = self.character_of_holonomy_free_representation()
        D = C.decompose()

        # canonical numerotation for holonomy
        P = {}
        for d,r in D:
            v = d.values()
            p = matrix(ring,n)
            for i,cc in enumerate(G.conjugacy_classes_representative()):
                for a in gap.ConjugacyClass(A,cc):
                    pass

            P[r] = d*r[0] / A.order() * p








    #
    # KZ and GL(2,Z) action
    #

    def sl2z_simplicial_action(self,w,return_origamis=False):
        r"""
        Return a matrix action on the canonical 1-dimensional chains

        We return the action on the origami in standard forms...

        See also :meth:`automorphism_simplicial_action`

        OUTPUT:

        - ``o1,o2`` - the origamis at the begining and at the end

        - ``m`` - the matrix

        """
        o = self.to_standard_form()

        r = o.r()
        u = o.u()
        n = o.nb_squares()

        rr,uu,m1 = permutation_simplicial_action(r,u,n,w)

        oo = Origami(rr,uu)
        ooo,s = oo.to_standard_form(True)

        m2 = matrix(2*n)
        m2[:n,:n] = s.matrix().transpose()
        m2[n:,n:] = s.matrix().transpose()

        if return_origamis:
            return o,ooo,m2*m1
        return m2*m1

    def automorphism_simplicial_action(self, g):
        r"""
        Return the simplicial action of the automorphism ``g``.

        See also: :meth:`sl2z_simplicial_action`
        """
        from sage.matrix.constructor import matrix

        N = self.nb_squares()

        m = matrix(2*N)
        for i in xrange(N):
            m[g(i+1)-1, i] = 1
            m[N+g(i+1)-1, N+i] = 1
        return m

    def orbit_graph(self, return_map=False):
        r"""
        Return the graph of action of PSL on this origami

        INPUT:

        - ``return_map`` - return the list of origamis in the orbit

        - ``projective`` - get the projective (i.e. PSL)

        """
        return self.teichmueller_curve().orbit_graph(return_map)

    def veech_group(self):
        r"""
        Returns the Veech group of this origami
        """
        return self.teichmueller_curve().veech_group()

    @cached_method
    def teichmueller_curve(self):
        r"""
        Return the teichmueller curve of this origami

        (the result is cached for future usage)
        """
        from teichmueller_curve import TeichmuellerCurveOfOrigami
        return TeichmuellerCurveOfOrigami(self)

    def sum_of_lyapunov_exponents(self):
        r"""
        Returns the sum of Lyapunov exponents for this origami

        EXAMPLES::

            sage: o = Origami('(1,2)','(1,3)')
            sage: o.sum_of_lyapunov_exponents()
            4/3
            sage: o = Origami('(1,2)(3,4)','(2,3)')
            sage: o.sum_of_lyapunov_exponents()
            3/2
        """
        return self.teichmueller_curve().sum_of_lyapunov_exponents()

class PillowcaseCover_dense(PillowcaseCover_dense_pyx,PillowcaseCover_generic):
    def _repr_(self):
        return '\n'.join("g_%d = %s"%(i,self.g(i)) for i in xrange(4))

    def g(self,i=None):
        if i is None:
            return self.g(0), self.g(1), self.g(2), self.g(3)

        if i != 0 and i != 1 and i != 2 and i !=3:
            raise ValueError, "i should be in {0,1,2,3}"

        return PermutationGroupElement([j+1 for j in self.g_tuple(i)], check=False)

#
# Other stuff which should be moved in a more geometrical place (like CW
# complex or embeeded graph or whatever).
#

from sage.categories.action import Action
from sage.categories.finite_enumerated_sets import FiniteEnumeratedSets
import operator

class ActionOnOrigamiObjects(Action):
    r"""
    Generic action of the automorphism group of an origami.
    """
    def __init__(self, objects):
        o = objects.origami()
        # Action.__init__(G,S,is_left,op)
        Action.__init__(
                self,
                o.automorphism_group(),
                objects,
                True,
                operator.mul)

    def _call_(self, g, x):
        r"""
        Action of g on x.
        """
        return x._acted_upon_(g)

class OrigamiObjects(Parent):
    def chain_space(self):
        return VectorSpace(QQ, self.cardinality())

    @cached_method
    def cycle_space(self):
        return self.derivative().right_kernel()

    @cached_method
    def border_space(self):
        return self.derivative().column_space()

class OrigamiFaces(OrigamiObjects):
    def __init__(self, origami):
        Parent.__init__(self, category=FiniteEnumeratedSets())
        self._origami = origami

    def cardinality(self):
        return self._origami.nb_squares()

    def derivative(self):
        n = self._origami.nb_squares()
        ri = self._origami.r_inv_tuple()
        ui = self._origami.u_inv_tuple()
        der = matrix(2*n,n,ring=QQ)
        for i in xrange(n):
            if ui[i] != i: # horiz sides
                der[i,i] = -1
                der[ui[i],i] = 1
            if ri[i] != i: # vert sides
                der[n+i,i] = 1
                der[n+ri[i],i] = -1
        return der

class OrigamiEdges(OrigamiObjects):
    r"""
    """
    def __init__(self, origami):
        Parent.__init__(self)
        self._origami = origami
        ri = origami.r_inv_tuple()
        ui = origami.u_inv_tuple()
        n = origami.nb_squares()

        self._starts = [None]*(2*n)
        self._ends = [None]*(2*n)
        for i in xrange(n):
            self._ends[i] = origami.vertex(i+1).index()
            self._starts[i] = origami.vertex(ri[i]+1).index()

            self._ends[n+i] = origami.vertex(i+1).index()
            self._starts[n+i] = origami.vertex(ui[i]+1).index()

    def origami(self):
        return self._origami

    # about elements

    def _element_constructor(self, i):
        if i >= 0 and i < 2*o.nb_squares():
            return o.chain_complex().chain_space(1).gen(i)

    def start(self,i):
        return self._starts[i]

    def end(self,i):
        return self._ends[i]

    # about global derivation

    def cardinality(self):
        return 2*self._origami.nb_squares()

    def derivative(self):
        m = self._origami.nb_vertices(True)
        n = 2*self._origami.nb_squares()
        der = matrix(m,n,ring=QQ)
        for i in xrange(n):
            if self._starts[i] != self._ends[i]:
                der[self._ends[i], i] = 1
                der[self._starts[i], i] = -1
        return der

    # geometric stuff (should be moved in cylinder diagrams)

    def is_simple_closed_curve(self, c):
        r"""
        Test if c is a simple closed curve
        """
        assert(c in self.chain_space())
        d = c.dict()
        for i in d:
            if d[i] != 1 and d[i] != -1:
                return False

        vertices = set([])
        for i in d:
            if d[i] == 1:
                v = self.end(i)
            else:
                v = self.start(i)
            if v in vertices:
                return False

            vertices.add(v)

        return True

    def simple_closed_curve_to_vertex_in_out(self, c):
        r"""
        From a curve c (as a vector) returns two dictionnaries associated to
        input/output view from each visited vertices
        """
        c_in = {}
        c_out = {}
        for i,j in c.dict().iteritems():
            if j == 1:
                c_in[self.start(i)] = i
                c_out[self.end(i)] = i
            elif j == -1:
                c_in[self.end(i)] = i
                c_out[self.start(i)] = i
            else:
                raise ValueError, "not a simple closed curve"
        return c_in, c_out

    def basis_of_simple_closed_curves(self):
        from sage.graphs.digraph import DiGraph
        from sage.all import randint

        n = self._origami.nb_squares()
        C = self.chain_space()
        G = DiGraph(multiedges=True,loops=True,implementation='c_graph')

        for i in xrange(2*n):
            G.add_edge(self._starts[i], self._ends[i], i)

        waiting = [0]
        gens = []
        reps = [None] * G.num_verts()
        reps[0] = C.zero()

        while waiting:
            x = waiting.pop(randint(0,len(waiting)-1))
            for v0,v1,e in G.outgoing_edges(x):
                if reps[v1] is not None:
                    gens.append(reps[v0] + C.gen(e) - reps[v1])
                else:
                    reps[v1] = reps[v0] + C.gen(e)
                    waiting.append(v1)

        return gens

    def intersection(self, c1, c2):
        r"""
        Returns the intersection of c1 and c2 assuming that they are simple
        closed curves
        """
        assert(self.is_simple_closed_curve(c1) and self.is_simple_closed_curve(c2))

        c1_in, c1_out = self.simple_closed_curve_to_vertex_in_out(c1)
        c2_in, c2_out = self.simple_closed_curve_to_vertex_in_out(c2)

        intersection = 0
        for vert in c1_in:
            if vert in c2_in:
                if c1_in[vert] == c2_in[vert]:
                    if c1_out[vert] == c2_out[vert]:
                        pass
                    elif are_cyclically_ordered(
                            c1_in[vert], c1_out[vert], c2_out[vert]):
                        intersection += 1

                elif c1_out[vert] == c2_out[vert]:
                    if are_cyclically_ordered(
                            c1_out[vert], c2_in[vert], c1_in[vert]):
                        intersection -= 1

                elif are_cyclically_ordered(
                        c1_in[vert],c2_in[vert],c1_out[vert]):
                    if are_cyclically_ordered(
                            c1_out[vert],c2_out[vert],c1_in[vert]):
                            intersection += 1

                elif are_cyclically_ordered(
                        c1_in[vert],c2_out[vert],c1_out[vert]):
                    intersection -= 1

        return intersection

    def winding(self, c):
        r"""
        Return the winding of the curve c
        """
        assert(self.is_simple_closed_curve(c))
        pass

class OrigamiVertices(OrigamiObjects):
    r"""
    The set of vertices of an origami.

    It is in bijection with the biclasses H  G  C where H is the stabilizer of
    1 and C is the subgroup generated by the commutator ``r u r**-1 u **-1``.
    """
    def __init__(self, origami, register_automorphism_action=False):
        Parent.__init__(self, category=FiniteEnumeratedSets())
        self._origami = origami

        self._vertices = []
        self._vertices_inv = {}
        self._vertex_from_ur = {}
        self._vertex_from_dl = {}

        r = origami.r()
        u = origami.u()
        ru = r*u
        vperm = ru*~r*~u

        for ur in vperm.cycle_tuples(singletons=True):
            dl = map(ru,ur)
            v = OrigamiVertex(self, ur, tuple(dl))
            self._vertices_inv[v] = len(self._vertices)
            self._vertices.append(v)
            for i in ur:
                self._vertex_from_ur[i] = v
            for i in dl:
                self._vertex_from_dl[i] = v

        if register_automorphism_action:
            self.register_action(ActionOnOrigamiObjects(self))

    def origami(self):
        return self._origami

    def cardinality(self):
        return len(self._vertices)

    def chain_space(self):
        return VectorSpace(QQ, self.cardinality())

    def derivative(self):
        return matrix([1]*len(self._vertices), ring=QQ)

    def _repr_(self):
        return "Vertices of origami\n%s" %self.origami()

    def __contains__(self, v):
        return v in self._vertices

    def up_right_vertex(self, i):
        return self._vertex_from_ur[i]

    def down_left_vertex(self, i):
        return self._vertex_from_dl[i]

    vertex = up_right_vertex
    _element_constructor_ = up_right_vertex

    def vertex_index(self, v):
        return self._vertices_inv[v]

    def __getitem__(self, i):
        r"""
        Access to a given element.
        """
        return self._vertices[i]

    def __iter__(self):
        r"""
        Iterator over the vertices.
        """
        return iter(self._vertices)

class OrigamiVertex(Element):
    def __init__(self, parent, ur, dl):
        Element.__init__(self, parent)
        self._ur = ur
        self._dl = dl

    def _repr_(self):
        return "vertex %s" %(str(self._ur))

    def __str__(self):
        return str(self._ur)

    def __hash__(self):
        return hash((self._ur,self._dl))

    def __eq__(self, other):
        return (type(self) == type(other) and
                self.parent() == other.parent() and
                self._ur == other._ur)

    def __ne__(self, other):
        return (type(self) != type(other) or
                self.parent() != other.parent() or
                self._ur != other._ur)

    def _acted_upon_(self, g):
        r"""
        Return the action of the element g of the automorphism group of the
        origami on self.
        """
        return self.parent().up_right_vertex(g(self._ur[0]))

    def index(self):
        return self.parent().vertex_index(self)

    def degree(self):
        return len(self._ur)-1

    def up_right_tuple(self):
        return self._ur

    def down_left_tuple(self):
        return self._dl

    # adjacent vectors

    def adjacent_edge_indices(self):
        r"""
        Returns a 2-tuple (incoming,outgoing)
        """
        return self.incoming_edge_indices(), self.outgoing_edge_indices()

    def outgoing_edge_indices(self):
        n = self.parent().origami().nb_squares()
        ri = ~self.parent().origami().r()
        ui = ~self.parent().origami().u()
        res = []
        for i in self._dl:
            res.append(ui(i)-1)
            res.append(n+ri(i)-1)
        return res

    def incoming_edge_indices(self):
        res = []
        n = self.parent().origami().nb_squares()
        for i in self._ur:
            res.append(i-1)
            res.append(n+i-1)
        return res

    @cached_method
    def edge_positions(self):
        d_in = {}
        d_out = {}
        e_in = self.incoming_edge_indices()
        e_out = self.outgoing_edge_indices()
        k = 0
        for i in xrange(0,len(e_in),2):
            d_in[e_in[i]] = k
            d_in[e_in[i+1]] = k+1
            d_out[e_out[i]] = k+2
            d_out[e_out[i+1]] = k+3
            k += 4
        return d_in, d_out

    def incoming_edge_position(self, i):
        return self.edge_positions()[0][i]

    def outgoing_edge_positions(self, i):
        return self.edge_positions()[1][i]

class OrigamiChainComplex(SageObject, UniqueRepresentation):
    r"""
    Chain complex for reduced homology of the origami
    """
    def __init__(self, origami):
        self._origami = origami
        self._objects = [OrigamiVertices(origami), OrigamiEdges(origami), OrigamiFaces(origami)]

    def origami(self):
        r"""
        Return the underlying origami.
        """
        return self._origami

    def chain_space(self, degree):
        r"""
        Chain space.

        INPUT:

        - ``degree`` -- either

        """
        assert(degree > -2 and degree < 3)
        if degree == -1:
            return VectorSpace(QQ,1)
        return self._objects[degree].chain_space()

    def cycle_space(self, degree):
        r"""
        Returns the space of cycles of degree i

        Zi = ker(der: C_i -> C_{i-1})
        """
        assert(degree > -2 and degree < 3)
        if degree == -1:
            return VectorSpace(QQ,1)
        return self._objects[degree].cycle_space()

    def border_space(self, degree):
        r"""
        Returns the space of borders of degree i

        Bi = im(der: C_{i+1} -> Ci)
        """
        assert(degree > -2 and degree < 3)
        if degree == 2:
            return self._objects[2].chain_space().subspace([])
        return self._objects[degree+1].border_space()

    def _repr_(self):
        return "Chain complex of origami\n%s" %(self.origami())


