r"""
RC4

A simplified educational variant of the RC4 cryptosystem. It is a
full-scale version of the RC4 cipher, but the initialization
procedure for the state-array S has not been dealt with rigorously.
This can be an educational tool to teach RC4 as well as suitable for
small-scale encryption and decryption operations.

AUTHORS:

- Sourav Sen Gupta (2010-08): initial version
"""

###########################################################################
# Copyright (c) 2010 Sourav Sen Gupta <sg.sourav@gmail.com>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# http://www.gnu.org/licenses/
###########################################################################

from sage.structure.sage_object import SageObject
from sage.crypto.util import ascii_to_bin, ascii_integer
from sage.rings.integer import Integer
from sage.rings.integer_ring import ZZ


class RC4(SageObject):
    r"""
    This class implements an simple version of the RC4 Cryptosystem for Sage.

    The initial assignment of the bytearray is :math:`S = \{0,1,2,\ldots,255\}`
        Note that there are better and more secure initial assignment possible.
        We omit the details here in this studentized version of the code.
        One may refer to related publications on RC4 attacks to know further details.

    The initialization phase performs the Key Scheduling Algorithm (KSA) of RC4 on
    the initial configuration of :math:`S` to generate a random configuration, using
    the key supplied by the user.

    Key Scheduling Algorithm for RC4
    ::
        for i from 0 to 255 do
            S[i] = i

        for i from 0 to 255 do
            K[i] = key[i mod len(key)]

        i = 0
        j = 0
        while i < 256 do
            j = (j + S[i] + K[i]) mod 256
            swap S[i], S[j]
            i = i + 1

    The PRGA uses the configuration of :math:`S` as produced by the KSA to generate a pseudo-random bytestream.

    Pseudo-Random Generation Algorithm (PRGA) of RC4
    ::
        i = 0
        j = 0
        while i < n do
            i = (i + 1) mod 256
            j = (j + S[i]) mod 256

            swap S[i], S[j]
            Z = S[(S[i] + S[j]) mod 256]

            return Z

    The Plaintext is converted into a bytestream and XORed with the same length
    bytestream generated by PRGA to produce the Ciphertext.

    RC4 Encryption
    ::
        P = Bytestream from Plaintext
        Z = PRGA(length of the Plaintext bystream)

        C = P xor Z
        Ciphertext = String from Bytestream C

        return Ciphertext

    The Ciphertext is converted into a bytestream and XORed with the same length
    bytestream generated by PRGA to produce the Plaintext (note that the PRGA generated
    ketstream is the same as that in encryption as we use the same key for both cases).

    RC4 Decryption
    ::
        C = Bytestream from Ciphertext
        Z = PRGA(length of the Ciphertext bystream)

        P = C xor Z
        Plaintext = String from Bytestream P

        return Plaintext

    EXAMPLES::

        sage: from sage.crypto.rc4 import RC4
        sage: M = "Sage Days"
        sage: k = [7,1,4,8,2,9,0,12,46,234]
        sage: r = RC4(k); r
        An educational version of the RC4 Cryptosystem
        sage: C = r.encrypt(M); C
        '!\xe2\x1b\xb4\x9b\xa8+\x1f\xb0'
        sage: P = r.decrypt(C); P
        'Sage Days'
    """
    def __init__(self, key):
        """
        Initiates the instance of RC4 with the Key specified by the user.

        INPUT: The key for RC4 (usually a array of 8 to 15 bytes)

        - ``key`` - a list or bytearray of size between 8 to 15

        The initial assignment of the bytearray is :math:`S = \{0,1,2,\ldots,255\}`
        Note that there are better and more secure initial assignment possible.
        We omit the details here in this studentized version of the code.
        One may refer to related publications on RC4 attacks to know further details.

        The initialization phase performs the Key Scheduling Algorithm (KSA) of RC4 on
        the initial configuration of :math:`S` to generate a random configuration, using
        the key supplied by the user.

    Key Scheduling Algorithm for RC4
    ::
        for i from 0 to 255 do
            S[i] = i

        for i from 0 to 255 do
            K[i] = key[i mod len(key)]

        i = 0
        j = 0
        while i < 256 do
            j = (j + S[i] + K[i]) mod 256
            swap S[i], S[j]
            i = i + 1
        """
        if not isinstance(key, list):
            raise TypeError("input 'key' must be a non-empty list of integers between 0 to 255, or a bytearray (generally the size of the list is between 8 to 15)")

        if len(key) == 0:
            raise TypeError("input 'key' must be a non-empty list or bytearray (generally the size of the list is between 8 to 15)")

        self._key = key
        self._K = bytearray(256)
        self._S = range(256)

        for i in range(256):
            self._K[i] = self._key[(ZZ(i)).mod(len(self._key))]

        j = 0
        for i in range(256):
            j = (ZZ(j + self._S[i] + self._K[i])).mod(256)
            temp = self._S[i]
            self._S[i] = self._S[j]
            self._S[j] = temp

    def __repr__(self):
        """
        A single line description of the module

        EXAMPLES::

            sage: from sage.crypto.rc4 import RC4
            sage: k = [7,1,4,8,2,9,0,12,46,234]
            sage: RC4(k)
            An educational version of the RC4 Cryptosystem
        """
        return 'An educational version of the RC4 Cryptosystem'

    def prga(self, n):
        """
        The Pseudo-Random (stream) Generation Algorithm of RC4.

        INPUT: The number of initial pseudo-random bytes required as output

        - ``n`` - non-negative integer

        OUTPUT: The first n bytes of the pseudo-random stream generated by PRGA.
        In the form of a list of size n.

        The PRGA uses the configuration of :math:`S` as produced by the KSA to generate a pseudo-random bytestream.

        Pseudo-Random Generation Algorithm (PRGA) of RC4
        ::
            i = 0
            j = 0
            while i < n do
                i = (i + 1) mod 256
                j = (j + S[i]) mod 256

                swap S[i], S[j]
                Z = S[(S[i] + S[j]) mod 256]

                return Z
        """
        if not isinstance(n, Integer):
            raise TypeError("input n must be an integer, denoting "
                            "the length of the pseudo-random sequence desired")

        self.__init__(self._key)
        bytestream = []
        j = 0
        for i in range(n):
            i = (ZZ(i + 1)).mod(256)
            j = (ZZ(j + self._S[i])).mod(256)

            temp = self._S[i]
            self._S[i] = self._S[j]
            self._S[j] = temp

            Z = self._S[(ZZ(self._S[i] + self._S[j])).mod(256)]
            bytestream.append(Z)

        return bytestream

    def encrypt(self, Plaintext):
        """
        Encryption algorithm for RC4

        INPUT: Plaintext message, input to RC4.encrypt() in String format.

        - ``Plaintext`` - string

        OUTPUT: Ciphertext, output from RC4.encrypt() in String format.

        - ``Ciphertext`` - string

        The input Plaintext is converted into a bytestream and XORed with the same length
        bytestream generated by PRGA to produce the Ciphertext.

        RC4 Encryption
        ::
            P = Bytestream from Plaintext
            Z = PRGA(length of the Plaintext bystream)

            C = P xor Z
            Ciphertext = String from Bytestream C

            return Ciphertext
        """
        if not isinstance(Plaintext, str):
            raise TypeError("input Plaintext must be a string")

        P = [ascii_integer(ascii_to_bin(x)) for x in Plaintext]

        Z = self.prga(ZZ(len(P)))

        C = [p.__xor__(z) for p, z in zip(P, Z)]
        C_list = [chr(c) for c in C]
        Ciphertext = ''.join(C_list)

        return Ciphertext

    def decrypt(self, Ciphertext):
        """
        Decryption algorithm for RC4

        INPUT: Ciphertext message, input to RC4.decrypt() in String format.

        - ``Ciphertext`` - string

        OUTPUT: Plaintext, output from RC4.decrypt() in String format.

        - ``Plaintext`` - string

        The input Ciphertext is converted into a bytestream and XORed with the same length
        bytestream generated by PRGA to produce the Plaintext (note that the PRGA generated
        ketstream is the same as that in encryption as we use the same key for both cases).

        RC4 Decryption
        ::
            C = Bytestream from Ciphertext
            Z = PRGA(length of the Ciphertext bystream)

            P = C xor Z
            Plaintext = String from Bytestream P

            return Plaintext
        """
        if not isinstance(Ciphertext, str):
            raise TypeError("input Ciphertext must be a string")

        C = [ascii_integer(ascii_to_bin(x)) for x in Ciphertext]

        Z = self.prga(ZZ(len(C)))

        P = [c.__xor__(z) for c, z in zip(C, Z)]
        P_list = [chr(p) for p in P]
        Plaintext = ''.join(P_list)

        return Plaintext
