"""
Crystal Isomorphisms
"""
def weight_decomposition(C):
    """
    Return the weight decomposition of a set of crystal elements ``C``.

    Returns a dictionary whose keys are weights of ``C`` and the values are a
    list of elements which have the same weight.
    """
    ret = {}
    for x in C:
        wt = x.weight()
        if ret.has_key(wt):
            ret[wt].append(x)
        else:
            ret[wt] = [x]
    return ret

def are_crystals_isomorphic(L, R, index_set=None, known=set(), direction='both'):
    """
    Check if crystals `L` and `R` are isomorphic.

    INPUT:

    - ``L``, ``R`` -- Two crystals

    - ``index_set`` -- (Default: ``None``) Index set to check. If `L` and `R`
      do not have the same index set and ``index_set`` is ``None``, then the
      index sets of both ``L`` and ``R`` must be equal.

    - ``known`` -- (Default: ``{}``) A set of known pairs of elements in ``L``
      and ``R`` which are known to already be part of isomorphic crystals.

    .. WARNING::

        This assumes that the weight decomposition of the module generators
        of ``L`` and ``R`` have the same sizes and that the entire crystals
        can be build from the module generators using only `f_i`'s.
    """
    if index_set is None:
        if L.index_set() != R.index_set():
            return False
        index_set = L.index_set()
    wt_decomp_left = weight_decomposition(L.module_generators)
    wt_decomp_right = weight_decomposition(R.module_generators)
    for wt in wt_decomp_left:
        # Simple check to make sure we have the same number of module
        #   generators of the same weight
        if not wt_decomp_right.has_key(wt) \
          or len(wt_decomp_right[wt]) != len(wt_decomp_left[wt]):
            return False
        # Try to find an element in the each wt decomp such that the generated
        #   crystals are isomorphic
        for x in wt_decomp_left[wt]:
            found_match = False
            for j in xrange(len(wt_decomp_right[wt])):
                if (x, wt_decomp_right[wt][j]) in known:
                    found_match = True
                    wt_decomp_left[wt].pop()
                    wt_decomp_right[wt].pop(j)
                    break
                ret = are_generated_isomorphic(x, wt_decomp_right[wt][j], index_set, known)
                if ret is not None:
                    found_match = True
                    known = known.union(ret)
                    wt_decomp_right[wt].pop(j)
                    break
            if not found_match:
                return False
    return True

def are_generated_isomorphic(mg_left, mg_right, index_set=None, known=set()):
    """
    Check if the lower subcrystals generated by ``mg_left`` and ``mg_right``
    using the ``index_set`` are isomorphic.

    Return ``None`` if they are not isomorphic, otherwise return the set of
    found vertices.

    INPUT:

    - ``mg_left``, ``mg_right`` -- Left and right module generator
    - ``index_set`` -- (Default: ``None``) The index set, if ``None`` then
      take the index set of ``mg_left``.
    - ``known`` -- (Default: ``{}``) Set of known pairs which the crystals are
      known to be isomorphic
    - ``down`` -- (Default: ``True``) Boolean to check the downward or upward
      directions
    """
    if index_set is None:
        index_set = mg_left.index_set()
    for i in index_set:
        if mg_left.phi(i) != mg_right.phi(i) or \
                mg_left.epsilon(i) != mg_right.epsilon(i):
            print "failed at (%s, %s) for i = %s"%(mg_left,mg_right,i)
            return None
    todo = set()
    todo.add((mg_left, mg_right))
    found = todo.copy()

    while len(todo) > 0:
        (x,y) = todo.pop()
        for i in index_set:
            next = (x.f(i), y.f(i))
            if (next[0] is None and next[1] is not None) or (next[0] is not None and next[1] is None):
                print "failed at (%s, %s) for i = %s"%(x,y,i)
                return None
            if next[0] is None or next in found or next in known:
                continue
            todo.add(next)
            found.add(next)
    return found


