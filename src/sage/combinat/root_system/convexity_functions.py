
def cycle_spaces(S, k):
    r"""
    Return the cycle spaces.
    """
    for U in Subsets(S, k):
        V = map(lambda x: x.to_vector().change_ring(ZZ), U)
        VS = V[0].parent()
        if not VS.linear_dependence(V):
            # No linear dependence, i.e. linearly independent
            continue
        yield matrix(V).kernel()

def is_convex(S):
    r"""
    Check if a set ``S`` of positive roots is a convex set.

    A set `S \subseteq \Pi^+` is convex if for all `\alpha, \beta \in S` such
    that `\alpha + \beta \in \Pi^+`, then `\alpha + \beta \in S`.
    """
    if not S: # Empty set is trivially convex
        return True

    Pi = list(S[0].parent().positive_roots())
    for a in S:
        for b in S:
            if a + b in Pi and a + b not in S:
                return False
    return True

def is_coconvex(S):
    r"""
    Check if a set ``S`` of positive roots is a coconvex set.

    A set `S \subseteq \Pi^+` is convex if for all `\alpha \in S` and
    `\beta \in \Pi^+ \setminus S` such that `\alpha - \beta \in \Pi^+`,
    then `\alpha - \beta \in S`.
    """
    if not S: # Empty set is trivially convex
        return True

    Pi = set(S[0].parent().positive_roots())
    PiC = Pi.difference(S)
    for a in S:
        for b in PiC:
            if a - b in Pi and a - b not in S:
                print "alpha: {}\nbeta: {}".format(a, b)
                return False
    return True

def convex_set_generated_by(gens):
    """
    Return the convex set generated by ``gens``.
    """
    if not gens: # Corner case
        return []

    Pi = set(gens[0].parent().positive_roots())
    ret = set([])
    to_add = set(gens)
    while to_add:
        ret = ret.union(to_add)
        to_add = set([])
        for g in gens:
            for b in ret:
                p = g + b
                if p in Pi and p not in ret:
                    to_add.add(p)
    return ret

def convex_generators(S):
    """
    Return the convex generators of ``S``.
    """
    raise NotImplementedError

