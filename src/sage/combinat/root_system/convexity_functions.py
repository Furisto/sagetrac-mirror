
def cycle_spaces(S, k):
    r"""
    Return the cycle spaces.
    """
    for U in Subsets(S, k):
        V = map(lambda x: x.to_vector().change_ring(ZZ), U)
        VS = V[0].parent()
        if not VS.linear_dependence(V):
            # No linear dependence, i.e. linearly independent
            continue
        yield matrix(V).kernel()

def is_convex(S):
    r"""
    Check if a set ``S`` of positive roots is a convex set.

    A set `S \subseteq \Pi^+` is convex if for all `\alpha, \beta \in S` such
    that `\alpha + \beta \in \Pi^+`, then `\alpha + \beta \in S`.
    """
    if not S: # Empty set is trivially convex
        return True

    Pi = list(S[0].parent().positive_roots())
    for a in S:
        for b in S:
            if a + b in Pi and a + b not in S:
                return False
    return True

def is_coconvex(S):
    r"""
    Check if a set ``S`` of positive roots is a coconvex set.

    A set `S \subseteq \Pi^+` is convex if for all `\alpha \in S` and
    `\beta \in \Pi^+ \setminus S` such that `\alpha - \beta \in \Pi^+`,
    then `\alpha - \beta \in S`.
    """
    if not S: # Empty set is trivially convex
        return True

    Pi = set(S[0].parent().positive_roots())
    PiC = Pi.difference(S)
    for a in S:
        for b in PiC:
            if a - b in Pi and a - b not in S:
                print "alpha: {}\nbeta: {}".format(a, b)
                return False
    return True

def convex_set_generated_by(gens):
    """
    Return the convex set generated by ``gens``.
    """
    if not gens: # Corner case
        return []

    Pi = set(gens[0].parent().positive_roots())
    ret = set([])
    to_add = set(gens)
    while to_add:
        ret = ret.union(to_add)
        to_add = set([])
        for g in gens:
            for b in ret:
                p = g + b
                if p in Pi and p not in ret:
                    to_add.add(p)
    return ret

def convex_generators(S):
    """
    Return the convex generators of ``S``.
    """
    raise NotImplementedError




def min_gen_set(S):
    """
    Return the minimial generating set of a subset of a root system ``S``.
    """
    if not S:
        return []
    P = S[0].parent()
    B = list(P.basis())
    G = list(Cone(map(lambda x: x.to_vector(), S)).rays().set())
    return [P.sum(B[i]*c for i,c in v.iteritems()) for v in G]

def generating_sets(ct, indep=True):
    """
    Iterate over all inversion sets of the positive roots of the root system
    associated to the Cartan type ``ct`` such that it has a linearly
    (in)dependent minimal generating set.

    INPUT:

    - ``ct`` -- a Cartan type
    - ``indep`` -- to return the independent minimal generating sets
    """
    ct = CartanType(ct)
    Q = RootSystem(ct).root_lattice()
    M = QQ**ct.rank()
    ret = []
    count = 0
    for w in Q.weyl_group():
        count += 1
        if count % 100 == 0:
            print "cur count:", count
        inv = w.inversions('right', 'roots')
        m = min_gen_set(inv)
        v = map(lambda x: x.to_vector(), m)
        lin_dep = bool(M.linear_dependence(v))
        if indep == lin_dep:
            yield (w, inv, m)

def big_count(ct):
    return sum(1 for dummy in generating_sets(ct))

def print_check(ct):
    for (w,i,v) in generating_sets(ct):
        print "red expression:", w.reduced_word()
        print "inversions:\n", repr(inv)
        print "minimal generating set:\n", repr(m)
        print "\n"

