r"""
Cactus Groups

AUTHORS:

- Travis Scrimshaw (12-2015): initial version
"""

##############################################################################
#       Copyright (C) 2015 Travis Scrimshaw <tscrimsh at umn.edu>
#
#  Distributed under the terms of the GNU General Public License (GPL)
#
#  The full text of the GPL is available at:
#
#                  http://www.gnu.org/licenses/
##############################################################################

from sage.misc.cachefunc import cached_method
from sage.sets.family import Family
from sage.structure.element import MultiplicativeGroupElement
from sage.structure.unique_representation import UniqueRepresentation
from sage.matrix.constructor import matrix
from sage.categories.groups import Groups
from sage.groups.group import Group
from sage.groups.kernel_subgroup import KernelSubgroup
from sage.combinat.permutation import Permutations

class CactusGroup(UniqueRepresentation, Group):
    r"""
    A cactus group.

    The `n`-fruit cactus group `J_n` is the group generated by `s_{pq}`
    for `1 \leq p < q \leq n` with relations:

    - `s_{pq}^2 = 1`
    - `s_{pq} s_{kl} = s_{kl} s_{pq}` if the intervals `[p, q]` and `[k, l]`
      are disjoint, and
    - `s_{pq} s_{kl} = s_{p+q-l,p+q-k} s_{pq}` if `[k, l] \subseteq [p, q]`.

    INPUT:

    - ``n`` -- an integer

    EXAMPLES:

    We construct the cactus group `J_3` and do some basic computations::

        sage: J3 = groups.misc.Cactus(3)
        sage: s12,s13,s23 = J3.group_generators()
        sage: s12 * s13
        s[1,2]*s[1,3]
        sage: x = s12 * s23; x
        s[1,2]*s[2,3]
        sage: x^4
        s[1,2]*s[2,3]*s[1,2]*s[2,3]*s[1,2]*s[2,3]*s[1,2]*s[2,3]
        sage: s12 * s13 == s13 * s23
        True

    We verify the key equality in Lemma 2.3 in [White15]_, which shows
    that `J_5` is generated by `s_{1q}`::

        sage: J5 = groups.misc.Cactus(5)
        sage: gens = J5.group_generators()
        sage: all(gens[(p,q)] == gens[(1,q)] * gens[(1,q-p+1)] * gens[(1,q)]
        ....:     for p in range(1, 6) for q in range(p+1, 6))
        True

    REFERENCES:

    .. [DJS02] M. Davis, T. Januszkiewicz, and R. Scott.
       *Fundamental groups of blow-ups*.
       Sel. math., New ser. 4 (2002) pp 491-547. :arxiv:`math/0203127`.

    .. [White15] Noah White.
       *The monodromy of real Bethe vectors for the Gaudin model*.
       (2015). :arxiv:`1511.04740v1`.
    """
    def __init__(self, n):
        """
        Initialize ``self``.

        TESTS::

            sage: G = groups.misc.Cactus(3)
            sage: TestSuite(G).run()
        """
        self._n = n
        cat = Groups().FinitelyGeneratedAsMagma()
        if n > 2:
            cat = cat.Infinite()
        # Set the names
        l = len(str(n))
        names = ['s{}{}'.format('0'*(l-len(str(i))) + str(i), '0'*(l-len(str(j))) + str(j))
                 for i in range(1, self._n+1) for j in range(i+1, self._n+1)]
        Group.__init__(self, category=cat)
        self._assign_names(names)

    def _repr_(self):
        """
        Return a string representation of ``self``.

        EXAMPLES::

            sage: groups.misc.Cactus(3)
            Cactus Group with 3 fruit
        """
        return "Cactus Group with {} fruit".format(self._n)

    def _latex_(self):
        r"""
        Return a latex representation of ``self``.

        EXAMPLES::

            sage: J3 = groups.misc.Cactus(3)
            sage: latex(J3)
            J_{3}
        """
        return "J_{{{}}}".format(self._n)

    def n(self):
        """
        Return the value `n`.

        EXAMPLES::

            sage: J3 = groups.misc.Cactus(3)
            sage: J3.n()
            3
        """
        return self._n

    @cached_method
    def group_generators(self):
        """
        Return the group generators of ``self``.

        EXAMPLES::

            sage: J3 = groups.misc.Cactus(3)
            sage: J3.group_generators()
            Finite family {(1, 2): s[1,2], (1, 3): s[1,3], (2, 3): s[2,3]}
        """
        l = [(i,j) for i in range(1, self._n+1) for j in range(i+1, self._n+1)]
        return Family(l, lambda x: self.element_class(self, [x]))

    @cached_method
    def gens(self):
        """
        Return the generators of ``self`` as a tuple.

        EXAMPLES::

            sage: J3 = groups.misc.Cactus(3)
            sage: J3.gens()
            (s[1,2], s[1,3], s[2,3])
        """
        return tuple(self.group_generators())

    @cached_method
    def one(self):
        """
        Return the identity element in ``self``.

        EXAMPLES::

            sage: J3 = groups.misc.Cactus(3)
            sage: J3.one()
            1
        """
        return self.element_class(self, [])

    def _an_element_(self):
        """
        Return an element of ``self``.

        TESTS::

            sage: J1 = groups.misc.Cactus(1)
            sage: J1._an_element_()
            1
            sage: J2 = groups.misc.Cactus(2)
            sage: J2._an_element_()
            s[1,2]
            sage: J3 = groups.misc.Cactus(3)
            sage: J3._an_element_()
            s[1,2]*s[2,3]*s[1,3]
        """
        if self._n <= 1:
            return self.one()
        if self._n == 2:
            return self.element_class(self, [(1,2)])
        return self.element_class(self, [(1,2), (2,3), (1,3)])

    def random_element(self, max_length=10):
        """
        Return a random element of ``self`` of length at most ``max_length``.

        TESTS::

            sage: J3 = groups.misc.Cactus(3)
            sage: J3.random_element() # random
            s[1,2]*s[2,3]*s[1,2]*s[1,3]
        """
        from sage.misc.prandom import randint
        l = randint(0, max_length)
        gens = list(self.group_generators())
        ret = self.one()
        for _ in range(l):
            ret *= gens[randint(0, len(gens)-1)]
        return ret

    def bilinear_form(self, t=None):
        r"""
        Return the ``t``-bilinear form of ``self``.

        We define a bilinear form `B` on the group algebra by

        .. MATH::

            B(s_{ij}, s_{pq}) = \begin{cases}
            1 & \text{if } i = p, j = q, \\
            -t & \text{if } [i, j] \not\subseteq [p, q] \text{ and }
            [p, q] \not\subseteq [i, j], \\
            0 & \text{otherwise}.
            \end{cases}

        In other words, it is `1` if `s_{ij} = s_{pq}`, `-t` if `s_{ij}`
        and `s_{pq}` generate a free group, and `0` otherwise (they commute
        or almost commute).

        INPUT:

        - ``t`` -- (default: `t` in `\ZZ[t]`) the variable `t`

        EXAMPLES::

            sage: J = groups.misc.Cactus(4)
            sage: B = J.bilinear_form()
            sage: B
            [ 1  0  0 -t -t  0]
            [ 0  1  0  0 -t -t]
            [ 0  0  1  0  0  0]
            [-t  0  0  1  0 -t]
            [-t -t  0  0  1  0]
            [ 0 -t  0 -t  0  1]

        We reorder the generators so the bilinear form is more
        "Coxeter-like". In particular, when we remove the generator
        `s_{1,4}`, we recover the bilinear form in Example 6.2.5
        of [DJS02]_::

            sage: J.gens()
            (s[1,2], s[1,3], s[1,4], s[2,3], s[2,4], s[3,4])
            sage: S = SymmetricGroup(6)
            sage: g = S([1,4,6,2,5,3])
            sage: B.permute_rows_and_columns(g, g)
            sage: B
            [ 1 -t  0  0 -t  0]
            [-t  1 -t  0  0  0]
            [ 0 -t  1 -t  0  0]
            [ 0  0 -t  1 -t  0]
            [-t  0  0 -t  1  0]
            [ 0  0  0  0  0  1]
        """
        if t is None:
            from sage.rings.polynomial.polynomial_ring_constructor import PolynomialRing
            from sage.rings.all import ZZ
            t = PolynomialRing(ZZ, 't').gen()
        R = t.parent()
        ret = []
        K = self.group_generators().keys()
        for x in K:
            for y in K:
                if x is y:
                    ret.append(R.one())
                elif (x[1] < y[0] or x[0] > y[1] # Disjoint
                      or (x[0] <= y[0] and y[1] <= x[1]) # y <= x
                      or (y[0] <= x[0] and x[1] <= y[1])): # x <= y
                    ret.append(R.zero())
                else:
                    ret.append(-t)
        return matrix(R, len(K), len(K), ret)

    def representation_generators(self, t=None):
        r"""
        Return the matrices corresponding to the generators of ``self``.

        We construct a representation over `R = ZZ(t)` of `J_n` as follows.
        Let `E` be the vector space over `R` spanned by `\{\epsilon_v\}_v`,
        where `v` is a generator of `J_n`. Fix some generator `v`, and
        let `E_v` denote the span of `\epsilon_u - \epsilon_{u'}`,
        where `u'` is the reflected interval of `u` in `v`, over all
        `u` such that `u \subset v`. Let `F_v` denote the orthogonal
        complement of `R \epsilon_v \oplus E_v` with respect to the
        :meth:`bilinear form <bilinear_form>` `B`. We define the action
        of `v` on `E` by

        .. MATH::

            \rho(v) = -I |_{R\espilon_v \oplus E_v} \oplus I |_{F_v}.

        By Theorem 6.2.3 of [DJS02]_, this defines a representation of `J_n`.
        It is expected that this is a faithful representation (see
        Remark 6.2.4 of [DJS02]_).

        INPUT:

        - ``t`` -- (default: `t` in `\ZZ[t]`) the variable `t`

        EXAMPLES::

            sage: J = groups.misc.Cactus(3)
            sage: list(J.representation_generators())
            [
            [ -1   0 2*t]  [ 0  0  1]  [  1   0   0]
            [  0   1   0]  [ 0 -1  0]  [  0   1   0]
            [  0   0   1], [ 1  0  0], [2*t   0  -1]
            ]
        """
        B = self.bilinear_form(t)
        F = B.base_ring().fraction_field()
        K = self.group_generators().keys()
        from sage.modules.free_module import FreeModule
        V = FreeModule(F, len(K))
        basis = V.basis()
        ret = {}
        for ik,k in enumerate(K):
            E = [basis[ik]]
            ME = matrix(E)
            # The only non-trivial elements are those reflected by the interval k
            for low in range(k[0], k[1]+1):
                for high in range(low+1, k[1]+1):
                    v = (low, high)
                    vp = (k[0]+k[1]-high, k[0]+k[1]-low)
                    if v == vp:
                        continue
                    elt = basis[K.index(v)] - basis[K.index(vp)]
                    if elt not in ME.row_space():
                        E.append(elt)
                        ME = ME.stack(elt)
            # Get the orthogonal complement wrt to the bilinear form B
            Fv = (ME * B).right_kernel().basis_matrix()
            T = ME.stack(Fv).transpose()
            rho = matrix.diagonal(F, [-1]*len(E) + [1]*(len(K)-len(E)))
            ret[k] = T * rho * ~T
        return Family(K, lambda k: ret[k])

    @cached_method
    def _product_on_gens(self, x, y):
        """
        Return the product of generators indexed by ``x`` and ``y``.

        EXAMPLES::

            sage: J3 = groups.misc.Cactus(4)
            sage: J3._product_on_gens((1,2), (1,2))
            ()
            sage: J3._product_on_gens((1,2), (1,3))
            ((1, 2), (1, 3))
            sage: J3._product_on_gens((1,3), (1,2))
            ((2, 3), (1, 3))
            sage: J3._product_on_gens((1,2), (3,4))
            ((1, 2), (3, 4))
            sage: J3._product_on_gens((3,4), (1,2))
            ((1, 2), (3, 4))

            sage: J3 = groups.misc.Cactus(5)
            sage: J3._product_on_gens((2,5), (3,4))
            ((3, 4), (2, 5))
            sage: J3._product_on_gens((1,5), (3,4))
            ((2, 3), (1, 5))
        """
        if x == y:
            return ()
        if x[1] < y[0]: # Disjoint and in order
            return (x, y)
        if x[0] > y[1]: # Disjoint but out of order
            return (y, x)
        # They must not be disjoint
        if x[0] <= y[0] and y[1] <= x[1]: # x contains y, swap
            return ((x[0]+x[1]-y[1],x[0]+x[1]-y[0]), x)
        return (x, y)

    class Element(MultiplicativeGroupElement):
        """
        An element of a cactus group.
        """
        def __init__(self, parent, word):
            """
            Initialize ``self``.

            EXAMPLES::

                sage: J3 = groups.misc.Cactus(3)
                sage: elt = J3.an_element()
                sage: TestSuite(elt).run()
            """
            self._word = tuple(word)
            MultiplicativeGroupElement.__init__(self, parent)

        def _repr_(self):
            """
            Return a string representation of ``self``.

            EXAMPLES::

                sage: J3 = groups.misc.Cactus(3)
                sage: J3.one()
                1
                sage: J3.an_element()
                s[1,2]*s[2,3]*s[1,3]
            """
            if not self._word:
                return '1'
            return '*'.join("s[{},{}]".format(*x) for x in self._word)

        def _latex_(self):
            """
            Return a latex representation of ``self``.

            EXAMPLES::

                sage: J3 = groups.misc.Cactus(3)
                sage: latex(J3.one())
                1
                sage: latex(J3.an_element())
                s_{1,2} s_{2,3} s_{1,3}
            """
            if not self._word:
                return '1'
            return ' '.join("s_{%s,%s}"%x for x in self._word)

        def __hash__(self):
            """
            Return the hash of ``self``.

            EXAMPLES::

                sage: J3 = groups.misc.Cactus(3)
                sage: hash(J3.an_element()) == hash((J3, ((1,2), (2,3), (1,3))))
                True
            """
            return hash((self.parent(), self._word))

        def _cmp_(self, other):
            """
            Compare ``self`` and ``other``.

            EXAMPLES::

                sage: J3 = groups.misc.Cactus(3)
                sage: elt = J3.an_element()
                sage: elt == J3.one()
                False
                sage: elt != J3.one()
                True
                sage: s12,s13,s23 = J3.gens()
                sage: elt == s12*s23*s13
                True
            """
            return cmp(self._word, other._word)

        def _mul_(self, other):
            """
            Return the product of ``self`` and ``other``.

            EXAMPLES::

                sage: J3 = groups.misc.Cactus(3)
                sage: s12,s13,s23 = J3.gens()
                sage: s12*s23
                s[1,2]*s[2,3]
                sage: s12*s13
                s[1,2]*s[1,3]
                sage: s13*s12
                s[2,3]*s[1,3]
                sage: J3.one() * (s13*s12*s13*s12*s23*s13)
                s[2,3]*s[1,2]*s[2,3]*s[1,3]
            """
            if not self._word:
                return other
            if not other._word:
                return self
            word = list(self._word + other._word)
            P = self.parent()
            cur_pos = len(self._word) - 1 # We know self._word is in order
            end = len(word) - 1
            while cur_pos < end:
                ret = P._product_on_gens(word[cur_pos], word[cur_pos+1])
                if not ret: # Reduce the length
                    word.pop(cur_pos)
                    word.pop(cur_pos)
                    if cur_pos > 0: # Nothing else to the left
                        cur_pos -= 1
                    end -= 2
                elif ret != (word[cur_pos], word[cur_pos+1]):
                    word[cur_pos] = ret[0]
                    word[cur_pos+1] = ret[1]
                    if cur_pos == 0: # Nothing else to check to the left
                        cur_pos += 1
                    else:
                        cur_pos -= 1
                else:
                    cur_pos += 1
            return type(self)(P, tuple(word))

        def __invert__(self):
            """
            Return the inverse of ``self``.

            EXAMPLES::

                sage: J3 = groups.misc.Cactus(3)
                sage: s12,s13,s23 = J3.gens()
                sage: elt = s12*s23*s13
                sage: ~elt
                s[1,2]*s[2,3]*s[1,3]
                sage: elt * elt
                1
            """
            if len(self._word) <= 1:
                return self
            P = self.parent()
            G = P.group_generators()
            return P.prod(G[x] for x in reversed(self._word))

        def to_permutation(self):
            """
            Return ``self`` as a permutation.

            EXAMPLES::

                sage: J3 = groups.misc.Cactus(3)
                sage: s12,s13,s23 = J3.gens()
                sage: s12.to_permutation()
                [2, 1, 3]
                sage: s23.to_permutation()
                [1, 3, 2]
                sage: s13.to_permutation()
                [3, 2, 1]
                sage: elt = s12*s23*s13
                sage: elt.to_permutation()
                [1, 3, 2]

                sage: J7 = groups.misc.Cactus(7)
                sage: J7.group_generators()[3,6].to_permutation()
                [1, 2, 6, 5, 4, 3, 7]

            We check that this respects the multiplication order
            of permutations::

                sage: P3 = Permutations(3)
                sage: elt = s12*s23
                sage: elt.to_permutation() == P3(s12) * P3(s23)
                True
                sage: Permutations.global_options(mult='r2l')
                sage: elt.to_permutation() == P3(s12) * P3(s23)
                True
                sage: Permutations.global_options.reset()
            """
            n = self.parent().n()
            P = Permutations(n)
            ret = P.one()
            for x in self._word:
                lst = list(range(1, n+1))
                lst[x[0]-1:x[1]] = list(reversed(lst[x[0]-1:x[1]]))
                ret *= P(lst)
            return ret

        def _matrix_(self):
            """
            Return ``self`` as a matrix.

            EXAMPLES::

                sage: J3 = groups.misc.Cactus(3)
                sage: s12,s13,s23 = J3.gens()
                sage: s12.to_matrix()
                [ -1   0 2*t]
                [  0   1   0]
                [  0   0   1]
                sage: (s12*s13).to_matrix()
                [2*t   0  -1]
                [  0  -1   0]
                [  1   0   0]
                sage: (s13*s23).to_matrix()
                [2*t   0  -1]
                [  0  -1   0]
                [  1   0   0]
                sage: (s13*s12).to_matrix()
                [  0   0   1]
                [  0  -1   0]
                [ -1   0 2*t]
                sage: all(x.to_matrix() * y.to_matrix() == (x*y).to_matrix()
                ....:     for x in J3.gens() for y in J3.gens())
                True
            """
            G = self.parent().representation_generators()
            ret = G[(1,2)].parent().one()
            for x in self._word:
                ret *= G[x]
            return ret

        to_matrix = _matrix_

class PureCactusGroup(KernelSubgroup):
    """
    The pure cactus group.

    The *pure cactus group* `PJ_n` is the kernel of the natural
    surjection of the cactus group `J_n` onto the symmetric group
    `S_n`. In particular, we have the following exact sequence:

    .. MATH::

        1 \longrightarrow PJ_n \longrightarrow J_n \longrightarrow S_n
        \longrightarrow 1.
    """
    def __init__(self, n):
        """
        Initialize ``self``.

        EXAMPLES::

            sage: PJ3 = groups.misc.PureCactus(3)
            sage: TestSuite(PJ3).run()
        """
        J = CactusGroup(n)
        from sage.groups.perm_gps.permgroup_named import SymmetricGroup
        S = SymmetricGroup(n)
        KernelSubgroup.__init__(self, S.coerce_map_from(J))

    def _repr_(self):
        """
        Return a string representation of ``self``.

        EXAMPLES::

            sage: groups.misc.PureCactus(3)
            Pure Cactus Group with 3 fruit
        """
        return "Pure Cactus Group with {} fruit".format(self.n())

    def _latex_(self):
        r"""
        Return a latex representation of ``self``.

        EXAMPLES::

            sage: PJ3 = groups.misc.PureCactus(3)
            sage: latex(PJ3)
            PJ_{3}
        """
        return "PJ_{{{}}}".format(self.n())

    @cached_method
    def n(self):
        """
        Return the value `n`.

        EXAMPLES::

            sage: PJ3 = groups.misc.PureCactus(3)
            sage: PJ3.n()
            3
        """
        return self.ambient().n()

