r"""
Cactus Groups

AUTHORS:

- Travis Scrimshaw: initial version
"""

##############################################################################
#       Copyright (C) 2015 Travis Scrimshaw <tscrimsh at umn.edu>
#
#  Distributed under the terms of the GNU General Public License (GPL)
#
#  The full text of the GPL is available at:
#
#                  http://www.gnu.org/licenses/
##############################################################################


from sage.categories.groups import Groups
from sage.groups.group import Group
from sage.groups.kernel_subgroup import KernelSubgroup
from sage.structure.element import MultiplicativeGroupElement
from sage.structure.unique_representation import UniqueRepresentation
from sage.combinat.permutation import Permutations
from sage.misc.cachefunc import cached_method
from sage.sets.family import Family

#################################################################

class CactusGroup(UniqueRepresentation, Group):
    r"""
    A cactus group.

    The `n`-fruit cactus group `J_n` is the group generated by `s_{pq}`
    for `1 \leq p < q \leq n` with relations:

    - `s_{pq}^2 = 1`
    - `s_{pq} s_{kl} = s_{kl} s_{pq}` if the intervals `[p, q]` and `[k, l]`
      are disjoint, and
    - `s_{pq} s_{kl} = s_{p+q-l,p+q-k} s_{pq}` if `[k, l] \subseteq [p, q]`.

    INPUT:

    - ``n`` -- an integer

    EXAMPLES:

    We construct the cactus group `J_3` and do some basic computations::

        sage: J3 = groups.misc.Cactus(3)
        sage: s12,s13,s23 = J3.group_generators()
        sage: s12 * s13
        s[1,2]*s[1,3]
        sage: x = s12 * s23; x
        s[1,2]*s[2,3]
        sage: x^4
        s[1,2]*s[2,3]*s[1,2]*s[2,3]*s[1,2]*s[2,3]*s[1,2]*s[2,3]
        sage: s12 * s13 == s13 * s23
        True

    We verify the key equality in Lemma 2.3 in [White15]_, which shows
    that `J_5` is generated by `s_{1q}`::

        sage: J5 = groups.misc.Cactus(5)
        sage: gens = J5.group_generators()
        sage: all(gens[(p,q)] == gens[(1,q)] * gens[(1,q-p+1)] * gens[(1,q)]
        ....:     for p in range(1, 6) for q in range(p+1, 6))
        True

    REFERENCES:

    .. [White15] Noah White.
       *The monodromy of real Bethe vectors for the Gaudin model*.
       :arxiv:`http://arxiv.org/abs/1511.04740v1`.
    """
    def __init__(self, n):
        """
        Initialize ``self``.

        TESTS::

            sage: G = groups.misc.Cactus(3)
            sage: TestSuite(G).run()
        """
        self._n = n
        cat = Groups().FinitelyGeneratedAsMagma()
        if n > 2:
            cat = cat.Infinite()
        # Set the names
        l = len(str(n))
        names = ['s{}{}'.format('0'*(l-len(str(i))) + str(i), '0'*(l-len(str(j))) + str(j))
                 for i in range(1, self._n+1) for j in range(i+1, self._n+1)]
        Group.__init__(self, category=cat)
        self._assign_names(names)

    def _repr_(self):
        """
        Return a string representation of ``self``.

        EXAMPLES::

            sage: groups.misc.Cactus(3)
            Cactus Group with 3 fruit
        """
        return "Cactus Group with {} fruit".format(self._n)

    def _latex_(self):
        r"""
        Return a latex representation of ``self``.

        EXAMPLES::

            sage: J3 = groups.misc.Cactus(3)
            sage: latex(J3)
            J_{3}
        """
        return "J_{{{}}}".format(self._n)

    def n(self):
        """
        Return the value `n`.

        EXAMPLES::

            sage: J3 = groups.misc.Cactus(3)
            sage: J3.n()
            3
        """
        return self._n

    @cached_method
    def group_generators(self):
        """
        Return the group generators of ``self``.

        EXAMPLES::

            sage: J3 = groups.misc.Cactus(3)
            sage: J3.group_generators()
            Finite family {(1, 2): s[1,2], (1, 3): s[1,3], (2, 3): s[2,3]}
        """
        l = [(i,j) for i in range(1, self._n+1) for j in range(i+1, self._n+1)]
        return Family(l, lambda x: self.element_class(self, [x]))

    @cached_method
    def gens(self):
        """
        Return the generators of ``self`` as a tuple.

        EXAMPLES::

            sage: J3 = groups.misc.Cactus(3)
            sage: J3.gens()
            (s[1,2], s[1,3], s[2,3])
        """
        return tuple(self.group_generators())

    @cached_method
    def one(self):
        """
        Return the identity element in ``self``.

        EXAMPLES::

            sage: J3 = groups.misc.Cactus(3)
            sage: J3.one()
            1
        """
        return self.element_class(self, [])

    def _an_element_(self):
        """
        Return an element of ``self``.

        TESTS::

            sage: J1 = groups.misc.Cactus(1)
            sage: J1._an_element_()
            1
            sage: J2 = groups.misc.Cactus(2)
            sage: J2._an_element_()
            s[1,2]
            sage: J3 = groups.misc.Cactus(3)
            sage: J3._an_element_()
            s[1,2]*s[2,3]*s[1,3]
        """
        if self._n <= 1:
            return self.one()
        if self._n == 2:
            return self.element_class(self, [(1,2)])
        return self.element_class(self, [(1,2), (2,3), (1,3)])

    def random_element(self, max_length=10):
        """
        Return a random element of ``self`` of length at most ``max_length``.

        TESTS::

            sage: J3 = groups.misc.Cactus(3)
            sage: J3.random_element() # random
            s[1,2]*s[2,3]*s[1,2]*s[1,3]
        """
        from sage.misc.prandom import randint
        l = randint(0, max_length)
        gens = list(self.group_generators())
        ret = self.one()
        for _ in range(l):
            ret *= gens[randint(0, len(gens)-1)]
        return ret

    @cached_method
    def _product_on_gens(self, x, y):
        """
        Return the product of generators indexed by ``x`` and ``y``.

        EXAMPLES::

            sage: J3 = groups.misc.Cactus(4)
            sage: J3._product_on_gens((1,2), (1,2))
            ()
            sage: J3._product_on_gens((1,2), (1,3))
            ((1, 2), (1, 3))
            sage: J3._product_on_gens((1,3), (1,2))
            ((2, 3), (1, 3))
            sage: J3._product_on_gens((1,2), (3,4))
            ((1, 2), (3, 4))
            sage: J3._product_on_gens((3,4), (1,2))
            ((1, 2), (3, 4))

            sage: J3 = groups.misc.Cactus(5)
            sage: J3._product_on_gens((2,5), (3,4))
            ((3, 4), (2, 5))
            sage: J3._product_on_gens((1,5), (3,4))
            ((2, 3), (1, 5))
        """
        if x == y:
            return ()
        if x[1] < y[0]: # Disjoint and in order
            return (x, y)
        if x[0] > y[1]: # Disjoint but out of order
            return (y, x)
        # They must not be disjoint
        if x[0] <= y[0] and y[1] <= x[1]: # x contains y, swap
            return ((x[0]+x[1]-y[1],x[0]+x[1]-y[0]), x)
        return (x, y)

    class Element(MultiplicativeGroupElement):
        """
        An element of a cactus group.
        """
        def __init__(self, parent, word):
            """
            Initialize ``self``.

            EXAMPLES::

                sage: J3 = groups.misc.Cactus(3)
                sage: elt = J3.an_element()
                sage: TestSuite(elt).run()
            """
            self._word = tuple(word)
            MultiplicativeGroupElement.__init__(self, parent)

        def _repr_(self):
            """
            Return a string representation of ``self``.

            EXAMPLES::

                sage: J3 = groups.misc.Cactus(3)
                sage: J3.one()
                1
                sage: J3.an_element()
                s[1,2]*s[2,3]*s[1,3]
            """
            if not self._word:
                return '1'
            return '*'.join("s[{},{}]".format(*x) for x in self._word)

        def _latex_(self):
            """
            Return a latex representation of ``self``.

            EXAMPLES::

                sage: J3 = groups.misc.Cactus(3)
                sage: latex(J3.one())
                1
                sage: latex(J3.an_element())
                s_{1,2} s_{2,3} s_{1,3}
            """
            if not self._word:
                return '1'
            return ' '.join("s_{%s,%s}"%x for x in self._word)

        def __hash__(self):
            """
            Return the hash of ``self``.

            EXAMPLES::

                sage: J3 = groups.misc.Cactus(3)
                sage: hash(J3.an_element()) == hash((J3, ((1,2), (2,3), (1,3))))
                True
            """
            return hash((self.parent(), self._word))

        def _cmp_(self, other):
            """
            Compare ``self`` and ``other``.

            EXAMPLES::

                sage: J3 = groups.misc.Cactus(3)
                sage: elt = J3.an_element()
                sage: elt == J3.one()
                False
                sage: elt != J3.one()
                True
                sage: s12,s13,s23 = J3.gens()
                sage: elt == s12*s23*s13
                True
            """
            return cmp(self._word, other._word)

        def _mul_(self, other):
            """
            Return the product of ``self`` and ``other``.

            EXAMPLES::

                sage: J3 = groups.misc.Cactus(3)
                sage: s12,s13,s23 = J3.gens()
                sage: s12*s23
                s[1,2]*s[2,3]
                sage: s12*s13
                s[1,2]*s[1,3]
                sage: s13*s12
                s[2,3]*s[1,3]
                sage: J3.one() * (s13*s12*s13*s12*s23*s13)
                s[2,3]*s[1,2]*s[2,3]*s[1,3]
            """
            if not self._word:
                return other
            if not other._word:
                return self
            word = list(self._word + other._word)
            P = self.parent()
            cur_pos = len(self._word) - 1 # We know self._word is in order
            end = len(word) - 1
            while cur_pos < end:
                ret = P._product_on_gens(word[cur_pos], word[cur_pos+1])
                if not ret: # Reduce the length
                    word.pop(cur_pos)
                    word.pop(cur_pos)
                    if cur_pos > 0: # Nothing else to the left
                        cur_pos -= 1
                    end -= 2
                elif ret != (word[cur_pos], word[cur_pos+1]):
                    word[cur_pos] = ret[0]
                    word[cur_pos+1] = ret[1]
                    if cur_pos == 0: # Nothing else to check to the left
                        cur_pos += 1
                    else:
                        cur_pos -= 1
                else:
                    cur_pos += 1
            return type(self)(P, tuple(word))

        def __invert__(self):
            """
            Return the inverse of ``self``.

            EXAMPLES::

                sage: J3 = groups.misc.Cactus(3)
                sage: s12,s13,s23 = J3.gens()
                sage: elt = s12*s23*s13
                sage: ~elt
                s[1,2]*s[2,3]*s[1,3]
                sage: elt * elt
                1
            """
            if len(self._word) <= 1:
                return self
            P = self.parent()
            G = P.group_generators()
            return P.prod(G[x] for x in reversed(self._word))

        def to_permutation(self):
            """
            Return ``self`` as a permutation.

            EXAMPLES::

                sage: J3 = groups.misc.Cactus(3)
                sage: s12,s13,s23 = J3.gens()
                sage: s12.to_permutation()
                [2, 1, 3]
                sage: s23.to_permutation()
                [1, 3, 2]
                sage: s13.to_permutation()
                [3, 2, 1]
                sage: elt = s12*s23*s13
                sage: elt.to_permutation()
                [1, 3, 2]

                sage: J7 = groups.misc.Cactus(7)
                sage: J7.group_generators()[3,6].to_permutation()
                [1, 2, 6, 5, 4, 3, 7]

            We check that this respects the multiplication order
            of permutations::

                sage: P3 = Permutations(3)
                sage: elt = s12*s23
                sage: elt.to_permutation() == P3(s12) * P3(s23)
                True
                sage: Permutations.global_options(mult='r2l')
                sage: elt.to_permutation() == P3(s12) * P3(s23)
                True
                sage: Permutations.global_options.reset()
            """
            n = self.parent().n()
            P = Permutations(n)
            ret = P.one()
            for x in self._word:
                lst = list(range(1, n+1))
                lst[x[0]-1:x[1]] = list(reversed(lst[x[0]-1:x[1]]))
                ret *= P(lst)
            return ret

class PureCactusGroup(KernelSubgroup):
    """
    The pure cactus group.

    The *pure cactus group* `PJ_n` is the kernel of the natural
    surjection of the cactus group `J_n` onto the symmetric group
    `S_n`. In particular, we have the following exact sequence:

    .. MATH::

        1 \longrightarrow PJ_n \longrightarrow J_n \longrightarrow S_n
        \longrightarrow 1.
    """
    def __init__(self, n):
        """
        Initialize ``self``.

        EXAMPLES::

            sage: PJ3 = groups.misc.PureCactus(3)
            sage: TestSuite(PJ3).run()
        """
        J = CactusGroup(n)
        from sage.groups.perm_gps.permgroup_named import SymmetricGroup
        S = SymmetricGroup(n)
        KernelSubgroup.__init__(self, S.coerce_map_from(J))

    def _repr_(self):
        """
        Return a string representation of ``self``.

        EXAMPLES::

            sage: groups.misc.PureCactus(3)
            Pure Cactus Group with 3 fruit
        """
        return "Pure Cactus Group with {} fruit".format(self.n())

    def _latex_(self):
        r"""
        Return a latex representation of ``self``.

        EXAMPLES::

            sage: PJ3 = groups.misc.PureCactus(3)
            sage: latex(PJ3)
            PJ_{3}
        """
        return "PJ_{{{}}}".format(self.n())

    @cached_method
    def n(self):
        """
        Return the value `n`.

        EXAMPLES::

            sage: PJ3 = groups.misc.PureCactus(3)
            sage: PJ3.n()
            3
        """
        return self.ambient().n()

