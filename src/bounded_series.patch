# HG changeset patch
# User Xavier Caruso <xavier.caruso@normalesup.org>
# Date 1362515260 -3600
# Node ID 24d08228a19cef063ffe8bbe82f658044b056a27
# Parent  adb4dc126d41215b1a267ee9d4f5e0947a749b9a
imported patch bounded_series

diff --git a/module_list.py b/module_list.py
--- a/module_list.py
+++ b/module_list.py
@@ -1414,6 +1414,15 @@
               language = 'c++',
               include_dirs = ['sage/libs/ntl/']),
 
+    Extension('sage.rings.bounded_series_poly',
+              sources = ['sage/rings/bounded_series_poly.pyx']),
+
+    Extension('sage.rings.bounded_series_ring_element',
+              sources = ['sage/rings/bounded_series_ring_element.pyx']),
+
+    Extension('sage.rings.bounded_series_ring_morphism',
+              sources = ['sage/rings/bounded_series_ring_morphism.pyx']),
+
     Extension('sage.rings.complex_double',
               sources = ['sage/rings/complex_double.pyx'],
               extra_compile_args=["-std=c99",  "-D_XPG6"],
diff --git a/sage/rings/all.py b/sage/rings/all.py
--- a/sage/rings/all.py
+++ b/sage/rings/all.py
@@ -121,6 +121,10 @@
 from laurent_series_ring import LaurentSeriesRing, is_LaurentSeriesRing
 from laurent_series_ring_element import LaurentSeries, is_LaurentSeries
 
+# Bounded series rings
+from bounded_series_ring import BoundedSeriesRing, is_BoundedSeriesRing
+from bounded_series_ring_element import is_BoundedSeries
+
 # Pseudo-ring of PARI objects.
 from pari_ring import PariRing, Pari
 
diff --git a/sage/rings/bounded_series_poly.pxd b/sage/rings/bounded_series_poly.pxd
new file mode 100644
--- /dev/null
+++ b/sage/rings/bounded_series_poly.pxd
@@ -0,0 +1,19 @@
+from bounded_series_ring_element cimport BoundedSeries
+from sage.rings.polynomial.polynomial_element cimport Polynomial
+
+from sage.structure.element cimport RingElement
+from sage.structure.parent cimport Parent
+
+cdef class BoundedSeries_poly(BoundedSeries):
+    cdef Polynomial _f
+
+    cdef _valuation
+    cdef int _degree
+    cdef _mu
+    cdef BoundedSeries_poly _a
+    cdef BoundedSeries_poly _b
+    cdef BoundedSeries_poly _binv
+
+    cpdef BoundedSeries _new_constant_series(self, RingElement a, Parent P, char check=*)
+
+    cdef _compute_valuation_degree(self)
diff --git a/sage/rings/bounded_series_poly.pyx b/sage/rings/bounded_series_poly.pyx
new file mode 100644
--- /dev/null
+++ b/sage/rings/bounded_series_poly.pyx
@@ -0,0 +1,365 @@
+#############################################################################
+#    Copyright (C) 2013 Xavier Caruso <xavier.caruso@normalesup.org>
+#
+#  Distributed under the terms of the GNU General Public License (GPL)
+#
+#                  http://www.gnu.org/licenses/
+#****************************************************************************
+
+include "../ext/stdsage.pxi"
+
+from infinity import Infinity
+from sage.structure.parent cimport Parent
+from sage.structure.element cimport Element, ModuleElement, RingElement
+from sage.combinat.newton_polygon import NewtonPolygon_lastslope
+from sage.rings.padics.precision_error import PrecisionError
+
+from sage.misc.misc import newton_method_sizes
+
+from bounded_series_ring_element cimport BoundedSeries
+from bounded_series_ring_element import is_BoundedSeries
+
+
+cdef class BoundedSeries_poly(BoundedSeries):
+    def __init__(self, parent, f=0, valuation_final_terms=None, prec=None, prec_coeffs=None, check=True, is_gen=0):
+        R = parent._polynomial_ring
+        base = parent.base_ring()
+        self._f = R(f, check=check)
+
+        if prec is None:
+            if isinstance(f, BoundedSeries):
+                prec = f._prec
+            else:
+                prec = Infinity
+        if prec is not Infinity:
+            if check:
+                self._f = self._f.truncate(prec)
+        elif valuation_final_terms is not None:
+            valuation_final_terms = Infinity
+
+        if prec_coeffs is not None:
+            coeffs = self._f.list()
+            zero = base(0)
+            for i in range(len(prec_coeffs)):
+                if i < len(coeffs):
+                    coeffs.append(zero)
+                if prec_coeffs[i] is not Infinity:
+                    coeffs[i] = coeffs[i].add_bigoh(prec_coeffs[i].ceil())
+            self._f = R(coeffs)
+
+        BoundedSeries.__init__(self, parent, None, valuation_final_terms, prec, is_gen)
+
+
+    def __hash__(self):
+        return hash(self._f)
+
+    #def __reduce__(self):
+
+    def __cmp__(left, right):
+        return (<Element>left)._cmp(right)
+
+    def __richcmp__(left, right, int op):
+        return (<Element>left)._richcmp(right, op)
+
+    cpdef BoundedSeries _new_constant_series(self,RingElement a,Parent P,char check=0):
+        cdef BoundedSeries_poly f = <BoundedSeries_poly>PY_NEW_SAME_TYPE(self)
+        f._parent = P
+        f._f = P._polynomial_ring(a)
+        f._prec = Infinity
+        f._valuation_final_terms = Infinity
+        f._degree = 0
+        return f
+
+    def polynomial(self):
+        return self._f
+
+    cdef _compute_valuation_degree(self):
+        log_radius = self._parent.log_radius()
+        val = Infinity; deg = -1;
+        f = self._f
+        if f == 0:
+            self._valuation = Infinity
+            self._degree = -1
+            self._mu = None
+            return
+        df = f.degree()
+        val = f[df].valuation(); deg = df
+        mu = Infinity
+        for d in range(df-1, -1, -1):
+            v = f[d].valuation()
+            slope = (v - val) / (deg - d)
+            if slope <= log_radius:
+                val = v
+                deg = d
+                mu = Infinity
+            elif slope < mu:
+                mu = slope
+        self._valuation = val + log_radius*deg
+        self._degree = deg
+        self._mu = mu
+
+    def is_secure(self):
+        if self._valuation is None:
+            self._compute_valuation_degree()
+        return self._valuation_final_terms is not None and self._valuation <= self._valuation_final_terms
+
+    def secure_log_radius(self):
+        if self._valuation_final_terms is None:
+            return Infinity
+        log_radius = self._parent._log_radius
+        if self._valuation is not None and self._valuation <= self._valuation_final_terms:
+            return log_radius
+        f = self._f
+        df = f.degree()
+        prec = self._prec
+        secure_log_radius = Infinity
+        valuation_final_terms = self._valuation_final_terms - log_radius*prec
+        for i in range(df+1):
+            c = f[i]
+            if c.is_zero(): continue
+            val = c.valuation()
+            slope = (val - valuation_final_terms) / (prec - i)
+            if slope < secure_log_radius:
+                secure_log_radius = slope
+        return max(log_radius, secure_log_radius)
+
+    def gauss_valuation(self, secure=False):
+        if self._valuation is None:
+            self._compute_valuation_degree()
+        if secure and not self.is_secure():
+            raise PrecisionError("Unable to determine for sure the Gauss valuation")
+        return self._valuation
+
+    def minimal_gauss_valuation(self):
+        if self._valuation_final_terms is None:
+            raise ValueError("This element is not secure")
+        if self._valuation is None:
+            self._compute_valuation_degree()
+        return min(self._valuation, self._valuation_final_terms)
+
+    def weierstrass_degree(self, secure=False):
+        if self._valuation is None or self._degree is None:
+            self._compute_valuation_degree()
+        if secure and not self.is_secure():
+            raise PrecisionError("Unable to determine for sure the Weierstrass degree")
+        return self._degree
+
+    def highest_slope(self, secure=False):
+        if self._mu is None:
+            self._compute_valuation_degree()
+        if secure and not self.is_secure():
+            raise ValueError("Unable to determine for sure the highest slope")
+        return -self._mu
+
+    def is_zero(self, secure=False):
+        true_zero = True
+        l = self._f.list()
+        for c in l:
+            if not c.is_zero():
+                return False
+            elif secure:
+                prec = c.precision_absolute()
+                if prec is not Infinity: true_zero = False
+        if secure and not true_zero:
+            raise PrecisionError("impossible to distinguish this element from zero")
+        return True
+
+    def __getitem__(self, n):
+        valuation_final_terms = self._valuation_final_terms
+        if n >= self._prec and valuation_final_terms is not Infinity:
+            if valuation_final_terms is None:
+                raise IndexError("coefficient not known")
+            else:
+                return self.base_ring()(0).add_bigoh(valuation_final_terms + n*self._parent._log_radius)
+        return self._f[n]
+
+    def __neg__(self):
+        return BoundedSeries_poly(self._parent, -self._f, self._prec, check=False)
+        
+    cpdef ModuleElement _add_(self, ModuleElement right_m):
+        cdef BoundedSeries_poly right = <BoundedSeries_poly>right_m
+        if self._valuation_final_terms is None or right._valuation_final_terms is None:
+            valuation_final_terms = None
+        else:
+            valuation_final_terms = min(self._valuation_final_terms, right._valuation_final_terms)
+        res = self._f + right._f
+        prec = min(self._prec, right._prec)
+        return BoundedSeries_poly(self._parent, res, valuation_final_terms, prec)
+                                         
+    cpdef ModuleElement _sub_(self, ModuleElement right_m):
+        cdef BoundedSeries_poly right = <BoundedSeries_poly>right_m
+        if self._valuation_final_terms is None or right._valuation_final_terms is None:
+            valuation_final_terms = None
+        else:
+            valuation_final_terms = min(self._valuation_final_terms + right.gauss_valuation(), right._valuation_final_terms)
+        res = self._f - right._f
+        prec = min(self._prec, right._prec)
+        return BoundedSeries_poly(self._parent, res, valuation_final_terms, prec)
+
+    cpdef RingElement _mul_(self, RingElement right_m):
+        cdef BoundedSeries_poly right = <BoundedSeries_poly>right_m
+        if self._valuation_final_terms is None or right._valuation_final_terms is None:
+            valuation_final_terms = None
+        else:
+            valuation_final_terms = min(self._valuation_final_terms + right.minimal_gauss_valuation(), right._valuation_final_terms + self.minimal_gauss_valuation())
+        res = self._f * right._f
+        prec = min(self._prec, right._prec)
+        return BoundedSeries_poly(self._parent, res, valuation_final_terms, prec)
+                                         
+    cpdef ModuleElement _rmul_(self, RingElement c):
+        if self._valuation_final_terms is None:
+            valuation_final_terms = None
+        else:
+            valuation_final_terms = self._valuation_final_terms + c.valuation()
+        res = c * self._f
+        return BoundedSeries_poly(self._parent, res, valuation_final_terms, self._prec)
+
+    cpdef ModuleElement _lmul_(self, RingElement c):
+        return self._rmul_(c)
+
+    def truncate(self, prec=Infinity):
+        if prec is Infinity:
+            return self._f
+        else:
+            return self._f.truncate(prec)
+
+    def list(self):
+        return self._f.list()
+
+    def inverse(self, secure=False):
+        if not self.is_unit(secure=secure):
+            raise ZeroDivisionError("This series in not invertible in the ring of bounded convergent series on {val >= %s}" % self.parent().log_radius())
+        prec = self._prec
+        if prec is Infinity:
+            prec = self._parent.default_prec()
+        f = self._f
+        res = f.parent()(~f[0])
+        for next_prec in newton_method_sizes(prec)[1:]:
+            z = res.square() * f.truncate(next_prec)
+            res = 2*res - z.truncate(next_prec)
+        if self.is_secure():
+            valuation_final_terms = -self._valuation
+        else:
+            valuation_final_terms = None
+        return BoundedSeries_poly(self._parent, res, valuation_final_terms, prec)
+
+    def weierstrass_preparation(self, monic=False, secure=False, compute_inverse=False):
+        if secure and not self.is_secure():
+            raise PrecisionError("This series is not secure")
+        d = self.weierstrass_degree()
+
+        if self._a is None or self._b is None:
+
+            f = self._f
+            prec = self._prec
+            log_radius = self._parent._log_radius
+
+            # Compute loss of precision coming from self._valuation_final_terms
+            ###################################################################
+
+            mu = self._mu
+
+            if prec is Infinity or mu is Infinity:
+                precs_res = [ ]
+            else:
+                lastprec = self._valuation_final_terms
+                if lastprec is None:
+                    lastprec = self._valuation
+                lastprec -= prec * log_radius
+                precs_res = [ lastprec + i*mu for i in range(prec) ]
+                precs_res.reverse()
+            for i in range(d, len(precs_res)):
+                precs_res[i] -= self._valuation
+
+            # Compute the decomposition
+            ###########################
+
+            parent_poly = f.parent()
+            if d == 0:
+                a = parent_poly(1)
+                b = f
+                v = parent_poly(~f[0])
+            else:
+                a = f._factor_of_degree(d)
+                b = f // a
+
+            parent = self._parent
+            if self._valuation_final_terms is None or self._valuation > self._valuation_final_terms:
+                self._a = BoundedSeries_poly(parent, a, valuation_final_terms=None, prec=Infinity, prec_coeffs=precs_res[:d])
+            else:
+                self._a = BoundedSeries_poly(parent, a, valuation_final_terms=Infinity, prec=Infinity, prec_coeffs=precs_res[:d])
+            valb = self._valuation + d*log_radius
+            if self._valuation_final_terms is None or self._valuation > self._valuation_final_terms:
+                valuation_final_terms = None
+            else:
+                valuation_final_terms = valb
+            self._b = BoundedSeries_poly(parent, b, valuation_final_terms=valuation_final_terms, prec=prec-d, prec_coeffs=precs_res[d:])
+
+        # Compute the inverse of b (if asked)
+        #####################################
+
+        if compute_inverse and self._binv is None:
+            self._binv = self._b.inverse()
+
+        # Return the result
+        ###################
+
+        a = self._a
+        b = self._b
+        binv = self._binv
+        if monic:
+            lc = a[d]
+            a /= lc
+            b *= lc
+            if compute_inverse:
+                binv /= lc
+                return a, b, binv
+            else:
+                return a, b
+        else:
+            if compute_inverse:
+                return a, b, binv
+            else:
+                return a, b
+
+
+    def quo_rem(self, right, secure=False):
+        if right.parent() != self.parent():
+            raise TypeError("Parents do not coincide")
+        prec = self._prec
+        log_radius = self._parent._log_radius
+        valright = right.gauss_valuation(secure=secure)
+        d = right.weierstrass_degree()
+
+        # Compute loss of precision coming from self._valuation_final_terms
+        ###################################################################
+
+        mu = -right.highest_slope()
+        if prec is Infinity or mu is Infinity:
+            precs_res = [ ]
+        else:
+            lastprec = self._valuation_final_terms
+            if lastprec is None:
+                lastprec = self._valuation
+            lastprec -= prec * log_radius
+            precs_res = [ lastprec + i*mu for i in range(prec) ]
+            precs_res.reverse()
+        for i in range(d, len(precs_res)):
+            precs_res[i] -= valright
+
+        # Compute the result
+        ####################
+
+        parent = self._parent
+        a, _, binv = right.weierstrass_preparation(compute_inverse=True)
+        q, r = self._f.quo_rem(a.polynomial())
+        if self._valuation_final_terms is None or binv.valuation_final_terms() is None:
+            q = BoundedSeries_poly(parent, q, valuation_final_terms=None, prec=Infinity)
+            r = BoundedSeries_poly(parent, r, valuation_final_terms=None, prec=Infinity, prec_coeffs=precs_res[:d])
+        else:
+            q = BoundedSeries_poly(parent, q, valuation_final_terms=Infinity, prec=Infinity)
+            r = BoundedSeries_poly(parent, r, valuation_final_terms=Infinity, prec=Infinity, prec_coeffs=precs_res[:d])
+        q *= binv
+        q = q.add_bigoh(precs_res[d:])
+
+        return q, r
diff --git a/sage/rings/bounded_series_ring.py b/sage/rings/bounded_series_ring.py
new file mode 100644
--- /dev/null
+++ b/sage/rings/bounded_series_ring.py
@@ -0,0 +1,259 @@
+#############################################################################
+#    Copyright (C) 2013 Xavier Caruso <xavier.caruso@normalesup.org>
+#
+#  Distributed under the terms of the GNU General Public License (GPL)
+#
+#                  http://www.gnu.org/licenses/
+#****************************************************************************
+
+from sage.structure.unique_representation import UniqueRepresentation 
+from sage.structure.parent_gens import normalize_names
+
+import sage.categories.basic as categories
+
+from integer import Integer
+from rational_field import QQ 
+from sage.structure.element import Element 
+from ring import Field, CommutativeAlgebra
+from infinity import Infinity 
+import sage.misc.latex as latex
+
+from polynomial.polynomial_ring_constructor import PolynomialRing 
+from polynomial.polynomial_element import Polynomial 
+from sage.structure.parent_gens import ParentWithGens
+
+from bounded_series_ring_element import BoundedSeries 
+from bounded_series_ring_morphism import BoundedSeriesBaseringInjection
+from bounded_series_ring_morphism import BoundedSeriesRestriction
+
+
+def BoundedSeriesRing(base_ring, log_radius=0, name=None, names=None,
+                      sparse=False, default_prec=None):
+    if default_prec is None:
+        default_prec = 20
+
+    if name is None:
+        name = names
+    if name is None:
+        raise TypeError, "You must specify the name of the indeterminate of the Bounded Power series ring."
+    try:
+        name = normalize_names(1, name)[0]
+    except IndexError:
+        raise NotImplementedError("Multivariate bounded power series rings are not implemented yet.")
+    except TypeError:
+        raise TypeError, "illegal variable name"
+    
+    if not (isinstance(base_ring, Field) and base_ring.is_cdvf()):
+        raise TypeError("base_ring must be a complete discrete valuation field")
+    return BoundedSeriesRing_generic(base_ring, log_radius, name, default_prec, sparse=sparse)
+
+
+def is_BoundedSeriesRing(R):
+    return isinstance(R, BoundedSeriesRing_generic)
+
+
+class BoundedSeriesRing_generic(CommutativeAlgebra, UniqueRepresentation):
+    @staticmethod
+    def __classcall__(cls, base_ring, log_radius=0, name=None, default_prec=20, sparse=False, element_class=None):
+        if not element_class:
+            if sparse:
+                raise NotImplementedError("sparse bounded series are not implemented")
+            else:
+                from bounded_series_poly import BoundedSeries_poly
+                element_class = BoundedSeries_poly
+        return super(BoundedSeriesRing_generic,cls).__classcall__(cls, base_ring, log_radius, name, default_prec, sparse, element_class)
+        
+    def __init__(self, base_ring, log_radius=0, name=None, default_prec=20, sparse=False, element_class=None, category=None):
+        self.__is_sparse = sparse
+        self._series_class = element_class
+        self._by_one = False
+        self._log_radius = log_radius
+        self._default_prec = default_prec
+        self._polynomial_ring = PolynomialRing(base_ring, name=name)
+
+        # Algebra.__init__ also calls __init_extra__ of Algebras(...).parent_class, which tries to provide a conversion from the base ring, if it does not exist. This is for algebras that only do the 
+        # generic stuff in their initialisation. But here, we want to use PolynomialBaseringInjection. Hence, we need to wipe the memory and construct the conversion from scratch.
+        CommutativeAlgebra.__init__(self, base_ring, names=name, normalize=True, category=category)
+        self.__generator = self._series_class(self, self._polynomial_ring.gen(), valuation_final_terms=Infinity, prec=Infinity, is_gen=True)
+        self._base_inject = BoundedSeriesBaseringInjection(base_ring,self)
+        self._coercions_log_radius = { }
+
+        if log_radius in QQ:
+            self._refine_category_(categories.EuclideanDomains())
+
+    #def __reduce__(self):
+
+    def has_coerce_map_from(self, S):
+        base = self.base_ring()
+        if base.has_coerce_map_from(S):
+            return True
+        elif isinstance(S, BoundedSeriesRing_generic):
+            return self.base_ring() is S.base_ring() and self.variable_name() is S.variable_name() and self._log_radius >= S.log_radius()
+
+    def coerce_map_from(self, S):
+        base = self.base_ring()
+        if base is S:
+            return self._base_inject
+        elif base.has_coerce_map_from(S):
+            return self._base_inject * base.coerce_map_from(S) 
+        elif isinstance(S, BoundedSeriesRing_generic):
+            log_radius = S.log_radius()
+            if self.base_ring() is S.base_ring() and self.variable_name() is S.variable_name() and self._log_radius >= log_radius:
+                key = (self.default_prec(), log_radius)
+                try:
+                    return self._coercions_log_radius[key]
+                except KeyError:
+                    map = BoundedSeriesRestriction(S, self, check=False)
+                    self._coercions_log_radius[key] = map
+                    return map
+
+    def _element_constructor_(self, x=None, valuation_final_terms=Infinity, prec=Infinity, check=True, is_gen=False):
+        if is_gen:
+            x = [ 0,1 ]
+            prec = Infinity
+            valuation_final_terms = Infinity
+        elif isinstance(x, Element):
+            if isinstance(x, BoundedSeries):
+                # here, we know that x.parent().log_radius() > self.log_radius()
+                # hence, the only possibility is that x is actually a polynomial (i.e. has infinite precision)
+                if x.prec() is not Infinity:
+                    raise TypeError("Impossible to decrease the logarithmic radius of convergence")
+                if x._valuation_final_terms is None:
+                    valuation_final_terms = None
+                x = x.polynomial()
+            #elif isinstance(x, PowerSeries):
+            if isinstance(x, Polynomial):
+                pass
+            else:
+                x = [ x ]
+        elif isinstance(x, int):
+            x = [ x ]
+        return self._series_class(self, x, valuation_final_terms, prec)
+
+    def _repr_(self):
+        s = "Bounded Convergent Series Ring in %s on {val > %s} over %s"%(self.variable_name(), self.log_radius(), self.base_ring())
+        if self.is_sparse():
+            s = 'Sparse ' + s
+        return s
+
+    def is_sparse(self):
+        return self.__is_sparse
+
+    def is_dense(self):
+        return not self.__is_sparse
+
+    def log_radius(self):
+        return self._log_radius
+
+    def default_prec(self):
+        return self._default_prec
+
+    def _latex_(self):
+        return "%s\left<%s\right>"%(latex.latex(self.base_ring()), self.latex_variable_names()[0])
+
+    #def _is_valid_homomorphism_(self, codomain, im_gens):
+
+    def base_extend(self, R):
+        raise NotImplementedError
+    
+    def change_ring(self, R):
+        raise NotImplementedError
+
+    def change_log_radius(self, log_radius):
+        return self.__class__(self.base_ring(), log_radius, self.variable_name(), sparse=self.is_sparse(), default_prec=self.default_prec())
+
+    def change_default_prec(self, default_prec):
+        return self.__class__(self.base_ring(), self.log_radius(), self.variable_name(), sparse=self.is_sparse(), default_prec=default_prec)
+
+    def is_exact(self):
+        return False
+
+    def gen(self, n=0):
+        if n != 0:
+            raise IndexError, "generator n>0 not defined"
+        return self.__generator
+
+    def ngens(self):
+        return 1
+
+    def random_element(self, prec=None, degree=None, valuation=0, *args, **kwds):
+        from sage.functions.other import ceil
+        if prec is None:
+            prec = self.default_prec()
+        if degree is None or degree >= prec:
+            degree = prec - 1
+        if degree is Infinity:
+            degree = self.default_prec() - 1
+        val = valuation
+        log_radius = self._log_radius
+        coeffs = [ ]
+        base = self.base_ring()
+        integer_base = base.integer_ring()
+        for i in range(degree+1):
+            coeffs.append(base(integer_base.random_element()) << ceil(val))
+            val -= log_radius
+        if prec is Infinity:
+            valuation_final_terms = Infinity
+        else:
+            valuation_final_terms = valuation
+        return self._series_class(self, coeffs, valuation_final_terms=valuation_final_terms, prec=prec)
+
+    def __cmp__(self, other):
+        return self is other
+
+    def uniformizer(self):
+        if self._log_radius not in QQ:
+            raise ValueError("This ring does not have a uniformizer")
+        base = self.base_ring()
+        unif = base.uniformizer()
+        image_val = unif.valuation()
+        fraction = self._log_radius / image_val
+        num = fraction.numerator()
+        denom = fraction.denominator()
+        _, n, v = num.xgcd(denom)
+        if n < 0:
+            n += denom
+            v -= num
+        coeffs = n * [ base(0) ] + [ unif ** v ]
+        return self._series_class(self, coeffs)
+
+    def is_atomic_repr(self):
+        return False
+
+    def is_commutative(self):
+        return True
+
+    def is_field(self, proof = True):
+        return False
+
+    def is_finite(self):
+        return False
+
+    def characteristic(self):
+        return self.base_ring().characteristic()
+
+    #def integers(self):
+    #    return BoundedByOneSeriesRing_generic(self.base_ring(), self._log_radius(), self.variable_name(), self._default_prec, self.__is_sparse, self._series_class)
+
+    def hom(self, im_gen, morphism_on_coefficients=None):
+        from sage.categories.homset import Hom
+        from bounded_series_ring_morphism import BoundedSeriesHomomorphism_im_gens
+        if isinstance(im_gen, (int, Integer)):
+            parent = self
+        elif isinstance(im_gen, list):
+            parent = im_gen[0].parent()
+        else:
+            parent = im_gen.parent()
+        homset = Hom(self, parent)
+        return BoundedSeriesHomomorphism_im_gens(homset, im_gen, morphism_on_coefficients)
+
+    def frobenius_endomorphism(self, n=1, b=None):
+        from sage.categories.homset import Hom
+        from bounded_series_ring_morphism import BoundedSeriesHomomorphism_im_gens
+        base = self.base_ring()
+        if b is None:
+            b = base.characteristic()
+            if b == 0: b = base.prime()
+        morphism_on_coefficients = base.frobenius_endomorphism(n=n)
+        homset = Hom(self, self)
+        return BoundedSeriesHomomorphism_im_gens(homset, b**n, morphism_on_coefficients)
diff --git a/sage/rings/bounded_series_ring_element.pxd b/sage/rings/bounded_series_ring_element.pxd
new file mode 100644
--- /dev/null
+++ b/sage/rings/bounded_series_ring_element.pxd
@@ -0,0 +1,7 @@
+from sage.structure.element cimport AlgebraElement
+
+
+cdef class BoundedSeries(AlgebraElement):
+    cdef char __is_gen
+    cdef _prec
+    cdef _valuation_final_terms
diff --git a/sage/rings/bounded_series_ring_element.pyx b/sage/rings/bounded_series_ring_element.pyx
new file mode 100644
--- /dev/null
+++ b/sage/rings/bounded_series_ring_element.pyx
@@ -0,0 +1,407 @@
+#############################################################################
+#    Copyright (C) 2013 Xavier Caruso <xavier.caruso@normalesup.org>
+#
+#  Distributed under the terms of the GNU General Public License (GPL)
+#
+#                  http://www.gnu.org/licenses/
+#****************************************************************************
+
+include "../ext/stdsage.pxi"
+
+import operator, sage
+
+from infinity import Infinity
+from integer import Integer
+from rational_field import QQ
+from sage.rings.polynomial.polynomial_ring_constructor import PolynomialRing
+
+from sage.structure.element cimport Element, AlgebraElement
+
+from sage.categories.complete_discrete_valuation import CompleteDiscreteValuationFields
+
+from sage.combinat.newton_polygon import NewtonPolygon_lastslope 
+from sage.rings.padics.precision_error import PrecisionError
+
+
+def is_BoundedSeries(x):
+    return isinstance(x, BoundedSeries)
+
+cdef class BoundedSeries(AlgebraElement):
+    def __init__(self, parent, f, valuation_final_terms, prec, is_gen=False):  # NB: f is ignored here
+        AlgebraElement.__init__(self, parent)
+        self.__is_gen = is_gen
+        if not (prec is Infinity):
+            prec = int(prec)
+        self._prec = prec
+        self._valuation_final_terms = valuation_final_terms
+
+    #def __hash__(self):
+        
+    #def __reduce__(self):
+
+    def is_sparse(self):
+        return self._parent.is_sparse()
+
+    def is_dense(self):
+        return self._parent.is_dense()
+
+    def is_gen(self):
+        return self.__is_gen
+
+    def base_extend(self, R):
+        S = self._parent.base_extend(R)
+        return S(self)
+
+    def change_ring(self, R):
+        S = self._parent.change_ring(R)
+        return S(self)
+    
+    def __cmp__(left, right):
+        return (<Element>left)._cmp(right)
+    
+    def __richcmp__(left, right, int op):
+        return (<Element>left)._richcmp(right, op)
+
+    cdef int _cmp_c_impl(self, Element right) except -2:
+        prec = min(self.prec(), right.prec())
+        if prec is Infinity:
+            x = self.list()
+            y = right.list()
+        else:
+            x = self.list()[:prec]
+            y = right.list()[:prec]
+        zero = self.base_ring()(0)
+        dl = len(x) - len(y)
+        if dl < 0:
+            x += (-dl) * [ zero ]
+        elif dl > 0:
+            y += dl * [ zero ]
+        for i in range(len(x)):
+            c = cmp(x[i], y[i])
+            if c: return c
+        return 0
+    
+    def __call__(self, x): # you *MUST* override this in the derived class
+        raise NotImplementedError
+
+    def coefficients(self):
+        zero = self.parent().base_ring()(0)
+        return [c for c in self.list() if c != zero]
+
+    def exponents(self):
+        zero = self.parent().base_ring()(0)
+        l = self.list()
+        return [i for i in range(len(l)) if l[i] != zero]
+    
+    def list(self): # you *MUST* override this in the derived class
+        raise NotImplementedError
+
+    def polynomial(self): # you *MUST* override this in the derived class
+        raise NotImplementedError
+
+    def __copy__(self):
+        return self
+
+    def base_ring(self):
+        return self._parent.base_ring()
+
+    def variable(self):
+        return self._parent.variable_name()
+
+    def prec(self):
+        return self._prec
+
+    def log_radius(self):
+        if self._prec is Infinity:
+            return Infinity
+        else:
+            return self.parent().log_radius()
+
+    def change_prec(self, new_prec=None, valuation_final_terms=None):
+        f = self.polynomial()
+        if new_prec is None:
+            new_prec = self.parent().default_prec()
+        if self._valuation_final_terms is None:
+            valuation_final_terms = None
+        if new_prec is not Infinity:
+            if valuation_final_terms is None:
+                if self._valuation_final_terms is Infinity:
+                    valuation_final_terms = 0
+                else:
+                    valuation_final_terms = self._valuation_final_terms
+            else:
+                valuation_final_terms = min(valuation_final_terms, self._valuation_final_terms)
+            log_radius = self._parent._log_radius
+            for i in range(new_prec, f.degree()+1):
+                valuation_final_terms = min(valuation_final_terms, f[i].valuation() + i*log_radius)
+        return self.__class__(self._parent, f, valuation_final_terms, new_prec)
+
+    def add_bigoh(self, new_precs, shift=0):
+        if new_precs is Infinity:
+            return self
+        f = self.polynomial()
+        valuation_final_terms = self._valuation_final_terms
+        log_radius = self._parent._log_radius
+        prec = self._prec
+        if isinstance(new_precs, list):
+            new_precs = [ Infinity ] * shift + new_precs
+            if prec is not Infinity and valuation_final_terms is not None:
+                for i in range(prec, len(new_precs)):
+                    valuation_final_terms = min(valuation_final_terms, new_precs[i] - i*log_radius)
+        else:
+            valuation_final_terms = min(valuation_final_terms, new_precs)
+            if prec is Infinity:
+                prec = max(f.degree() + 1, self.parent().default_prec())
+            new_precs = [ Infinity ] * shift + [ new_precs - i*log_radius for i in range(shift, prec) ]
+        return self.__class__(self._parent, f, valuation_final_terms, prec, new_precs)
+
+    def weierstrass_degree(self, secure=False):
+        log_radius = self._parent.log_radius()
+        val = Infinity; deg = -1;
+        coeffs = self.list()
+        for i in range(len(coeffs)):
+            v = coeffs[i].valuation() - i*log_radius
+            if v < val:
+                val = v
+                deg = i
+        if secure and val > self._valuation_final_terms:
+            raise PrecisionError("Unable to determine for sure the Weierstrass degree")
+        return deg
+
+    def degree(self, secure=False):
+        return self.weierstrass_degree(secure=secure)
+
+    def valuation_final_terms(self):
+        return self._valuation_final_terms
+
+    def gauss_valuation(self, secure=False):
+        log_radius = self._parent.log_radius()
+        val = Infinity
+        coeffs = self.list()
+        for i in range(len(coeffs)):
+            v = coeffs[i].valuation() - i*log_radius
+            if v < val: val = v
+        if secure and val > self._valuation_final_terms:
+            raise PrecisionError("Unable to determine for sure the Gauss valuation")
+        return val
+
+    def valuation(self, secure=False):
+        return self.gauss_valuation(secure=secure)
+
+    def _repr_(self):
+        from sage.rings.integer_ring import ZZ
+        X = self._parent.variable_name()
+        if self._valuation_final_terms is None:
+            bigoh = "O(unknown)"
+        elif self._prec is Infinity or self._valuation_final_terms is Infinity:
+            bigoh = ""
+        else:
+            log_radius = self.parent().log_radius()
+            unif = self.base_ring().uniformizer()
+            power_unif = (self._valuation_final_terms - log_radius * self._prec) / unif.valuation()
+            try:
+                unif = self.base_ring().variable_name()
+            except AttributeError:
+                pass
+            bigoh = "O("
+            if power_unif == 0:
+                pass
+            elif power_unif == 1:
+                bigoh += "%s*" % unif
+            elif power_unif in ZZ and power_unif > 0:
+                bigoh += "%s^%s*" % (unif, power_unif)
+            else:
+                bigoh += "%s^(%s)*" % (unif, power_unif)
+            bigoh += "%s^%s)" % (X, self._prec)
+
+        if self.is_zero():
+            return bigoh if bigoh != "" else "0"
+
+        atomic_repr = self._parent.base_ring().is_atomic_repr()
+
+        s = " "
+        v = self.list()
+        m = len(v)
+        first = True
+        for n in xrange(m):
+            x = v[n]
+            if not x.is_zero():
+                x = repr(x)
+                if not first:
+                    s += " + "
+                if not atomic_repr and n > 0 and (x[1:].find("+") != -1 or x[1:].find("-") != -1):
+                    x = "(%s)"%x
+                if n > 1:
+                    var = "*%s^%s"%(X,n)
+                elif n==1:
+                    var = "*%s"%X
+                else:
+                    var = ""
+                s += "%s%s"%(x,var)
+                first = False
+
+        s = s.replace(" + -", " - ")
+        s = s.replace(" 1*"," ")
+        s = s.replace(" -1*", " -")
+        if bigoh != "": s += " + %s"%bigoh
+        return s[1:]
+
+    #def _latex_(self):
+
+    def __getitem__(self,n):
+        if n<0:
+            return self.base_ring()(0)
+        c = self.list()
+        if n >= len(c):
+            if self._prec > n:
+                return self.base_ring()(0)
+            else:
+                raise IndexError, "coefficient not known"
+        return c[n]
+
+    def is_zero(self, secure=False):
+        raise NotImplementedError
+    
+    def __nonzero__(self):
+        return not self.is_zero()
+
+    def is_secure(self):
+        return self._valuation_final_terms is not None and self.valuation() <= self._valuation_final_terms
+
+    def secure_log_radius(self):
+        if self._valuation_final_terms is None:
+            return Infinity
+        log_radius = self._parent._log_radius
+        coeffs = self.list()
+        prec = self._prec
+        secure_log_radius = Infinity
+        valuation_final_terms = self._valuation_final_terms - log_radius*prec
+        for i in range(len(coeffs)):
+            c = coeffs[i]
+            if c.is_zero(): continue
+            val = c.valuation()
+            slope = (val - valuation_final_terms) / (prec - i)
+            if slope < secure_log_radius:
+                secure_log_radius = slope
+        return max(log_radius, secure_log_radius)
+
+    def change_log_radius(self, log_radius):
+        if log_radius < self.parent().log_radius():
+            raise TypeError("log radius can't decrease")
+        R = self.parent().change_log_radius(log_radius)
+        return R(self)
+
+    def restriction(self, log_radius):
+        return self.change_log_radius(log_radius)
+
+    def is_unit(self, secure=False):
+        return self.weierstrass_degree(secure=secure) == 0
+
+    def newton_polygon(self,secure=True):
+        if secure and not self.is_secure():
+            raise PrecisionError("The Newton polygon is not determined")
+        coeffs = self.list()
+        lastslope = -self._parent.log_radius()
+        vertices = [ ]
+        for x in range(len(coeffs)):
+            c = coeffs[x]
+            if c.is_zero(): continue
+            vertices.append((x, c.valuation()))
+        polygon = NewtonPolygon_lastslope(vertices, lastslope=lastslope)
+        if secure:
+            vertices_prec = [ (x, coeffs[x].precision_absolute()) for x in range(len(coeffs)) ]
+            if self._prec is not Infinity:
+                vertices_prec.append((self._prec, self._valuation_final_terms - self._prec * self._parent._log_radius))
+            polygon_prec = NewtonPolygon_lastslope(vertices_prec, lastslope=lastslope)
+            vertices = polygon.vertices()
+            vertices_prec = polygon_prec.vertices()
+            if vertices[0][0] < vertices_prec[0][0]:
+                raise PrecisionError("The Newton polygon is not determined")
+            for (x,y) in vertices:
+                if polygon_prec(x) <= y:
+                    raise PrecisionError("The Newton polygon is not determined")
+            (x, y) = vertices_prec[-1]
+            if polygon(x) > y:
+                raise PrecisionError("The Newton polygon is not determined")
+        return polygon
+
+    def minimal_newton_polygon(self):
+        coeffs = self.list()
+        lastslope = -self._parent.log_radius()
+        vertices = [ (x, coeffs[x].valuation()) for x in range(len(coeffs)) ]
+        prec = self.prec()
+        valuation_final_terms = self._valuation_final_terms
+        if valuation_final_terms is not None and prec is not Infinity:
+            vertices.append((prec, valuation_final_terms - prec*self.log_radius()))
+        return NewtonPolygon_lastslope(vertices, lastslope=lastslope)
+
+    def newton_slopes(self,repetition=True,secure=True):
+        polygon = self.newton_polygon(secure=secure)
+        return [ -s for s in polygon.slopes(repetition=repetition) ]
+
+    def __invert__(self):
+        raise NotImplementedError
+
+    def inverse(self, secure=False):
+        raise NotImplementedError
+
+    def inverse_of_unit(self, secure=False):
+        return self.inverse(self, secure=secure)
+
+    def weierstrass_preparation(self, monic=False, secure=False):
+        raise NotImplementedError
+
+    def quo_rem(self, right, secure=False):
+        raise NotImplementedError
+
+    def __floordiv__(self,other):
+        q,r = self.quo_rem(other)
+        return q
+            
+    def __mod__(self,other):
+        q,r = self.quo_rem(other)
+        return r
+
+    def __call__(self, x, **kwds):
+        from bounded_series_ring import BoundedSeriesRing_generic
+        parent_self = self.parent()
+        parent_x = x.parent()
+        if isinstance(parent_x, BoundedSeriesRing_generic):
+            if self._valuation_final_terms is None:
+                raise NotImplementedError("Composition of series involving O(unknown) not implemented")
+            # First, we consider the case where self is actually a polynomial
+            if self._prec is Infinity:
+                return self.polynomial()(x)
+            # We compute the radius of convergence
+            prec = x.prec()
+            unif = parent_self.base_ring().uniformizer()
+            e = parent_x.base_ring()(unif).valuation() / unif.valuation()
+            v = e * parent_self.log_radius()
+            coeffs = x.list()
+            log_radius = -coeffs[0].valuation()
+            if log_radius >= v:
+                raise ValueError("The composite does not converge")
+            for i in range(1, len(coeffs)):
+                slope = (v - coeffs[i].valuation()) / i
+                if log_radius < slope:
+                    log_radius = slope
+            if prec is not Infinity:
+                valuation_final_terms = x.valuation_final_terms()
+                slope = (v - valuation_final_terms)/prec - x.log_radius()
+                if log_radius < slope:
+                    log_radius = slope
+            parent_x = parent_x.change_log_radius(log_radius)
+            x = x.change_log_radius(log_radius)
+            check = False
+        else:
+            check = True
+        from bounded_series_ring_morphism import BoundedSeriesHomomorphism_im_gens
+        from sage.categories.homset import Hom
+        morphism = BoundedSeriesHomomorphism_im_gens(Hom(parent_self, parent_x), x, check=check)
+        return morphism(self, **kwds)
+
+    def derivative(self):
+        return self.__class__(self._parent, self.polynomial().derivative(), self.valuation_final_terms()+self.log_radius(), max(0,self._prec-1), check=False)
+    
+    def __setitem__(self, n, value):
+        raise IndexError, "power series are immutable"
diff --git a/sage/rings/bounded_series_ring_morphism.pxd b/sage/rings/bounded_series_ring_morphism.pxd
new file mode 100644
--- /dev/null
+++ b/sage/rings/bounded_series_ring_morphism.pxd
@@ -0,0 +1,21 @@
+from sage.structure.element cimport Element, RingElement
+from sage.rings.morphism cimport RingHomomorphism
+from sage.rings.morphism cimport RingHomomorphism_im_gens
+
+
+cdef class BoundedSeriesBaseringInjection(RingHomomorphism):
+    cdef RingElement _an_element
+    cdef object _new_constant_series_
+
+cdef class BoundedSeriesRestriction(RingHomomorphism):
+    cdef _series_class
+    cdef _diff_log_radius
+
+cdef class BoundedSeriesHomomorphism_im_gens(RingHomomorphism_im_gens):
+    cdef _morphism
+    cdef _image
+    cdef _e
+    cdef _function
+    cdef _zeroes
+    cdef _gain_precision
+    cdef list _vertices
diff --git a/sage/rings/bounded_series_ring_morphism.pyx b/sage/rings/bounded_series_ring_morphism.pyx
new file mode 100644
--- /dev/null
+++ b/sage/rings/bounded_series_ring_morphism.pyx
@@ -0,0 +1,265 @@
+#############################################################################
+#    Copyright (C) 2013 Xavier Caruso <xavier.caruso@normalesup.org>
+#
+#  Distributed under the terms of the GNU General Public License (GPL)
+#
+#                  http://www.gnu.org/licenses/
+#****************************************************************************
+
+include "../ext/stdsage.pxi"
+
+import sage
+
+from infinity import Infinity
+from integer import Integer
+
+from sage.categories.complete_discrete_valuation import CompleteDiscreteValuationFields
+from sage.rings.morphism cimport RingHomomorphism 
+from sage.rings.morphism cimport RingHomomorphism_im_gens 
+from sage.categories.homset import Hom
+
+
+
+cdef class BoundedSeriesBaseringInjection(RingHomomorphism):
+    def __init__(self, domain, codomain):
+        assert codomain.base_ring() is domain, "domain must be basering"
+        RingHomomorphism.__init__(self, Hom(domain,codomain))
+        self._an_element = codomain.gen()
+        self._repr_type_str = "Bounded Series base injection"
+        self._new_constant_series_ = self._an_element._new_constant_series
+
+    cpdef Element _call_(self, x):
+        return self._new_constant_series_(x, self._codomain)
+
+    cpdef Element _call_with_args(self, x, args=(), kwds={}):
+        try:
+            return self._codomain._element_constructor_(x, *args, **kwds)
+        except AttributeError:
+            # if there is no element constructor, there is a custom call method.
+            return self._codomain(x, *args, **kwds)
+
+
+cdef class BoundedSeriesRestriction(RingHomomorphism):
+    def __init__(self, domain, codomain, check=True):
+        self._diff_log_radius = codomain.log_radius() - domain.log_radius()
+        if check:
+            from bounded_series_ring import BoundedSeriesRing_generic
+            if not isinstance(domain, BoundedSeriesRing_generic):
+                raise TypeError("The domain must be a ring of Bounded Series")
+            if not isinstance(codomain, BoundedSeriesRing_generic):
+                raise TypeError("The codomain must be a ring of Bounded Series")
+            if domain.base_ring() is not codomain.base_ring():
+                raise TypeError("The domain and the codomain must share the same base ring")
+            if self._diff_log_radius < 0:
+                raise TypeError("Log radius of convergence must increase")
+        RingHomomorphism.__init__(self, Hom(domain,codomain))
+        self._repr_type_str = "Restriction morphism:\n From: %s\n To: %s" % (domain, codomain)
+        self._series_class = codomain._series_class
+
+    def _repr_(self):
+        return self._repr_type_str
+
+    cpdef Element _call_(self, x):
+        prec = x.prec()
+        valuation_final_terms = x.valuation_final_terms()
+        if prec is not Infinity and valuation_final_terms is not None:
+            valuation_final_terms += self._diff_log_radius * prec
+        return self._series_class(self.codomain(), x.polynomial(), valuation_final_terms, prec)
+
+
+cdef class BoundedSeriesHomomorphism_im_gens(RingHomomorphism_im_gens):
+    def __init__(self, parent, im_gens, morphism_on_coefficients=None, check=True):
+        RingHomomorphism.__init__(self, parent)
+        domain = self.domain(); codomain = self.codomain()
+        from bounded_series_ring import BoundedSeriesRing_generic
+
+        if check:
+            if not isinstance(domain, BoundedSeriesRing_generic):
+                raise TypeError("the domain must be a Bounded Series Ring")
+
+        if isinstance(im_gens, (int, Integer)):
+            image = im_gens
+            if check and image < 1:
+                raise ValueError("When im_gens is an integer, it must be positive")
+            self._zeroes = (image - 1) * [ codomain.base_ring()(0) ]
+            im_gens = [ codomain.gen() ** im_gens ]
+        elif not isinstance(im_gens, sage.structure.sequence.Sequence_generic):
+            if not isinstance(im_gens, (tuple, list)):
+                im_gens = [im_gens]
+            im_gens = sage.structure.all.Sequence(im_gens, codomain)
+            if check and len(im_gens) != 1:
+                raise ValueError("too many images")
+            image = im_gens[0]
+
+        base = domain.base_ring()
+        unif = base.uniformizer()
+        if codomain in CompleteDiscreteValuationFields():
+            e = codomain(unif).valuation() / unif.valuation()
+            self._function = self._call_cdvf
+            self._gain_precision = image.valuation() - e*domain.log_radius()
+            if check:
+                if self._gain_precision <= 0:
+                    raise ValueError("Image does not define a valid morphism")
+                base_codomain = codomain.base_ring()
+                if (morphism_on_coefficients is not None and 
+                   (not isinstance(morphism_on_coefficients, RingHomomorphism) or morphism_on_coefficients.domain() != base or morphism_on_coefficients.codomain() != base)):
+                    raise ValueError("morphism_on_coefficients must be an endomorphism of the base ring of the domain (= %s)" % base)
+        elif isinstance(codomain, BoundedSeriesRing_generic):
+            base_codomain = codomain.base_ring()
+            if morphism_on_coefficients is None:
+                e = base_codomain(unif).valuation() / unif.valuation()
+            else:
+                e = morphism_on_coefficients(unif).valuation() / unif.valuation()
+            if self._zeroes is None:
+                self._gain_precision = image.valuation(secure=True) - e*domain.log_radius()
+                self._function = self._call_composition
+                self._vertices = image.minimal_newton_polygon().vertices()
+            else:
+                self._gain_precision = image*codomain.log_radius() - e*domain.log_radius()
+                self._function = self._call_composition_monomial
+            if check:
+                if self._gain_precision < 0 or (self._zeroes is None and self._gain_precision == 0 and image.weierstrass_degree() == 0):
+                    raise ValueError("Image does not define a valid morphism")
+                if (morphism_on_coefficients is not None and 
+                   (not isinstance(morphism_on_coefficients, RingHomomorphism) or morphism_on_coefficients.domain() != base or morphism_on_coefficients.codomain() != base_codomain)):
+                    raise ValueError("morphism_on_coefficients must be a morphism from the base ring of the domain (= %s) to the base ring of the codomain (= %s)" % (base, base_codomain))
+        else:
+            raise NotImplementedError
+
+        self._e = e
+        self._image = image
+        self.__im_gens = im_gens
+        if morphism_on_coefficients is not None and not morphism_on_coefficients.is_identity():
+            self._morphism = morphism_on_coefficients
+
+    def _repr_defn(self):
+        s = "%s |--> %s" % (self._domain.variable_name(), self.__im_gens[0])
+        if self._morphism is not None:
+            s += "\nAction on coefficients: %s" % (self._morphism._repr_short())
+        return s
+
+    def morphism_on_coefficients(self):
+        return self._morphism
+
+    cpdef Element _call_(self, x):
+        return self._function(x)
+
+    def _call_cdvf(self, x):
+        image = self._image
+        codomain = self._codomain
+        pow = codomain(1)
+        res = 0
+        morphism = self._morphism
+        if morphism is None:
+            morphism = codomain.base_ring()
+        for c in x.list():
+            res += morphism(c)*pow
+            pow *= image
+        valuation_final_terms = x.valuation_final_terms()
+        if valuation_final_terms is None:
+            return res
+        prec = self._e * valuation_final_terms + x.prec() * self._gain_precision 
+        if prec is not Infinity:
+            from sage.functions.other import ceil
+            res = res.add_bigoh(ceil(prec))
+        return res
+
+    def _call_composition(self, f):
+        from sage.functions.other import ceil
+        image = self._image
+        codomain = self._codomain
+        base_codomain = codomain.base_ring()
+        prec = f.prec()
+        vertices = self._vertices
+        d = vertices[-1][0]
+        trunc = d*prec
+        pow = codomain(1)
+        series = codomain(0)
+        morphism = self._morphism
+        if morphism is None:
+            morphism = base_codomain
+        for c in f.list():
+            series += morphism(c)*pow
+            pow *= image
+        valuation_final_terms = f.valuation_final_terms()
+        coeffs = series.list()
+        if prec is not Infinity:
+            if len(coeffs) < trunc:
+                coeffs.extend((trunc-len(coeffs))*[base_codomain(0)])
+            e = self._e
+            (ax,ay) = vertices[0]
+            for (x,y) in vertices[1:]:
+                slope = e * (ay-y) / (ax-x)
+                bigoh = e * prec * ay
+                start = prec*ax
+                end = prec*x
+                for i in range(start, min(end,trunc)):
+                    coeffs[i] = coeffs[i].add_bigoh(ceil(bigoh))
+                    bigoh += slope
+                if end > trunc: break
+                (ax,ay) = (x,y)
+            if valuation_final_terms is not None:
+                valuation_final_terms = e * valuation_final_terms + prec * self._gain_precision
+        valuation_final_terms = min(valuation_final_terms, series.valuation_final_terms())
+        prec = min(trunc, series.prec())
+        return codomain._series_class(codomain, coeffs, valuation_final_terms, prec, check=False)
+
+
+    def _call_composition_monomial(self, x):
+        codomain = self._codomain
+        base_codomain = codomain.base_ring()
+        zeroes = self._zeroes
+        ans = [ ]
+        coeffs = x.list()
+        morphism = self._morphism
+        if morphism is None:
+            for c in coeffs:
+                ans.append(base_codomain(c))
+                ans.extend(zeroes)
+        else:
+            for c in coeffs:
+                ans.append(morphism(c))
+                ans.extend(zeroes)
+        prec = x.prec()
+        valuation_final_terms = x.valuation_final_terms()
+        if valuation_final_terms is not None:
+            valuation_final_terms = self._e * valuation_final_terms + prec * self._gain_precision
+        return codomain._series_class(codomain, ans, valuation_final_terms, self._image * prec, check=False)
+
+    def _composition(self, right_m):
+        cdef BoundedSeriesHomomorphism_im_gens right
+        if isinstance(right_m, BoundedSeriesHomomorphism_im_gens):
+            right = <BoundedSeriesHomomorphism_im_gens>right_m
+            if self._morphism is None:
+                morphism_on_coefficients = right._morphism
+            elif right._morphism is None:
+                morphism_on_coefficients = self._morphism
+            else:
+                morphism_on_coefficients = self._morphism * right._morphism
+            if self._zeroes is not None and right._zeroes is not None:
+                im_gens = self._image * right._image
+            else:
+                im_gens = self._function(right._image)
+            return BoundedSeriesHomomorphism_im_gens(self.parent(), im_gens, morphism_on_coefficients)
+        else:
+            return RingHomomorphism._composition(self, right_m)
+
+    def __richcmp__(left, right, int op):
+        return (<Element>left)._richcmp(right, op)
+
+    cdef int _cmp_c_impl(self, Element other) except -2:
+        c = cmp(self.domain(), other.domain())
+        if c: return c
+        c = cmp(self.codomain(), other.codomain())
+        if c: return c
+        try:
+            c = cmp(self.morphism_on_coefficients(), other.morphism_on_coefficients())
+        except AttributeError:
+            c = (self._morphism is None)
+        if c: return c
+        c = cmp(self.im_gens(), other.im_gens())
+        return c
+
+    def __hash__(self):
+        return hash((self.domain(), self.codomain(), (self._morphism, self.__im_gens[0])))
+
diff --git a/sage/rings/homset.py b/sage/rings/homset.py
--- a/sage/rings/homset.py
+++ b/sage/rings/homset.py
@@ -91,6 +91,10 @@
             sage: H == loads(dumps(H))
             True
         """
+        from bounded_series_ring import BoundedSeriesRing_generic
+        if isinstance(self.domain(), BoundedSeriesRing_generic):
+            from bounded_series_ring_morphism import BoundedSeriesHomomorphism_im_gens
+            return BoundedSeriesHomomorphism_im_gens(self, im_gens, check=check)
         if isinstance(im_gens, (morphism.RingHomomorphism_im_gens,  morphism.RingHomomorphism_cover, morphism.RingHomomorphism_from_base) ):
             return self._coerce_impl(im_gens)
         try:
diff --git a/sage/rings/polynomial/polynomial_ring.py b/sage/rings/polynomial/polynomial_ring.py
--- a/sage/rings/polynomial/polynomial_ring.py
+++ b/sage/rings/polynomial/polynomial_ring.py
@@ -1,4 +1,3 @@
-
 """
 Univariate Polynomial Rings
 
diff --git a/sage/rings/power_series_poly.pyx b/sage/rings/power_series_poly.pyx
--- a/sage/rings/power_series_poly.pyx
+++ b/sage/rings/power_series_poly.pyx
@@ -91,22 +91,22 @@
         return self.__class__, (self._parent, self.__f, self._prec, self.__is_gen)
 
     def __richcmp__(left, right, int op):
-       """
-       Used for comparing power series.
+        """
+        Used for comparing power series.
 
-       EXAMPLES::
+        EXAMPLES::
        
-           sage: R.<t> = ZZ[[]]
-           sage: f = 1 + t + t^7 - 5*t^10
-           sage: g = 1 + t + t^7 - 5*t^10 + O(t^15)
-           sage: f == f
-           True
-           sage: f < g
-           False
-           sage: f == g
-           True
-       """
-       return (<Element>left)._richcmp(right, op)
+            sage: R.<t> = ZZ[[]]
+            sage: f = 1 + t + t^7 - 5*t^10
+            sage: g = 1 + t + t^7 - 5*t^10 + O(t^15)
+            sage: f == f
+            True
+            sage: f < g
+            False
+            sage: f == g
+            True
+        """
+        return (<Element>left)._richcmp(right, op)
         
     def polynomial(self):
         """
diff --git a/sage/structure/element.pyx b/sage/structure/element.pyx
--- a/sage/structure/element.pyx
+++ b/sage/structure/element.pyx
@@ -917,7 +917,7 @@
                (<Element>left)._cmp_c_impl == Element._cmp_c_impl:
             # Not implemented, try some basic defaults
             if op == Py_EQ:
-                 return left is right
+                return left is right
             elif op == Py_NE:
                 return left is not right
         return left._rich_to_bool(op, left._cmp_c_impl(right))
